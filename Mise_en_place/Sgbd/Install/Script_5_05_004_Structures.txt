##
AUDIT_ALIM_PERIODE_COL
=SQL IF_TYPE_NOTEXIST=AUDIT_ALIM_PERIODE_COL=
create or replace TYPE AUDIT_ALIM_PERIODE_COL AS OBJECT (paiezad varchar2(8), debut_recueil_force DATE, fin_recueil_force DATE)
##
AUDIT_ALIM_PERIODE_TAB
=SQL IF_TYPE_NOTEXIST=AUDIT_ALIM_PERIODE_TAB=
create or replace TYPE AUDIT_ALIM_PERIODE_TAB AS TABLE OF AUDIT_ALIM_PERIODE_COL;
##
CAD_DATEVALID
=SQL=
BEGIN 
EXECUTE_IMMEDIATE_STRING ('DROP TYPE TAB_CAD_DATEVALID',0);
EXCEPTION  WHEN OTHERS THEN  NULL; end ;
##
CAD_DATEVALID
=SQL=
create or replace TYPE CAD_DATEVALID AS OBJECT  
(Code_Compteur  VARCHAR2(5), 
Code_element  VARCHAR2(4), 
paiezad   VARCHAR2(8),
 Matricule    VARCHAR2(32), 
 Periode_Recueil   DATE,
 DATE_DEBUT  DATE,
 unite VARCHAR2(1));
##
CAD_LIGNE_RESULTAT_THEME
=SQL IF_TYPE_NOTEXIST=CAD_LIGNE_RESULTAT_THEME=
CREATE OR REPLACE TYPE CAD_LIGNE_RESULTAT_THEME FORCE AS   object   (     matricule  VARCHAR2(32),     code_theme VARCHAR2(10),     code_item  VARCHAR2(10),    lib_item   VARCHAR2(50),    resultat   VARCHAR2(1000) );
##
CAD_LIG_TYPE_POP_REGLES_MAJ
=SQL IF_TYPE_NOTEXIST=CAD_LIG_TYPE_POP_REGLES_MAJ=
CREATE OR REPLACE TYPE CAD_LIG_TYPE_POP_REGLES_MAJ FORCE AS   object  (    POPULATION        VARCHAR2(32 BYTE),    CODE_BASCULE      VARCHAR2(20 BYTE),    DATE_THEO_BASCULE VARCHAR2(8 BYTE),    ORDRE_A_PROPAGER  NUMBER );
##
CAD_RESULTAT_THEME
=SQL IF_TYPE_NOTEXIST=CAD_RESULTAT_THEME=
CREATE OR REPLACE TYPE "CAD_RESULTAT_THEME" AS   TABLE OF CAD_LIGNE_RESULTAT_THEME;
##
CAD_TYPE_POP_REGLES_MAJ
=SQL IF_TYPE_NOTEXIST=CAD_TYPE_POP_REGLES_MAJ=
CREATE OR REPLACE TYPE "CAD_TYPE_POP_REGLES_MAJ" IS  TABLE OF CAD_LIG_TYPE_POP_REGLES_MAJ;
##
TAG_CHARSET=@€éèç
##
COMPARE_DICO_HISTO_LIGNE
=SQL IF_TYPE_NOTEXIST=COMPARE_DICO_HISTO_LIGNE=
CREATE OR REPLACE TYPE COMPARE_DICO_HISTO_LIGNE FORCE AS object (NOM_DONNEE VARCHAR2(20), LIB_DONNEE VARCHAR2(50), VALEUR_PREC VARCHAR2(100), VALEUR_SELECT VARCHAR2(100) );
##
TAG_CHARSET=@€éèç
##
COMPARE_DICO_HISTO_TAB
=SQL IF_TYPE_NOTEXIST=COMPARE_DICO_HISTO_TAB=
CREATE OR REPLACE TYPE COMPARE_DICO_HISTO_TAB AS   TABLE OF COMPARE_DICO_HISTO_LIGNE;
##
COMPARE_LIVRAISON_JSP_RECORD
=SQL IF_TYPE_NOTEXIST=COMPARE_LIVRAISON_JSP_RECORD=
create or replace TYPE COMPARE_LIVRAISON_JSP_RECORD IS  OBJECT ( JSP_ECRAN_L1 VARCHAR2(300), ECRAN VARCHAR2(300), TAILLE_L1 FLOAT(126), TAILLE_L2 FLOAT(126), NB_OCCURENCES_L1   NUMBER, NB_OCCURENCES_L2   NUMBER, INDICE_PRESENCE_L1 NUMBER,  INDICE_PRESENCE_L2 NUMBER,  DIFF_TAILLE FLOAT(126),  DIFF_INDICE_PRES NUMBER, RATIO_INDICE_PRES NUMBER,   RATIO_TAILLE NUMBER  );
##
COMPARE_LIVRAISON_JSP_TABLE
=SQL IF_TYPE_NOTEXIST=COMPARE_LIVRAISON_JSP_TABLE=
CREATE OR REPLACE TYPE COMPARE_LIVRAISON_JSP_TABLE IS TABLE OF COMPARE_LIVRAISON_JSP_RECORD;
##
DATE_A275
=SQL IF_TYPE_NOTEXIST=DATE_A275=
CREATE OR REPLACE TYPE DATE_A275 FORCE AS   object     (numpac      varchar2(6),      IDPACMAT    varchar2(14),     donnee_A275 DATE  );
##
DATE_W580
=SQL IF_TYPE_NOTEXIST=DATE_W580=
create TYPE DATE_W580 IS Object  (numpac   varchar2(6),   IDPACMAT  varchar2(14),   donnee_W580 Varchar2(8)  );
##
TAG_CHARSET=@€éèç
##
EDI_HISTO_LANCEMENTS_SUIVI_TABLE
=SQL IF_TYPE_EXIST=EDI_HISTO_LANCEMENTS_SUIVI_TABLE=
DROP TYPE EDI_HISTO_LANCEMENTS_SUIVI_TABLE
##
EDI_HISTO_LANCEMENTS_SUIVI_RECORD
==
CREATE OR REPLACE TYPE EDI_HISTO_LANCEMENTS_SUIVI_RECORD IS OBJECT (ID_LANCEMENT NUMBER, CODEDI NUMBER, FAMEDI VARCHAR2(50), LOGIN VARCHAR2(32), DATE_LANCEMENT DATE, MATRIC VARCHAR2(32), DATE_EFF DATE, CHEMIN_FICHIER VARCHAR2(512), ID_DOC_CONTAINER VARCHAR2(24), SIGN_LISTE_MANDATAIRES VARCHAR2(100), SIGN_PROCEDURE VARCHAR2(1), SIGN_DATE_FIN DATE, SIGN_MANDATAIRES VARCHAR2(1), SIGN_CONTRACTANT VARCHAR2(1), DATE_STATUTS DATE, IS_BILLED VARCHAR2(1), IS_PAPERLESS VARCHAR2(1), IS_DIGIPOSTE VARCHAR2(1), BENEFICIAIRE VARCHAR2(200), SEXE VARCHAR2(1), EMAIL VARCHAR2(50), TELEPHONE VARCHAR2(50), TRI_BENEFICIAIRE VARCHAR2(32), CONTRAT VARCHAR2(50), TRI_CONTRAT DATE, FILTRE_CONTRAT VARCHAR2(10), ETABLISSEMENT VARCHAR2(255), MAQUETTE VARCHAR2(200), STATUTEDITION VARCHAR2(100), FILTRE_STATUTEDITION VARCHAR2(2), DATECREATION VARCHAR2(10), TRI_DATECREATION DATE, DATEFIN VARCHAR2(10), TRI_DATEFIN DATE, SIGNATURE VARCHAR2(100), FILTRE_SIGNATURE VARCHAR2(1), DATEACTUALISATION VARCHAR2(50), TRI_DATEACTUALISATION DATE, EXTENSIONFICHIER VARCHAR2(512), FILTRE_SOUMISSIGNATURE CHAR(1), FILTRE_SIGN_LISTE_MANDATAIRES VARCHAR2(120), TYPEDOC VARCHAR2(1), DISPLAY_ECRAN_SUIVI VARCHAR2(1), ALLOW_EDIT VARCHAR2(1), IS_AUTORIZED VARCHAR2(1));
##
EDI_HISTO_LANCEMENTS_SUIVI_TABLE
==
CREATE OR REPLACE TYPE EDI_HISTO_LANCEMENTS_SUIVI_TABLE IS TABLE OF EDI_HISTO_LANCEMENTS_SUIVI_RECORD;
##
TAG_CHARSET=@€éèç
##
EDI_HISTO_LANCEMENTS_SUIVI_TABLE
==
CREATE OR REPLACE TYPE EDI_HISTO_LANCEMENTS_SUIVI_TABLE IS TABLE OF EDI_HISTO_LANCEMENTS_SUIVI_RECORD;
##
GXP_TRT_PARTICULIER_DATA
==
create or replace TYPE GXP_TRT_PARTICULIER_DATA FORCE AS OBJECT (NUMPAC VARCHAR2(6),DONNEEGXP VARCHAR(50))
##
GXP_TRT_PARTICULIER_DATAS
==
create or replace TYPE GXP_TRT_PARTICULIER_DATAS FORCE AS TABLE OF GXP_TRT_PARTICULIER_DATA
##
HISTO_EMPLOI
==
create or replace TYPE HISTO_EMPLOI FORCE AS OBJECT (NUM_EMPLOI VARCHAR2(2), DATE_EFF DATE, DATE_FIN DATE, LIBELLE_EMPLOI VARCHAR(4000))
##
HISTO_EMPLOI_TAB
==
create or replace TYPE HISTO_EMPLOI_TAB FORCE AS TABLE OF HISTO_EMPLOI
##
HISTO_PENIB_ROW_DATA
=SQL=
create or replace TYPE "HISTO_PENIB_ROW_DATA" FORCE AS OBJECT (
 PACMAT	VARCHAR2(8),
 NUMPAC	VARCHAR2(6),
 ANNEE  NUMBER(4,0),
 DATE_STC DATE,
 NUM_CONTRAT  NUMBER(9,0),
 PENIB_CHARGE_MANUELLES	VARCHAR2(3 BYTE),
 PENIB_POSTURE_PENIB	VARCHAR2(3 BYTE),
 PENIB_VIBRATION	VARCHAR2(3 BYTE),
 PENIB_EXPO_AGENT_CHIM	VARCHAR2(3 BYTE),
 PENIB_MILLIEU_HYPERB	VARCHAR2(3 BYTE),
 PENIB_TEMP_EXTREM	VARCHAR2(3 BYTE),
 PENIB_BRUIT	VARCHAR2(3 BYTE),
 PENIB_NUIT	VARCHAR2(3 BYTE),
 PENIB_EQP_ALTERN	VARCHAR2(3 BYTE),
 PENIB_TRAV_REPET	VARCHAR2(3 BYTE),
 DATE_EFF DATE,
 DATE_FIN  DATE
 );
##
LIG_CLI_MODELE_DONNES
=SQL IF_TYPE_NOTEXIST=LIG_CLI_MODELE_DONNES=
create TYPE LIG_CLI_MODELE_DONNES AS OBJECT ( ESPACE	VARCHAR2(50),REGROUPEMENT	VARCHAR2(50),THEME	VARCHAR2(50),LIBELLE_PAGE	VARCHAR2(50),NOM_PAGE	VARCHAR2(100),ONGLET	VARCHAR2(100),NOM_DONNEE	VARCHAR2(151),LIBELLE_DONNEE	VARCHAR2(100),NOM_DICTIONNAIRE	VARCHAR2(24),TYPE_DONNEE	VARCHAR2(1),LONGUEUR_PARTIE_ENTIERE	VARCHAR2(10),LONGUEUR_PARTIE_DECIMALE	VARCHAR2(1),MODE_SAISIE	VARCHAR2(20),AFFICHE_CHOIX_VIDE_SELECT	VARCHAR2(1),VALEURS_OUI_NON	VARCHAR2(1000),REGLES_AFFICHAGE	VARCHAR2(50),PENTREE	VARCHAR2(4000),PENTREE_FORCABLE	VARCHAR2(1),PENTREE_CODE_MODIF	VARCHAR2(4000),NOMTABLE	VARCHAR2(1000));
##
TAG_CHARSET=@€éèç
##
LIG_REF_OBJ_USED_BY_OBJECT
==
CREATE OR REPLACE TYPE LIG_REF_OBJ_USED_BY_OBJECT FORCE AS OBJECT (CODE_OBJET_INIT VARCHAR2(1000), NOM_TABLE VARCHAR2(1000), CLE_TABLE VARCHAR2(1000), CODE_OBJET VARCHAR2(1000), NOM_TABLE_PARENT VARCHAR2(1000), CODE_OBJET_PARENT_1 VARCHAR2(1000), CODE_OBJET_PARENT_2 VARCHAR2(1000));
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_ENTITE
==
create or replace TYPE MP_CODELISTS_ESI_ENTITE FORCE AS OBJECT (CID VARCHAR2(32), CODE_ENTITE VARCHAR2(25), LIBELLE_REDUIT VARCHAR2(20), LIBELLE VARCHAR(255))
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_TAB_ENTITES
==
create or replace TYPE MP_CODELISTS_ESI_TAB_ENTITES FORCE AS TABLE OF MP_CODELISTS_ESI_ENTITE
##
SCH_ELEMENT
=SQL IF_TYPE_NOTEXIST=SCH_ELEMENT=
create or replace TYPE SCH_ELEMENT AS OBJECT (  code_schema       NUMBER(38,3),  code_element      NUMBER(38,3),  libelle           VARCHAR2(512, BYTE),  nom_page          VARCHAR2(512, BYTE),  code_asso         NUMBER(38,3),  code_asso_pere    NUMBER(38,3),  niveau            NUMBER(38,3));
##
TAB_CAD_DATEVALID
=SQL IF_TYPE_NOTEXIST=TAB_CAD_DATEVALID=
create or replace TYPE TAB_CAD_DATEVALID  AS TABLE OF CAD_DATEVALID;
##
TAB_DATE_A275
=SQL IF_TYPE_NOTEXIST=TAB_DATE_A275=
CREATE OR REPLACE TYPE "TAB_DATE_A275" FORCE AS  TABLE OF DATE_A275;
##
TAB_DATE_W580
=SQL IF_TYPE_NOTEXIST=TAB_DATE_W580=
create or replace TYPE TAB_DATE_W580 AS TABLE OF DATE_W580;
##
TAB_DONNEES_UX
=SQL IF_TYPE_NOTEXIST=TAB_DONNEES_UX=
create or replace TYPE TAB_DONNEES_UX FORCE AS TABLE OF TYP_DONNEES_UX;
##
TAB_ERR
=SQL IF_TYPE_NOTEXIST=TAB_ERR=
create or replace TYPE TAB_ERR FORCE AS TABLE OF TYP_ERR;
##
TAB_HISTO_PENIB
==
create or replace TYPE "TAB_HISTO_PENIB" FORCE AS TABLE OF HISTO_PENIB_ROW_DATA
##
TAB_PH_ABS
=SQL IF_TYPE_NOTEXIST=TAB_PH_ABS=
create or replace TYPE TAB_PH_ABS FORCE AS TABLE OF TYP_TAB_ABS;
##
TAG_CHARSET=@€éèç
##
TAB_REF_OBJ_USED_BY_OBJECT
==
CREATE OR REPLACE TYPE TAB_REF_OBJ_USED_BY_OBJECT AS TABLE OF LIG_REF_OBJ_USED_BY_OBJECT;
##
TAB_SMALLVARCHAR
=SQL IF_TYPE_NOTEXIST=TAB_SMALLVARCHAR=
create or replace TYPE "TAB_SMALLVARCHAR" IS TABLE OF VARCHAR2(8);
##
TAB_VARCHAR
=SQL IF_TYPE_NOTEXIST=TAB_VARCHAR=
create or replace TYPE "TAB_VARCHAR" IS TABLE OF VARCHAR2(1000);
##
TAG_CHARSET=@€éèç
##
TGE_CTRL40_abs_row_cursor
=SQL IF_TYPE_NOTEXIST=TGE_CTRL40_abs_row_cursor=
create or replace type TGE_CTRL40_abs_row_cursor AS OBJECT(DATE_DEBUT    VARCHAR2(8),DATE_FIN      VARCHAR2(8),UNITE         VARCHAR2(1),HEURES_IP     VARCHAR2(500),DEMI_JOURNEE  NUMBER(1),RUB_ECHANGE   VARCHAR2(4),CONSTRUCTOR FUNCTION TGE_CTRL40_abs_row_cursor RETURN SELF AS RESULT)
##
TAG_CHARSET=@€éèç
##
TGE_CTRL40_info_absence
=SQL IF_TYPE_NOTEXIST=TGE_CTRL40_info_absence=
create or replace TYPE TGE_CTRL40_info_absence AS OBJECT (          fin_ma      VARCHAR2(1),          debut_ma    VARCHAR2(1),          HEURES_IP	VARCHAR2(500));##
TAG_CHARSET=@€éèç
##
TGE_CTRL40_prop_absence
=SQL IF_TYPE_NOTEXIST=TGE_CTRL40_prop_absence=
create or replace TYPE TGE_CTRL40_prop_absence AS OBJECT (  isDemiJourneeSurUnSeulJour  NUMBER (1),  isDemiJourneeSurPlusieursJour  NUMBER (1),  isJourneeCompleteSurUnSeulJour  NUMBER (1),  isEnDureeSurUnSeulJour  NUMBER (1),  isJourneCompletSurPlusieurJour  NUMBER (1),  isEnDureeSurPlusieursJour  NUMBER (1),  isMatinSurUnSeulJour NUMBER (1),  isMatinSurPlusieursJour  NUMBER (1),  isApresMidiSurUnSeulJour  NUMBER (1),  isApresMidiSurPlusieursJour NUMBER (1),  isStatApremdAndFinitToutJourne NUMBER (1),  isStartApremidiAndFinitMatin  NUMBER (1),  isStartToutJourneAndFinitMatin  NUMBER (1),  estDemiJournee NUMBER (1),  erreur NUMBER (1));
##
TGE_MAP_ARG_ELT_ENTRY
=SQL IF_TYPE_NOTEXIST=TGE_MAP_ARG_ELT_ENTRY=
create or replace TYPE TGE_MAP_ARG_ELT_ENTRY AS OBJECT (NOM_ARG VARCHAR2(50),NOM_ELT VARCHAR2(50) )
##
TGE_MAP_ARG_ELT_ENTRY_TABLE
==
create or replace TYPE TGE_MAP_ARG_ELT_ENTRY_TABLE FORCE AS TABLE OF TGE_MAP_ARG_ELT_ENTRY
##
TGE_PAC_PAIEZAD_PERIOD_RETRO
=SQL IF_TYPE_NOTEXIST=TGE_PAC_PAIEZAD_PERIOD_RETRO=
create or replace TYPE TGE_PAC_PAIEZAD_PERIOD_RETRO AS OBJECT (PAIEZAD VARCHAR2(8), NUMPAC VARCHAR2(6),  PERIODE  VARCHAR2(6))
##
TYPE_GAP_SEL_PACMAT
=SQL IF_TYPE_NOTEXIST=TYPE_GAP_SEL_PACMAT=
create or replace type TYPE_GAP_SEL_PACMAT is table of VARCHAR2(8)
##
TYP_DONNEES_UX
=SQL IF_TYPE_NOTEXIST=TYP_DONNEES_UX=
create or replace TYPE TYP_DONNEES_UX FORCE AS OBJECT (NOM_DONNEE VARCHAR2(100));
##
TYP_ERR
=SQL IF_TYPE_NOTEXIST=TYP_ERR=
create or replace TYPE TYP_ERR FORCE AS OBJECT (NOM_TABLE VARCHAR2(30), NOM_COLONNE VARCHAR2(30), LIBELLE_ERREUR VARCHAR2(50));
##
TYP_OBJ
=SQL IF_TYPE_NOTEXIST=TYP_OBJ=
create or replace TYPE TYP_OBJ FORCE AS OBJECT (DONNEEGXP VARCHAR2(30), TABLEGXP VARCHAR2(30), TABLE_NAME VARCHAR2(30), NUMPAC VARCHAR2(6), ELEMENT VARCHAR2(4));
##
TYP_TAB
=SQL IF_TYPE_NOTEXIST=TYP_TAB=
create or replace TYPE TYP_TAB FORCE AS TABLE OF TYP_OBJ;
##
TYP_TAB_ABS
=SQL IF_TYPE_NOTEXIST=TYP_TAB_ABS=
create or replace TYPE TYP_TAB_ABS FORCE AS OBJECT (TABLE_PH_ABS VARCHAR2(50));
##
TYP_TAB_VERIF
=SQL IF_TYPE_NOTEXIST=TYP_TAB_VERIF=
create or replace TYPE TYP_TAB_VERIF FORCE AS TABLE OF TYP_VERIF;
##
TYP_VERIF
=SQL IF_TYPE_NOTEXIST=TYP_VERIF=
create or replace TYPE TYP_VERIF FORCE AS OBJECT (NUMPAC VARCHAR2(6),TABLEGXP VARCHAR2(30), DONNEEGXP VARCHAR2(30), PACMAT VARCHAR2(8), PAIEZAD VARCHAR2(8), VALEUR VARCHAR2(40));
##
T_CLES_IDX_CONTRAT_HISTO
==
CREATE OR REPLACE TYPE T_CLES_IDX_CONTRAT_HISTO FORCE AS TABLE OF T_CLE_IDX_CONTRAT_HISTO
##
T_CLE_IDX_CONTRAT_HISTO
==
CREATE OR REPLACE TYPE T_CLE_IDX_CONTRAT_HISTO FORCE AS OBJECT (MATRIC VARCHAR2(32), NUMPAC VARCHAR2(6), PACMAT VARCHAR2(8), NUMCNT NUMBER(9,0), DATE_IDX DATE)
##
T_COL
=SQL IF_TYPE_NOTEXIST=T_COL=
create or replace TYPE T_COL FORCE AS OBJECT (NUMPAC VARCHAR2(6), ELEMENT VARCHAR2(4), TRAITEMENT VARCHAR(500));
##
T_LIGEMP_METAGT
==
create or replace TYPE T_LIGEMP_METAGT FORCE AS OBJECT (MATRIC VARCHAR2(32), DATDEB VARCHAR2(8), OCCURS NUMBER(38,3)  ,DATFIN VARCHAR2(8), NIVEAU             NUMBER(38,3) , CODFMET            VARCHAR2(10) , CODMETIER          VARCHAR2(10) ,CODEMPLOI          VARCHAR2(16))
##
T_LIGRAGCLASSI
=SQL=
create or replace TYPE T_LIGRAGCLASSI FORCE AS OBJECT (MATRIC VARCHAR2(32), DATDEB VARCHAR2(8), DATFIN VARCHAR2(8), COD_CAT VARCHAR2(5))
##
T_LIGRAGCONTRAT
=SQL=
create or replace TYPE T_LIGRAGCONTRAT FORCE AS OBJECT (MATRIC VARCHAR2(32), DATDEB VARCHAR2(8), DATFIN VARCHAR2(8), CODCONT VARCHAR2(2))
##
T_LIGRAGNATCONTRAT
=SQL=
create or replace TYPE T_LIGRAGNATCONTRAT FORCE AS OBJECT (MATRIC VARCHAR2(32), DATDEB VARCHAR2(8), DATEFIN VARCHAR2(8), NATCONT VARCHAR2(3))
##
TAG_CHARSET=@€éèç
##
T_LIG_DAC
=SQL IF_TYPE_NOTEXIST=T_LIG_DAC=
CREATE OR REPLACE TYPE T_LIG_DAC FORCE AS OBJECT (NUMPAC VARCHAR2(6), PACMAT VARCHAR2(8), NUMCNT NUMBER(9,0))
##
TAG_CHARSET=@€éèç
##
T_LIG_DACH
=SQL IF_TYPE_NOTEXIST=T_LIG_DACH=
CREATE OR REPLACE TYPE T_LIG_DACH FORCE AS OBJECT (NUMPAC VARCHAR2(6), PACMAT VARCHAR2(8), NUMCNT NUMBER(9,0), DATE_EFF DATE)
##
TAG_CHARSET=@€éèç
##
T_MULTICLIENT_REF_PAC
==
create or replace TYPE T_MULTICLIENT_REF_PAC FORCE AS TABLE OF T_MULTICLIENT_REF_PAC_OBJ
##
TAG_CHARSET=@€éèç
##
T_MULTICLIENT_REF_PAC_OBJ
==
create or replace TYPE T_MULTICLIENT_REF_PAC_OBJ FORCE AS OBJECT (NUMPAC VARCHAR2(6), COMPANY_ID VARCHAR2(32))
##
TAG_CHARSET=@€éèç
##
T_SYS_USR_CID
==
create or replace TYPE T_SYS_USR_CID FORCE AS TABLE OF T_SYS_USR_CID_OBJ
##
TAG_CHARSET=@€éèç
##
T_SYS_USR_CID_OBJ
==
create or replace TYPE T_SYS_USR_CID_OBJ FORCE AS OBJECT (LOGIN VARCHAR2(32), COMPANY_ID VARCHAR2(32))
##
T_TABCLI_MODELE_DONNES
=SQL=
create or replace TYPE T_TABCLI_MODELE_DONNES FORCE AS TABLE OF LIG_CLI_MODELE_DONNES
##
T_TABEMP_METAGT
=SQL=
create or replace TYPE T_TABEMP_METAGT FORCE AS TABLE OF T_LIGEMP_METAGT
##
T_TABLE
=SQL IF_TYPE_NOTEXIST=T_TABLE=
create or replace TYPE T_TABLE FORCE AS TABLE OF T_COL;
##
T_TABRAGCLASSI
=SQL=
create or replace TYPE T_TABRAGCLASSI FORCE AS TABLE OF T_LIGRAGCLASSI
##
T_TABRAGCONTRAT
=SQL=
create or replace TYPE T_TABRAGCONTRAT FORCE AS TABLE OF T_LIGRAGCONTRAT
##
T_TABRAGNATCONTRAT
=SQL=
create or replace TYPE T_TABRAGNATCONTRAT FORCE AS TABLE OF T_LIGRAGNATCONTRAT
##
TAG_CHARSET=@€éèç
##
T_TAB_DAC
==
CREATE OR REPLACE TYPE T_TAB_DAC FORCE AS TABLE OF T_LIG_DAC
##
TAG_CHARSET=@€éèç
##
T_TAB_DACH
==
CREATE OR REPLACE TYPE T_TAB_DACH FORCE AS TABLE OF T_LIG_DACH
##
TAG_CHARSET=@€éèç
##
T_WKF_DATA
==
create or replace TYPE T_WKF_DATA FORCE AS OBJECT (NOM_DICTIONNAIRE VARCHAR2(50), NUM_LIGNE NUMBER, NOM_DONNEE VARCHAR2(4000), VALEUR_DONNEE VARCHAR(4000))
##
T_WKF_DATAS
==
create or replace TYPE T_WKF_DATAS FORCE AS TABLE OF T_WKF_DATA
##
ADM_ADD_SCH_APPLICATION
=SQL=
create or replace FUNCTION ADM_ADD_SCH_APPLICATION ( p_code_schema            IN NUMBER, p_lib_1                  IN VARCHAR2,
 p_description            IN VARCHAR2,
 code_langue              IN VARCHAR2)
 RETURN SCH_ELEMENT
 
 IS
 cnt number;
 p_obj_application        SCH_ELEMENT;
 
 BEGIN
 p_obj_application := sch_element (p_code_schema, 0, p_lib_1, NULL, 0, 0, 1);
 
 BEGIN
 /* VERIFICATION DANS SYS_SCH_ELEMENT */
 SELECT NVL (code_element, 0) INTO p_obj_application.code_element FROM sys_sch_element
 WHERE (libelle = p_lib_1 AND niveau = 1) AND ROWNUM = 1;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_application.code_element = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCH_ELEMENT */
 SELECT MAX (code_element) + 1 INTO p_obj_application.code_element FROM (select code_element from sys_sch_element UNION all select 0 from dual);
 
 INSERT INTO sys_sch_element (niveau, code_element, libelle, nom_page, code_role, description, tags, TYPE)
 VALUES (p_obj_application.niveau, p_obj_application.code_element, p_obj_application.libelle, NULL, NULL, p_description, NULL, NULL);
 --dbms_output.put_line('ADM_ADD_SCH_APPLICATION: (C) [code_element] ' || p_obj_application.code_element || ' [libelle] ' || p_obj_application.libelle || ' [niveau] ' || p_obj_application.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_APPLICATION: (E) [code_element] ' || p_obj_application.code_element || ' [libelle] ' || p_obj_application.libelle || ' [niveau] ' || p_obj_application.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 BEGIN
 SELECT count(*) INTO cnt FROM sys_sch_element_ml a
 WHERE a.code_element = p_obj_application.code_element AND a.CODLANG = code_langue AND a.niveau = p_obj_application.niveau;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (cnt = 0) THEN
 INSERT INTO sys_sch_element_ml (CODLANG, NIVEAU, CODE_ELEMENT, LIBELLE)
 VALUES (code_langue, p_obj_application.niveau, p_obj_application.code_element, p_obj_application.libelle);
 END IF;
 
 
 /* VERIFICATION DANS SYS_SCHEMAS */
 BEGIN
 SELECT s1.code_asso INTO p_obj_application.code_asso
 FROM sys_sch_element e1, sys_schemas s1
 WHERE s1.code_schema = p_code_schema
 AND s1.code_elt = e1.code_element
 AND s1.niveau = e1.niveau
 AND s1.niveau = '1'
 AND e1.libelle = p_lib_1;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_application.code_asso = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCHEMAS */
 SELECT MAX (code_asso) + 1 INTO p_obj_application.code_asso FROM (select code_asso from sys_schemas UNION all select 0 from dual);
 p_obj_application.code_asso_pere := 0;
 
 INSERT INTO sys_schemas (code_schema, code_asso, code_asso_pere, code_elt, niveau, ordre)
 VALUES (p_obj_application.code_schema, p_obj_application.code_asso, p_obj_application.code_asso_pere, p_obj_application.code_element, p_obj_application.niveau, 0);
 --dbms_output.put_line('ADM_ADD_SCH_APPLICATION: (C) [code_schema] ' || p_obj_application.code_schema || ' [code_asso] ' || p_obj_application.code_asso || ' [code_asso_pere) ' || p_obj_application.code_asso_pere || ' [niveau] ' || p_obj_application.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_APPLICATION: (E) [code_schema] ' || p_obj_application.code_schema || ' [code_asso] ' || p_obj_application.code_asso || ' [code_asso_pere] ' || p_obj_application.code_asso_pere || ' [niveau] ' || p_obj_application.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 RETURN p_obj_application;
 END ADM_ADD_SCH_APPLICATION; 
 ##
ADM_ADD_SCH_CLASSEUR
=SQL=
create or replace FUNCTION ADM_ADD_SCH_CLASSEUR( p_code_schema            IN NUMBER, p_lib_1                  IN VARCHAR2,
 p_lib_2                  IN VARCHAR2,
 p_lib_3                  IN VARCHAR2,
 p_lib_4                  IN VARCHAR2,
 p_obj_theme              IN SCH_ELEMENT,
 p_description            IN VARCHAR2,
 code_langue              IN VARCHAR2
 ) RETURN SCH_ELEMENT
 
 IS
 p_obj_classeur              SCH_ELEMENT;
 ordreClasseur     NUMBER;
 cnt NUMBER;
 BEGIN
 p_obj_classeur := sch_element(p_code_schema, 0, p_lib_4, NULL, 0, 0, 4);
 
 BEGIN
 /* VERIFICATION DANS SYS_SCH_ELEMENT*/
 SELECT NVL(code_element, 0) INTO p_obj_classeur.code_element FROM sys_sch_element
 WHERE (libelle = p_lib_4 AND niveau = 4) AND ROWNUM = 1;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_classeur.code_element = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCH_ELEMENT */
 SELECT MAX(code_element) + 1 INTO p_obj_classeur.code_element FROM sys_sch_element;
 
 INSERT INTO sys_sch_element(niveau, code_element, libelle, nom_page, code_role, description, tags, type)
 VALUES(p_obj_classeur.niveau, p_obj_classeur.code_element, p_obj_classeur.libelle, NULL, NULL, p_description, NULL, NULL);
 
 --dbms_output.put_line('ADM_ADD_SCH_SUJET: (C) [code_element] ' || p_obj_classeur.code_element || ' [libelle] ' || p_obj_classeur.libelle || ' [niveau] ' || p_obj_classeur.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_SUJET: (E) [code_element] ' || p_obj_classeur.code_element || ' [libelle] ' || p_obj_classeur.libelle || ' [niveau] ' || p_obj_classeur.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 IF (code_langue != 'fr_fr') THEN
 BEGIN
 SELECT count(*) INTO cnt FROM sys_sch_element_ml a
 WHERE a.code_element = p_obj_classeur.code_element AND a.CODLANG = code_langue AND a.niveau = p_obj_classeur.niveau;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (cnt = 0) THEN
 INSERT INTO sys_sch_element_ml (CODLANG, NIVEAU, CODE_ELEMENT, LIBELLE)
 VALUES (code_langue , p_obj_classeur.niveau, p_obj_classeur.code_element, p_obj_classeur.libelle);
 END IF;
 END IF;
 
 /* VERIFICATION DANS SYS_SCHEMAS */
 BEGIN
 SELECT s4.code_asso, s4.code_asso_pere INTO p_obj_classeur.code_asso, p_obj_classeur.code_asso_pere
 FROM sys_sch_element e1, sys_sch_element e2, sys_sch_element e3, sys_sch_element e4, sys_schemas s1, sys_schemas s2, sys_schemas s3, sys_schemas s4
 WHERE  s1.code_schema = p_code_schema
 AND s4.code_schema = p_code_schema
 AND s3.code_schema = p_code_schema
 AND s2.code_schema = p_code_schema
 AND s1.code_schema = p_code_schema
 AND s4.code_elt = e4.code_element AND s4.niveau = e4.niveau
 AND s3.code_elt = e3.code_element AND s3.niveau = e3.niveau
 AND s2.code_elt = e2.code_element AND s2.niveau = e2.niveau
 AND s1.code_elt = e1.code_element AND s1.niveau = e1.niveau
 AND s4.niveau ='4'
 AND s3.niveau ='3'
 AND s2.niveau ='2'
 AND s1.niveau ='1'
 AND s4.code_asso_pere = s3.code_asso
 AND s3.code_asso_pere = s2.code_asso
 AND s2.code_asso_pere = s1.code_asso
 AND e1.libelle = p_lib_1
 AND e2.libelle = p_lib_2
 AND e3.libelle = p_lib_3
 AND e4.libelle = p_lib_4;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_classeur.code_asso = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCHEMAS */
 SELECT MAX(code_asso) + 2 INTO p_obj_classeur.code_asso FROM sys_schemas;
 p_obj_classeur.code_asso_pere := p_obj_theme.code_asso;
 
 /* RECUPERATION de L ORDRE*/
 SELECT MAX(NVL(ORDRE,0))+1 INTO ordreClasseur FROM SYS_SCHEMAS WHERE code_schema = p_obj_classeur.code_schema AND code_asso_pere = p_obj_classeur.code_asso_pere ;
 IF ordreClasseur is NULL THEN
 ordreClasseur := 0;
 END IF;
 
 
 
 INSERT INTO sys_schemas(code_schema, code_asso, code_asso_pere, code_elt, niveau, ordre)
 VALUES(p_obj_classeur.code_schema, p_obj_classeur.code_asso, p_obj_classeur.code_asso_pere, p_obj_classeur.code_element, p_obj_classeur.niveau, ordreClasseur);
 --dbms_output.put_line('ADM_ADD_SCH_SUJET: (C) [code_schema] ' || p_obj_classeur.code_schema || ' [code_asso] ' || p_obj_classeur.code_asso || ' [code_asso_pere) ' || p_obj_classeur.code_asso_pere || ' [niveau] ' || p_obj_classeur.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_SUJET: (E) [code_schema] ' || p_obj_classeur.code_schema || ' [code_asso] ' || p_obj_classeur.code_asso || ' [code_asso_pere] ' || p_obj_classeur.code_asso_pere || ' [niveau] ' || p_obj_classeur.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 RETURN p_obj_classeur;
 END ADM_ADD_SCH_CLASSEUR; 
 ##
ADM_ADD_SCH_REGROUPEMENT
=SQL=
create or replace FUNCTION ADM_ADD_SCH_REGROUPEMENT( p_code_schema            IN NUMBER, p_lib_1                  IN VARCHAR2,
 p_lib_2                  IN VARCHAR2,
 p_obj_application        IN SCH_ELEMENT,
 p_description            IN VARCHAR2,
 p_code_role              IN NUMBER DEFAULT NULL,
 code_langue              IN VARCHAR2
 ) RETURN SCH_ELEMENT
 
 IS
 p_obj_regroup              SCH_ELEMENT;
 ordreRegroup    NUMBER;
 cnt NUMBER;
 BEGIN
 p_obj_regroup := sch_element(p_code_schema, 0, p_lib_2, NULL, 0, 0, 2);
 
 BEGIN
 /* VERIFICATION DANS SYS_SCH_ELEMENT*/
 SELECT NVL(code_element, 0) INTO p_obj_regroup.code_element
 FROM sys_sch_element
 WHERE (libelle = p_lib_2 AND niveau = 2) AND ROWNUM = 1 ;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_regroup.code_element = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCH_ELEMENT */
 SELECT MAX(code_element) + 1 INTO p_obj_regroup.code_element FROM sys_sch_element;
 
 INSERT INTO sys_sch_element(niveau, code_element, libelle, nom_page, code_role, description, tags, type)
 VALUES(p_obj_regroup.niveau, p_obj_regroup.code_element, p_obj_regroup.libelle, NULL, p_code_role, p_description, NULL, NULL);
 
 --dbms_output.put_line('ADM_ADD_SCH_REGROUP: (C) [code_element] ' || p_obj_regroup.code_element || ' [libelle] ' || p_obj_regroup.libelle || ' [niveau] ' || p_obj_regroup.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_REGROUP: (E) [code_element] ' || p_obj_regroup.code_element || ' [libelle] ' || p_obj_regroup.libelle || ' [niveau] ' || p_obj_regroup.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 IF (code_langue != 'fr_fr') THEN
 BEGIN
 SELECT count(*) INTO cnt FROM sys_sch_element_ml a
 WHERE a.code_element = p_obj_regroup.code_element AND a.CODLANG = code_langue AND a.niveau = p_obj_regroup.niveau;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (cnt = 0) THEN
 INSERT INTO sys_sch_element_ml (CODLANG, NIVEAU, CODE_ELEMENT, LIBELLE)
 VALUES (code_langue , p_obj_regroup.niveau, p_obj_regroup.code_element, p_obj_regroup.libelle);
 END IF;
 END IF;
 
 /* VERIFICATION DANS SYS_SCHEMAS */
 BEGIN
 SELECT s2.code_asso, s2.code_asso_pere INTO p_obj_regroup.code_asso, p_obj_regroup.code_asso_pere
 FROM sys_sch_element e1, sys_sch_element e2, sys_schemas s1, sys_schemas s2
 WHERE s1.code_schema = p_code_schema
 AND s2.code_schema = p_code_schema
 AND s2.code_elt = e2.code_element AND s2.niveau = e2.niveau
 AND s1.code_elt = e1.code_element AND s1.niveau = e1.niveau
 AND s2.niveau ='2'
 AND s1.niveau ='1'
 AND s2.code_asso_pere = s1.code_asso
 AND e1.libelle = p_lib_1
 AND e2.libelle = p_lib_2;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_regroup.code_asso = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCHEMAS */
 SELECT MAX(code_asso) + 1 INTO p_obj_regroup.code_asso FROM sys_schemas;
 p_obj_regroup.code_asso_pere := p_obj_application.code_asso;
 
 /*RECUPERATION DE L ORDRE pour ajouter à la fin */
 SELECT MAX(NVL(ORDRE,0))+1 INTO ordreRegroup FROM SYS_SCHEMAS WHERE code_schema = p_obj_regroup.code_schema AND code_asso_pere = p_obj_regroup.code_asso_pere ;
 IF ordreRegroup is NULL THEN
 ordreRegroup := 0;
 END IF;
 
 INSERT INTO sys_schemas(code_schema, code_asso, code_asso_pere, code_elt, niveau, ordre)
 VALUES(p_obj_regroup.code_schema, p_obj_regroup.code_asso, p_obj_regroup.code_asso_pere, p_obj_regroup.code_element, p_obj_regroup.niveau, ordreRegroup);
 --dbms_output.put_line('ADM_ADD_SCH_REGROUP: (C) [code_schema] ' || p_obj_regroup.code_schema || ' [code_asso] ' || p_obj_regroup.code_asso || ' [code_asso_pere) ' || p_obj_regroup.code_asso_pere || ' [niveau] ' || p_obj_regroup.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_REGROUP: (E) [code_schema] ' || p_obj_regroup.code_schema || ' [code_asso] ' || p_obj_regroup.code_asso || ' [code_asso_pere) ' || p_obj_regroup.code_asso_pere || ' [niveau] ' || p_obj_regroup.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF ;
 
 RETURN p_obj_regroup;
 END ADM_ADD_SCH_REGROUPEMENT; 
 ##
ADM_ADD_SCH_SUJET
=SQL=
create or replace FUNCTION ADM_ADD_SCH_SUJET( p_code_schema            IN NUMBER, p_lib_1                  IN VARCHAR2,
 p_lib_2                  IN VARCHAR2,
 p_lib_3                  IN VARCHAR2,
 p_lib_4                  IN VARCHAR2,
 p_lib_99                 IN VARCHAR2,
 p_nom_page               IN VARCHAR2,
 p_obj_classeur           IN SCH_ELEMENT,
 p_description            IN VARCHAR2,
 code_langue              IN VARCHAR2
 ) RETURN SCH_ELEMENT
 
 IS
 p_obj_sujet               SCH_ELEMENT;
 ordrePage NUMBER;
 cnt NUMBER;
 BEGIN
 p_obj_sujet := sch_element(p_code_schema, 0, p_lib_99, p_nom_page, 0, 0, 99);
 
 BEGIN
 /* VERIFICATION DANS SYS_SCH_ELEMENT */
 SELECT NVL(code_element, 0) INTO p_obj_sujet.code_element FROM sys_sch_element e
 WHERE (nom_page = p_nom_page AND niveau = 99) AND ROWNUM = 1;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_sujet.code_element = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCH_ELEMENT */
 SELECT MAX(code_element) + 1 INTO p_obj_sujet.code_element FROM sys_sch_element;
 
 INSERT INTO sys_sch_element(niveau, code_element, libelle, nom_page, code_role, description, tags, type)
 VALUES(p_obj_sujet.niveau, p_obj_sujet.code_element, p_obj_sujet.libelle, p_obj_sujet.nom_page, NULL, p_description, NULL, NULL);
 --dbms_output.put_line('ADM_ADD_SCH_PAGE: (C) [code_element] ' || p_obj_sujet.code_element || ' [libelle] ' || p_obj_sujet.libelle || ' [niveau] ' || p_obj_sujet.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_PAGE: (E) [code_element] ' || p_obj_sujet.code_element || ' [libelle] ' || p_obj_sujet.libelle || ' [niveau] ' || p_obj_sujet.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 IF (code_langue != 'fr_fr') THEN
 BEGIN
 SELECT count(*) INTO cnt FROM sys_sch_element_ml a
 WHERE a.code_element = p_obj_sujet.code_element AND a.CODLANG = code_langue AND a.niveau = p_obj_sujet.niveau;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (cnt = 0) THEN
 INSERT INTO sys_sch_element_ml (CODLANG, NIVEAU, CODE_ELEMENT, LIBELLE)
 VALUES (code_langue , p_obj_sujet.niveau, p_obj_sujet.code_element, p_obj_sujet.libelle);
 END IF;
 END IF;
 
 /* VERIFICATION DANS SYS_SCHEMAS */
 BEGIN
 SELECT s5.code_asso, s5.code_asso_pere INTO p_obj_sujet.code_asso, p_obj_sujet.code_asso_pere
 FROM sys_sch_element e1, sys_sch_element e2, sys_sch_element e3, sys_sch_element e4, sys_sch_element e5, sys_schemas s1, sys_schemas s2, sys_schemas s3, sys_schemas s4, sys_schemas s5
 WHERE  s5.code_schema = p_code_schema
 AND s4.code_schema = p_code_schema
 AND s3.code_schema = p_code_schema
 AND s2.code_schema = p_code_schema
 AND s1.code_schema = p_code_schema
 AND s5.code_elt = e5.code_element AND s5.niveau = e5.niveau
 AND s4.code_elt = e4.code_element AND s4.niveau = e4.niveau
 AND s3.code_elt = e3.code_element AND s3.niveau = e3.niveau
 AND s2.code_elt = e2.code_element AND s2.niveau = e2.niveau
 AND s1.code_elt = e1.code_element AND s1.niveau = e1.niveau
 AND s5.niveau ='99'
 AND s4.niveau ='4'
 AND s3.niveau ='3'
 AND s2.niveau ='2'
 AND s1.niveau ='1'
 AND s5.code_asso_pere = s4.code_asso
 AND s4.code_asso_pere = s3.code_asso
 AND s3.code_asso_pere = s2.code_asso
 AND s2.code_asso_pere = s1.code_asso
 AND e1.libelle = p_lib_1
 AND e2.libelle = p_lib_2
 AND e3.libelle = p_lib_3
 AND e4.libelle = p_lib_4
 AND e5.libelle = p_lib_99;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_sujet.code_asso = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCHEMAS */
 SELECT MAX(code_asso) + 1 INTO p_obj_sujet.code_asso FROM sys_schemas;
 p_obj_sujet.code_asso_pere := p_obj_classeur.code_asso;
 
 
 SELECT NVL(MAX(ordre),0) + 1 INTO ordrePage FROM sys_schemas
 where code_schema = p_obj_sujet.code_schema
 and code_asso_pere = p_obj_sujet.code_asso_pere ;
 
 INSERT INTO sys_schemas(code_schema, code_asso, code_asso_pere, code_elt, niveau, ordre)
 VALUES(p_obj_sujet.code_schema, p_obj_sujet.code_asso, p_obj_sujet.code_asso_pere, p_obj_sujet.code_element, p_obj_sujet.niveau, ordrePage);
 --dbms_output.put_line('ADM_ADD_SCH_PAGE: (C) [code_schema] ' || p_obj_sujet.code_schema || ' [code_asso] ' || p_obj_sujet.code_asso || ' [code_asso_pere) ' || p_obj_sujet.code_asso_pere || ' [niveau] ' || p_obj_sujet.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_PAGE: (E) [code_schema] ' || p_obj_sujet.code_schema || ' [code_asso] ' || p_obj_sujet.code_asso || ' [code_asso_pere) ' || p_obj_sujet.code_asso_pere || ' [niveau] ' || p_obj_sujet.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 RETURN p_obj_sujet;
 END ADM_ADD_SCH_SUJET;
 ##
ADM_ADD_SCH_THEME
=SQL=
create or replace FUNCTION ADM_ADD_SCH_THEME( p_code_schema            IN NUMBER, p_lib_1                  IN VARCHAR2,
 p_lib_2                  IN VARCHAR2,
 p_lib_3                  IN VARCHAR2,
 p_obj_regroupement       IN SCH_ELEMENT,
 p_description            IN VARCHAR2,
 code_langue              IN VARCHAR2
 ) RETURN SCH_ELEMENT
 
 IS
 p_obj_theme           SCH_ELEMENT;
 ordretheme NUMBER;
 cnt NUMBER;
 
 BEGIN
 /* INITIALISATION OBJET */
 p_obj_theme := sch_element(p_code_schema, 0, p_lib_3, NULL, 0, 0, 3);
 
 BEGIN
 /* VERIFICATION DANS SYS_SCH_ELEMENT*/
 SELECT NVL(code_element, 0) INTO p_obj_theme.code_element FROM sys_sch_element
 WHERE (libelle = p_lib_3 AND niveau = 3) AND ROWNUM = 1;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_theme.code_element = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCH_ELEMENT */
 SELECT MAX(code_element) + 1 INTO p_obj_theme.code_element FROM sys_sch_element;
 
 INSERT INTO sys_sch_element(niveau, code_element, libelle, nom_page, code_role, description, tags, type)
 VALUES(p_obj_theme.niveau, p_obj_theme.code_element, p_obj_theme.libelle, NULL, NULL, p_description, NULL, NULL);
 
 --dbms_output.put_line('ADM_ADD_SCH_THEME: (C) [code_element] ' || p_obj_theme.code_element || ' [libelle] ' || p_obj_theme.libelle || ' [niveau] ' || p_obj_theme.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_THEME: (E) [code_element] ' || p_obj_theme.code_element || ' [libelle] ' || p_obj_theme.libelle || ' [niveau] ' || p_obj_theme.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 IF (code_langue != 'fr_fr') THEN
 BEGIN
 SELECT count(*) INTO cnt FROM sys_sch_element_ml a
 WHERE a.code_element = p_obj_theme.code_element AND a.CODLANG = code_langue AND a.niveau = p_obj_theme.niveau;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (cnt = 0) THEN
 INSERT INTO sys_sch_element_ml (CODLANG, NIVEAU, CODE_ELEMENT, LIBELLE)
 VALUES (code_langue , p_obj_theme.niveau, p_obj_theme.code_element, p_obj_theme.libelle);
 END IF;
 END IF;
 
 /* VERIFICATION DANS SYS_SCHEMAS */
 BEGIN
 SELECT s3.code_asso, s3.code_asso_pere INTO p_obj_theme.code_asso, p_obj_theme.code_asso_pere
 FROM sys_sch_element e1, sys_sch_element e2, sys_sch_element e3, sys_schemas s1, sys_schemas s2, sys_schemas s3
 WHERE s1.code_schema = p_code_schema
 AND s3.code_schema = p_code_schema
 AND s2.code_schema = p_code_schema
 AND s1.code_schema = p_code_schema
 AND s3.code_elt = e3.code_element and s3.niveau = e3.niveau
 AND s2.code_elt = e2.code_element and s2.niveau = e2.niveau
 AND s1.code_elt = e1.code_element and s1.niveau = e1.niveau
 AND s3.niveau ='3'
 AND s2.niveau ='2'
 AND s1.niveau ='1'
 AND s3.code_asso_pere = s2.code_asso
 AND s2.code_asso_pere = s1.code_asso
 AND e1.libelle = p_lib_1
 AND e2.libelle = p_lib_2
 AND e3.libelle = p_lib_3;
 EXCEPTION WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 
 IF (p_obj_theme.code_asso = 0) THEN
 /* CREATION ELEMENT DANS SYS_SCHEMAS */
 SELECT MAX(code_asso) + 1 INTO p_obj_theme.code_asso FROM sys_schemas;
 p_obj_theme.code_asso_pere := p_obj_regroupement.code_asso;
 
 /* RECUPERATION de L ORDRE*/
 SELECT MAX(NVL(ORDRE,0))+1 INTO ordretheme FROM SYS_SCHEMAS WHERE code_schema = p_obj_theme.code_schema AND code_asso_pere = p_obj_theme.code_asso_pere ;
 IF ordretheme is NULL THEN
 ordretheme := 0;
 END IF;
 
 
 INSERT INTO sys_schemas(code_schema, code_asso, code_asso_pere, code_elt, niveau, ordre)
 VALUES(p_obj_theme.code_schema, p_obj_theme.code_asso, p_obj_theme.code_asso_pere, p_obj_theme.code_element, p_obj_theme.niveau, ordretheme);
 --dbms_output.put_line('ADM_ADD_SCH_THEME: (C) [code_schema] ' || p_obj_theme.code_schema || ' [code_asso] ' || p_obj_theme.code_asso || ' [code_asso_pere) ' || p_obj_theme.code_asso_pere || ' [niveau] ' || p_obj_theme.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 --ELSE
 --dbms_output.put_line('ADM_ADD_SCH_THEME: (E) [code_schema] ' || p_obj_theme.code_schema || ' [code_asso] ' || p_obj_theme.code_asso || ' [code_asso_pere] ' || p_obj_theme.code_asso_pere || ' [niveau] ' || p_obj_theme.niveau);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 
 RETURN p_obj_theme;
 END ADM_ADD_SCH_THEME;
 ##
ADM_PAGE_EXIST_IN_SCHEMA
=SQL=
create or replace FUNCTION ADM_PAGE_EXIST_IN_SCHEMA (
  p_nom_page               IN VARCHAR2,
  p_code_schema            IN NUMBER
) RETURN NUMBER

IS
  p_page                   NUMBER :=0;

BEGIN
  BEGIN
    SELECT COUNT(DISTINCT s.code_elt) INTO p_page FROM sys_schemas s, sys_sch_element e
     WHERE (s.code_schema = p_code_schema AND s.code_elt = e.code_element AND e.nom_page = p_nom_page AND e.niveau = 99);

    IF (p_page > 0) THEN
      RETURN 1; -- la page est présente dans ce schéma
    END IF;

    EXCEPTION WHEN NO_DATA_FOUND THEN
      RETURN 0;
  END; 
  RETURN 0; -- la page n'est pas présente dans ce schéma
END ADM_PAGE_EXIST_IN_SCHEMA;
##
ALERTE_PARCOURS
=SQL=
CREATE OR REPLACE
  FUNCTION ALERTE_PARCOURS(
      p1 IN VARCHAR2,
      p2 IN VARCHAR2,
      p3 IN VARCHAR2,
      p4 IN VARCHAR2 ,
      p5 IN VARCHAR2 ,
      p6 IN VARCHAR2 )
    RETURN VARCHAR2
  IS
    LR$ALERTE FOR_ALERTE_PARCOURS%RowType ;
    LN$RETOUR VARCHAR2(500)                 := '';
    LC$NUM    NUMBER                        := 0;
    LN$REQ FOR_ALERTE_PARCOURS.REQUETE%type := '';
    CURSOR C_ALERTE
    IS
      SELECT * FROM FOR_ALERTE_PARCOURS WHERE ACTIVE = 1 ORDER BY ORDRE ;
  BEGIN
    OPEN C_ALERTE ;
    LOOP
      FETCH C_ALERTE INTO LR$ALERTE ;
      EXIT
    WHEN C_ALERTE%NOTFOUND ;
      --dbms_output.put_line( 'requete=' || LR$ALERTE.REQUETE ) ;
      --FIXME utiliser la procédure trace_dbms_output()
      LN$REQ := LR$ALERTE.REQUETE;
      LN$REQ := REPLACE(LN$REQ,'#1',p1);
      LN$REQ := REPLACE(LN$REQ,'#2',p2);
      LN$REQ := REPLACE(LN$REQ,'#3',p3);
      LN$REQ := REPLACE(LN$REQ,'#4',p4);
      LN$REQ := REPLACE(LN$REQ,'#5',p5);
      LN$REQ := REPLACE(LN$REQ,'#6',p6);
      --dbms_output.put_line( 'apres=' || LN$REQ ) ;
      --FIXME utiliser la procédure trace_dbms_output()
      LC$NUM      := ALERTE_UNITAIRE('select count(*) from ('|| LN$REQ ||')');
      IF (LC$NUM   >0) THEN
        LN$RETOUR := LN$RETOUR || LR$ALERTE.CODEALERTE || ';' ;
      END IF;
    END LOOP ;
    CLOSE C_ALERTE ;
    RETURN( LN$RETOUR ) ;
  END;
##
ALERTE_UNITAIRE
=SQL=
CREATE OR REPLACE
  FUNCTION ALERTE_UNITAIRE(
      Req IN VARCHAR2)
    RETURN NUMBER
  IS
  TYPE TCur
IS
  REF
  CURSOR ;
    cur TCur ;
    RetourSelect VARCHAR2(80);
    Retour       NUMBER := 0;
  BEGIN
    OPEN cur FOR Req ;
    LOOP
      FETCH cur INTO Retour ;
    EXIT
  WHEN cur%NOTFOUND ;
    RETURN Retour ;
  END LOOP ;
  CLOSE cur ;
  RETURN Retour;
END ; 
##
AUDIT_ALIM_PERIODE_INDIV
=SQL=
CREATE OR REPLACE FUNCTION AUDIT_ALIM_PERIODE_INDIV(
    p_id           IN NUMBER,
    p_numpac       IN VARCHAR2,
    p_periode_paie IN VARCHAR2,
    p_pacmat       IN VARCHAR2 )
  RETURN AUDIT_ALIM_PERIODE_TAB
AS
  w_err VARCHAR2(2000);
  req CLOB;
type PERIODE
IS
  RECORD
  (
    paiezad DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE,
    deb_rec DATE,
    fin_rec DATE );
type PERIODE_TAB
IS
  TABLE OF PERIODE INDEX BY BINARY_INTEGER;
  tab1 PERIODE_TAB;
  retour AUDIT_ALIM_PERIODE_TAB := AUDIT_ALIM_PERIODE_TAB();
  w_tablegxp TGE_REF_MAPDO.TABLEGXP%TYPE;
  w_Y326 TGE_REF_MAPDO.DONNEEGXP%TYPE;
  w_Y327 TGE_REF_MAPDO.DONNEEGXP%TYPE;
BEGIN
  TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','AUDIT_ALIM_PERIODE_INDIV début');
  BEGIN
    SELECT tablegxp ,
      Y326_DONNEE ,
      Y327_DONNEE
    INTO w_tablegxp,
      w_Y326,
      w_Y327
    FROM
      ( SELECT DISTINCT c.element,
        c.tablegxp,
        c.DONNEEGXP
      FROM tge_ref_mapdo c
      WHERE C.numpac = p_numpac
      AND c.element IN ('Y326','Y327')
      UNION ALL
      SELECT DISTINCT c.element,
        c.tablegxp,
        c.DONNEEGXP
      FROM tge_ref_mapdo c
      WHERE C.numpac                  ='*'
      AND c.element                  IN ('Y326','Y327')
      AND (c.TABLEGXP,c.ELEMENT) NOT IN
        (SELECT a.TABLEGXP,
          a.element
        FROM tge_ref_mapdo a
        WHERE a.numpac = p_numpac
        AND A.ELEMENT IN ('Y326','Y327')
        )
      ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element) IN('Y326' AS Y326 ,'Y327' AS Y327));
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','AUDIT_ALIM_PERIODE_INDIV ERR : Erreurs de configuration de TGE_REF_MAPDO : NUMPAC = ''' || p_numpac || ''' AND ELEMENT in (''Y326'',''Y327'')');
    raise;
  END;
req         := 'select rec.PAIEZAD, rec.'|| w_Y326|| ' as deb_rec , rec.'|| w_Y327||' as fin_rec ';
req         := req || 'from '|| w_tablegxp ||' rec inner join DIC_ADM_CONTRAT_SITU sit on rec.numpac = sit.numpac AND rec.paiezad = sit.paiezad ';
req         := req || 'where NVL(sit.DSFSC,TO_DATE(''20990101'',''YYYYMMDD'')) >= last_day(to_date(to_char('''|| p_periode_paie ||'''),''yyyymm'')) ';
req         := req || 'AND ((rec.'|| w_Y326 ||' IS NULL AND rec.'|| w_Y327 ||' IS NOT NULL) OR (rec.'|| w_Y326 ||' IS NOT NULL AND rec.'|| w_Y327 ||' IS NULL)) ';
req         := req || 'AND sit.numpac = ''' || p_numpac || '''';
IF p_pacmat IS NOT NULL THEN
  req       := req || ' AND sit.pacmat = ''' || p_pacmat || '''';
END IF;
TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','AUDIT_ALIM_PERIODE_INDIV EXECUTE ' || req);
EXECUTE IMMEDIATE req BULK COLLECT INTO tab1;
IF tab1.exists(1) THEN
  FOR i IN tab1.first..tab1.last
  LOOP
    retour.extend;
    retour(retour.count) := AUDIT_ALIM_PERIODE_COL(tab1(i).PAIEZAD, tab1(i).deb_rec,tab1(i).fin_rec);
  END LOOP;
END IF;
TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin AUDIT_ALIM_PERIODE_INDIV OK');
RETURN retour;
EXCEPTION
WHEN OTHERS THEN
  w_err := SQLCODE;
  w_err := 'AUDIT_ALIM_PERIODE_INDIV '||w_err||' '||sqlerrm;
  TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin AUDIT_ALIM_PERIODE_INDIV KO ' || w_err);
  raise;
END AUDIT_ALIM_PERIODE_INDIV;
##
BDC_LINEARISE_ANOMALIE
=SQL=
CREATE OR REPLACE
  FUNCTION BDC_LINEARISE_ANOMALIE(
      pmatric        IN VARCHAR2,
      pnumcontrole   IN NUMBER,
      pdatetraitplp  IN VARCHAR2,
      pruped         IN NUMBER ,
      penvironnement IN VARCHAR2)
    RETURN VARCHAR2
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
    req VARCHAR2(2500);
  BEGIN
    req := 'SELECT (BDC_ANOMALIE.CODE_ALERTE) ';
    req :=req||'||''-''||'||penvironnement||'.LIB_ALERTE  from BDC_ANOMALIE, ';
    req :=req||penvironnement||' WHERE BDC_ANOMALIE.CODE_ALERTE = ';
    req :=req||penvironnement||'.CODE_ALERTE ';
    req :=req||' AND BDC_ANOMALIE.MATRIC='||pmatric ;
    req :=req||' AND BDC_ANOMALIE.DATE_TRAIT_PLP ='||pdatetraitplp;
    req :=req||' AND  BDC_ANOMALIE.NUM_CONTROLE='||pnumcontrole;
    req :=req||' AND BDC_ANOMALIE.RUPED = '||pruped||' AND ROWNUM <= 10';
    OPEN cur FOR req ;
    LOOP
      FETCH cur INTO retourselect;
    EXIT
  WHEN cur % NOTFOUND;
    retour := retour||retourselect||'<br>';
  END LOOP ;
  CLOSE cur;
  RETURN SUBSTR(retour, 0, LENGTH(retour)-4);
END;
##
TAG_CHARSET=@€éèç
##
BUILD_TABLE_INDEX
=SQL=
create or replace FUNCTION "BUILD_TABLE_INDEX"(p_cid IN std_struc_arbre.cid%TYPE, p_codts IN std_struc_arbre.codts%TYPE ,p_date_eff IN std_struc_arbre.date_eff%TYPE ,p_date_fin IN std_struc_arbre.date_fin%TYPE) RETURN INTEGER IS retour INTEGER; 
req CLOB;

BEGIN
 
 req:=' insert into STD_STRUC_INDEX (CID, CODTS, LAST_ENTITE, DATE_EFF, DATE_FIN, NIV_TECH, IDX_CODE_ENTITE, NIV1, NIV2, NIV3, NIV4, NIV5, NIV6, NIV7, NIV8, NIV9, NIV10,';
 req:=req||'NIV11, NIV12, NIV13, NIV14, NIV15, NIV16, NIV17, NIV18, NIV19, NIV20, NIV21, NIV22, NIV23, NIV24, NIV25, NIV26, NIV27, NIV28, NIV29, NIV30, NIV31, NIV32, NIV33,';
 req:=req||'NIV34, NIV35, NIV36, NIV37, NIV38, NIV39, NIV40)';
 req:=req||' select '''||p_cid||''', '||p_codts||',code_entite,'''||p_date_eff||''','''||p_date_fin||''',niv_tech,chaine_entite,';
 req:=req||'NVL(';
      -- Si un code entité est défini pour le niveau, on le prend
 req:=req||' trim(SUBSTR(CHAINE_ENTITE, 1, 25))';
      -- S'il n'y a pas de code entité défini, mais par contre qu'il y a des codes entités définis après ce niveau, alors on écrit @NON_AFFECTE@
 req:=req||',NVL2( trim(SUBSTR(CHAINE_ENTITE, 26)) ,''@NON_AFFECTE@''';
      -- Sinon on met null
 req:=req||',''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 26, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 51)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 51, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 76)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 76, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 101)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 101, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 126)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 126, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 151)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 151, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 176)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 176, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 201)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 201, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 226)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 226, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 251)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 251, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 276)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 276, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 301)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 301, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 326)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 326, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 351)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 351, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 376)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 376, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 401)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 401, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 426)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 426, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 451)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 451, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 476)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 476, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 501)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 501, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 526)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 526, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 551)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 551, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 576)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 576, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 601)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 601, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 626)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 626, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 651)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 651, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 676)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 676, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 701)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 701, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 726)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 726, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 751)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 751, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 776)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 776, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 801)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 801, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 826)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 826, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 851)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 851, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 876)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 876, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 901)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 901, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 926)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 926, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 951)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
 req:=req||'NVL( trim(SUBSTR(CHAINE_ENTITE, 951, 25)) ,NVL2( trim(SUBSTR(CHAINE_ENTITE, 976)) ,''@NON_AFFECTE@'' ,''@VIDE@'' ) ),';
      -- Dernier niveau pas besoin de regarder s'il y a des codes entités après
 req:=req||'NVL(trim(SUBSTR(CHAINE_ENTITE, 976, 25)),''@VIDE@'')';
 req:=req||' from ( ';
 req:=req||' with ARBRE(CODE_ENTITE, CID, TYPE_ENTITE, NIVEAU, NB_OCC_MEME_TYPE, CODE_ENT_MERE, TYPE_ENTITE_MERE, NIVEAU_ENTITE_MERE, NB_OCC_ENTITE_MERE, NB_OCC_MEME_TYPE_MERE, CHAINE_ENTITE, NIV_TECH, CODTS) as (';
 req:=req||'  select';
 req:=req||'   A.CODE_ENTITE';
 req:=req||'   , A.CID';
 req:=req||'   , E.TYPE_ENTITE';
 req:=req||'   , N.NIVEAU';
 req:=req||'   , 1 as NB_OCC_MEME_TYPE';
 req:=req||'   , A.CODE_ENT_MERE';
 req:=req||'   , (';
 req:=req||'     select TYPE_ENTITE';
 req:=req||'     from STD_STRUC_ENTITE E1';
 req:=req||'     where E1.CODE_ENTITE = A.CODE_ENT_MERE';
 req:=req||'     and A.DATE_EFF between E1.DATE_EFF and E1.DATE_FIN';
 req:=req||'     and E1.CID = '''||p_cid||'''';
 req:=req||'   ) as TYPE_ENTITE_MERE';
 req:=req||'   , 0 as NIVEAU_ENTITE_MERE';
 req:=req||'   , 0 as NB_OCC_ENTITE_MERE';
 req:=req||'   , 0 as NB_OCC_MEME_TYPE_MERE'; -- Calcule le nombre d'entité de même type qui se suivent (pour les occurrences multiples)
 req:=req||'   , RPAD('' '',(25*(n.niveau-1)))||RPAD(a.code_entite,25)';
 req:=req||'   , N.NIVEAU as NIV_TECH';
 req:=req||'   , a.codts';
 req:=req||'  from';
 req:=req||'   STD_STRUC_ARBRE A';
 req:=req||'   , STD_STRUC_ENTITE E';
 req:=req||'   , STD_STRUC_NIV N';
 req:=req||'  where';
 req:=req||'   A.CID = '''||p_cid||'''';
 req:=req||'   and E.CID = '''||p_cid||'''';
 req:=req||'   and A.CODTS = '||p_codts;
 req:=req||'   and A.CODE_ENT_MERE is null';
 req:=req||'   and '''||p_date_eff||''' between A.DATE_EFF and A.DATE_FIN';
 req:=req||'   and '''||p_date_eff||''' between E.DATE_EFF and E.DATE_FIN';
 req:=req||'   and '''||p_date_eff||''' between N.DATE_EFF and N.DATE_FIN';
 req:=req||'   and A.CODE_ENTITE = E.CODE_ENTITE';
 req:=req||'   and E.TYPE_ENTITE = N.TYPE_ENTITE';
 req:=req||'   and A.CODTS = N.CODTS';
 req:=req||'   and A.STATUT = ''1''';
 req:=req||' union all';
 req:=req||'  select';
 req:=req||'   A.CODE_ENTITE';
 req:=req||'   , A.CID';
 req:=req||'   , E.TYPE_ENTITE';
 req:=req||'   , N.NIVEAU';
 req:=req||'   , case';
 req:=req||'      when E.TYPE_ENTITE = RECUR.TYPE_ENTITE';
 req:=req||'       then RECUR.NB_OCC_MEME_TYPE + 1';
 req:=req||'      else 1';
 req:=req||'   end as NB_OCC_MEME_TYPE';
 req:=req||'   , A.CODE_ENT_MERE';
 req:=req||'   , (';
 req:=req||'     select TYPE_ENTITE';
 req:=req||'     from STD_STRUC_ENTITE E1';
 req:=req||'     where';
 req:=req||'      E1.CODE_ENTITE = A.CODE_ENT_MERE';
 req:=req||'      and A.DATE_EFF between E1.DATE_EFF and E1.DATE_FIN';
 req:=req||'     and E1.CID = '''||p_cid||'''';
 req:=req||'   ) as TYPE_ENTITE_MERE';
 req:=req||'   , RECUR.NIVEAU as NIVEAU_ENTITE_MERE';
 req:=req||'   , NIM.NB_OCCURRENCES as NB_OCC_ENTITE_MERE';
 req:=req||'   , RECUR.NB_OCC_MEME_TYPE as NB_OCC_MEME_TYPE_MERE';
 req:=req||'   , case';
 -- L'entité mère n'a pas d'occurrences multiples : l'écart entre les entités mère et fille correspond à la différence entre le niveau de l'entité mère et celui de la fille
 req:=req||'      when NIM.NB_OCCURRENCES = 1';
 req:=req||'       then CHAINE_ENTITE||RPAD('' '',(25*((N.NIVEAU - RECUR.NIVEAU)-1)))||RPAD(A.CODE_ENTITE,25)';
 -- L'entité mère a des occurrences multiples et l'entité mère et fille sont de même type : il n'y a pas d'écart entre les codes entité
 req:=req||'      when NIM.NB_OCCURRENCES > 1 and E.TYPE_ENTITE = RECUR.TYPE_ENTITE';
 req:=req||'       then CHAINE_ENTITE||RPAD(A.CODE_ENTITE, 25)';
 -- Les autres cas : on calcule l'écart entre l'entité mère et sa fille à partir du nombre d'occurrences de l'entité mère, du nombre d'occurrences de même type de l'entité mère,
 -- du niveau de l'entité fille, du niveau de l'entité mère et du nombre d'occurrences de l'entité mère
 req:=req||'      else CHAINE_ENTITE||RPAD('' '',(25*(NIM.NB_OCCURRENCES - RECUR.NB_OCC_MEME_TYPE + (N.NIVEAU - RECUR.NIVEAU - NIM.NB_OCCURRENCES))))||RPAD(A.CODE_ENTITE, 25)';
 req:=req||'   end';
 req:=req||'   ,case';
 req:=req||'     when E.TYPE_ENTITE = RECUR.TYPE_ENTITE';
 req:=req||'      then RECUR.NB_OCC_MEME_TYPE + N.NIVEAU';
 req:=req||'     else N.NIVEAU';
 req:=req||'   end as NIV_TECH';
 req:=req||'   , A.CODTS';
 req:=req||'  from';
 req:=req||'   STD_STRUC_ARBRE A';
 req:=req||'   , STD_STRUC_ENTITE E';
 req:=req||'   , STD_STRUC_NIV N';
 req:=req||'   , STD_STRUC_ENTITE EM';
 req:=req||'   , STD_STRUC_NIV_INFO NIM';
 req:=req||'   ,ARBRE RECUR';
 req:=req||'  where';
 req:=req||'   A.CODTS = RECUR.CODTS';
 req:=req||'   and A.CODE_ENT_MERE = RECUR.CODE_ENTITE';
 req:=req||'   and A.CID = RECUR.CID';
 req:=req||'   and E.CID = RECUR.CID';
 req:=req||'   and '''||p_date_eff||''' between A.DATE_EFF and A.DATE_FIN ';
 req:=req||'   and '''||p_date_eff||''' between E.DATE_EFF and E.DATE_FIN';
 req:=req||'   and '''||p_date_eff||''' between N.DATE_EFF and N.DATE_FIN';
 req:=req||'   and '''||p_date_eff||''' between EM.DATE_EFF and EM.DATE_FIN';
 req:=req||'   and A.CODE_ENTITE = E.CODE_ENTITE';
 req:=req||'   and E.TYPE_ENTITE = N.TYPE_ENTITE';
 req:=req||'   and A.CODTS = N.CODTS';
 req:=req||'   and EM.CODE_ENTITE = A.CODE_ENT_MERE';
 req:=req||'   and EM.CID = '''||p_cid||'''';
 req:=req||'   and A.CODTS = NIM.CODTS';
 req:=req||'   and EM.TYPE_ENTITE = NIM.TYPE_ENTITE';
 req:=req||' )';
 req:=req||' select * from arbre )';
 req:=req||' ';
 
 EXECUTE_IMMEDIATE_STRING(req,0) ;
 
 retour := retour +SQL%ROWCOUNT;
 return retour ;
 END BUILD_TABLE_INDEX;
 ##
CAD_CALCUL_DATE_RELATIVE
=SQL=
create or replace
FUNCTION "CAD_CALCUL_DATE_RELATIVE" (
 DATE_RELATIVE    IN VARCHAR2,
 DATE_COMPARAISON IN VARCHAR2 )
 RETURN VARCHAR2
 AS
 dte           VARCHAR2(12);
 TYPE tableau IS VARRAY(4) OF VARCHAR2(8);
 tab tableau :=tableau();
 pos     NUMBER;
 indice  NUMBER;
 subs    VARCHAR2(10);
 dteCalc VARCHAR2(8);
 dtecompare DATE;
 unite VARCHAR2(1);
 jour  VARCHAR2(2);
 mois  VARCHAR2(2);
 annee VARCHAR2(4);
 BEGIN
 IF DATE_RELATIVE      IS NOT NULL THEN
 IF date_comparaison IS NULL THEN
 dtecompare        :=sysdate;
 ELSE
 dtecompare:=to_date(date_comparaison,'yyyymmdd');
 END IF;
 dte          :=DATE_RELATIVE;
 IF LENGTH(dte)<8 THEN
 tab.extend;
 tab(1):=dte;
 ELSE
 tab.extend;
 tab(1):=SUBSTR(dte,0,4);
 tab.extend;
 tab(2):=SUBSTR(dte,5);
 tab(2):=SUBSTR( tab(2),0,LENGTH( tab(2))-2);
 tab.extend;
 tab(3):=SUBSTR(dte,LENGTH(dte)-1);
 END IF;
 IF tab.last                  =3 THEN
 IF tab(3)                  ='00' THEN
 jour                    :=TO_CHAR(dtecompare ,'dd');
 elsif SUBSTR( tab(3),1,1) IN ('L','M','W','J','V','S','D') THEN
 -- on prend le jour minimum possible pour la semaine puis on affinera
 IF SUBSTR( tab(3),2,1)   ='1' THEN
 jour                  :='08';
 elsif SUBSTR( tab(3),2,1)='2' THEN
 jour                  :='15';
 elsif SUBSTR( tab(3),2,1)='3' THEN
 jour                  :='22';
 elsif SUBSTR( tab(3),2,1)='4' THEN
 jour                  :='29';
 END IF;
 ELSE
 jour:=tab(3);
 END IF;
 IF tab(2)='00' THEN
 mois  :=TO_CHAR(dtecompare ,'mm');
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,-1) ,'mm');
 ELSE
 mois:=TO_CHAR(dtecompare,'mm');
 END IF;
 
 elsif tab(2) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))-1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 elsif tab(2) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'dd')>=jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 ELSE
 mois:=tab(2);
 END IF;
 IF tab(1)                       ='0000' THEN
 annee                        := TO_CHAR(dtecompare ,'yyyy');
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,-12) ,'yyyy');
 ELSE
 annee:= TO_CHAR(dtecompare ,'yyyy');
 END IF;
 elsif tab(1) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 END IF;
 elsif tab(1) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')>=mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 END IF;
 ELSE
 annee:=tab(1);
 END IF;
 IF jour='32' THEN
 jour:=TO_CHAR(last_day(to_date(annee||mois||'01','yyyymmdd')) ,'dd');
 END IF;
 IF SUBSTR( tab(3),0,1) IN ('L','M','W','J','V','S','D') THEN
 jour                 :=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),1,1),SUBSTR(tab(3),2,1) ,annee,mois );
 IF tab(2)             ='00' THEN
 mois               :=TO_CHAR(dtecompare ,'mm');
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,-1) ,'mm');
 ELSE
 mois:=TO_CHAR(dtecompare,'mm');
 END IF;
 elsif tab(2) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))-1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 elsif tab(2) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'dd')>=jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))+1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 ELSE
 mois:=tab(2);
 END IF;
 jour                           :=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),0,1),SUBSTR(tab(3),2,1) ,annee,mois );
 IF tab(1)                       ='0000' THEN
 annee                        := TO_CHAR(dtecompare ,'yyyy');
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,-12) ,'yyyy');
 ELSE
 annee:= TO_CHAR(dtecompare ,'yyyy');
 END IF;
 elsif tab(1) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 END IF;
 elsif tab(1) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')>mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 END IF;
 ELSE
 annee:=tab(1);
 END IF;
 jour:=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),0,1),SUBSTR(tab(3),2,1) ,annee,mois );
 END IF;
 dteCalc:=annee||mois||jour;
 ELSE
 IF tab(1) LIKE '+%' OR tab(1) LIKE '-%' THEN
 unite     := SUBSTR(tab(1), LENGTH(tab(1)));
 tab(1)    :=REPLACE(tab(1),unite,'');
 IF unite   ='A' THEN
 dteCalc :=TO_CHAR(add_Months(dtecompare,12*to_number(tab(1))) -to_number(SUBSTR(tab(1),1,1)||'1'),'yyyymmdd');
 elsif unite='M' THEN
 dteCalc :=TO_CHAR(add_Months(dtecompare,to_number(tab(1))) -to_number(SUBSTR(tab(1),1,1)||'1'),'yyyymmdd');
 elsif unite='J' THEN
 dteCalc :=TO_CHAR(dtecompare+to_number(tab(1)) ,'yyyymmdd');
 END IF;
 END IF;
 END IF;
 END IF;
 RETURN dteCalc;
 END CAD_CALCUL_DATE_RELATIVE;
 ##
CAD_CALCUL_JOUR_SEMAINE
=SQL=
create or replace
FUNCTION "CAD_CALCUL_JOUR_SEMAINE" (JourSemaine varchar2,numSemaine varchar2, annee varchar2, mois varchar2) RETURN VARCHAR2 AS jour varchar2(2);
 BEGIN
 
 if JourSemaine='L' then
 jour:=to_char(   next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121001','yyyymmdd'),'DAY')) + (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='M' then
 jour:=to_char(next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121002','yyyymmdd'),'DAY')  ) + (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='W' then
 jour:=to_char(next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121003','yyyymmdd'),'DAY')  )+ (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='J' then
 jour:=to_char(next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121004','yyyymmdd'),'DAY')  ) + (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='V' then
 jour:=to_char( next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121005','yyyymmdd'),'DAY')  )+ (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='S' then
 jour:=to_char(next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121006','yyyymmdd'),'DAY')  ) + (to_number( numSemaine)-1 )*7    ,'dd') ;
 elsif JourSemaine='D' then
 jour:=to_char(next_day(to_date(annee||mois||'01','yyyymmdd' ), to_char(to_date('20121001','yyyymmdd'),'DAY')  ) + (to_number( numSemaine)-1 )*7    ,'dd') ;
 end if;
 
 RETURN jour;
 END CAD_CALCUL_JOUR_SEMAINE;
##
CHECK_FORCAGE_RECYCLAGE
=SQL=
create or replace FUNCTION CHECK_FORCAGE_RECYCLAGE( 
    p_numpac IN DIC_ADM_CONTRAT.NUMPAC%TYPE, 
    p_pacmat IN DIC_ADM_CONTRAT.PACMAT%TYPE, 
    p_numcnt IN DIC_ADM_CONTRAT.NUMCNT%TYPE, 
    p_drpai2 IN DIC_ADM_CONTRAT_HISTO.DRPAI2%TYPE, 
    p_periodeencours IN TGE_REF_PAC.PERIODEENCOURS%TYPE ) 
RETURN INTEGER IS
  v_dsdcn DIC_ADM_CONTRAT.DSDCN%TYPE; 
  v_natcol DIC_ADM_CONTRAT.NATCOL%TYPE; 
  v_periodeencours TGE_REF_PAC.PERIODEENCOURS%TYPE; 
BEGIN
    SELECT DSDCN, NATCOL INTO v_dsdcn, v_natcol FROM DIC_ADM_CONTRAT WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt;
    IF v_natcol IN ('SAL','STA') THEN
      IF p_periodeencours IS NOT NULL THEN
        v_periodeencours := p_periodeencours;
      ELSE
        SELECT PERIODEENCOURS INTO v_periodeencours FROM TGE_REF_PAC WHERE NUMPAC=p_numpac;
      END IF;
      IF TO_CHAR(v_dsdcn,'YYYYMM') <= v_periodeencours THEN
        UPDATE SECUPACMAT SET PERIODE_RECYCLAGE='1' WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat;
        RETURN 1;
      END IF;
    END IF; 
  RETURN 0;
EXCEPTION
  WHEN OTHERS THEN RETURN 0;
END CHECK_FORCAGE_RECYCLAGE;
##
TAG_CHARSET=@€éèç
##
COMPARE_DICO_HISTO
=SQL=
/*********************************************************
Permet de comparer deux lignes d'un dictionnaire historisé
*********************************************************/
create or replace FUNCTION COMPARE_DICO_HISTO (
NOM_DICO IN VARCHAR2,
MATRIC IN VARCHAR2,
NUMPAC IN VARCHAR2,
PACMAT IN VARCHAR2,
PAIEZAD_CLE1 IN VARCHAR2,
DATE_EFFET_CLE1 IN VARCHAR2,
PAIEZAD_CLE2 IN VARCHAR2,
DATE_EFFET_CLE2 IN VARCHAR2,
TYPE_CLE IN VARCHAR2
)
RETURN COMPARE_DICO_HISTO_TAB
AS
retour COMPARE_DICO_HISTO_TAB := COMPARE_DICO_HISTO_TAB();

--gestion du curseur et du retour
TYPE refCursor IS REF CURSOR;
cur_val refCursor;

NOM_DONNEE VARCHAR2(20);
LIB_DONNEE VARCHAR2(50);
VALEUR_SELECT VARCHAR2(100);
VALEUR_PREC VARCHAR2(100);

--variables pour la requête
WHERE1 VARCHAR2(4000);
WHERE2 VARCHAR2(4000);
query CLOB;
PREMIER NUMBER;
COLS CLOB;
COLS_AS CLOB;

table_dico_exist number;

BEGIN    
    --on vérifie que le dictionnaire existe
    SELECT COUNT(*) INTO  table_dico_exist FROM USER_TABLES WHERE TABLE_NAME = NOM_DICO;
    IF table_dico_exist > 0 THEN
        --on génére les clause where en fonction du type de clé de l'écran        
        IF upper(type_cle) like 'N' THEN
            /** Ecran de type matricule de paie (NUMPAC/PACMAT) */
            WHERE1 := 'NUMPAC = '''|| NUMPAC ||''' AND PACMAT = '''|| PACMAT ||''' AND TO_DATE('''|| DATE_EFFET_CLE1 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN';
            WHERE2 := 'NUMPAC = '''|| NUMPAC ||''' AND PACMAT = '''|| PACMAT ||''' AND TO_DATE('''|| DATE_EFFET_CLE2 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN';                                    
        ELSIF upper(type_cle) like 'M' THEN 
            /** Ecran de type période d'emploi (NUMPAC/PAIEZAD) */
            WHERE1 := 'PAIEZAD = '''|| PAIEZAD_CLE1 ||''' AND PACMAT = '''|| PACMAT ||''' AND TO_DATE('''|| DATE_EFFET_CLE1 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN';
            WHERE2 := 'PAIEZAD = '''|| PAIEZAD_CLE2 ||''' AND PACMAT = '''|| PACMAT ||''' AND TO_DATE('''|| DATE_EFFET_CLE2 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN';
        ELSE
            /** Ecran de type matricule RHID (MATRIC) : type_cle = R ou R%*/
            WHERE1 := 'MATRIC = '''|| MATRIC ||''' AND TO_DATE('''|| DATE_EFFET_CLE1 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN';
            WHERE2 := 'MATRIC = '''|| MATRIC ||''' AND TO_DATE('''|| DATE_EFFET_CLE2 ||''',''DD.MM.YYYY'') BETWEEN DATE_EFF AND DATE_FIN'; 
        END IF;


        PREMIER := 0;
        COLS := '';
        COLS_AS := '';
        FOR col IN (SELECT COLUMN_NAME,DATA_TYPE FROM USER_TAB_COLS UTC WHERE TABLE_NAME = NOM_DICO)
        LOOP
            IF PREMIER = 0 THEN
                PREMIER := 1;
            ELSE
                COLS := COLS||',';
            COLS_AS := COLS_AS||',';
            END IF;
            COLS_AS := COLS_AS||col.COLUMN_NAME||' AS '''||col.COLUMN_NAME||'''';
    
            IF col.DATA_TYPE = 'DATE' THEN
                COLS := COLS||' TO_CHAR('||col.COLUMN_NAME||',''DD.MM.YYYY'') AS '||col.COLUMN_NAME;
            ELSIF col.DATA_TYPE = 'NUMBER' THEN
                COLS := COLS||'REGEXP_REPLACE(TO_CHAR('||col.COLUMN_NAME||'),''^,'',''0,'') AS '||col.COLUMN_NAME;
            ELSE
                COLS := COLS||col.COLUMN_NAME;
            END IF;
        END LOOP;
    
        query := 'SELECT a.COLONNE,a.COLONNE as LIB_DONNEE, a.VALEUR,b.VALEUR FROM (';
        --------------
        query := query ||' SELECT * FROM (';
        query := query ||' SELECT ';
        query := query ||' '||COLS;
        query := query ||' FROM '||NOM_DICO;
        query := query ||' WHERE '||WHERE1;
        query := query ||' ) UNPIVOT INCLUDE NULLS ( VALEUR FOR COLONNE IN (';
        query := query ||' '||COLS_AS;
        query := query ||' ))';
        query := query ||') a INNER JOIN (';
        --------------
        query := query ||' SELECT * FROM (';
        query := query ||' SELECT ';
        query := query ||' '||COLS;
        query := query ||' FROM '||NOM_DICO;
        query := query ||' WHERE '||WHERE2;
        query := query ||' ) UNPIVOT INCLUDE NULLS ( VALEUR FOR COLONNE IN (';
        query := query ||' '||COLS_AS;
        query := query ||' ))';
        query := query ||') b ON a.COLONNE = b.COLONNE';
        query := query ||' WHERE NVL(a.VALEUR,''NULL'') != NVL(b.VALEUR,''NULL'')';
    
    
        OPEN cur_val  FOR  query;
        LOOP
            FETCH cur_val INTO nom_donnee ,lib_donnee, valeur_prec, valeur_select ;
            EXIT WHEN cur_val%NOTFOUND ;
            retour.extend();
            retour(retour.last):= COMPARE_DICO_HISTO_LIGNE(nom_donnee, lib_donnee, valeur_prec, valeur_select);
        END LOOP;
    END IF;
	RETURN retour;
END COMPARE_DICO_HISTO;
##
COMPARE_LIVRAISON_JSP_FUNCTION
=SQL=
create or replace FUNCTION COMPARE_LIVRAISON_JSP_FUNCTION( ID_GENERATION_L1 in varchar2,
 ID_GENERATION_L2 in varchar2
 ) RETURN compare_Livraison_Jsp_TABLE is
 myres compare_Livraison_Jsp_TABLE;
 begin
 
 
 SELECT compare_Livraison_Jsp_RECORD(JSP_ECRAN_L1,
 nvl((select max(libelle) from sys_sch_element  where nom_page = JSP_ECRAN_L1 ) ,
 
 (select  max(libelle) from sys_pages_modal  where nom_page  =  JSP_ECRAN_L1 )
 
 ),
 ROUND((TAILLE_VL1 /1024 ),2),
 ROUND((TAILLE_VL2 /1024),2) ,
 NB_OCCURENCES_VL1,
 NB_OCCURENCES_L2,
 ROUND(indice_presence_VL1,2),
 ROUND(indice_presence_L2,2),
 ABS(TAILLE_VL1 - TAILLE_VL2) ,
 ABS(indice_presence_VL1  - indice_presence_L2),
 CASE WHEN indice_presence_VL1 > indice_presence_L2 
      THEN (100 - ROUND((indice_presence_L2*100 /indice_presence_VL1),2) )    
      ELSE (100- ROUND((indice_presence_VL1 *100/indice_presence_L2),2))
  END,
  CASE WHEN TAILLE_VL1 > TAILLE_VL2 
      THEN (100 - ROUND((TAILLE_VL2  *100/TAILLE_VL1),2) )
     
      ELSE (100 - ROUND((TAILLE_VL1  *100/TAILLE_VL2),2))
  END
  
 )
 bulk collect into myres
 
 FROM
 (
 select T1.JSP_ECRAN_L1,NB_OCCURENCES_VL1,NB_OCCURENCES_L2,indice_presence_VL1,indice_presence_L2, T2.TAILLE_VL1,T2.TAILLE_VL2 from (

 SELECT JSP_ECRAN_L1, 
 SUM(NB_OCCURENCES_VL1)   as NB_OCCURENCES_VL1,
 SUM(NB_OCCURENCES_L2)   as NB_OCCURENCES_L2,
 SUM(indice_presence_VL1) AS indice_presence_VL1 ,
 SUM(indice_presence_L2) AS indice_presence_L2
 FROM
 (
 
 SELECT VL1.JSP_PATH                    AS JSP_PATH_L1 ,
 VL1.JSP_ECRAN                         AS JSP_ECRAN_L1 ,
 L2.JSP_ECRAN                         AS JSP_ECRAN_5_02 ,
 VL1.ID_PATTERN                        AS ID_PATTERN_L1,
 L2.ID_PATTERN                        AS ID_PATTERN_5_02,
 patterns.poids                          AS pattern_poids,
 L2.NB_OCCURENCES                     AS NB_OCCURENCES_L2,
 VL1.NB_OCCURENCES                     AS NB_OCCURENCES_VL1,
 ( patterns.poids * L2.NB_OCCURENCES) AS indice_presence_L2,
 ( patterns.poids * VL1.NB_OCCURENCES) AS indice_presence_VL1
 FROM SYS_JSP_STATS_DETAILS VL1 ,
 SYS_JSP_STATS_DETAILS L2,
 
 sys_jsp_stats_data_patterns patterns
 WHERE VL1.jsp_path         = L2.JSP_PATH
 AND VL1.id_pattern         = L2.id_pattern
 AND VL1.id_GENERATION      = ID_GENERATION_L1
 AND L2.id_GENERATION       = ID_GENERATION_L2
 AND VL1.ID_PATTERN         = patterns.ID_PATTERN 
 
 )
 GROUP BY JSP_ECRAN_L1
 ) T1
 INNER JOIN (
 SELECT STAT_VL2.JSP_ECRAN as JSP_ECRAN_L1, SUM(STAT_VL1.TAILLE) as TAILLE_VL1 ,SUM(STAT_VL2.TAILLE)  as TAILLE_VL2
 FROM 
 SYS_JSP_STATS STAT_VL1,
 SYS_JSP_STATS STAT_VL2
 where 
stat_vL1.id_generation = ID_GENERATION_L1
and STAT_VL2.id_generation = ID_GENERATION_L2
 AND stat_vL1.JSP_PATH      = STAT_VL2.JSP_PATH 
 
group by   STAT_VL2.JSP_ECRAN
 ) T2 ON T1.JSP_ECRAN_L1 = T2.JSP_ECRAN_L1
 );
 return myres;
 
 end compare_Livraison_Jsp_Function;
 ##
CONVERSIONSECONDESHHCC
=SQL=
create or replace FUNCTION conversionSecondesHHCC(
  p_seconde       IN NUMBER)
  RETURN VARCHAR2
IS
  v_h             NUMBER;
  v_m             NUMBER;
BEGIN
  v_h := TRUNC(p_seconde / 3600);
  v_m := TRUNC(MOD(p_seconde, 3600) / 60 * 100 / 60);
  IF v_h IS NULL THEN
    v_h := '0';
  END IF;
  IF v_m IS NULL THEN
    v_m := '00';
  END IF;
  IF (v_m < 0 AND v_h >= 0) THEN
    RETURN('-' || v_h || ',' || TRIM(TO_CHAR(ABS(v_m), '00')));
  ELSIF (v_m < 0 AND v_h < 0) THEN
    RETURN (v_h || ',' || TRIM(TO_CHAR(ABS(v_m), '00')));
  END IF;
  RETURN (v_h || ',' || TRIM(TO_CHAR(v_m, '00')));
END;
##
CONVERSIONSECONDESHHMM
=SQL=
CREATE OR REPLACE
  FUNCTION CONVERSIONSECONDESHHMM(
      p_seconde IN NUMBER)
    RETURN VARCHAR2
  IS
    v_h NUMBER;
    v_m NUMBER;
  BEGIN
    v_h    := TRUNC(p_seconde          /3600);
    v_m    := TRUNC(mod(p_seconde,3600)/60);
    IF v_h IS NULL THEN
      v_h  :='0';
    END IF;
    IF v_m IS NULL THEN
      v_m  :='00';
    END IF;
    RETURN (TO_CHAR(v_h) ||'h'||TO_CHAR (v_m, '00'));
  END; 
##
TAG_CHARSET=@€éèç
##
COUNT_CONTRAT_HORS_TRANSAC
=SQL=
CREATE OR REPLACE FUNCTION COUNT_CONTRAT_HORS_TRANSAC(
    p_matric IN VARCHAR2 )
  RETURN NUMBER
IS
  PRAGMA AUTONOMOUS_TRANSACTION;
  RETOUR NUMBER ;
BEGIN
  SELECT COUNT(*) INTO RETOUR FROM DIC_ADM_CONTRAT WHERE MATRIC = p_matric ;
  RETURN RETOUR;
END COUNT_CONTRAT_HORS_TRANSAC;
##
FONCTION_CAST
=SQL=
create or replace function CRF_TRANSFERT_CAST_COLUMN(DbLinkSource VARCHAR2, NomTable VARCHAR2, NomColonne VARCHAR2 )return varchar2
IS
v_return  varchar2(100);

v_requete CLOB;
DbLinkCible varchar2(30);
data_TypeSource varchar2(30);
data_LengthSource number;
data_PrecisionSource number;

data_TypeCible varchar2(30);
data_LengthCible number;
data_PrecisionCible number;


begin
  v_return := NomColonne;
  
  v_requete := 'select sys_context( ''userenv'', ''current_schema'' ) from dual';
  EXECUTE IMMEDIATE v_requete into DbLinkCible;

  v_requete := 'select data_Type, data_Length, data_Precision from all_tab_columns@' || DbLinkSource || ' where owner = upper(''' || DbLinkSource || ''') and  table_name = upper(''' || NomTable || ''') and column_name =upper(''' || NomColonne || ''')';
  EXECUTE IMMEDIATE v_requete into data_TypeSource, data_LengthSource, data_PrecisionSource;

  v_requete := 'select data_Type, data_Length, data_Precision from all_tab_columns where owner = upper(''' || DbLinkCible || ''') and table_name = upper(''' || NomTable || ''') and column_name = upper(''' || NomColonne || ''')';
  EXECUTE IMMEDIATE v_requete into data_TypeCible, data_LengthCible, data_PrecisionCible;
    
  -- Si le format de donnee est different d'une base a une autre je cast la donne au format de la base cible
  if data_TypeSource <> data_TypeCible OR data_LengthSource <> data_LengthCible OR data_PrecisionSource <> data_PrecisionCible then
    -- si la donne est au format varchar
    if data_TypeCible = 'VARCHAR2' then
      -- cast en varchar de la valeur a retourner 
      v_return := 'cast(' || NomColonne || ' as varchar(' || data_LengthSource || '))';
    end if;
    -- Si un nombre
    if data_TypeCible = 'NUMBER' then
      -- Si un nombre avec precision
      if data_PrecisionCible is not null then
        -- je cast remplace les eventuels points par des virgule
        v_return := 'cast(to_number(trim(replace(' || NomColonne || ',''.'','',''))) as number(' || data_LengthCible || ',' || data_PrecisionCible ||'))';
      -- Nombre sans virgule
      else
        v_return := 'cast(to_number(trim(replace(' || NomColonne || ',''.'','',''))) as number(' || data_LengthCible || '))';
      end if;
    end if;
  end if;
      
 return v_return;
end CRF_TRANSFERT_CAST_COLUMN;
##
TAG_CHARSET=@€éèç
##
DIC_PERIODES_REC_H_AFTER_STMNT
=SQL=
create or replace FUNCTION DIC_PERIODES_REC_H_AFTER_STMNT RETURN VARCHAR2 AS BEGIN
 RETURN '
 idx       := paiezadPacPeriodModifed.FIRST;
  WHILE idx IS NOT NULL
  LOOP
    IF v_type_writer = ''M'' THEN
      listJobMasseAsyncTab.extend();
      listJobMasseAsyncTab(listJobMasseAsyncTab.last):='' TGE_ALIM_PERIODE_INDIV(0, '''''' || paiezadPacPeriodModifed(idx).NUMPAC || '''''', '''''' || paiezadPacPeriodModifed(idx).PERIODE || '''''', '''''' || paiezadPacPeriodModifed(idx).PAIEZAD || '''''');'';
    ELSE
      TGE_ALIM_PERIODE_INDIV(0, paiezadPacPeriodModifed(idx).NUMPAC, paiezadPacPeriodModifed(idx).PERIODE, paiezadPacPeriodModifed(idx).PAIEZAD);
    END IF;
    idx := paiezadPacPeriodModifed.NEXT(idx);
  END LOOP;
    --Lancement du job async lors d''une mise à jour Manuelle, en Masse (type_writer = ''M'')
  IF v_type_writer = ''M'' THEN
    DBMS_JOB_SUBMIT_MASSE(listJobMasseAsyncTab, ''TRG_DPRH'');
  END IF;
 ';
 END DIC_PERIODES_REC_H_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
DIC_PERIODES_RECEUIL_HISTO_AFTER_ROW
=SQL=
create or replace FUNCTION DIC_PERIOD_REC_HISTO_AFTER_ROW RETURN CLOB
 AS
 v_retour CLOB;
 BEGIN
 
 v_retour := '
 v_numpac                 := NVL(v_ligNew.NUMPAC, v_ligOld.NUMPAC);
 v_paiezad                := NVL(v_ligNew.paiezad, v_ligOld.paiezad);
 v_periode                := NVL(v_ligNew.PRH_MOIS_PAIE, v_ligOld.PRH_MOIS_PAIE);
 IF NOT IS_EQ_DATE(v_ligNew.PRH_DATE_DEBUT_1, v_ligOld.PRH_DATE_DEBUT_1) OR NOT IS_EQ_DATE(v_ligNew.PRH_DATE_FIN_1, v_ligOld.PRH_DATE_FIN_1) THEN
  IF (not paiezadPacPeriodModifed.exists(v_numpac||''#''||v_paiezad) or paiezadPacPeriodModifed(v_numpac||''#''||v_paiezad).PERIODE > v_periode) THEN 
   paiezadPacPeriodModifed(v_numpac||''#''||v_paiezad):= TGE_PAC_PAIEZAD_PERIOD_RETRO(v_paiezad,v_numpac,v_periode);
  END IF;
 END IF;
 ';
 RETURN v_retour;
 END DIC_PERIOD_REC_HISTO_AFTER_ROW;
##
TAG_CHARSET=@€éèç
##
EDI_HISTO_LANCEMENTS_SUIVI_FUNCTION
=SQL=
CREATE OR REPLACE FUNCTION EDI_HISTO_LANCEMENTS_SUIVI_FUNCTION(
  p_LOGIN IN VARCHAR2 DEFAULT NULL,
  p_START_DATE IN VARCHAR2 DEFAULT NULL,
  p_END_DATE IN VARCHAR2 DEFAULT NULL,
  p_TYPE_DOC IN VARCHAR2 DEFAULT NULL,
  p_ONLY_PROC_SIGN IN VARCHAR2 DEFAULT 'N',
  p_SIGNATAIRE IN VARCHAR2 DEFAULT NULL,
  p_EDITEUR IN VARCHAR2 DEFAULT NULL
) RETURN EDI_HISTO_LANCEMENTS_SUIVI_TABLE IS

  v_count NUMBER;
  v_MODE_ADMIN VARCHAR2(10);
  v_EDITEUR VARCHAR2(100);
  v_CODTS_JUR VARCHAR2(4000);
  v_ID_SECU_POP NUMBER;
  v_ID_SECU_STRUCT_JUR NUMBER;
  v_ID_SECU_PAC NUMBER;
  retour EDI_HISTO_LANCEMENTS_SUIVI_TABLE;

BEGIN

  SELECT MIN(VALVAR) INTO v_CODTS_JUR FROM SYS_VARSYS WHERE CODVAR='STRUCTURE_JUR';
  IF v_CODTS_JUR IS NULL THEN
    v_CODTS_JUR := 1;
  END IF;
  v_count := 0;
  v_ID_SECU_POP := -1;
  v_ID_SECU_STRUCT_JUR := -1;
  v_ID_SECU_PAC := -1;
  IF p_LOGIN IS NOT NULL THEN
    SELECT COUNT(*) INTO v_count FROM SYS_SCH_PROFIL_P E, SYS_USR_PROFIL U WHERE E.CODE_PROFIL=U.CODE_PROFIL AND LOGIN = p_LOGIN AND NOM_PAGE = 'Ext.adp.Modules.Signature.SuiviDocumentsEtSignaturesAdmin';
    BEGIN
      SELECT ID_SECU INTO v_ID_SECU_POP FROM SYS_SEC_RESOLUE_POP_REQ WHERE LOGIN=p_LOGIN;
    EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN
      SELECT ID_SECU INTO v_ID_SECU_STRUCT_JUR FROM SYS_SEC_RESOLUE_STRUCT_REQ WHERE LOGIN=p_LOGIN AND CODTS=v_CODTS_JUR;
    EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN
      SELECT ID_SECU INTO v_ID_SECU_PAC FROM SYS_SEC_RESOLUE_PAC_REQ WHERE LOGIN=p_LOGIN;
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;
  v_MODE_ADMIN := 'false';
  IF v_count>0 THEN
    v_MODE_ADMIN := 'true';
  END IF;

  v_EDITEUR := p_EDITEUR;
  IF v_MODE_ADMIN='false' THEN
    IF v_EDITEUR='|#ME#|' THEN
      v_EDITEUR := p_LOGIN;
    ELSE
      v_EDITEUR := '';
    END IF;
  END IF;

  SELECT EDI_HISTO_LANCEMENTS_SUIVI_RECORD(
    ID_LANCEMENT, 
    CODEDI, 
    FAMEDI, 
    LOGIN, 
    DATE_LANCEMENT, 
    MATRIC, 
    DATE_EFF, 
    CHEMIN_FICHIER, 
    ID_DOC_CONTAINER, 
    SIGN_LISTE_MANDATAIRES, 
    SIGN_PROCEDURE, 
    SIGN_DATE_FIN, 
    SIGN_MANDATAIRES, 
    SIGN_CONTRACTANT, 
    DATE_STATUTS, 
    IS_BILLED, 
    IS_PAPERLESS, 
    IS_DIGIPOSTE, 
    BENEFICIAIRE, 
    SEXE, 
    EMAIL, 
    TELEPHONE, 
    TRI_BENEFICIAIRE, 
    CONTRAT, 
    TRI_CONTRAT, 
    FILTRE_CONTRAT, 
    ETABLISSEMENT, 
    MAQUETTE, 
    STATUTEDITION, 
    FILTRE_STATUTEDITION, 
    DATECREATION, 
    TRI_DATECREATION, 
    DATEFIN, 
    TRI_DATEFIN, 
    SIGNATURE, 
    FILTRE_SIGNATURE, 
    DATEACTUALISATION, 
    TRI_DATEACTUALISATION, 
    EXTENSIONFICHIER, 
    FILTRE_SOUMISSIGNATURE, 
    FILTRE_SIGN_LISTE_MANDATAIRES, 
    TYPEDOC, 
    DISPLAY_ECRAN_SUIVI, 
    ALLOW_EDIT, 
    IS_AUTORIZED
  ) 

  BULK COLLECT INTO retour

  FROM (
    SELECT 
      ID_LANCEMENT, 
      CODEDI, 
      FAMEDI, 
      LOGIN, 
      DATE_LANCEMENT, 
      MATRIC, 
      DATE_EFF, 
      CHEMIN_FICHIER, 
      ID_DOC_CONTAINER, 
      SIGN_LISTE_MANDATAIRES, 
      SIGN_PROCEDURE, 
      SIGN_DATE_FIN, 
      SIGN_MANDATAIRES, 
      SIGN_CONTRACTANT, 
      DATE_STATUTS, 
      IS_BILLED, 
      IS_PAPERLESS, 
      IS_DIGIPOSTE, 
      BENEFICIAIRE, 
      SEXE, 
      EMAIL, 
      TELEPHONE, 
      TRI_BENEFICIAIRE, 
      CONTRAT, 
      TRI_CONTRAT, 
      FILTRE_CONTRAT, 
      ETABLISSEMENT, 
      MAQUETTE, 
      STATUTEDITION, 
      FILTRE_STATUTEDITION, 
      DATECREATION, 
      TRI_DATECREATION, 
      DATEFIN, 
      TRI_DATEFIN, 
      SIGNATURE, 
      FILTRE_SIGNATURE, 
      DATEACTUALISATION, 
      TRI_DATEACTUALISATION, 
      EXTENSIONFICHIER, 
      FILTRE_SOUMISSIGNATURE, 
      FILTRE_SIGN_LISTE_MANDATAIRES, 
      TYPEDOC, 
      -- DISPLAY_ECRAN_SUIVI
      --   On affiche l'édition sur l'écran de suivi si :
      --   - On n'a pas de login pour faire le test
      --   OU
      --   - Le login a accès à l'écran en mode Admin et le bénéficiaire est autorisé par la sécu
      --   OU
      --   - L'utilisateur connecté a effectué l'édition
      --   OU
      --   - Une procédure de signature est en cours et le login est signataire
      CASE 
        WHEN p_LOGIN IS NULL THEN 'O' 
        WHEN LOGIN=p_LOGIN THEN 'O' 
        WHEN v_MODE_ADMIN = 'true' AND IS_AUTORIZED='O' THEN 'O' 
        WHEN ','||SIGN_LISTE_MANDATAIRES||',' LIKE '%,'||p_LOGIN||',%' AND ID_DOC_CONTAINER IS NOT NULL THEN 'O' 
        ELSE 'N' 
      END AS DISPLAY_ECRAN_SUIVI, 
      -- ALLOW_EDIT
      --   On peut éditer une procédure (annuler, charger un document, modifier les coordonnées des signataires, ou lancer) si :
      --   - On n'a pas de login pour faire le test
      --   OU
      --   - Le login a accès à l'écran en mode Admin et le bénéficiaire est autorisé par la sécu
      --   OU
      --   - L'utilisateur connecté a effectué l'édition
      CASE 
        WHEN p_LOGIN IS NULL THEN 'O' 
        WHEN v_MODE_ADMIN = 'true' AND IS_AUTORIZED='O' THEN 'O' 
        WHEN LOGIN=p_LOGIN THEN 'O' 
        ELSE 'N' 
      END AS ALLOW_EDIT, 
      IS_AUTORIZED
    FROM (
      SELECT H.ID_LANCEMENT, 
        H.CODEDI, 
        H.FAMEDI, 
        H.LOGIN, 
        H.DATE_LANCEMENT, 
        H.MATRIC, 
        H.DATE_EFF, 
        H.CHEMIN_FICHIER, 
        H.ID_DOC_CONTAINER, 
        H.SIGN_LISTE_MANDATAIRES, 
        H.SIGN_PROCEDURE, 
        H.SIGN_DATE_FIN, 
        H.SIGN_MANDATAIRES, 
        H.SIGN_CONTRACTANT, 
        H.DATE_STATUTS, 
        H.IS_BILLED, 
        H.IS_PAPERLESS, 
        H.IS_DIGIPOSTE, 
        -- BENEFICIAIRE
        '('||H.MATRIC||') '||H.NOM||' '||H.PRENOM AS BENEFICIAIRE, 
        H.SEXE, 
        H.EMAIL, 
        H.TELEPHONE, 
        -- TRI_BENEFICIAIRE
        H.MATRIC AS TRI_BENEFICIAIRE, 
        -- CONTRAT
        CASE 
          WHEN H.DATE_DEB_CNT IS NULL THEN NULL 
          WHEN H.DATE_FIN_CNT IS NULL THEN 'A partir du '||TO_CHAR(H.DATE_DEB_CNT, 'dd.mm.yyyy') 
          ELSE 'Du '||TO_CHAR(H.DATE_DEB_CNT, 'dd.mm.yyyy')||' au '||TO_CHAR(H.DATE_FIN_CNT, 'dd.mm.yyyy') 
        END AS CONTRAT, 
        -- TRI_CONTRAT
        H.DATE_DEB_CNT AS TRI_CONTRAT, 
        -- FILTRE_CONTRAT
        TO_CHAR(H.DATE_DEB_CNT, 'dd.mm.yyyy') AS FILTRE_CONTRAT, 
        -- ETABLISSEMENT
        E.LIBELLE_ENTITE AS ETABLISSEMENT, 
        -- MAQUETTE
        CASE 
          WHEN G.LIBELLE IS NULL THEN A.ATTEST_LIBELLE 
          ELSE G.LIBELLE 
        END AS MAQUETTE, 
        -- STATUTEDITION
        --   Pas de statut dans EDI_DS_LANCEMENT --> Edition Jasper
        --   SIGN_PROCEDURE vide --> Edition Jasper non soumis à signature : on retourne
        --   le statut 03 (Document généré)
        --   SIGN_PROCEDURE renseignée --> Edition Jasper soumis à signature : on retourne
        --   le statut 06 (Document soumis à signature)
        CASE 
          WHEN L.STATUT IS NULL AND H.SIGN_PROCEDURE IS NULL THEN 'Document récupéré' 
          WHEN L.STATUT IS NULL THEN 'Document soumis à signature' 
          ELSE DS.LIBELLE_STATUT 
        END AS STATUTEDITION, 
        -- FILTRE_STATUTEDITION
        CASE 
          WHEN L.STATUT IS NULL AND H.SIGN_PROCEDURE IS NULL THEN '03' 
          WHEN L.STATUT IS NULL THEN '06' 
          ELSE L.STATUT 
        END AS FILTRE_STATUTEDITION, 
        -- DATECREATION
        TO_CHAR(H.DATE_LANCEMENT, 'dd.mm.yyyy') AS DATECREATION, 
        -- TRI_DATECREATION
        H.DATE_LANCEMENT AS TRI_DATECREATION, 
        -- DATEFIN
        TO_CHAR(H.SIGN_DATE_FIN, 'dd.mm.yyyy') AS DATEFIN, 
        -- TRI_DATEFIN
        H.SIGN_DATE_FIN AS TRI_DATEFIN, 
        -- SIGNATURE
        --   On ne retourne pas le libellé du statut G (Génération en cours)
        CASE 
          WHEN H.SIGN_PROCEDURE='G' THEN NULL 
          ELSE PS.LIBELLE_STATUT 
        END AS SIGNATURE, 
        -- FILTRE_SIGNATURE
        H.SIGN_PROCEDURE AS FILTRE_SIGNATURE, 
        -- DATEACTUALISATION
        CASE 
          WHEN H.DATE_STATUTS IS NULL THEN NULL 
          ELSE TO_CHAR(H.DATE_STATUTS, 'dd.mm.yyyy')||' à '||TO_CHAR(H.DATE_STATUTS, 'hh24:mi:ss') 
        END AS DATEACTUALISATION, 
        -- TRI_DATEACTUALISATION
        H.DATE_STATUTS AS TRI_DATEACTUALISATION, 
        -- EXTENSIONFICHIER
        UPPER(SUBSTR(CHEMIN_FICHIER, INSTR(CHEMIN_FICHIER, '.', -1)+1)) AS EXTENSIONFICHIER, 
        -- FILTRE_SOUMISSIGNATURE
        CASE 
          WHEN H.SIGN_PROCEDURE IS NULL THEN 'N' 
          ELSE 'O' 
        END AS FILTRE_SOUMISSIGNATURE, 
        -- FILTRE_SIGN_LISTE_MANDATAIRES
        ','||H.SIGN_LISTE_MANDATAIRES||',' AS FILTRE_SIGN_LISTE_MANDATAIRES, 
        -- TYPEDOC
        CASE 
          WHEN G.TYPE IS NOT NULL THEN G.TYPE 
          WHEN A.ATTEST_ID IS NOT NULL THEN 'A' 
          ELSE H.TYPE_DOC
        END AS TYPEDOC, 
        -- IS_AUTORIZED
        --   Application de la sécurité :
        --   - Population PACMAT, si NUMPAC/PACMAT
        --   - Population MATRIC, si pas de NUMPAC/PACMAT mais un MATRIC (seulement MATRIC en écriture pas en lecture)
        --   - Structure juridique, si pas de NUMPAC/PACMAT ni de MATRIC, mais un ETABLISSEMENT
        --   - PAC si pas de NUMPAC/PACMAT ni de MATRIC ni de ETABLISSEMENT, mais un NUMPAC
        CASE 
          WHEN H.NUMPAC IS NOT NULL AND H.PACMAT IS NOT NULL 
            --AND (H.NUMPAC,H.PACMAT) IN (SELECT NUMPAC,PACMAT FROM SYS_SEC_RESOLUE_POP_PAC WHERE ID_SECU=v_ID_SECU_POP) 
            AND EXISTS (SELECT 1 FROM SYS_SEC_RESOLUE_POP_PAC WHERE ID_SECU=v_ID_SECU_POP AND NUMPAC=H.NUMPAC AND PACMAT=H.PACMAT) 
          THEN 'O' 
          WHEN (H.NUMPAC IS NULL OR H.PACMAT IS NULL) AND H.MATRIC IS NOT NULL 
            --AND H.MATRIC IN (SELECT MATRIC FROM SYS_SEC_RESOLUE_POP_MAT WHERE ID_SECU=v_ID_SECU_POP) 
            AND EXISTS (SELECT 1 FROM SYS_SEC_RESOLUE_POP_MAT WHERE ID_SECU=v_ID_SECU_POP AND MATRIC=H.MATRIC and ACCES_ECR_LEC = 'E') 
          THEN 'O' 
          WHEN (H.NUMPAC IS NULL OR H.PACMAT IS NULL) AND H.MATRIC IS NULL AND H.ETABLISSEMENT IS NOT NULL 
            --AND H.ETABLISSEMENT IN (SELECT CODE_ENTITE FROM SYS_SEC_RESOLUE_STRUCT WHERE ID_SECU=v_ID_SECU_STRUCT_JUR AND CODTS=v_CODTS_JUR) 
             AND EXISTS (SELECT 1 FROM SYS_SEC_RESOLUE_STRUCT WHERE ID_SECU=v_ID_SECU_STRUCT_JUR AND CODTS=v_CODTS_JUR AND CODE_ENTITE=H.ETABLISSEMENT) 
          THEN 'O' 
          WHEN H.NUMPAC IS NOT NULL AND H.PACMAT IS NULL AND H.MATRIC IS NULL AND H.ETABLISSEMENT IS NULL 
            --AND H.NUMPAC IN (SELECT NUMPAC FROM SYS_SEC_RESOLUE_PAC WHERE ID_SECU=v_ID_SECU_PAC) 
            AND EXISTS (SELECT 1 FROM SYS_SEC_RESOLUE_PAC WHERE ID_SECU=v_ID_SECU_PAC AND NUMPAC=H.NUMPAC) 
          THEN 'O' 
          WHEN H.NUMPAC IS NULL AND H.PACMAT IS NULL AND H.MATRIC IS NULL AND H.ETABLISSEMENT IS NULL THEN 'O' 
          ELSE 'N' 
        END AS IS_AUTORIZED 
      FROM 
        EDI_HISTO_LANCEMENTS H 
        LEFT OUTER JOIN STD_STRUC_ENTITE_VIEW E ON E.CODE_ENTITE=H.ETABLISSEMENT 
        LEFT OUTER JOIN EDI_DS_LANCEMENT L ON L.ID_HISTO_LANCEMENT=H.ID_LANCEMENT 
        LEFT OUTER JOIN EDI_DS_STATUTS DS ON DS.CODE_STATUT=L.STATUT 
        LEFT OUTER JOIN GA_EDITIONS_GAP G ON G.CODE=L.ID_MAQUETTE 
        LEFT OUTER JOIN GA_ATTESTATION_TYPES A ON A.FAMEDI=H.FAMEDI AND A.CODEDI=H.CODEDI 
        LEFT OUTER JOIN SIGN_PROCEDURE_STATUTS PS ON PS.CODE_STATUT=H.SIGN_PROCEDURE 
    ) 
  )
  WHERE 1=1 
    -- Filtre sur la date de lancement
    AND TRUNC(DATE_LANCEMENT,'dd') BETWEEN TO_DATE(NVL(p_START_DATE,'01.01.1901'),'dd.MM.yyyy') AND TO_DATE(NVL(p_END_DATE,'31.12.2099'),'dd.MM.yyyy') 
    -- Filtre sur le type de document 
    AND NVL(TYPEDOC,'_AUCUN_') = NVL(p_TYPE_DOC,NVL(TYPEDOC,'_AUCUN_')) 
    --  Filtre sur les documents soumis à signature électronique
    AND (NVL(p_ONLY_PROC_SIGN,'N') != 'O' OR FILTRE_SOUMISSIGNATURE = 'O') 
    -- Filtre sur un signataire
    AND (p_SIGNATAIRE is null OR ','||SIGN_LISTE_MANDATAIRES||',' LIKE '%,'||p_SIGNATAIRE||',%') 
    -- Filtre sur un éditeur
    AND LOGIN=NVL(v_EDITEUR,LOGIN);

  RETURN retour;
 
END EDI_HISTO_LANCEMENTS_SUIVI_FUNCTION;
##
EXISTE_DONNEE_WKF
=SQL=
create or replace FUNCTION EXISTE_DONNEE_WKF(    P_NOM_DIC      IN VARCHAR2 ,
    P_NOM_DONNEE   IN VARCHAR2 ,
    P_VALUE        IN VARCHAR2 ,
    P_CLAUSE_WHERE IN VARCHAR2 )  RETURN INTEGER IS
	
	cur_wkf_select   CLOB;
	cur_node_select  CLOB;
  	cur_table_select CLOB;
 	w_err            CLOB;
  	xml_content      XMLTYPE;
  	dos_num_cpt      NUMBER(10);
	cur_wkf          tab_varchar;
	cur_node         tab_varchar;
	cur_table        SYS_REFCURSOR;  
	BEGIN
  	--controle de saisie
    IF length(trim(P_NOM_DIC)) IS NULL  OR P_NOM_DIC IS NULL THEN
       --dbms_output.put_line('Veuillez saisir le nom du dictionnaire');
       --FIXME utiliser la procédure trace_dbms_output()
       RETURN -1;
    ELSIF length(trim(P_NOM_DONNEE))  IS NULL OR P_NOM_DONNEE IS NULL THEN
      --dbms_output.put_line('Veuillez saisir le nom de donnee');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN -1;
    END IF;
    
    --creation des curseurs selon l'existance de la partie where
    cur_table_select := 'SELECT dos_num,xml_datas FROM WKF_METIER_GENERIQUE';
		cur_wkf_select   := 'SELECT extractvalue(:1,''/DATA_DOS/''||:2 ||''/''||:3) As nodeValue	FROM dual';
		cur_node_select  := 'SELECT node_name  FROM XMLTable(''/DATA_DOS/*'' passing  (SELECT xml_datas FROM WKF_METIER_GENERIQUE WHERE dos_num = :1 ) columns node_name VARCHAR2(30) path ''name(.)'' , node_value VARCHAR2(30) path ''.'') WHERE node_name LIKE (:2 ||''_%'')';
		
		IF P_CLAUSE_WHERE IS NOT NULL THEN
        cur_table_select := cur_table_select||' WHERE ' || P_CLAUSE_WHERE;
    END IF;
    
		--ouvrir le curseur principale qui va parcourir la table
    OPEN cur_table FOR cur_table_select;
    LOOP
			  FETCH cur_table INTO dos_num_cpt,xml_content;
			  EXIT WHEN cur_table%NOTFOUND;
        EXECUTE immediate cur_node_select bulk collect INTO cur_node USING dos_num_cpt,P_NOM_DIC;
        IF cur_node.exists(1) THEN
          FOR j IN cur_node.first..cur_node.last
          LOOP
            --chercher les dictionnaires qui ont le nom passer en paramétre suivi par _XX
            IF  substr(cur_node(j),1, INSTR(cur_node(j),'_', -1, 1)-1) = P_NOM_DIC THEN
               EXECUTE immediate cur_wkf_select bulk collect INTO cur_wkf USING xml_content,cur_node(j),P_NOM_DONNEE;
               IF cur_wkf.exists(1) THEN
               FOR k IN cur_wkf.first..cur_wkf.last
                LOOP
                IF cur_wkf(k) = P_VALUE OR (P_VALUE IS NULL AND cur_wkf(k) IS NULL) THEN
                  --dbms_output.put_line('donnee existe');
                  --FIXME utiliser la procédure trace_dbms_output()
                  RETURN 1;
                END IF; 
              END LOOP;
              END IF;
            END IF;
          END LOOP;
        END IF;
    END LOOP;
    --dbms_output.put_line('donnee n''existe pas');
    --FIXME utiliser la procédure trace_dbms_output()
	RETURN 0;
Exception 
 when others then 
   w_err := 'ERROR EXISTE_DONNEE_WKF '||sqlerrm ;
   RETURN -1;
END EXISTE_DONNEE_WKF;
##
TAG_CHARSET=@€éèç
##
EXISTS_CODE_CHRONO
=SQL=
CREATE OR REPLACE FUNCTION EXISTS_CODE_CHRONO(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_codeChrono VARCHAR2) RETURN NUMBER IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour NUMBER;
BEGIN 
  	-- On regarde d'abord si le code_chrono n'est pas utilisé dans DACS
	SELECT COUNT(*) INTO retour FROM DIC_ADM_CONTRAT_SITU WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND CODE_CHRONO=p_codeChrono;
	
	IF retour = 0 THEN
		-- Si le code_chrono n'est pas utilisé dans DACS, on va vérifier que le code_chrono n'a pas déjà été utilisé (présent dans DELETED_PAIEZAD)
		-- (cas d'une réembauche après une annulation avec réutilisation du code_chrono)
		select COUNT(*) INTO retour from DELETED_PAIEZAD where NUMPAC = p_numpac and PACMAT = p_pacmat and CODE_CHRONO = p_codeChrono;	
	END IF;
	
  	RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN 0;
END EXISTS_CODE_CHRONO;
##
FORMATE_DATE
=SQL=
CREATE OR REPLACE
  FUNCTION FORMATE_DATE(
      DATE_TO_FORMAT    IN VARCHAR2,
      IN_TEMPLATE_DATE  IN VARCHAR2,
      OUT_TEMPLATE_DATE IN VARCHAR2)
    RETURN VARCHAR2
  IS
    DATE_FORMATED VARCHAR2(20);
  BEGIN
    DATE_FORMATED     := REPLACE(DATE_TO_FORMAT, ' ', '');
    IF (DATE_FORMATED IS NULL) THEN
      DATE_FORMATED   := '';
    END IF;
    DATE_FORMATED := TO_CHAR(TO_DATE(DATE_FORMATED, IN_TEMPLATE_DATE), OUT_TEMPLATE_DATE);
    RETURN (DATE_FORMATED);
  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20000, 'Ceci n''est pas une date valide : '||DATE_TO_FORMAT);
  END FORMATE_DATE; 
  ##
FORMATE_DATE_DDMMYYYY
=SQL=
CREATE OR REPLACE
  FUNCTION FORMATE_DATE_DDMMYYYY(
      DATE_TO_FORMAT IN VARCHAR2)
    RETURN VARCHAR2
  IS
  BEGIN
    RETURN FORMATE_DATE(DATE_TO_FORMAT, 'YYYYMMDD', 'DD/MM/YYYY');
  END FORMATE_DATE_DDMMYYYY; 
  ##
GETREGROUPEMENT
=SQL=
CREATE OR REPLACE
  FUNCTION GETREGROUPEMENT(
      p_code_element IN SYS_SCH_ELEMENT.CODE_ELEMENT%Type,
      p_code_schema  IN SYS_SCHEMAS.CODE_SCHEMA%Type )
    RETURN VARCHAR2
  IS
    retour SYS_SCH_ELEMENT.LIBELLE%Type ;
  BEGIN
    IF (p_code_element IS NULL OR p_code_schema IS NULL) THEN
      RETURN NULL;
    END IF;
    SELECT libelle
    INTO retour
    FROM
      ( WITH regroupement(code_element, libelle, niveau, code_role, code_schema, code_asso, code_asso_pere) AS
      (SELECT e.code_element,
        e.libelle,
        e.niveau,
        e.code_role,
        s.code_schema,
        s.code_asso,
        S.code_asso_pere
      FROM SYS_SCHEMAS s,
        SYS_SCH_ELEMENT e
      WHERE s.code_elt  = e.code_element
      AND s.code_elt    = p_code_element
      AND s.niveau      = e.niveau
      AND s.niveau      = 99
      AND s.code_schema = p_code_schema
      UNION ALL
      SELECT e.code_element,
        e.libelle,
        e.niveau,
        e.code_role,
        s.code_schema,
        S.code_asso,
        s.code_asso_pere
      FROM SYS_SCHEMAS s,
        SYS_SCH_ELEMENT e,
        regroupement r
      WHERE r.code_asso_pere = s.code_asso
      AND s.code_elt         = e.code_element
      AND s.niveau           = e.niveau
      AND s.niveau          <= 99
      AND s.code_schema      = p_code_schema
      )
    SELECT code_element,
      libelle,
      niveau,
      code_role,
      code_schema,
      code_asso,
      code_asso_pere
    FROM regroupement
    WHERE niveau = 2
      );
    RETURN retour;
  END GETREGROUPEMENT;
  ##
TAG_CHARSET=@€éèç
##
GET_CID_FOR_LOGIN
=SQL=
CREATE OR REPLACE FUNCTION GET_CID_FOR_LOGIN(p_login IN VARCHAR2) 
	RETURN VARCHAR2 
AS 
	v_retour VARCHAR2(32);
BEGIN
	/**
	 * Dans le cadre du multiclient, la table SYS_USR_CID permet d'associer un LOGIN avec un COMPANY_ID (CID).
	 * Le problème, c'est que cette table n'existe pas dans ADP Link car on est monoclient.
	 * Cette fonction va permettre de récupérer le CID associé à un login sans avoir à s'interroger sur l'existence ou non de la table.
	 * Si la table existe, on utilise les données de SYS_USR_CID, 
	 * sinon on va utiliser la table SYS_USR_CONFIG et la valeur du CID contenue dans la varsys "NS_CLIENT_ID"
	 * ATTENTION, les utilisateurs techniques (SYS_USR_ADMIN_ONLY) sont exclus
	*/
	select COMPANY_ID into v_retour from GET_SYS_USR_CID() where LOGIN = p_login;
	return v_retour;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    -- Le login n'a pas été trouvé  	
    return NULL;
END GET_CID_FOR_LOGIN;
##
TAG_CHARSET=@€éèç
##
GET_CID_FOR_NUMPAC
=SQL=
CREATE OR REPLACE FUNCTION GET_CID_FOR_NUMPAC(p_numpac IN VARCHAR2) 
	RETURN VARCHAR2 
AS 
	v_retour VARCHAR2(32);
BEGIN
	/**
	 * Dans le cadre du multiclient, la table MULTICLIENT_REF_PAC permet d'associer un NUMPAC avec un COMPANY_ID (CID).
	 * Le problème, c'est que cette table n'existe pas dans ADP Link car on est monoclient.
	 * Cette fonction va permettre de récupérer le CID associé à un login sans avoir à s'interroger sur l'existence ou non de la table.
	 * Si la table existe, on utilise les données de MULTICLIENT_REF_PAC, 
	 * sinon on va utiliser la table TGE_REF_PAC et la valeur du CID contenue dans la varsys "NS_CLIENT_ID"
	*/
	select COMPANY_ID into v_retour from GET_MULTICLIENT_REF_PAC() where NUMPAC = p_numpac;
	return v_retour;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    -- Le login n'a pas été trouvé  	
    return NULL;
END GET_CID_FOR_NUMPAC;
##
GET_CLI_MODELE_DONNEES
=SQL=
create or replace FUNCTION GET_CLI_MODELE_DONNEES ( numpac varchar2) RETURN T_TABCLI_MODELE_DONNES AS
 p_retour T_TABCLI_MODELE_DONNES      := T_TABCLI_MODELE_DONNES ();
 
 type MODELE_DONNEES
 IS
 record
 (
 ESPACE	VARCHAR2(50),
 REGROUPEMENT	VARCHAR2(50),
 THEME	VARCHAR2(50),
 LIBELLE_PAGE	VARCHAR2(50),
 NOM_PAGE	VARCHAR2(100),
 ONGLET	VARCHAR2(100),
 NOM_DONNEE	VARCHAR2(151),
 LIBELLE_DONNEE	VARCHAR2(100),
 NOM_DICTIONNAIRE	VARCHAR2(24),
 TYPE_DONNEE	VARCHAR2(1),
 LONGUEUR_PARTIE_ENTIERE	VARCHAR2(10),
 LONGUEUR_PARTIE_DECIMALE	VARCHAR2(1),
 MODE_SAISIE	VARCHAR2(20),
 AFFICHE_CHOIX_VIDE_SELECT	VARCHAR2(1),
 VALEURS_OUI_NON	VARCHAR2(1000),
 REGLES_AFFICHAGE	VARCHAR2(50),
 PENTREE	VARCHAR2(4000),
 PENTREE_FORCABLE	VARCHAR2(1),
 PENTREE_CODE_MODIF	VARCHAR2(4000),
 NOMTABLE	VARCHAR2(1000));
 TYPE TAB_MODELE_DONNES
 IS
 TABLE OF MODELE_DONNEES INDEX BY binary_integer ;
 tabModeles TAB_MODELE_DONNES;
 requete CLOB;
 begin
 requete:= ' WITH liensDonneesGroupes(company_id, id_groupe, nom_donnee, id_groupe_donnees, suffixe_ou_libelle, onglet) AS (SELECT gd.company_id,gd.id_groupe,';
 requete:= requete||'   CASE      WHEN SUBSTR(gd.nom_donnee,1,1)=''#''      THEN gd.nom_donnee        ||''£''        ||gd.id_groupe      ELSE gd.nom_donnee    END AS nom_donnee,    gd.id_groupe,    gd.suffixe_ou_libelle,';
 requete:= requete||'  '''' ';
 requete:= requete||' FROM meta_groupe_donnees gd  UNION ALL  SELECT l.company_id,    l.id_groupe,    CASE      WHEN SUBSTR(gd.nom_donnee,1,1)=''#''      THEN gd.nom_donnee        ||''£''        ||gd.id_groupe      ELSE gd.nom_donnee    END AS nom_donnee,';
 requete:= requete||'gd.id_groupe,    gd.suffixe_ou_libelle,    DECODE(gd_info.EST_ONGLET,''O'', gd_info.LIBELLE_GROUPE, l.ONGLET)  FROM meta_groupe_donnees gd,    liensDonneesGroupes l  ,    META_GROUPE_DONNEES_INFO gd_info   where gd.company_id=l.company_id  AND gd.ID_GROUPE   =gd_info.ID_GROUPE  AND gd.id_groupe   =l.suffixe_ou_libelle  AND l.nom_donnee LIKE ''#GROUPE%''),   TGE_REF_MAPDO_PAR_DONNEE(NUMPAC, DONNEEGXP, ELEMENTS, FORCABLE) AS';
 requete:= requete||'(SELECT MAPDO.NUMPAC,    MAPDO.DONNEEGXP,    LISTAGG(MAPDO.ELEMENT, '','') WITHIN GROUP (  ORDER BY MAPDO.ELEMENT) ELEMENTS,    MAX(FORCABLE_ECRAN_GENERE) FORCABLE  FROM TGE_REF_MAPDO MAPDO  GROUP BY MAPDO.NUMPAC,    MAPDO.DONNEEGXP  )  select   ESPACE_ELT.LIBELLE ESPACE,  REGROUPEMENT_ELT.LIBELLE REGROUPEMENT,';
 requete:= requete||'THEME_ELT.LIBELLE THEME,  PAGE_ELT.LIBELLE LIBELLE_PAGE,  META_ECRAN.NOM_PAGE,  liensDonneesGroupes.ONGLET,  liensDonneesGroupes.NOM_DONNEE,  META_DONNEE_ECRAN.LIBELLE_DONNEE,  META_DONNEE_GENERALE.NOM_DICTIONNAIRE,  META_DONNEE_GENERALE.TYPE_DONNEE,  DECODE(META_DONNEE_GENERALE.TYPE_DONNEE, ''D'', '''', META_DONNEE_GENERALE.LONGUEUR_MASQUE_NB_ENTIERS) LONGUEUR_PARTIE_ENTIERE,  META_DONNEE_GENERALE.NB_DECIMAUX LONGUEUR_PARTIE_DECIMALE,  META_DONNEE_ECRAN.MODE_SAISIE,  META_DONNEE_ECRAN.AFFICHE_CHOIX_VIDE_SELECT,';
 requete:= requete||'CASE    WHEN META_DONNEE_ECRAN.MODE_SAISIE=''checkbox''    THEN META_DONNEE_GENERALE.CHECKBOX_VALEUR_OFF      || ''/ ''     || META_DONNEE_GENERALE.CHECKBOX_VALEUR_ON    WHEN META_DONNEE_ECRAN.MODE_SAISIE                     =''select''    AND instr(UPPER(SYS_REQUETES_JSP.NOMTABLE), ''''''OUI'''''')!=0    THEN SYS_REQUETES_JSP.NOMTABLE  END VALEURS_OUI_NON,  CASE    WHEN REGLES_AFF_RD.ID_REGLEGESTION IS NOT NULL    THEN REGLES_AFF_RD.ID_REGLEGESTION    WHEN REGLES_AFF_CLI.ID_REGLEGESTION IS NOT NULL    THEN REGLES_AFF_CLI.ID_REGLEGESTION  END REGLES_AFFICHAGE,';
 requete:= requete||'NVL(PAC_ENTREE.ELEMENTS, PAC_ETOILE.ELEMENTS) "PENTREE",  NVL(PAC_ENTREE.FORCABLE, PAC_ETOILE.FORCABLE) "PENTREE_FORCABLE",  NVL(  (SELECT codemodifs  FROM    (SELECT MAPDO.DONNEEGXP AS DONN,      LISTAGG(MAPDO.ELEMENT, '','') WITHIN GROUP (    ORDER BY MAPDO.ELEMENT) ELEMENTS,      LISTAGG(DICOZ.CODEMODIF, '','') WITHIN GROUP (    ORDER BY MAPDO.ELEMENT) CODEMODIFS    FROM TGE_REF_DICOZ DICOZ    LEFT OUTER JOIN TGE_REF_MAPDO MAPDO    ON dicoz.numpac    ='''|| numpac  ||'''    AND dicoz.element  = mapdo.element';
 requete:= requete||'  WHERE mapdo.numpac = '''|| numpac  ||'''    GROUP BY MAPDO.NUMPAC,      MAPDO.DONNEEGXP    )  WHERE DONN   = liensDonneesGroupes.NOM_DONNEE  AND ELEMENTS = NVL(PAC_ENTREE.ELEMENTS, PAC_ETOILE.ELEMENTS)  ), (  (SELECT codemodifs  FROM    (SELECT MAPDO.DONNEEGXP AS DONN,      LISTAGG(MAPDO.ELEMENT, '','') WITHIN GROUP (    ORDER BY MAPDO.ELEMENT) ELEMENTS,      LISTAGG(DICOZ.CODEMODIF, '','') WITHIN GROUP (    ORDER BY MAPDO.ELEMENT) CODEMODIFS    FROM TGE_REF_DICOZ DICOZ    LEFT OUTER JOIN TGE_REF_MAPDO MAPDO    ON dicoz.numpac    = '''|| numpac  ||'''    AND dicoz.element  = mapdo.element    WHERE mapdo.numpac = ''*''    GROUP BY MAPDO.NUMPAC,';
 requete:= requete||'    MAPDO.DONNEEGXP    )  WHERE DONN   = liensDonneesGroupes.NOM_DONNEE  AND ELEMENTS = NVL(PAC_ENTREE.ELEMENTS, PAC_ETOILE.ELEMENTS)  ))) "PENTREE_CODE_MODIF",    SYS_REQUETES_JSP.NOMTABLE   FROM META_ECRAN INNER JOIN liensDonneesGroupes ON META_ECRAN.ID_GROUPE_DONNEES   =liensDonneesGroupes.ID_GROUPE AND liensDonneesGroupes.COMPANY_ID=''*'' INNER JOIN META_DONNEE_GENERALE ON liensDonneesGroupes.NOM_DONNEE  =META_DONNEE_GENERALE.NOM_DONNEE AND META_DONNEE_GENERALE.COMPANY_ID=''*'' INNER JOIN META_DONNEE_ECRAN ON META_DONNEE_GENERALE.NOM_DONNEE  =META_DONNEE_ECRAN.NOM_DONNEE AND META_DONNEE_ECRAN.COMPANY_ID    =''*'' AND META_DONNEE_ECRAN.NOM_PAGE      =''*'' AND (META_DONNEE_ECRAN.MODE_SAISIE! =''hidden'' OR META_DONNEE_GENERALE.NOM_DONNEE IN (SELECT NOM_DONNEE FROM STD_STRUC_DONNEES_HOST';
 requete:= requete||')OR META_DONNEE_GENERALE.NOM_DICTIONNAIRE=META_ECRAN.NOM_DICTIONNAIRE ) LEFT OUTER JOIN META_REGLEGESTION_DESC REGLES_AFF_CLI ON REGLES_AFF_CLI.ID_REGLEGESTION        =META_DONNEE_ECRAN.ID_REGLEGESTION_AFF_CLI AND REGLES_AFF_CLI.COMPANY_ID            =''*'' AND REGLES_AFF_CLI.FLAG_SPECIF_TYPE_REGLE=''M'' LEFT OUTER JOIN META_REGLEGESTION_DESC REGLES_AFF_RD ON REGLES_AFF_RD.ID_REGLEGESTION        =META_DONNEE_ECRAN.ID_REGLEGESTION_AFF_RD AND REGLES_AFF_RD.COMPANY_ID            =''*'' AND REGLES_AFF_RD.FLAG_SPECIF_TYPE_REGLE=''M'' LEFT OUTER JOIN SYS_REQUETES_JSP ON META_DONNEE_ECRAN.APPELTABLE_NOMPAGE   =SYS_REQUETES_JSP.NOMPAGE AND META_DONNEE_ECRAN.APPELTABLE_IDREQUETE=SYS_REQUETES_JSP.IDREQUETE LEFT OUTER JOIN TGE_REF_MAPDO_PAR_DONNEE PAC_ETOILE ON (PAC_ETOILE.NUMPAC             =''*'') AND liensDonneesGroupes.NOM_DONNEE=PAC_ETOILE.DONNEEGXP LEFT OUTER JOIN TGE_REF_MAPDO_PAR_DONNEE PAC_ENTREE ON (PAC_ENTREE.NUMPAC             ='''|| numpac  ||''') AND liensDonneesGroupes.NOM_DONNEE=PAC_ENTREE.DONNEEGXP INNER JOIN SYS_SCH_ELEMENT PAGE_ELT';
 requete:= requete||' ON PAGE_ELT.NOM_PAGE= ''Modules/''  || CODE_DESTINATION  || ''/''  || MODULE_ECRAN  || ''/''  || ROLE_ECRAN  || ''/''  || META_ECRAN.NOM_PAGE  || ''.jsp'' OR PAGE_ELT.NOM_PAGE=REPLACE(''Modules/''  || CODE_DESTINATION  || ''/''  || MODULE_ECRAN  || ''/''  || ROLE_ECRAN  || ''/''  || META_ECRAN.NOM_PAGE  || ''.jsp'', ''_POP'', '''') OR PAGE_ELT.NOM_PAGE= REPLACE(''Modules/''  || CODE_DESTINATION  || ''/''  || MODULE_ECRAN  || ''/''  || ROLE_ECRAN  || ''/''  || META_ECRAN.NOM_PAGE  || ''.jsp'', ''_POP'', ''_TAB'') INNER JOIN SYS_SCHEMAS PAGE_LIEN ON PAGE_ELT.CODE_ELEMENT=PAGE_LIEN.CODE_ELT AND PAGE_ELT.NIVEAU     =PAGE_LIEN.NIVEAU INNER JOIN SYS_SCHEMAS THEME_LIEN ON PAGE_LIEN.CODE_ASSO_PERE=THEME_LIEN.CODE_ASSO INNER JOIN SYS_SCH_ELEMENT THEME_ELT ON THEME_LIEN.CODE_ELT=THEME_ELT.CODE_ELEMENT AND THEME_LIEN.NIVEAU =THEME_ELT.NIVEAU INNER JOIN SYS_SCHEMAS REGROUPEMENT_LIEN ON THEME_LIEN.CODE_ASSO_PERE=REGROUPEMENT_LIEN.CODE_ASSO INNER JOIN SYS_SCH_ELEMENT REGROUPEMENT_ELT ON REGROUPEMENT_LIEN.CODE_ELT=REGROUPEMENT_ELT.CODE_ELEMENT AND REGROUPEMENT_LIEN.NIVEAU =REGROUPEMENT_ELT.NIVEAU INNER JOIN SYS_SCHEMAS ESPACE_LIEN ON REGROUPEMENT_LIEN.CODE_ASSO_PERE=ESPACE_LIEN.CODE_ASSO INNER JOIN SYS_SCH_ELEMENT ESPACE_ELT ON ESPACE_LIEN.CODE_ELT    =ESPACE_ELT.CODE_ELEMENT AND ESPACE_LIEN.NIVEAU     =ESPACE_ELT.NIVEAU ';
 
 --DBMS_OUTPUT.PUT_LINe(requete);
 --FIXME utiliser la procédure trace_dbms_output()
 execute immediate requete bulk collect into tabModeles  ;
  IF (tabModeles.exists(1) ) THEN
 FOR j IN tabModeles.first .. tabModeles.last
 LOOP
 p_retour.extend ;
 p_retour(p_retour.count) := LIG_CLI_MODELE_DONNES(
 tabModeles(j).ESPACE	,
 tabModeles(j).REGROUPEMENT	,
 tabModeles(j).THEME	,
 tabModeles(j).LIBELLE_PAGE	,
 tabModeles(j).NOM_PAGE	,
 tabModeles(j).ONGLET	,
 tabModeles(j).NOM_DONNEE	,
 tabModeles(j).LIBELLE_DONNEE	,
 tabModeles(j).NOM_DICTIONNAIRE	,
 tabModeles(j).TYPE_DONNEE	,
 tabModeles(j).LONGUEUR_PARTIE_ENTIERE	,
 tabModeles(j).LONGUEUR_PARTIE_DECIMALE	,
 tabModeles(j).MODE_SAISIE	,
 tabModeles(j).AFFICHE_CHOIX_VIDE_SELECT	,
 tabModeles(j).VALEURS_OUI_NON	,
 tabModeles(j).REGLES_AFFICHAGE	,
 tabModeles(j).PENTREE	,
 tabModeles(j).PENTREE_FORCABLE	,
 tabModeles(j).PENTREE_CODE_MODIF	,
 tabModeles(j).NOMTABLE	 );
 END LOOP;
 END IF ;
 return p_retour;
 end GET_CLI_MODELE_DONNEES;
 ##
GET_CONTRAT
=SQL=
CREATE OR REPLACE FUNCTION GET_CONTRAT(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER) RETURN DIC_ADM_CONTRAT%ROWTYPE IS 
retour DIC_ADM_CONTRAT%ROWTYPE; 
BEGIN 
  SELECT * INTO retour FROM DIC_ADM_CONTRAT WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END GET_CONTRAT;
##
GET_CONTRAT_HISTO
=SQL=
CREATE OR REPLACE FUNCTION GET_CONTRAT_HISTO(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER, p_dateEff DATE) RETURN DIC_ADM_CONTRAT_HISTO%ROWTYPE IS 
retour DIC_ADM_CONTRAT_HISTO%ROWTYPE; 
BEGIN 
  SELECT * INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND DATE_EFF=p_dateEff;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END GET_CONTRAT_HISTO;
##
TAG_CHARSET=@€éèç
##
GET_CONTRAT_HISTO_HORS_TRANSAC
=SQL=
CREATE OR REPLACE FUNCTION GET_CONTRAT_HISTO_HORS_TRANSAC(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER, p_dateEff DATE, p_useBetween BOOLEAN DEFAULT FALSE) RETURN DIC_ADM_CONTRAT_HISTO%ROWTYPE IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour DIC_ADM_CONTRAT_HISTO%ROWTYPE; 
BEGIN 
  IF p_useBetween THEN
    SELECT * INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND p_dateEff BETWEEN DATE_EFF AND DATE_FIN;
  ELSE
    SELECT * INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND DATE_EFF=p_dateEff;
  END IF;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END GET_CONTRAT_HISTO_HORS_TRANSAC;
##
GET_CONTRAT_HORS_TRANSAC
=SQL=
CREATE OR REPLACE FUNCTION GET_CONTRAT_HORS_TRANSAC(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER) RETURN DIC_ADM_CONTRAT%ROWTYPE IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour DIC_ADM_CONTRAT%ROWTYPE; 
BEGIN 
  SELECT * INTO retour FROM DIC_ADM_CONTRAT WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END GET_CONTRAT_HORS_TRANSAC;
##
TAG_CHARSET=@€éèç
##
GET_DACH_MATRIC
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_DACH_MATRIC' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DACH_MATRIC(p_matric VARCHAR2) RETURN T_TAB_DACH IS 
retour T_TAB_DACH; 
BEGIN 
  SELECT T_LIG_DACH(NUMPAC, PACMAT, NUMCNT, DATE_EFF) BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE MATRIC=p_matric ORDER BY DATE_EFF;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DACH();
END GET_DACH_MATRIC;',0);
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
GET_DACH_MULTI_HORS_TRANSAC
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_DACH_MULTI_HORS_TRANSAC' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING('CREATE OR REPLACE FUNCTION GET_DACH_MULTI_HORS_TRANSAC(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) RETURN T_TAB_DACH IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour T_TAB_DACH; 
BEGIN 
  SELECT T_LIG_DACH(NUMPAC, PACMAT, NUMCNT, DATE_EFF) BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE (NUMPAC,PACMAT,NUMCNT,DATE_EFF) IN (SELECT NUMPAC, PACMAT, NUMCNT, DATE_IDX FROM TABLE( p_listeClesIdxContrat )) ORDER BY MATRIC, DATE_EFF;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DACH();
END GET_DACH_MULTI_HORS_TRANSAC;', 0);
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
GET_DAC_MATRIC
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_DAC_MATRIC' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DAC_MATRIC(p_matric VARCHAR2) RETURN T_TAB_DAC IS 
retour T_TAB_DAC; 
BEGIN 
  SELECT T_LIG_DAC(NUMPAC, PACMAT, NUMCNT) BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT WHERE MATRIC=p_matric ORDER BY DSDCN;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DAC();
END GET_DAC_MATRIC;',0);
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
GET_DAC_MULTI_HORS_TRANSAC
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_DAC_MULTI_HORS_TRANSAC' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING('CREATE OR REPLACE FUNCTION GET_DAC_MULTI_HORS_TRANSAC(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) RETURN T_TAB_DAC IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour T_TAB_DAC; 
BEGIN 
  SELECT T_LIG_DAC(NUMPAC, PACMAT, NUMCNT) BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT WHERE (NUMPAC,PACMAT,NUMCNT) IN (SELECT NUMPAC, PACMAT, NUMCNT FROM TABLE( p_listeClesIdxContrat )) ORDER BY MATRIC, DSDCN;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DAC();
END GET_DAC_MULTI_HORS_TRANSAC;', 0);
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
GET_DATE_EFF_CONTRAT
=SQL=
CREATE OR REPLACE FUNCTION GET_DATE_EFF_CONTRAT(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER, p_dateRef DATE DEFAULT NULL) RETURN DATE IS 
  v_dateRef DATE;
  retour DATE; 
BEGIN 
  IF p_dateRef IS NULL THEN
    v_dateRef := SYSDATE;
  ELSE
    v_dateRef := p_dateRef;
  END IF;
  v_dateRef := TRUNC(v_dateRef,'dd');
  BEGIN
    SELECT MAX(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND v_dateRef BETWEEN DATE_EFF AND DATE_FIN;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  IF retour IS NOT NULL THEN
    RETURN retour;
  END IF;
  BEGIN
    SELECT MIN(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND DATE_EFF>v_dateRef;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  IF retour IS NOT NULL THEN
    RETURN retour;
  END IF;
  BEGIN
    SELECT MAX(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND DATE_EFF<v_dateRef;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  RETURN retour;
END GET_DATE_EFF_CONTRAT;
##
TAG_CHARSET=@€éèç
##
GET_DATE_EFF_SITU
=SQL=
CREATE OR REPLACE FUNCTION GET_DATE_EFF_SITU(p_numpac VARCHAR2, p_pacmat VARCHAR2, p_numcnt NUMBER, p_paiezad VARCHAR2, p_dateRef DATE DEFAULT NULL) RETURN DATE IS 
  v_dateRef DATE;
  retour DATE; 
BEGIN 
  IF p_dateRef IS NULL THEN
    v_dateRef := SYSDATE;
  ELSE
    v_dateRef := p_dateRef;
  END IF;
  v_dateRef := TRUNC(v_dateRef,'dd');
  BEGIN
    SELECT MAX(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND PAIEZAD=p_paiezad AND v_dateRef BETWEEN DATE_EFF AND DATE_FIN;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  IF retour IS NOT NULL THEN
    RETURN retour;
  END IF;
  BEGIN
    SELECT MIN(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND PAIEZAD=p_paiezad AND DATE_EFF>v_dateRef;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  IF retour IS NOT NULL THEN
    RETURN retour;
  END IF;
  BEGIN
    SELECT MAX(DATE_EFF) INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE NUMPAC=p_numpac AND PACMAT=p_pacmat AND NUMCNT=p_numcnt AND PAIEZAD=p_paiezad AND DATE_EFF<v_dateRef;
  EXCEPTION
    WHEN OTHERS THEN retour:=NULL;
  END;
  RETURN retour;
END GET_DATE_EFF_SITU;
##
TAG_CHARSET=@€éèç
##
GET_DEB_HISTO_PACMAT
=SQL=
CREATE OR REPLACE FUNCTION GET_DEB_HISTO_PACMAT(P_NUMPAC VARCHAR2, P_PACMAT VARCHAR2 ) RETURN VARCHAR2 IS 
  v_debHistoPacmat VARCHAR2(6);
BEGIN 
  SELECT  GREATEST(DEB_HISTO_RETRO, TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS, 'YYYYMM'), -NB_MOIS_RETRO), 'YYYYMM'),NVL( PREMIERE_PAIE, '190101')) 
  INTO  v_debHistoPacmat 
  FROM TGE_REF_PAC T
  LEFT JOIN SECUPACMAT S ON S.NUMPAC=T.NUMPAC AND S.PACMAT = P_PACMAT
  WHERE DEB_HISTO_RETRO IS NOT NULL 
  AND T.NUMPAC = P_NUMPAC;
  RETURN v_debHistoPacmat;
  EXCEPTION WHEN NO_DATA_FOUND
  THEN RETURN null;
END GET_DEB_HISTO_PACMAT ;##
TAG_CHARSET=@€éèç
##
GET_DONNEEGXP
=SQL=
create or replace FUNCTION GET_DONNEEGXP(pElement VARCHAR2 , pNumpac VARCHAR2, pMatric VARCHAR2 , pacmat VARCHAR2, numcnt VARCHAR2) RETURN VARCHAR2 AS 
donnee_GXP VARCHAR2(30);
table_GXP VARCHAR2(30);
valeur VARCHAR2(50);
v_requete CLOB;

BEGIN

  BEGIN
    SELECT donneegxp, tablegxp into donnee_GXP
        , table_GXP 
        FROM tge_ref_mapdo
        WHERE element = pElement
        AND numpac    =pNumpac;
  EXCEPTION
      WHEN NO_DATA_FOUND THEN
        -- Pas trouvé pour le NUMPAC passé en paramètre, on recherche pour NUMPAC='*'
        BEGIN
          SELECT DONNEEGXP , TABLEGXP INTO donnee_GXP, table_GXP  FROM TGE_REF_MAPDO WHERE NUMPAC='*' AND ELEMENT=pElement;
        EXCEPTION
          WHEN OTHERS THEN
            RETURN NULL;
        END;
      WHEN OTHERS THEN
        RETURN NULL;
    END; 
    v_requete:= 'select '|| donnee_GXP ||  ' from ' || table_GXP || ' where numpac=''' || pNumpac || ''' and matric= '''||pMatric || ''' and pacmat= '''|| pacmat ||''' and numcnt='''||numcnt||''''; 
    
begin
  execute immediate v_requete into valeur;
   EXCEPTION
          WHEN OTHERS THEN
            RETURN NULL;
 END;
  RETURN valeur;
END GET_DONNEEGXP;
##
TAG_CHARSET=@€éèç
##
GET_EMAIL_MATRIC
=SQL=
create or replace FUNCTION GET_EMAIL_MATRIC(pMatric VARCHAR2) RETURN VARCHAR2
 IS
 varsys VARCHAR2(50);
 reqSelect VARCHAR2(4000);
 nomTable VARCHAR2(30);
 retour VARCHAR2(100);
 BEGIN
 SELECT VALVAR INTO varsys FROM SYS_VARSYS WHERE MODULE='STD' AND CODVAR = 'EMAIL_FIELD';
 nomTable := SUBSTR(varsys,0, INSTR(varsys,'.', -1, 1)-1);
 reqSelect := 'SELECT '||varsys||' FROM '||nomTable||' WHERE matric= :1';
 EXECUTE IMMEDIATE reqSelect INTO retour using pMatric;
 RETURN retour;
 EXCEPTION
 WHEN OTHERS THEN RETURN NULL;
 END GET_EMAIL_MATRIC;
 ##
TAG_CHARSET=@€éèç
##
GET_EMPTY_LIG_DAC
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_EMPTY_LIG_DAC' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING('CREATE OR REPLACE FUNCTION GET_EMPTY_LIG_DAC RETURN T_LIG_DAC IS 
BEGIN 
  RETURN T_LIG_DAC(NULL,NULL,NULL);
END GET_EMPTY_LIG_DAC;', 0);
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
GET_EMPTY_LIG_DACH
=SQL=
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM USER_OBJECTS WHERE OBJECT_NAME='GET_EMPTY_LIG_DACH' AND OBJECT_TYPE='FUNCTION' AND STATUS='VALID';
  IF v_count = 0 THEN
    EXECUTE_IMMEDIATE_STRING('CREATE OR REPLACE FUNCTION GET_EMPTY_LIG_DACH RETURN T_LIG_DACH IS 
BEGIN 
  RETURN T_LIG_DACH(NULL,NULL,NULL,NULL);
END GET_EMPTY_LIG_DACH;', 0);
  END IF;
END;
##
GET_GXP_TRT_PARTICULIER_DATAS
=SQL=
CREATE OR REPLACE FUNCTION GET_GXP_TRT_PARTICULIER_DATAS(nom_table IN VARCHAR2,code_element IN VARCHAR2 DEFAULT NULL) RETURN GXP_TRT_PARTICULIER_DATAS AS 
  p_retour GXP_TRT_PARTICULIER_DATAS := GXP_TRT_PARTICULIER_DATAS();
  regexpPattern VARCHAR2(20) := '\$TABLE\.[A-Z0-9_]+';
  nbDonnees INTEGER;
BEGIN
 FOR r IN (SELECT DISTINCT NUMPAC,TRTPARTICULIER FROM TGE_REF_MAPDO WHERE TRTPARTICULIER LIKE '%$TABLE%' AND ELEMENT=NVL(code_element,ELEMENT) AND  TABLEGXP IN
      (SELECT tableparam
      FROM tge_ref_mapta
      WHERE tablephy = nom_table
        --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
        --Ajout du type 'I'
      AND allerretour IN ('A','2','I')
      )ORDER BY TRTPARTICULIER)
  LOOP
  	nbDonnees := REGEXP_COUNT(r.TRTPARTICULIER, regexpPattern, 1);
    -- On boucle autant de fois qu’il y a de données
    FOR i IN 1 .. nbDonnees LOOP
	   	p_retour.extend;
	   	 -- On récupère la i-ème donnée (et on supprime au passage les 8 premiers caractères correspondant à "$TABLE.")
	  	p_retour(p_retour.count) := GXP_TRT_PARTICULIER_DATA(r.NUMPAC,SUBSTR(REGEXP_SUBSTR(r.TRTPARTICULIER, regexpPattern, 1, i), 8));
    END LOOP;
  END LOOP;
  RETURN p_retour;
END GET_GXP_TRT_PARTICULIER_DATAS;
##
TAG_CHARSET=@€éèç
##
GET_HISTO_EMPLOI
=SQL=
CREATE OR REPLACE FUNCTION GET_HISTO_EMPLOI(
          p_numpac  VARCHAR2,
          p_paiezad VARCHAR2)
     RETURN HISTO_EMPLOI_TAB
AS
     p_req CLOB;
     p_selectLibEmploi CLOB;
     p_cursHisto SYS_REFCURSOR;
     p_dateEff       DATE;
     p_dateFin       DATE;
     p_libelleEmploi VARCHAR2(4000);
     p_tabTmp HISTO_EMPLOI_TAB := HISTO_EMPLOI_TAB();
     p_retour HISTO_EMPLOI_TAB := HISTO_EMPLOI_TAB();
     p_tableGxp  VARCHAR2(24);
     p_donneeGxp VARCHAR2(50);
     p_trt       VARCHAR2(4000);
BEGIN
     p_req := 'SELECT DATE_EFF, (CASE WHEN DATE_FIN=TO_DATE(''20991231'',''yyyymmdd'') THEN NULL ELSE DATE_FIN END)        AS DATE_FIN, ';
     -- Par défaut, on récupère QUALPE, ou le libellé de l’emploi
     p_selectLibEmploi := 'NVL(QUALPE,(SELECT F.LIBELLE FROM GA_FILIERE F WHERE F.NUMPAC=C.NUMPAC AND F.FILIERE=C.FILIR AND F.REGROUPEMENT_METIER=C.SSFIL AND F.METIER=C.METIER AND F.QUALIFICATION=C.EMPLOI))';
     -- ICI ON VA RECUPERER LE TRAITEMENT PARTICULIER POTENTIEL pour l’élément A670
     BEGIN
          SELECT TABLEGXP,
               DONNEEGXP,
               TRTPARTICULIER
          INTO p_tableGxp,
               p_donneeGxp,
               p_trt
          FROM TGE_REF_MAPDO
          WHERE NUMPAC = p_numpac
           AND ELEMENT = 'A670';
     EXCEPTION
     WHEN NO_DATA_FOUND THEN
          -- Pas trouvé pour le NUMPAC passé en paramètre, on recherche pour NUMPAC='*'
          BEGIN
               SELECT TABLEGXP,
                    DONNEEGXP,
                    TRTPARTICULIER
               INTO p_tableGxp,
                    p_donneeGxp,
                    p_trt
               FROM TGE_REF_MAPDO
               WHERE NUMPAC = '*'
                AND ELEMENT = 'A670';
          EXCEPTION
          WHEN NO_DATA_FOUND THEN NULL;
          END;
     END;
IF p_tableGxp               IS NOT NULL AND p_tableGxp='DIC_ADM_CONTRAT_HISTO' THEN
     IF p_trt               IS NOT NULL THEN
          p_selectLibEmploi := p_trt;
          p_selectLibEmploi := REPLACE(p_selectLibEmploi,'$TABLE','C');
          p_selectLibEmploi := REPLACE(p_selectLibEmploi,'$MATRIC','C.MATRIC');
          p_selectLibEmploi := REPLACE(p_selectLibEmploi,'$NUMPAC','C.NUMPAC');
          p_selectLibEmploi := REPLACE(p_selectLibEmploi,'$DONNEEGXP','C.'||p_donneeGxp);
     ELSE
          IF p_donneeGxp         != 'QUALPE' THEN
               p_selectLibEmploi := REPLACE(p_selectLibEmploi, 'QUALPE', p_donneeGxp);
          END IF;
     END IF;
END IF;
p_req := p_req || p_selectLibEmploi;
p_req := p_req || ' AS LIBELLE_EMPLOI FROM DIC_ADM_CONTRAT_HISTO C WHERE NUMPAC='''||p_numpac||''' AND PAIEZAD ='''||p_paiezad||''' ORDER BY DATE_EFF';
OPEN p_cursHisto FOR p_req;
LOOP
     FETCH p_cursHisto INTO p_dateEff, p_dateFin, p_libelleEmploi;
     EXIT
WHEN p_cursHisto%NOTFOUND;
     IF p_tabTmp.count = 0 THEN
          p_tabTmp.extend;
          p_tabTmp(p_tabTmp.count) := HISTO_EMPLOI(NULL, p_dateEff, p_dateFin, p_libelleEmploi);
     ELSE
          IF p_libelleEmploi = p_tabTmp(p_tabTmp.count).LIBELLE_EMPLOI AND p_dateEff = p_tabTmp(p_tabTmp.count).DATE_FIN+1 THEN
               -- Même emploi sur une période continue : on modifie la date de fin du dernier histo stocké
               p_tabTmp(p_tabTmp.count).DATE_FIN := p_dateFin;
          ELSE
               -- Emploi différent, ou même emploi avec rupture (départ / réembauche avec période d'inactivité) : on stocke un nouvel histo
               p_tabTmp.extend;
               p_tabTmp(p_tabTmp.count) := HISTO_EMPLOI(NULL, p_dateEff, p_dateFin, p_libelleEmploi);
          END IF;
     END IF;
END LOOP;
CLOSE p_cursHisto;
FOR i IN REVERSE 1..p_tabTmp.count
LOOP
     EXIT
WHEN p_retour.count=30;
     p_retour.extend;
     p_retour(p_retour.count)            := p_tabTmp(i);
     p_retour(p_retour.count).NUM_EMPLOI := LPAD(p_retour.count,2,'0');
END LOOP;
RETURN p_retour;
END GET_HISTO_EMPLOI;
##
GET_LIBELLE_ELEMENT
=SQL=
CREATE OR REPLACE
  FUNCTION GET_LIBELLE_ELEMENT(
      p_nom_page VARCHAR2 ,
      p_niveau   NUMBER)
    RETURN VARCHAR2
  AS
    v_retour VARCHAR2 (50);
  BEGIN
  WITH ARBO_SCHEMA (CODE_ELEMENT, NIVEAU, LIBELLE, CODE_ASSO_PERE) AS
    (SELECT E.CODE_ELEMENT,
      E.NIVEAU,
      E.LIBELLE,
      S.CODE_ASSO_PERE
    FROM SYS_SCH_ELEMENT E,
      SYS_SCHEMAS S
    WHERE E.CODE_ELEMENT=S.CODE_ELT
    AND E.NIVEAU        =S.NIVEAU
    AND E.NOM_PAGE      =p_nom_page
    UNION ALL
    SELECT E.CODE_ELEMENT,
      E.NIVEAU,
      E.LIBELLE,
      S.CODE_ASSO_PERE
    FROM SYS_SCH_ELEMENT E,
      SYS_SCHEMAS S,
      ARBO_SCHEMA A
    WHERE E.CODE_ELEMENT=S.CODE_ELT
    AND E.NIVEAU        =S.NIVEAU
    AND S.CODE_ASSO     =A.CODE_ASSO_PERE
    )
  SELECT LIBELLE INTO v_retour FROM ARBO_SCHEMA WHERE NIVEAU=p_niveau;
  RETURN v_retour;
END GET_LIBELLE_ELEMENT; 
##
GET_MESSAGE_ERREUR
=SQL=
create or replace FUNCTION GET_MESSAGE_ERREUR 
(
  P_CODMOD IN VARCHAR2 
, P_CODERR IN VARCHAR2 
, P_CODLANG IN VARCHAR2 
) RETURN VARCHAR2 AS 

message varchar2(1000);

BEGIN
  select liberr into message from sys_def_erreurs where codmod=p_codmod and coderr=p_coderr and codlang=p_codlang;
  return message;  
END GET_MESSAGE_ERREUR;
##
GET_MESSAGE_ERREUR_PARAM
=SQL=
create or replace FUNCTION GET_MESSAGE_ERREUR_PARAM 
(
  P_MESSAGE IN VARCHAR2 
, PARAMS IN VARCHAR2 
) RETURN VARCHAR2 AS 

message varchar2(3000);
param varchar2(100);
position number;
v_params varchar2(1000);
BEGIN
  message:=p_message;
  v_params:=params;
    while instr(message,'#')>0 
      loop
        position:=INSTR(v_params,'|',1)-1;
        if position=-1 then
        position:= length(v_params);
        end if;
        param:=substr(v_params,0,position);
        v_params:=substr(v_params,position+2);
        message:= REGEXP_REPLACE(message,'#[1-9]?', param,1,1);      
      end loop;
  return message;  
END GET_MESSAGE_ERREUR_PARAM;
##
TAG_CHARSET=@€éèç
##
GET_MULTICLIENT_REF_PAC
=SQL=
CREATE OR REPLACE FUNCTION GET_MULTICLIENT_REF_PAC 
	RETURN T_MULTICLIENT_REF_PAC 
AS 
	v_retour T_MULTICLIENT_REF_PAC := T_MULTICLIENT_REF_PAC();
	-- Une valeur si la table SYS_USR_CID existe, null sinon
	v_existTable VARCHAR2(40);
	v_clientId_varsys VARCHAR2(32);
BEGIN
	/**
	 * Dans le cadre du multiclient, la table MULTICLIENT_REF_PAC permet d'associer un NUMPAC avec un COMPANY_ID (CID).
	 * Le problème, c'est que cette table n'existe pas dans ADP Link car on est monoclient.
	 * Cette fonction va permettre de faire des requêtes sans avoir à s'interroger sur l'existence ou non de la table.
	 * Si la table existe, on retourne les données de MULTICLIENT_REF_PAC, 
	 * sinon on les créé en utilisant la table TGE_REF_PAC et la valeur du CID contenue dans la varsys "NS_CLIENT_ID"
	*/
	BEGIN
	    select TABLE_NAME into v_existTable from USER_TABLES where TABLE_NAME = 'MULTICLIENT_REF_PAC';
  	EXCEPTION
    WHEN NO_DATA_FOUND THEN
    	-- La table n'exite pas  	
    	v_existTable := NULL;
  	END;
	
	IF v_existTable IS NOT NULL THEN 
		-- Execute immediate car la table peut ne pas existée (pb de statement ignored)
		execute immediate 'select T_MULTICLIENT_REF_PAC_OBJ(NUMPAC, COMPANY_ID) from MULTICLIENT_REF_PAC' bulk collect into v_retour;
  	ELSE
  		select VALVAR into v_clientId_varsys from SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		-- On ne veut pas récupérer les utilisateurs techniques
  		select T_MULTICLIENT_REF_PAC_OBJ(NUMPAC, v_clientId_varsys) bulk collect into v_retour from TGE_REF_PAC;
  	END IF;
  	RETURN v_retour;
END GET_MULTICLIENT_REF_PAC;
##
GET_NB_LIGNES
=SQL=
create or replace FUNCTION GET_NB_LIGNES( nomTable IN VARCHAR2, clauseWhere IN VARCHAR2 ) RETURN INTEGER IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour INTEGER; 
req varchar(4000);
BEGIN
  IF nomTable IS NULL THEN RETURN 0; END IF;
  req := 'SELECT COUNT(*) FROM '||nomTable;
  IF clauseWhere IS NOT NULL THEN
    req := req||' WHERE '||clauseWhere;
  END IF;
  EXECUTE IMMEDIATE req INTO retour;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN 0;
END GET_NB_LIGNES;
##
TAG_CHARSET=@€éèç
##
GET_SYS_USR_CID
=SQL=
CREATE OR REPLACE FUNCTION GET_SYS_USR_CID 
	RETURN T_SYS_USR_CID 
AS 
	v_retour T_SYS_USR_CID := T_SYS_USR_CID();
	-- Une valeur si la table SYS_USR_CID existe, null sinon
	v_existTable VARCHAR2(40);
	v_clientId_varsys VARCHAR2(32);
BEGIN
	/**
	 * Dans le cadre du multiclient, la table SYS_USR_CID permet d'associer un LOGIN avec un COMPANY_ID (CID).
	 * Le problème, c'est que cette table n'existe pas dans ADP Link car on est monoclient.
	 * Cette fonction va permettre de faire des requêtes sans avoir à s'interroger sur l'existence ou non de la table.
	 * Si la table existe, on retourne les données de SYS_USR_CID, 
	 * sinon on les créé en utilisant la table SYS_USR_CONFIG et la valeur du CID contenue dans la varsys "NS_CLIENT_ID"
	 * MAIS on exclu les utilisateurs techniques (SYS_USR_ADMIN_ONLY)
	*/
	BEGIN
	    select TABLE_NAME into v_existTable from USER_TABLES where TABLE_NAME = 'SYS_USR_CID';
  	EXCEPTION
    WHEN NO_DATA_FOUND THEN
    	-- La table n'exite pas  	
    	v_existTable := NULL;
  	END;
	
	IF v_existTable IS NOT NULL THEN 
		-- Execute immediate car la table peut ne pas existée (pb de statement ignored)
		execute immediate 'select T_SYS_USR_CID_OBJ(LOGIN, COMPANY_ID) from SYS_USR_CID' bulk collect into v_retour;
  	ELSE
  		select VALVAR into v_clientId_varsys from SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		-- On ne veut pas récupérer les utilisateurs techniques
  		select T_SYS_USR_CID_OBJ(LOGIN, v_clientId_varsys) bulk collect into v_retour from SYS_USR_CONFIG C where not exists (select 1 from SYS_USR_ADMIN_ONLY O where C.LOGIN = O.LOGIN);
  	END IF;
  	RETURN v_retour;
END GET_SYS_USR_CID;
##
GET_TGE_MAP_ARG_ELT_BY_NUMPAC
=SQL=
create or replace FUNCTION GET_TGE_MAP_ARG_ELT_BY_NUMPAC ( NUMPAC                  IN VARCHAR2
 )
 RETURN TGE_MAP_ARG_ELT_ENTRY_TABLE
 IS
  resultat TGE_MAP_ARG_ELT_ENTRY_TABLE;
  CURSOR tge_map_arg (p_numpac TGE_REF_PAC.NUMPAC%TYPE)
 IS
 WITH tge_map_arg_elt_with_PAC (nom_elt,nom_arg) AS
 (SELECT nom_elt,
 nom_arg
 FROM tge_map_arg_elt
 WHERE nom_arg IN ('A01','A02','A03')
 AND code_table = 'LTP'
 AND NUMPAC     = p_numpac
 )
 select TGE_MAP_ARG_ELT_ENTRY(nom_arg,nom_elt)
 from (
 SELECT nom_elt,nom_arg FROM tge_map_arg_elt_with_PAC 
 UNION ALL
 SELECT el2.nom_elt,el2.nom_arg
 FROM tge_map_arg_elt el2
 WHERE el2.nom_arg   IN ('A01','A02','A03')
 AND el2.code_table   = 'LTP'
 AND el2.NUMPAC       = '*'
 AND el2.nom_arg NOT IN
 ( SELECT nom_arg FROM tge_map_arg_elt_with_PAC)
)P ;
 BEGIN
OPEN tge_map_arg(NUMPAC) ;
 LOOP
 FETCH tge_map_arg BULK COLLECT INTO resultat ;
 EXIT
 WHEN tge_map_arg%NOTFOUND;
 END LOOP;
 CLOSE tge_map_arg;
 RETURN resultat;
 END GET_TGE_MAP_ARG_ELT_BY_NUMPAC;
 ##
GET_VAL_DATA_BY_ELEMENT
=SQL=
CREATE OR REPLACE FUNCTION GET_VAL_DATA_BY_ELEMENT(p_MATRIC VARCHAR2, p_NUMPAC VARCHAR2, p_PACMAT VARCHAR2, p_NUMCNT VARCHAR2, p_PAIEZAD VARCHAR2, p_DATE_EFF VARCHAR2, p_ELEMENT VARCHAR2, p_cleSupp1 VARCHAR2, p_valCleSupp1 VARCHAR2, p_cleSupp2 VARCHAR2, p_valCleSupp2 VARCHAR2) RETURN VARCHAR2 AS 
  donneeGxp VARCHAR2(30);
  tableGxp VARCHAR2(30);
  tablePhy VARCHAR2(30);
  valTmp VARCHAR2(4000);
  clWhere VARCHAR2(4000);
  req VARCHAR2(4000);
  retour VARCHAR2(4000);
BEGIN
  -- NUMPAC et ELEMENT obligatoires
  IF p_NUMPAC IS NULL OR p_ELEMENT IS NULL THEN
    RETURN NULL;
  END IF;
  -- On recherche la donnée et la table dans lesquelles l'élément est stocké
  BEGIN
    SELECT DONNEEGXP, TABLEGXP INTO donneeGxp, tableGxp FROM TGE_REF_MAPDO WHERE NUMPAC=p_NUMPAC AND ELEMENT=p_ELEMENT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- Pas trouvé pour le NUMPAC passé en paramètre, on recherche pour NUMPAC='*'
      BEGIN
        SELECT DONNEEGXP, TABLEGXP INTO donneeGxp, tableGxp FROM TGE_REF_MAPDO WHERE NUMPAC='*' AND ELEMENT=p_ELEMENT;
      EXCEPTION
        WHEN OTHERS THEN
          RETURN NULL;
      END;
    WHEN OTHERS THEN
      RETURN NULL;
  END;
  -- On recherche la table dans lesquelles l'élément est stocké
  BEGIN
    SELECT TABLEPHY INTO tablePhy FROM TGE_REF_MAPTA WHERE NUMPAC=p_NUMPAC AND TABLEPARAM=tableGxp;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- Pas trouvé pour le NUMPAC passé en paramètre, on recherche pour NUMPAC='*'
      BEGIN
        SELECT TABLEPHY INTO tablePhy FROM TGE_REF_MAPTA WHERE NUMPAC='*' AND TABLEPARAM=tableGxp;
      EXCEPTION
        WHEN OTHERS THEN
          RETURN NULL;
      END;
    WHEN OTHERS THEN
      RETURN NULL;
  END;
  clWhere := '1=1';
  FOR une_cle_primaire IN (SELECT CC.COLUMN_NAME, (SELECT DATA_TYPE FROM USER_TAB_COLUMNS TC WHERE TC.COLUMN_NAME=CC.COLUMN_NAME AND TC.TABLE_NAME=CC.TABLE_NAME) AS DATA_TYPE FROM USER_CONSTRAINTS C, USER_CONS_COLUMNS CC WHERE C.CONSTRAINT_TYPE='P' AND C.CONSTRAINT_NAME=CC.CONSTRAINT_NAME AND CC.TABLE_NAME=tablePhy ORDER BY CC.POSITION)
  LOOP
  --  VARCHAR2,  VARCHAR2,  VARCHAR2,  VARCHAR2,  VARCHAR2, p_ELEMENT VARCHAR2) RETURN VARCHAR2 AS
    valTmp := NULL;
    IF une_cle_primaire.COLUMN_NAME='MATRIC' THEN
      valTmp := p_MATRIC;
    ELSIF une_cle_primaire.COLUMN_NAME='NUMPAC' THEN
      valTmp := p_NUMPAC;
    ELSIF une_cle_primaire.COLUMN_NAME='PACMAT' THEN
      valTmp := p_PACMAT;
    ELSIF une_cle_primaire.COLUMN_NAME='NUMCNT' THEN
      valTmp := p_NUMCNT;
    ELSIF une_cle_primaire.COLUMN_NAME='PAIEZAD' THEN
      valTmp := p_PAIEZAD;
    ELSIF une_cle_primaire.COLUMN_NAME='DATE_EFF' THEN
      valTmp := p_DATE_EFF;
    ELSIF p_cleSupp1 IS NOT NULL AND une_cle_primaire.COLUMN_NAME=p_cleSupp1 THEN
      valTmp := p_valCleSupp1;
    ELSIF p_cleSupp2 IS NOT NULL AND une_cle_primaire.COLUMN_NAME=p_cleSupp2 THEN
      valTmp := p_valCleSupp2;
    END IF;
    IF valTmp IS NULL THEN
      RETURN NULL;
    END IF;
    IF une_cle_primaire.DATA_TYPE='NUMBER' THEN
      valTmp := valTmp;
    ELSIF une_cle_primaire.DATA_TYPE='DATE' THEN
      valTmp := 'TO_DATE('''||valTmp||''', ''yyyymmdd'')';
    ELSE
      valTmp := ''''||valTmp||'''';
    END IF;
    clWhere := clWhere||' AND '||une_cle_primaire.COLUMN_NAME||'='||valTmp;
  END LOOP;
  req := 'SELECT '||donneeGxp||' FROM '||tablePhy||' WHERE '||clWhere||' AND ROWNUM=1';
  EXECUTE IMMEDIATE req INTO retour;
  RETURN retour;
END GET_VAL_DATA_BY_ELEMENT;
##
GET_WKF_DATAS
=SQL=
CREATE OR REPLACE FUNCTION GET_WKF_DATAS(p_DOS_NUM NUMBER) RETURN T_WKF_DATAS AS 
  p_retour T_WKF_DATAS := T_WKF_DATAS();
	cur_dictionnaire SYS_REFCURSOR;
  nom_donnee VARCHAR2(50);
  valeur_donnee CLOB;
  nb_lignes NUMBER;
  cpt NUMBER;
BEGIN
  FOR un_dictionnaire IN (SELECT NOM_DICTIONNAIRE FROM XMLTABLE('/DATA_DOS/*' PASSING (SELECT XML_DATAS FROM WKF_METIER_GENERIQUE WHERE DOS_NUM = p_DOS_NUM ) COLUMNS NOM_DICTIONNAIRE VARCHAR2(30) PATH 'name(.)') WHERE NOM_DICTIONNAIRE LIKE 'DIC%' OR NOM_DICTIONNAIRE LIKE 'SIMU_TGE%')
  LOOP
    OPEN cur_dictionnaire FOR 'SELECT NOM_DONNEE, VALEUR_DONNEE FROM XMLTABLE(''/DATA_DOS/'||un_dictionnaire.NOM_DICTIONNAIRE||'/*'' PASSING (SELECT XML_DATAS FROM WKF_METIER_GENERIQUE WHERE DOS_NUM = '||p_DOS_NUM||' ) COLUMNS NOM_DONNEE VARCHAR2(50) PATH ''name(.)'', VALEUR_DONNEE CLOB PATH ''.'') WHERE NOT NOM_DONNEE=''BIDON'' AND NOT NOM_DONNEE='''||un_dictionnaire.NOM_DICTIONNAIRE||'_NB_LIGNES'' AND NOT REGEXP_REPLACE(NOM_DONNEE,''_[0-9]+$'','''')='''||un_dictionnaire.NOM_DICTIONNAIRE||'_LIGNE''';
    LOOP FETCH cur_dictionnaire INTO nom_donnee, valeur_donnee;
      EXIT WHEN cur_dictionnaire%NOTFOUND;
      p_retour.extend;
      p_retour(p_retour.count) := T_WKF_DATA(un_dictionnaire.NOM_DICTIONNAIRE, NULL, nom_donnee, SUBSTR(valeur_donnee,1,4000) );
    END LOOP;
    CLOSE cur_dictionnaire;
    SELECT EXTRACTVALUE(XML_DATAS, '/DATA_DOS/'||un_dictionnaire.NOM_DICTIONNAIRE||'/'||un_dictionnaire.NOM_DICTIONNAIRE||'_NB_LIGNES') INTO nb_lignes FROM WKF_METIER_GENERIQUE WHERE DOS_NUM=p_DOS_NUM;
    IF nb_lignes IS NOT NULL AND NOT nb_lignes='0' THEN
      cpt := 0;
      WHILE NOT TO_CHAR(cpt)=nb_lignes
      LOOP
        OPEN cur_dictionnaire FOR 'SELECT NOM_DONNEE, VALEUR_DONNEE FROM XMLTABLE(''/DATA_DOS/'||un_dictionnaire.NOM_DICTIONNAIRE||'/'||un_dictionnaire.NOM_DICTIONNAIRE||'_LIGNE_'||cpt||'/*'' PASSING (SELECT XML_DATAS FROM WKF_METIER_GENERIQUE WHERE DOS_NUM = '||p_DOS_NUM||' ) COLUMNS NOM_DONNEE VARCHAR2(50) PATH ''name(.)'', VALEUR_DONNEE CLOB PATH ''.'') WHERE NOM_DONNEE NOT IN (''BIDON'',''CODE_OPERATION_LIGNE'',''NOM_ECRAN_SAISIE'')';
        LOOP FETCH cur_dictionnaire INTO nom_donnee, valeur_donnee;
          EXIT WHEN cur_dictionnaire%NOTFOUND;
          p_retour.extend;
          p_retour(p_retour.count) := T_WKF_DATA(un_dictionnaire.NOM_DICTIONNAIRE, cpt+1, nom_donnee, SUBSTR(valeur_donnee,1,4000) );
        END LOOP;
        CLOSE cur_dictionnaire;
        cpt := cpt+1;
      END LOOP;
    END IF;
  END LOOP;
  RETURN p_retour;
END GET_WKF_DATAS;
##
HELPDESK_LINEARISE_DEV
=SQL=
CREATE OR REPLACE
  FUNCTION HELPDESK_LINEARISE_DEV(
      pcodfiche IN VARCHAR2 )
    RETURN VARCHAR2
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
  BEGIN
    OPEN cur FOR SELECT CODEUSER FROM HELPDESK_FICHE_INTERVENANT WHERE CODFICHE = pcodfiche order by CODEUSER ASC ;
    LOOP
      FETCH cur INTO retourselect;
    EXIT
  WHEN cur % NOTFOUND;
    retour := retour||retourselect||';';
  END LOOP ;
  CLOSE cur;
  RETURN SUBSTR(retour, 0, LENGTH(retour)-1);
END;
##
HREXTR_CHARGER_DATE_EFF
=SQL=
CREATE OR REPLACE
  FUNCTION HREXTR_CHARGER_DATE_EFF(
      DateSynchro IN VARCHAR2,
      DateCloture IN VARCHAR2)
    RETURN VARCHAR2
  AS
  BEGIN
    IF (DateSynchro IS NOT NULL) THEN
      IF (sysdate    < TO_DATE(DateSynchro, 'YYYYMMDD')) THEN
        RETURN TO_CHAR(sysdate, 'YYYYMMDD');
      ELSE
        RETURN DateSynchro;
      END IF;
    ELSE
      IF (DateCloture IS NOT NULL) THEN
        RETURN DateCloture;
      ELSE
        RETURN TO_CHAR(sysdate, 'YYYYMMDD');
      END IF;
    END IF;
    RETURN NULL;
  END HREXTR_CHARGER_DATE_EFF; 
  ##
HREXTR_CODTS_ATPOSIT
=SQL=
CREATE OR REPLACE
  FUNCTION HREXTR_CODTS_ATPOSIT(
      p_position IN NUMBER )
    RETURN VARCHAR2
  IS
  TYPE tcur
IS
  REF
  CURSOR;
    cur tcur;
    retour VARCHAR2(10);
  BEGIN
    OPEN cur FOR SELECT TAB.codts FROM
    (SELECT ROWNUM AS position,
      codts
    FROM
      (SELECT * FROM std_structures ORDER BY ordre
      )
    ) TAB WHERE TAB.position=p_position;
    LOOP
      FETCH cur INTO retour;
      EXIT
    WHEN cur % NOTFOUND;
    END LOOP ;
    CLOSE cur;
    RETURN retour;
  END HREXTR_CODTS_ATPOSIT;
  ##
HRGP_EXISTSALAIRE
=SQL=
CREATE OR REPLACE
  FUNCTION HRGP_EXISTSALAIRE(
      p_matric  IN donpaie.matric%TYPE,
      p_annee   IN donpaie.an%TYPE,
      p_periode IN VARCHAR)
    RETURN INTEGER
  IS
    nb_salaire INTEGER;
  BEGIN
    IF p_periode = 'A' THEN
      SELECT COUNT(*)
      INTO nb_salaire
      FROM donpaie
      WHERE mois    = 'A'
      AND an        = p_annee
      AND matric    = p_matric;
    ELSIF p_periode = 'M' THEN
      SELECT COUNT(*)
      INTO nb_salaire
      FROM donpaie
      WHERE mois =
        (SELECT MAX(mois)
        FROM donpaie
        WHERE NOT mois = 'A'
        AND an         = p_annee
        AND matric     = p_matric
        )
      AND matric = p_matric
      AND an     = p_annee;
    ELSE
      SELECT COUNT(*)
      INTO nb_salaire
      FROM donpaie
      WHERE an   = p_annee
      AND matric = p_matric;
    END IF;
    RETURN nb_salaire;
  END hrgp_existsalaire; 
  ##
HRGP_SALAIRE_MENSUEL
=SQL=
CREATE OR REPLACE
  FUNCTION HRGP_SALAIRE_MENSUEL(
      p_matric IN donpaie.matric%TYPE,
      p_annee  IN donpaie.an%TYPE)
    RETURN NUMBER
  IS
    le_salaire NUMBER;
  BEGIN
    IF hrgp_existsalaire(p_matric, p_annee, 'A')   = 0 THEN
      IF hrgp_existsalaire(p_matric, p_annee, 'M') = 0 THEN
        le_salaire                                := 0;
      ELSE
        le_salaire := hrgp_salaire_mensuel_mois(p_matric, p_annee);
      END IF;
    ELSE
      le_salaire := hrgp_salaire_mensuel_an(p_matric, p_annee);
    END IF;
    RETURN le_salaire;
  END hrgp_salaire_mensuel; 
  ##
HRGP_SALAIRE_MENSUEL_AN
=SQL=
CREATE OR REPLACE
  FUNCTION HRGP_SALAIRE_MENSUEL_AN(
      p_matric IN DONPAIE.MATRIC%Type ,
      p_annee  IN DONPAIE.AN%Type)
    RETURN NUMBER
  IS
    le_salaire NUMBER;
  BEGIN
    SELECT ROUND(MBRUT/12,2)
    INTO le_salaire
    FROM DONPAIE
    WHERE MATRIC = p_matric
    AND AN       =p_annee
    AND mois     ='A' ;
    RETURN le_salaire;
  END hrgp_salaire_mensuel_an ; 
  ##
HRGP_SALAIRE_MENSUEL_MOIS
=SQL=
CREATE OR REPLACE
  FUNCTION HRGP_SALAIRE_MENSUEL_MOIS(
      p_matric IN DONPAIE.MATRIC%Type ,
      p_annee  IN DONPAIE.AN%Type)
    RETURN NUMBER
  IS
    le_salaire NUMBER;
  BEGIN
    SELECT MBRUT
    INTO le_salaire
    FROM donpaie
    WHERE mois=
      (SELECT MAX(mois)
      FROM DONPAIE
      WHERE NOT mois='A'
      AND an        = p_annee
      AND matric    = p_matric
      )
    AND matric = p_matric
    AND an     = p_annee;
    RETURN le_salaire;
  END hrgp_salaire_mensuel_mois ; 
  ##
TAG_CHARSET=@€éèç
##
HRORG_ENTITE
=SQL=
CREATE OR REPLACE FUNCTION "HRORG_ENTITE"(
    p_codts  IN std_struc_arbre.codts%TYPE,
    p_niveau IN std_struc_niv.niveau%TYPE,
    p_entite IN std_struc_entite.code_entite%TYPE,
    p_date   IN std_struc_entite.date_eff%TYPE,
    p_cid    IN std_struc_entite.cid%TYPE default null)
  RETURN std_struc_entite.code_entite%TYPE
IS
  v_entite_mere VARCHAR2(25);
  v_date_fin    VARCHAR2(8);
  v_type_entite VARCHAR2(15);
  v_niv_tech    NUMBER;
  v_cid std_struc_entite.cid%TYPE;
  
BEGIN
  
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
	
  /* lecture du niveau technique de l'entité */
  SELECT niv_tech
  INTO v_niv_tech
  FROM std_struc_index
  WHERE niv_tech >= p_niveau
  AND cid = v_cid
  AND codts       = p_codts
  AND last_entite = p_entite
  AND p_date BETWEEN date_eff AND date_fin ;
  
  IF v_niv_tech IS NULL THEN
    /* échec de la lecture */
    RETURN NULL ;
  ELSE
    /* on vérifie le niveau technique dans la structure */
    IF v_niv_tech > p_niveau THEN
      /* lecture de l'arbre pour trouver l'entite mère un cran au-dessus */
      SELECT code_ent_mere,
        date_fin
      INTO v_entite_mere,
        v_date_fin
      FROM std_struc_arbre
      WHERE codts     = p_codts
      AND cid = v_cid
      AND code_entite = p_entite
      AND p_date BETWEEN date_eff AND date_fin ;
      
      IF v_entite_mere IS NULL THEN
        /* échec de la lecture de l'entité mère */
        RETURN NULL ;
      ELSE
        /* appel récursif à la fonction avec l'entité mère */
        RETURN HRORG_ENTITE(p_codts,p_niveau,v_entite_mere,p_date, v_cid) ;
      END IF ;
    ELSE
      /* c'est bon on a l'entité du bon niveau */
      --DBMS_OUTPUT.PUT_LINE('p_entite ' || p_entite);
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN p_entite ;
    END IF;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  RETURN NULL ;
END HRORG_ENTITE ;
##
TAG_CHARSET=@€éèç
##
HRORG_GET_GROUPE_VALIDEUR
=SQL=
CREATE OR REPLACE
  FUNCTION HRORG_GET_GROUPE_VALIDEUR(
      p_codts  IN STD_STRUC_ARBRE.codts%TYPE,
      p_opnum  IN WKF_OPERATIONS.op_num%TYPE,
      p_date   IN STD_STRUC_ENTITE.date_eff%TYPE,
      p_entite IN STD_STRUC_ENTITE.code_entite%TYPE, 
      p_cid     IN STD_STRUC_ARBRE.cid%TYPE default null
      )
    RETURN SYS_GROUPE_VALIDEURS.GROUPE_VALIDEURS%TYPE
  IS
  TYPE tcur
IS
  REF
  CURSOR;
    curentite1 tcur;
    ventite     VARCHAR2 (100);
    vgroupe_val VARCHAR2 (100);
    vlogin      VARCHAR2 (100);
    vniv        NUMBER;
    vnbhab      NUMBER;
    vcodts      NUMBER;
    vdate       NUMBER;
    vnbfctrole  NUMBER;
    v_cid        STD_STRUC_ARBRE.cid%TYPE;
  BEGIN
    IF (p_opnum IS NULL) THEN
      RETURN NULL;
    END IF;
    IF (p_entite IS NULL) THEN
      RETURN NULL;
    END IF;
    vdate     := p_date;
    IF (vdate IS NULL) THEN
      SELECT TO_CHAR(SYSDATE,'yyyymmdd') INTO vdate FROM DUAL;
  	END IF;
  	
  	v_cid := p_cid;
  	IF (v_cid IS NULL) THEN
  		BEGIN
  			SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		EXCEPTION
  		WHEN NO_DATA_FOUND THEN
  			v_cid := null;
  		END;
  	END IF;
  	IF (v_cid IS NULL) THEN
  		-- En mode multiclient, la varsys peut être null et le passage du paramètre p_cid est obligatoire
  		RETURN NULL;
  	END IF;
  	
  vcodts     := p_codts;
  IF (vcodts IS NULL) THEN
    SELECT CODTS INTO vcodts FROM STD_STRUC_TYPE WHERE CRITERE_VALIDEURS='1';
  END IF;
  IF (vcodts IS NULL) THEN
    RETURN NULL;
  END IF;
  SELECT COUNT(*)
  INTO vnbfctrole
  FROM WKF_OP_ROLE
  WHERE OP_NUM    =p_opnum
  AND NOT FCT_ROLE='*';
  OPEN curentite1 FOR
WITH entitepere (code_entite, code_ent_mere, groupe_valideurs, login, niveau) AS
  (SELECT std_struc_arbre.code_entite,
    std_struc_arbre.code_ent_mere,
    std_struc_arbre.groupe_valideurs,
    sys_groupe_valideurs.login,
    0 niveau
  FROM std_struc_arbre
  LEFT OUTER JOIN sys_groupe_valideurs
  ON std_struc_arbre.groupe_valideurs=sys_groupe_valideurs.groupe_valideurs
  WHERE
  std_struc_arbre.cid = v_cid
  AND std_struc_arbre.code_entite  =p_entite
  AND vdate BETWEEN std_struc_arbre.date_eff AND std_struc_arbre.date_fin
  AND std_struc_arbre.codts=vcodts
  UNION ALL
  SELECT std_struc_arbre.code_entite,
    std_struc_arbre.code_ent_mere,
    std_struc_arbre.groupe_valideurs,
    sys_groupe_valideurs.login,
    niveau-1
  FROM std_struc_arbre
  LEFT OUTER JOIN sys_groupe_valideurs
  ON std_struc_arbre.groupe_valideurs=sys_groupe_valideurs.groupe_valideurs,
    entitepere
  WHERE 
  std_struc_arbre.cid = v_cid
  AND std_struc_arbre.code_entite=entitepere.code_ent_mere
  AND vdate BETWEEN std_struc_arbre.date_eff AND std_struc_arbre.date_fin
  AND std_struc_arbre.codts=vcodts
  )
SELECT DISTINCT code_entite,
  groupe_valideurs,
  login,
  niveau
FROM entitepere
WHERE groupe_valideurs IS NOT NULL
AND login              IS NOT NULL
AND login              IN
  (SELECT login FROM sys_usr_config
  )
ORDER BY niveau DESC,
  login;
LOOP
  FETCH curentite1 INTO ventite, vgroupe_val, vlogin, vniv;
  EXIT
WHEN curentite1%NOTFOUND;
  IF (vnbfctrole=0) THEN
    RETURN vgroupe_val;
  END IF;
  SELECT COUNT(*)
  INTO vnbhab
  FROM SYS_USR_PROFIL UP,
    WKF_OP_ROLE WOR
  WHERE TO_CHAR(UP.CODE_PROFIL)=WOR.fct_role
  AND UP.LOGIN                 =vlogin
  AND wor.op_num               =p_opnum;
  IF (vnbhab                   >0) THEN
    RETURN vgroupe_val;
  END IF;
END LOOP;
CLOSE curentite1;
RETURN NULL;
END hrorg_get_groupe_valideur;
##
TAG_CHARSET=@€éèç
##
HRORG_GET_NUMPAC
=SQL=
CREATE OR REPLACE FUNCTION HRORG_GET_NUMPAC (
  p_codts        IN NUMBER,
  p_code_entite  IN VARCHAR2,
  p_date_eff     IN VARCHAR2,
  type_ent_ste IN VARCHAR2,
  type_ent_etb IN VARCHAR2,
  p_cid   IN std_struc_entite.cid%TYPE default null)
  RETURN VARCHAR2
IS
  numpac    VARCHAR2(700);
  numpacSte VARCHAR2(700);
  numpacEtb VARCHAR2(700);
  v_cid std_struc_entite.cid%TYPE;
BEGIN
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
  
  numpacSte := NULL;
  numpacEtb := NULL;
  for E in (with ENTITES (CODE_ENTITE, CODE_ENT_MERE, LIBELLE, TYPE_ENTITE, NUMPAC) as (
    select e.CODE_ENTITE, a.CODE_ENT_MERE, e.LIBELLE, e.TYPE_ENTITE, e.NUMPAC 
    from STD_STRUC_ENTITE e, STD_STRUC_ARBRE a 
    where
    a.cid = v_cid and e.cid = v_cid
    and e.CODE_ENTITE = p_code_entite and p_date_eff between e.DATE_EFF and e.DATE_FIN and e.CODE_ENTITE=a.CODE_ENTITE and a.CODTS = p_codts and p_date_eff between a.DATE_EFF and a.DATE_FIN and a.STATUT=1 
    union all 
    select e.CODE_ENTITE, a.CODE_ENT_MERE, e.LIBELLE, e.TYPE_ENTITE, e.NUMPAC 
    from STD_STRUC_ENTITE e, STD_STRUC_ARBRE a, ENTITES z 
    where
    a.cid = v_cid and e.cid = v_cid
    and e.CODE_ENTITE=z.CODE_ENT_MERE and p_date_eff between e.DATE_EFF and e.DATE_FIN and e.CODE_ENTITE=a.CODE_ENTITE and a.CODTS = p_codts and p_date_eff between a.DATE_EFF and a.DATE_FIN
  ) select CODE_ENTITE,LIBELLE,TYPE_ENTITE,NUMPAC from ENTITES)
  LOOP
    IF E.TYPE_ENTITE=type_ent_ste THEN
      numpacSte := E.NUMPAC;
    ELSIF E.TYPE_ENTITE=type_ent_etb THEN
      numpacEtb := E.NUMPAC;
    END IF;
  END LOOP;
  IF numpacEtb IS NOT NULL THEN
    numpac := numpacEtb;
  ELSIF numpacSte IS NOT NULL THEN
    numpac := numpacSte;
  ELSE
  	numpac := NULL;
  END IF;
  RETURN numpac;
END HRORG_GET_NUMPAC;
##
TAG_CHARSET=@€éèç
##
HRORG_IS_ENTITE_FILLE_HERITEE
=SQL=
CREATE OR REPLACE
  FUNCTION HRORG_IS_ENTITE_FILLE_HERITEE(
      p_codts  IN std_struc_arbre.codts%TYPE,
      p_entite IN std_struc_entite.code_entite%TYPE,
      p_date   IN std_struc_entite.date_eff%TYPE,
      p_cid   IN std_struc_entite.cid%TYPE default null)
    RETURN VARCHAR2
  IS
    v_lien_codts std_struc_type.lien_codts%TYPE;
    v_type_entite std_struc_entite.type_entite%TYPE;
    v_niveau std_struc_niv.niveau%TYPE;
    v_type_entite_fille std_struc_entite.type_entite%TYPE;
    v_count NUMBER;
    v_cid std_struc_entite.cid%TYPE;
  BEGIN
	  
	v_cid := p_cid;
  	IF (v_cid IS NULL) THEN
  		BEGIN
  			SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		EXCEPTION
  		WHEN NO_DATA_FOUND THEN
  			v_cid := null;
  		END;
  	END IF;
  	IF (v_cid IS NULL) THEN
  		-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  		RETURN 0;
  	END IF;
	  
    /* On vérifie que la structure hérite d'une autre structure */
    SELECT lien_codts INTO v_lien_codts FROM std_struc_type WHERE codts=p_codts;
    IF (v_lien_codts IS NULL) THEN
      RETURN '0';
    END IF;
    /* On récupère le type d'entité de l'entité */
    SELECT type_entite
    INTO v_type_entite
    FROM std_struc_entite
    WHERE code_entite=p_entite
   	AND cid = v_cid
    AND p_date BETWEEN date_eff AND date_fin;
    /* On récupère le niveau de l'entité dans la structure */
    SELECT niveau
    INTO v_niveau
    FROM std_struc_niv
    WHERE codts=p_codts
    AND p_date BETWEEN date_eff AND date_fin
    AND type_entite=v_type_entite;
    /* On récupère le type d'entité fille de l'entité */
    SELECT type_entite
    INTO v_type_entite_fille
    FROM std_struc_niv
    WHERE codts=p_codts
    AND p_date BETWEEN date_eff AND date_fin
    AND niveau=v_niveau+1;
    /* On regarde si le lien type entité <-> type entité fille existe (directement ou indirectement) dans la structure mère */
    SELECT COUNT(*)
    INTO v_count
    FROM std_struc_niv n1,
      std_struc_niv n2
    WHERE n1.codts    =v_lien_codts
    AND n1.type_entite=v_type_entite
    AND n2.codts      =v_lien_codts
    AND n2.type_entite=v_type_entite_fille
    AND n1.niveau     <n2.niveau
    AND p_date BETWEEN n1.date_eff AND n1.date_fin
    AND p_date BETWEEN n2.date_eff AND n2.date_fin;
    IF (v_count=0) THEN
      RETURN '0';
    END IF;
    RETURN '1';
  EXCEPTION
  WHEN OTHERS THEN
    RETURN '0' ;
  END HRORG_IS_ENTITE_FILLE_HERITEE ;
  ##
TAG_CHARSET=@€éèç
##
HRORG_IS_ENTITE_MERE_HERITEE
=SQL=
CREATE OR REPLACE
  FUNCTION HRORG_IS_ENTITE_MERE_HERITEE(
      p_codts  IN std_struc_arbre.codts%TYPE,
      p_entite IN std_struc_entite.code_entite%TYPE,
      p_date   IN std_struc_entite.date_eff%TYPE,
      p_cid   IN std_struc_entite.cid%TYPE default null)
    RETURN VARCHAR2
  IS
    v_lien_codts std_struc_type.lien_codts%TYPE;
    v_type_entite std_struc_entite.type_entite%TYPE;
    v_niveau std_struc_niv.niveau%TYPE;
    v_type_entite_mere std_struc_entite.type_entite%TYPE;
    v_count NUMBER;
    v_cid std_struc_entite.cid%TYPE;
  BEGIN
	  
	v_cid := p_cid;
  	IF (v_cid IS NULL) THEN
  		BEGIN
  			SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		EXCEPTION
  		WHEN NO_DATA_FOUND THEN
  			v_cid := null;
  		END;
  	END IF;
  	IF (v_cid IS NULL) THEN
  		-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  		RETURN 0;
  	END IF;
	
    /* On vérifie que la structure hérite d'une autre structure */
    SELECT lien_codts INTO v_lien_codts FROM std_struc_type WHERE codts=p_codts;
    IF (v_lien_codts IS NULL) THEN
      RETURN '0';
    END IF;
    /* On récupère le type d'entité de l'entité */
    SELECT type_entite
    INTO v_type_entite
    FROM std_struc_entite
    WHERE code_entite=p_entite
    AND cid = v_cid
    AND p_date BETWEEN date_eff AND date_fin;
    /* On récupère le niveau de l'entité dans la structure */
    SELECT niveau
    INTO v_niveau
    FROM std_struc_niv
    WHERE codts=p_codts
    AND p_date BETWEEN date_eff AND date_fin
    AND type_entite=v_type_entite;
    IF (v_niveau   =1) THEN
      /* On regarde si le type d'entité existe dans la structure mère */
      SELECT COUNT(*)
      INTO v_count
      FROM std_struc_niv
      WHERE codts    =v_lien_codts
      AND type_entite=v_type_entite
      AND p_date BETWEEN date_eff AND date_fin;
    ELSE
      /* On récupère le type d'entité mère de l'entité */
      SELECT type_entite
      INTO v_type_entite_mere
      FROM std_struc_niv
      WHERE codts=p_codts
      AND p_date BETWEEN date_eff AND date_fin
      AND niveau=v_niveau-1;
      /* On regarde si le lien type entité <-> type entité mère existe (directement ou indirectement) dans la structure mère */
      SELECT COUNT(*)
      INTO v_count
      FROM std_struc_niv n1,
        std_struc_niv n2
      WHERE n1.codts    =v_lien_codts
      AND n1.type_entite=v_type_entite_mere
      AND n2.codts      =v_lien_codts
      AND n2.type_entite=v_type_entite
      AND n1.niveau     <n2.niveau
      AND p_date BETWEEN n1.date_eff AND n1.date_fin
      AND p_date BETWEEN n2.date_eff AND n2.date_fin;
    END IF;
    IF (v_count=0) THEN
      RETURN '0';
    END IF;
    RETURN '1';
  EXCEPTION
  WHEN OTHERS THEN
    RETURN '0' ;
  END HRORG_IS_ENTITE_MERE_HERITEE ;
  ##
HRORG_NIV_MERE_AFFEC_HERITAGE
=SQL=
CREATE OR REPLACE
  FUNCTION HRORG_NIV_MERE_AFFEC_HERITAGE(
      p_codts IN std_struc_arbre.codts%TYPE,
      p_date  IN std_struc_entite.date_eff%TYPE)
    RETURN VARCHAR2
  IS
    v_lien_codts std_struc_type.lien_codts%TYPE;
    v_type_entite std_struc_entite.type_entite%TYPE;
    v_niveau NUMBER;
  BEGIN
    /* On vérifie que la structure hérite d'une autre structure */
    SELECT lien_codts INTO v_lien_codts FROM std_struc_type WHERE codts =p_codts;
    IF (v_lien_codts IS NULL) THEN
      RETURN '0';
    END IF;
    /* On récupère le type d'entité le plus bas dans l'organisation des niveaux */
    SELECT type_entite
    INTO v_type_entite
    FROM std_struc_niv
    WHERE codts=p_codts
    AND niveau =
      (SELECT MAX(niveau) FROM std_struc_niv WHERE codts=p_codts
      );
    /* On regarde si le type entité est utilisé dans l'organisation des niveaux de la structure mère */
    SELECT niveau
    INTO v_niveau
    FROM std_struc_niv
    WHERE codts    =v_lien_codts
    AND type_entite=v_type_entite
    AND p_date BETWEEN date_eff AND date_fin ;
    IF (v_niveau IS NULL) THEN
      RETURN '0';
    END IF;
    RETURN v_niveau;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN '0' ;
  END HRORG_NIV_MERE_AFFEC_HERITAGE ;
  ##
TAG_CHARSET=@€éèç
##
HRORG_RESP
=SQL=
CREATE OR REPLACE
  FUNCTION HRORG_RESP(
      p_matric IN secumatric.matric%TYPE,
      p_date   IN std_struc_entite.date_eff%TYPE,
      p_cid   IN std_struc_entite.cid%TYPE default null)
    RETURN std_struc_entite.matric_resp%TYPE
  IS
    v_retour std_struc_arbre.matric_resp%TYPE;
    v_cid std_struc_entite.cid%TYPE;
  BEGIN
	  
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
	  
    /* Regarde le codts hierachique */
    SELECT HRORG_RESP_CODTS(codts,p_matric,p_date, v_cid)
    INTO v_retour
    FROM std_struc_type
    WHERE critere_hierarchique =1 ;
    RETURN v_retour ;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
  END HRORG_RESP ; 
  ##
TAG_CHARSET=@€éèç
##
HRORG_RESP_CODTS
=SQL=
CREATE OR REPLACE
FUNCTION HRORG_RESP_CODTS(
  p_codts  IN std_struc_arbre.codts%TYPE,
  p_matric IN VARCHAR2,
  p_date   IN std_struc_entite.date_eff%TYPE,
  p_cid    IN std_struc_entite.cid%TYPE default null)
RETURN std_struc_entite.matric_resp%TYPE
IS
  v_matricPrincipal secumatric.matric%TYPE;
  v_retour std_struc_arbre.matric_resp%TYPE;
  v_nomcolsecumatric std_struc_type.NOMCOL_SECUMATRIC%TYPE ;
  v_nomcoletat_civ std_struc_type.nomcol_etat_civ%TYPE ;
  v_matricdefaut std_struc_type.matric_resp%TYPE ;
  v_entite std_struc_entite.code_entite%TYPE ;
  v_req VARCHAR2(500);
  v_nbParam NUMBER;
  v_cid std_struc_entite.cid%TYPE;
BEGIN
	
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;	

  v_matricPrincipal             := p_matric;
  IF INSTR(v_matricPrincipal,',')>0 THEN
    v_matricPrincipal           := SUBSTR(v_matricPrincipal,1,INSTR(v_matricPrincipal,',')-1);
  END IF;
  SELECT NOMCOL_SECUMATRIC,
    nomcol_etat_civ,
    matric_resp
  INTO v_nomcolsecumatric,
    v_nomcoletat_civ,
    v_matricdefaut
  FROM std_struc_type
  WHERE codts=p_codts ;
  v_nbParam := 1;
  IF (v_nomcolsecumatric IS NOT NULL) THEN
    v_req := 'SELECT '||v_nomcolsecumatric||' FROM SECUMATRIC WHERE MATRIC = :1';
  ELSE
    IF (v_nomcoletat_civ IS NOT NULL) THEN
      v_req := 'SELECT '||v_nomcoletat_civ||' FROM ETAT_CIV WHERE MATRIC = :1';
    ELSE
      -- TODO VRI : ZEU FE, il faudra gérer le CID lors du traitement de cette partie utilisé v_cid
      v_req := 'SELECT CODE_ENTITE FROM STD_STRUC_AFFECTATION WHERE MATRIC = :1 AND :2 BETWEEN DATE_EFF AND DATE_FIN AND NOT CODE_ENTITE=''@NON_AFFECTE@'' AND CODTS = :3' ;
      v_nbParam := 3;
    END IF;
  END IF;
  BEGIN
    IF v_nbParam=1 THEN
      EXECUTE IMMEDIATE v_req INTO v_entite USING v_matricPrincipal ;
    ELSE
      EXECUTE IMMEDIATE v_req INTO v_entite USING v_matricPrincipal, p_date, p_codts ;
    END IF;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    v_entite := NULL;
  END ;
  IF (v_entite IS NOT NULL) THEN
    v_retour   := HRORG_RESP_ENTITE(p_codts, v_entite, p_date, 0, p_matric, v_cid);
  END IF ;
  RETURN v_retour ;
EXCEPTION
  WHEN OTHERS THEN
  IF(v_matricdefaut <> v_matricPrincipal) THEN
    RETURN v_matricdefaut ;
  END IF ;
  RETURN NULL;
END HRORG_RESP_CODTS ; 
##
TAG_CHARSET=@€éèç
##
HRORG_RESP_ENTITE
=SQL=
create or replace FUNCTION HRORG_RESP_ENTITE(
    p_codts          IN std_struc_arbre.codts%TYPE,
    p_codeEntite     IN std_struc_arbre.code_entite%TYPE,
    p_date           IN std_struc_entite.date_eff%TYPE,
    p_avecUsrExterne IN INT,                    -- 0 : on ne retourne que les salariés, 1 : on retourne les responsables user externe
    p_matric         IN VARCHAR2, -- peut être null
    p_cid   IN std_struc_arbre.cid%TYPE default null)
  RETURN std_struc_entite.matric_resp%TYPE
IS
  v_matricPrincipal secumatric.matric%TYPE;
  v_retour std_struc_arbre.login_resp%TYPE;
  v_matricResp std_struc_arbre.matric_resp%TYPE;
  v_reqSelectMatricResp VARCHAR2(4000);
  v_matricRespSuppOuRemp VARCHAR2(4000);
  v_matricRespRemp VARCHAR2(4000);
  v_listMatricRespSuppOuRemp VARCHAR2(4000);
  v_loginResp std_struc_arbre.login_resp%TYPE;
  v_req VARCHAR2(4000);
  v_withMatric BOOLEAN;
  v_cid std_struc_arbre.cid%TYPE;
BEGIN
  
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
	
  -- p_matric peut être de la forme :
  -- - 'XXXXXXX'
  -- - 'XXXXXXX,YYYYYYY,ZZZZZZZ'
  -- - 'XXXXXXX,YYYYYYY-->ZZZZZZZ,AAAAAAA-->BBBBBBB'
  -- Le premier matricule (XXXXXXX) est le matricule principal (à ne pas retourner)
  -- Les matricules suivants doivent être considérés comme supprimés (si seul) / remplacés (si '-->')
  v_matricPrincipal             := p_matric;
  IF INSTR(v_matricPrincipal,',')>0 THEN
    v_matricPrincipal           := SUBSTR(v_matricPrincipal,1,INSTR(v_matricPrincipal,',')-1);
  END IF;
  v_withMatric := false;
  v_reqSelectMatricResp := 'matric_resp';
  IF p_matric IS NOT NULL AND NOT v_matricPrincipal = p_matric THEN
    v_listMatricRespSuppOuRemp := SUBSTR(p_matric,INSTR(p_matric,',')+1);
    LOOP
      IF INSTR(v_listMatricRespSuppOuRemp,',')>0 THEN
        v_matricRespSuppOuRemp := SUBSTR(v_listMatricRespSuppOuRemp,1,INSTR(v_listMatricRespSuppOuRemp,',')-1);
        v_listMatricRespSuppOuRemp := SUBSTR(v_listMatricRespSuppOuRemp,INSTR(v_listMatricRespSuppOuRemp,',')+1);
      ELSE
        v_matricRespSuppOuRemp := v_listMatricRespSuppOuRemp;
        v_listMatricRespSuppOuRemp := NULL;
      END IF;
      IF INSTR(v_matricRespSuppOuRemp,'-->')>0 THEN
        v_matricRespRemp := ''''||SUBSTR(v_matricRespSuppOuRemp,INSTR(v_matricRespSuppOuRemp,'-->')+3)||'''';
        v_matricRespSuppOuRemp := SUBSTR(v_matricRespSuppOuRemp,1,INSTR(v_matricRespSuppOuRemp,'-->')-1);
      ELSE
        v_matricRespRemp := 'NULL';
      END IF;
      v_reqSelectMatricResp := 'REPLACE('||v_reqSelectMatricResp||','''||v_matricRespSuppOuRemp||''','||v_matricRespRemp||')';
      EXIT WHEN v_listMatricRespSuppOuRemp IS NULL;
    END LOOP;
  END IF;
  -- Recherche du responsable sur la branche de l'arbre  
  v_req := 'SELECT matric_resp, login_resp';
  v_req := v_req||' FROM (';
  v_req := v_req||'   SELECT code_entite, code_ent_mere, codTs, '||v_reqSelectMatricResp||' as matric_resp, login_resp';  
  v_req := v_req||'   FROM std_struc_arbre';
  v_req := v_req||'   START WITH'; 
  v_req := v_req||'     code_entite = :1'; 
  v_req := v_req||'     AND codTs = :2';
  v_req := v_req||'     AND :3 BETWEEN date_eff AND date_fin';
  v_req := v_req||'     AND cid = :4';
  v_req := v_req||'     AND statut = ''1'''; 
  v_req := v_req||'   CONNECT BY'; 
  v_req := v_req||'   PRIOR code_ent_mere = code_entite';
  v_req := v_req||'   AND PRIOR codTs = codTs';
  v_req := v_req||'   AND PRIOR cid = cid';
  v_req := v_req||'   AND :5 BETWEEN date_eff AND date_fin';
  v_req := v_req||')'; 
  v_req := v_req||' WHERE';
  v_req := v_req||'   1=1';
  IF p_avecUsrExterne = 0 THEN
    v_req := v_req||'    AND matric_resp IS NOT NULL';
  ELSE
    v_req := v_req||'   AND (matric_resp IS NOT NULL';
    v_req := v_req||'   OR';
    v_req := v_req||'   login_resp IS NOT NULL)';
  END IF;
  IF(p_matric IS NOT NULL) THEN
    v_withMatric := true;
    v_req := v_req||' AND NVL(matric_resp,''*'') != :6 ';
  END IF;
  v_req := v_req||'   AND ROWNUM = 1';
  
  BEGIN
    IF v_withMatric THEN
      EXECUTE IMMEDIATE v_req INTO v_matricResp, v_loginResp USING p_codeEntite, p_codts, p_date, v_cid, p_date,  v_matricPrincipal;
    ELSE
      EXECUTE IMMEDIATE v_req INTO v_matricResp, v_loginResp USING p_codeEntite, p_codts, p_date, v_cid, p_date;
    END IF;
    
    IF v_loginResp IS NOT NULL AND p_avecUsrExterne = 1 THEN
      v_retour := v_loginResp;
    ELSE
      v_retour := v_matricResp;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_retour := NULL;
  END;
  
-- Recherche du responsable sur l'entité
IF( v_retour  IS NULL ) THEN
  v_req       := 'SELECT matric_resp, login_resp';
  v_req       := v_req||' FROM std_struc_entite';
  v_req       := v_req||' WHERE';
  v_req       := v_req||'   code_entite = '''||p_codeEntite||'''';
  v_req       := v_req||'   and cid = '''||v_cid||'''';
  v_req       := v_req||'   AND '''||p_date||''' BETWEEN date_eff AND date_fin';
  IF(p_matric IS NOT NULL) THEN
    v_req     := v_req||'   AND matric_resp <> '''||v_matricPrincipal||'''';
  END IF;

  BEGIN
    EXECUTE IMMEDIATE v_req INTO v_matricResp, v_loginResp;
    IF v_loginResp IS NOT NULL AND p_avecUsrExterne = 1 THEN
      v_retour     := v_loginResp;
    ELSE
      v_retour := v_matricResp;
    END IF;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    v_retour := NULL;
  END;
END IF ;

-- Rechercher du responsable sur la structure
IF( v_retour IS NULL) THEN
  SELECT matric_resp,
    login_resp
  INTO v_matricResp,
    v_loginResp
  FROM std_struc_type
  WHERE codts     = p_codts ;
  IF v_loginResp IS NOT NULL AND p_avecUsrExterne = 1 THEN
    v_retour     := v_loginResp;
  ELSE
    v_retour := v_matricResp;
  END IF;
  IF(p_matric IS NOT NULL AND v_matricPrincipal = v_retour ) THEN
    v_retour  := NULL;
  END IF;
END IF;
RETURN v_retour ;
EXCEPTION
WHEN OTHERS THEN
  DBMS_OUTPUT.put_line('Exception ' || SQLCODE || ' - ' || SQLERRM);
  RETURN NULL;
END HRORG_RESP_ENTITE ;
##
TAG_CHARSET=@€éèç
##
HRORG_SECU 
=SQL=
CREATE OR REPLACE FUNCTION "HRORG_SECU"(
    p_codts       IN std_struc_arbre.codts%TYPE,
    p_type_entite IN std_struc_entite.type_entite%TYPE,
    p_entite      IN std_struc_entite.code_entite%TYPE,
    p_date        IN std_struc_entite.date_eff%TYPE,
    p_cid         IN std_struc_entite.cid%TYPE default null)
  RETURN std_struc_entite.code_entite%TYPE
IS
  v_retour VARCHAR2(25);
  v_typent std_struc_entite.type_entite%TYPE;
  v_cid std_struc_entite.cid%TYPE;
BEGIN
	
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
	
  SELECT TYPE_ENTITE
  INTO v_typent
  FROM STD_STRUC_ENTITE
  WHERE CODE_ENTITE = p_entite
  AND CID = v_cid
  AND p_date BETWEEN date_eff AND date_fin;
  
  IF v_typent = p_type_entite THEN
    RETURN p_entite;
  END IF;
  /* lecture du type d'entité */
  SELECT code_entite
  INTO v_retour
  FROM
    ( WITH entitepere ( code_entite, code_ent_mere ) AS
    (SELECT a.code_entite,
      a.code_ent_mere
    FROM std_struc_arbre a
    WHERE a.code_entite =p_entite
    AND a.cid         = v_cid
    AND a.codts         =p_codts
    AND p_date BETWEEN a.date_eff AND a.date_fin
    AND statut = '1'
    UNION ALL
    SELECT a.code_entite,
      a.code_ent_mere
    FROM std_struc_arbre a,
      entitepere f
    WHERE f.code_ent_mere = a.code_entite
    AND a.cid = v_cid
    AND a.codts           =p_codts
    AND p_date BETWEEN a.date_eff AND a.date_fin
    AND statut = '1'
    )
  SELECT a.code_entite
  FROM entitepere a,
    std_struc_entite e
  WHERE a.code_entite = e.code_entite
  AND e.cid = v_cid
  AND e.type_entite   = p_type_entite
  AND p_date BETWEEN e.date_eff AND e.date_fin
  /* En cas d'occurrences multiples, il est possible d'avoir plusieurs lignes en retour, on retourne alors la première ligne (qui correspond au niveau le plus bas correspondant au type d'entité) */
  AND ROWNUM = 1
    ) ;
  --DBMS_OUTPUT.PUT_LINE('v_retour ' || v_retour);
  --FIXME utiliser la procédure trace_dbms_output()
  RETURN v_retour ;
EXCEPTION
WHEN OTHERS THEN
  --DBMS_OUTPUT.PUT_LINE('v_retour ');
  --FIXME utiliser la procédure trace_dbms_output()
  RETURN NULL ;
END HRORG_SECU ;
##
TAG_CHARSET=@€éèç
##
HRORG_SECU_OPTI
=SQL=
CREATE OR REPLACE FUNCTION HRORG_SECU_OPTI(
  p_codts       IN std_struc_arbre.codts%TYPE,
  p_type_entite IN std_struc_entite.type_entite%TYPE,
  p_entite      IN std_struc_entite.code_entite%TYPE,
  p_date        IN std_struc_entite.date_eff%TYPE,
  p_clauseWhere IN VARCHAR2,
  p_cid   IN std_struc_entite.cid%TYPE default null)
RETURN INTEGER
IS
  v_req              VARCHAR2(4000);
  TYPE CODE_ENTITE_ROW IS TABLE OF std_struc_entite.code_entite%TYPE;
  tab_entitesRecherchees CODE_ENTITE_ROW;
  v_tmpEntite std_struc_entite.code_entite%TYPE;
  v_niveauTypeEntite std_struc_niv.niveau%TYPE;
  v_nbOccTypeEntite std_struc_niv_info.nb_occurrences%TYPE;
  v_retour           INTEGER;
  v_cid std_struc_entite.cid%TYPE;
BEGIN
	
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN -1;
  END IF;
	
  IF p_codts IS NULL OR p_type_entite IS NULL OR p_date IS NULL THEN
    RETURN -1;
  END IF;
  IF p_clauseWhere IS NULL THEN
    RETURN 1;
  END IF;
  IF p_entite IS NOT NULL THEN
    v_req := 'SELECT count(*)
      FROM STD_STRUC_ENTITE
      WHERE CODE_ENTITE = :1
      AND :2 BETWEEN date_eff AND date_fin
      AND TYPE_ENTITE = :3
      AND CID = :4
      AND CODE_ENTITE '||p_clauseWhere;
    EXECUTE immediate v_req INTO v_retour USING p_entite,p_date,p_type_entite, v_cid ;
    IF v_retour>0 THEN
      RETURN 1;
    END IF;
    v_req := 'select n.niveau, ni.nb_occurrences from std_struc_niv n, std_struc_niv_info ni where n.codts=ni.codts and n.type_entite=ni.type_entite and :1 between n.date_eff and n.date_fin and n.codts=:2 and n.type_entite=:3';
    EXECUTE immediate v_req INTO v_niveauTypeEntite, v_nbOccTypeEntite USING p_date,p_codts,p_type_entite;
    IF v_niveauTypeEntite IS NOT NULL AND v_niveauTypeEntite>0 THEN
      IF v_nbOccTypeEntite IS NULL THEN
        v_nbOccTypeEntite := 1;
      END IF;
      v_req := '';
      FOR i IN 0..v_nbOccTypeEntite-1 LOOP
        IF i>0 THEN
          v_req := v_req||' union all ';
        END IF;
         v_req := v_req||' select niv'||(v_niveauTypeEntite+i)||' as code_entite from std_struc_index where cid = '||v_cid||' and '''||p_date||''' between date_eff and date_fin and codts='||p_codts||' and last_entite='''||p_entite||''' and niv'||(v_niveauTypeEntite+i)||' is not null ';
      END LOOP;
      --DBMS_OUTPUT.PUT_LINE(v_req);
      --FIXME utiliser la procédure trace_dbms_output()
      EXECUTE immediate v_req bulk collect INTO tab_entitesRecherchees;
    END IF;
  END IF;
  IF NOT tab_entitesRecherchees.exists(1) AND NOT INSTR(p_clauseWhere,' NULL')=0 THEN
    v_req := 'SELECT count(*)
      FROM DUAL
      WHERE '''' '||p_clauseWhere;
    EXECUTE immediate v_req INTO v_retour;
  ELSE
    v_req := 'SELECT count(*)
      FROM DUAL
      WHERE :1 '||p_clauseWhere;
    IF NOT tab_entitesRecherchees.exists(1) THEN
      v_tmpEntite := '@VIDE@';
      EXECUTE immediate v_req INTO v_retour USING v_tmpEntite;
    ELSE
      FOR i IN tab_entitesRecherchees.first..tab_entitesRecherchees.last LOOP 
        EXIT WHEN v_retour>0;
        EXECUTE immediate v_req INTO v_retour USING tab_entitesRecherchees(i);
      END LOOP;
    END IF;
  END IF;
  RETURN v_retour ;
EXCEPTION
  WHEN OTHERS THEN RETURN -99 ;
END HRORG_SECU_OPTI;
##
TAG_CHARSET=@€éèç
##
HRORG_SIGNATAIRE_ENTITE
=SQL=
create or replace FUNCTION HRORG_SIGNATAIRE_ENTITE(
    p_codts          IN std_struc_arbre.codts%TYPE,
    p_codeEntite     IN std_struc_arbre.code_entite%TYPE,
    p_date           IN std_struc_entite.date_eff%TYPE)
  RETURN std_struc_arbre.aoid_signataire%TYPE
IS
  v_retour std_struc_arbre.aoid_signataire%TYPE;
  v_req VARCHAR2(4000);
BEGIN
 -- Recherche du signataire sur la branche de l'arbre  
  v_req := 'SELECT aoid_signataire';
  v_req := v_req||' FROM (';
  v_req := v_req||'   SELECT code_entite, code_ent_mere, codTs, aoid_signataire';  
  v_req := v_req||'   FROM std_struc_arbre';
  v_req := v_req||'   START WITH'; 
  v_req := v_req||'     code_entite = :1'; 
  v_req := v_req||'     AND codTs = :2';
  v_req := v_req||'     AND :3 BETWEEN date_eff AND date_fin';
  v_req := v_req||'     AND statut = ''1'''; 
  v_req := v_req||'   CONNECT BY'; 
  v_req := v_req||'   PRIOR code_ent_mere = code_entite';
  v_req := v_req||'   AND PRIOR codTs = codTs';
  v_req := v_req||'   AND :4 BETWEEN date_eff AND date_fin';
  v_req := v_req||')'; 
  v_req := v_req||' WHERE';
  v_req := v_req||'   1=1';
  v_req := v_req||'   AND aoid_signataire IS NOT NULL';
  v_req := v_req||'   AND ROWNUM = 1';
  
  BEGIN
    EXECUTE IMMEDIATE v_req INTO v_retour USING p_codeEntite, p_codts, p_date, p_date;
    
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_retour := '';
  END;
  RETURN v_retour;
END;
##
HRORG_SIGNATAIRE_ENTITE
=SQL=
drop function HRORG_SIGNATAIRE_ENTITE
##
HRO_CODTS
=SQL=
CREATE OR REPLACE
  FUNCTION HRO_CODTS(
      p_position IN NUMBER )
    RETURN VARCHAR2
  IS
    valvar      VARCHAR2(25);
    res         VARCHAR2(25);
    start_index NUMBER;
    end_index   NUMBER;
  BEGIN
    SELECT valvar
    INTO valvar
    FROM sys_varsys
    WHERE codvar  ='HREXTR_CODTS'
    AND module    ='HRO';
    IF p_position = 0 THEN
      RETURN NULL;
    END IF ;
    IF p_position = 1 THEN
      end_index  := instr(valvar,',',1,p_position)-1;
      res        := SUBSTR (valvar,0,end_index);
    ELSE
      start_index := instr(valvar,',',1,p_position-1)+1;
      end_index   := instr(valvar,',',1,p_position );
      IF end_index = 0 THEN
        end_index := LENGTH(valvar);
        res       := SUBSTR (valvar,start_index,end_index+1-start_index);
      ELSE
        res := SUBSTR (valvar,start_index,end_index-start_index);
      END IF ;
    END IF;
    IF instr(res,',',1,1) > 0 THEN
      RETURN NULL;
    END IF ;
    RETURN res;
  END HRO_CODTS;
  ##
TAG_CHARSET=@€éèç
##
HRO_GET_ENTITE
=SQL=
CREATE OR REPLACE FUNCTION HRO_GET_ENTITE(
    p_codts  IN std_struc_arbre.codts%TYPE,
    p_niv    IN std_struc_niv.niveau%TYPE,
    p_entite IN std_struc_entite.code_entite%TYPE,
    p_date   IN std_struc_entite.date_eff%TYPE,
    p_cid    IN std_struc_entite.cid%TYPE default null)
  RETURN std_struc_entite.code_entite%TYPE
IS
  v_cid std_struc_entite.cid%TYPE;
  v_retour VARCHAR2(25);
BEGIN
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN null;
  END IF;
	
	
	
  SELECT code_entite
  INTO v_retour
  FROM
    ( WITH entitepere ( code_entite, code_ent_mere, codts ) AS
    (SELECT a.code_entite,
      a.code_ent_mere,
      a.codts
    FROM std_struc_arbre a
    WHERE a.code_entite =p_entite
    AND a.cid = v_cid
    AND a.codts         =p_codts
    AND p_date BETWEEN a.date_eff AND a.date_fin
    AND statut = '1'
    UNION ALL
    SELECT a.code_entite,
      a.code_ent_mere,
      a.codts
    FROM std_struc_arbre a,
      entitepere f
    WHERE f.code_ent_mere = a.code_entite
    AND a.cid = v_cid
    AND a.codts           =p_codts
    AND p_date BETWEEN a.date_eff AND a.date_fin
    AND statut = '1'
    )
  SELECT a.code_entite
  FROM entitepere a,
    std_struc_entite e,
  	std_struc_index idx
  WHERE a.code_entite = e.code_entite
  AND e.cid = v_cid
  AND idx.cid = v_cid
  AND a.codts = idx.codts 
  AND a.code_entite = idx.last_entite
  AND p_date BETWEEN e.date_eff AND e.date_fin
  AND p_date BETWEEN idx.date_eff AND idx.date_fin
  AND idx.niv_tech = p_niv
    ) ;
  RETURN v_retour ;
END HRO_GET_ENTITE;
##
HR_GET_CATEGORIE
=SQL=
CREATE OR REPLACE
  FUNCTION HR_GET_CATEGORIE(
      anplan       IN VARCHAR2,
      code_interne IN NUMBER,
      type_info    IN VARCHAR2)
    RETURN VARCHAR2
  IS
    anPlanCateg VARCHAR2(4);
    ModeCateg   VARCHAR2(15);
    retour      VARCHAR2(200);
  BEGIN
    SELECT valvar
    INTO anPlanCateg
    FROM sys_varsys
    WHERE module='FOR'
    AND codvar  ='CATEGORIE_ANPLAN';
    IF (anplan IS NULL OR anPlanCateg IS NULL) THEN
      SELECT valvar
      INTO ModeCateg
      FROM sys_varsys
      WHERE module='FOR'
      AND codvar  ='CATEGORIE_MODE';
    ELSE
      IF (anplan  < anPlanCateg) THEN
        ModeCateg:='LEG2004';
      ELSE
        SELECT valvar
        INTO ModeCateg
        FROM sys_varsys
        WHERE module='FOR'
        AND codvar  ='CATEGORIE_MODE';
      END IF;
    END IF;
    IF (ModeCateg IS NULL) THEN
      ModeCateg   :='LEG2004';
    END IF;
    IF (type_info IS NULL OR type_info='CODE_CATEGORIE' OR type_info='CODE') THEN
      SELECT CODE_CATEGORIE
      INTO retour
      FROM FOR_CATEGORIE
      WHERE ID_INTERNE=code_interne
      AND LEGAL       =ModeCateg;
    END IF;
    IF (type_info='LIBELLE_CATEGORIE' OR type_info='LIBELLE') THEN
      SELECT LIBELLE_CATEGORIE
      INTO retour
      FROM FOR_CATEGORIE
      WHERE ID_INTERNE=code_interne
      AND LEGAL       =ModeCateg;
    END IF;
    IF (type_info='LIBCOURT_CATEGORIE' OR type_info='LIBCOURT') THEN
      SELECT LIBCOURT_CATEGORIE
      INTO retour
      FROM FOR_CATEGORIE
      WHERE ID_INTERNE=code_interne
      AND LEGAL       =ModeCateg;
    END IF;
    RETURN retour;
  END; 
  ##
HR_LINEARISE_ANIMATEUR
=SQL=
CREATE OR REPLACE
  FUNCTION HR_LINEARISE_ANIMATEUR(
      pcodfor IN VARCHAR2,
      pcodses IN VARCHAR2,
      poccseq IN VARCHAR2,
      sep     IN VARCHAR2 )
    RETURN VARCHAR2
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
  BEGIN
    OPEN cur FOR SELECT '- '||I.nomfam||' '||I.prenom||' de '||O.nomorg||' ('||NVL(DOM_EXPERTISE,'Domaine non renseigné')||')' FROM interloc I,animseq A, ORG O WHERE O.codorg = I.codOrg AND I.codorg = A.codorg AND I.occinloc = A.occinloc AND codfor= pcodfor AND codses = pcodses AND occseq = poccseq
    UNION ALL
  SELECT '- '
    ||E.nom
    ||' '
    ||E.prenom
    ||'('
    || NVL(DOM_EXPERTISE,'Domaine non renseigné')
    || ')'
  FROM SECUMATRIC E
  INNER JOIN animseq A
  ON A.matric = E.matric
  LEFT OUTER JOIN for_hfteint f
  ON f.matric = E.matric
  INNER JOIN for_ses s
  ON A.codfor    = s.codfor
  AND A.codses   = s.codses
  WHERE A.codfor = pcodfor
  AND A.codses   = pcodses
  AND A.codact   = '*'
  AND A.occseq   = poccseq
  AND s.jdeb BETWEEN f.datdeb AND NVL(f.datfin,'20990101')
  AND F.typp <>'4'
  ORDER BY 1 ASC ;
  LOOP
    FETCH cur INTO retourselect;
    EXIT
  WHEN cur % NOTFOUND;
    retour := retour||retourselect||sep;
  END LOOP ;
  CLOSE cur;
  RETURN '<br>'||SUBSTR(retour, 0, LENGTH(retour)-LENGTH(sep));
END;
##
HR_LINEARISE_PARTICIPANTABSENT
=SQL=
CREATE OR REPLACE
  FUNCTION HR_LINEARISE_PARTICIPANTABSENT(
      pcodfor IN VARCHAR2,
      pcodses IN VARCHAR2,
      poccseq IN VARCHAR2,
      sep     IN VARCHAR2 )
    RETURN VARCHAR2
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
  BEGIN
    OPEN cur FOR SELECT '&nbsp;'||SECUMATRIC.NOM||' '||SECUMATRIC.PRENOM FROM SECUMATRIC, FOR_SEQNSUIV F WHERE SECUMATRIC.matric = F.matric AND codfor = pcodfor AND codses = pcodses AND occseq = poccseq
    UNION ALL
  SELECT '&nbsp;'
    ||FOR_EXT_AGT.nomfam
    ||' '
    ||FOR_EXT_AGT.prenom
  FROM FOR_EXT_AGT,
    FOR_SEQNSUIV F
  WHERE FOR_EXT_AGT.matric = F.matric
  AND codfor               = pcodfor
  AND codses               = pcodses
  AND occseq               = poccseq
  ORDER BY 1 ASC ;
  LOOP
    FETCH cur INTO retourselect;
    EXIT
  WHEN cur % NOTFOUND;
    retour := retour || retourselect || sep;
  END LOOP ;
  CLOSE cur;
  RETURN SUBSTR(retour, 0, LENGTH(retour)-LENGTH(sep));
END; 
##
HR_LINEARISE_SEQUENCE
=SQL=
CREATE OR REPLACE
  FUNCTION HR_LINEARISE_SEQUENCE(
      pcodfor IN VARCHAR2,
      pcodses IN VARCHAR2,
      poccseq IN VARCHAR2,
      sep     IN VARCHAR2 )
    RETURN VARCHAR2
  IS
    retour CLOB;
    v_libfor      VARCHAR2(150);
    v_dateseq     VARCHAR2(150);
    v_nomsal      VARCHAR2(50);
    v_codsal      VARCHAR2(50);
    v_lieu        VARCHAR2(250);
    v_anim        VARCHAR2(250);
    v_participant VARCHAR2(512);
    v_objectif    VARCHAR2(512);
    v_contexte    VARCHAR2(512);
    v_description VARCHAR2(512);
    v_costcenter  VARCHAR2(250);
    nb            INTEGER ;
  BEGIN
    SELECT 'Module '
      ||libfor
      ||' ('
      ||codfor
      ||')'
    INTO v_libfor
    FROM for_form
    WHERE for_form.codfor=pcodfor;
    retour              := sep || sep || v_libfor;
    SELECT sq.codsal,
      'Du '
      ||TO_CHAR(to_date(SQ.JDEB,'yyyymmdd'),'dd.mm.yyyy')
      ||' au '
      ||TO_CHAR(to_date(SQ.JFIN,'yyyymmdd'),'dd.mm.yyyy')
      ||' de '
      ||SUBSTR(SQ.HDEB,1,2)
      ||'h'
      ||SUBSTR(SQ.HDEB,3,2)
      ||' à '
      ||SUBSTR(SQ.HFIN,1,2)
      ||'h'
      ||SUBSTR(SQ.HFIN,3,2)
    INTO v_codsal,
      v_dateseq
    FROM seqses sq
    WHERE sq.codfor =pcodfor
    AND sq.codses   =pcodses
    AND sq.occseq   = poccseq ;
    retour         := retour || sep || v_dateseq ;
    IF v_codsal    IS NULL THEN
      retour       := retour || sep ||'Pas de Salle';
    ELSE
      SELECT Sl.NOMSAL
      INTO v_nomsal
      FROM salfor sl,
        seqses sq
      WHERE sl.codsal = sq.codsal
      AND sq.codfor   =pcodfor
      AND sq.codses   =pcodses
      AND sq.occseq   = poccseq ;
      retour         := retour || sep || 'Salle : '||v_nomsal;
      SELECT 'Lieu : '
        ||
        ( SELECT nomorg FROM org WHERE ORG.CODORG = SQ.CODORG
        UNION
        SELECT liblieuint
        FROM for_lieu_int
        WHERE for_lieu_int.CODLIEUINT=SQ.CODLIEUINT
        )
        ||' '
        ||
        (SELECT numv
          ||' '
          ||btq.lib
          ||' '
          ||typvoie.lib
          ||' '
          ||nomv
          ||' '
          ||cp
          ||' '
          ||com
        FROM org,
          btq,
          typvoie
        WHERE ORG.CODORG   =SQ.CODORG
        AND btq.cod (+)    = org.btq
        AND typvoie.cod (+)= org.typv
        UNION
        SELECT numvlieuint
          ||' '
          ||btq.lib
          ||' '
          ||typvoie.lib
          ||' '
          ||nomvlieuint
          ||' '
          ||cplieuint
          ||' '
          ||comlieuint
        FROM for_lieu_int,
          btq,
          typvoie
        WHERE for_lieu_int.CODLIEUINT = SQ.CODLIEUINT
        AND btq.cod (+)               = for_lieu_int.btqlieuint
        AND typvoie.cod (+)           = for_lieu_int.typvlieuint
        )
      INTO v_lieu
      FROM seqses sq
      WHERE sq.codfor =pcodfor
      AND sq.codses   =pcodses
      AND sq.occseq   = poccseq ;
      retour         := retour || sep || v_lieu;
    END IF;
    SELECT HR_LINEARISE_ANIMATEUR(SQ.CODFOR,SQ.CODSES,SQ.OCCSEQ,' ')
    INTO v_anim
    FROM seqses sq
    WHERE sq.codfor =pcodfor
    AND sq.codses   =pcodses
    AND sq.occseq   = poccseq ;
    retour         := retour || sep ||'Animateur(s) :'|| v_anim ;
    SELECT HR_LINEARISE_PARTICIPANTABSENT(SQ.CODFOR,SQ.CODSES,SQ.OCCSEQ,' ')
    INTO v_participant
    FROM seqses sq
    WHERE sq.codfor =pcodfor
    AND sq.codses   =pcodses
    AND sq.occseq   = poccseq ;
    retour         := retour || sep ||'Participant(s) : Tous à l''exception de :'|| v_participant ;
    SELECT COUNT(*)
    INTO nb
    FROM FOR_DESCRI
    WHERE codfor = pcodfor
    AND coddesc  ='03';
    IF nb        > 0 THEN
      SELECT ( TO_CHAR(TXT))
      INTO v_contexte
      FROM FOR_DESCRI
      WHERE codfor = pcodfor
      AND coddesc  ='03';
      retour      := retour || sep || 'Contexte: ' || v_contexte;
    ELSE
      retour := retour || sep || 'Contexte: Non renseigné';
    END IF ;
    retour := retour || sep || sep|| 'Programme de formation ';
    SELECT COUNT(*)
    INTO nb
    FROM FOR_DESCRI
    WHERE codfor = pcodfor
    AND coddesc  ='01';
    IF nb        > 0 THEN
      SELECT ('Objectif: '
        || TXT)
      INTO v_objectif
      FROM FOR_DESCRI
      WHERE codfor = pcodfor
      AND coddesc  ='01';
      retour      := retour || sep || sep || v_objectif;
    ELSE
      retour := retour || sep || sep|| 'Objectif: Non renseigné';
    END IF ;
    SELECT COUNT(*)
    INTO nb
    FROM FOR_DESCRI
    WHERE codfor = pcodfor
    AND coddesc  ='02';
    IF nb        > 0 THEN
      SELECT ( TO_CHAR(TXT))
      INTO v_description
      FROM FOR_DESCRI
      WHERE codfor = pcodfor
      AND coddesc  ='02';
      retour      := retour || sep || 'Description: ' ||v_description;
    ELSE
      retour := retour || sep || 'Description: Non renseigné';
    END IF ;
    SELECT COUNT(*)
    INTO nb
    FROM FOR_FORMASSOOPT FO ,
      FOR_FORMOPTLIB FL
    WHERE FO.CODLIB = FL.CODLIB
    AND FO.CODOPT   = 'D'
    AND FO.CODFOR   = pcodfor;
    IF nb           > 0 THEN
      SELECT ( LIBELLE)
      INTO v_costcenter
      FROM FOR_FORMASSOOPT FO ,
        FOR_FORMOPTLIB FL
      WHERE FO.CODLIB = FL.CODLIB
      AND FO.CODOPT   = 'D'
      AND FO.CODFOR   = pcodfor;
      retour         := retour || sep || 'Centre de coût: '|| v_costcenter;
    ELSE
      retour := retour || sep || 'Centre de coût: Non renseigné';
    END IF ;
    RETURN retour;
  END ; 
  ##
HR_LINEARISE_SESSION
=SQL=
CREATE OR REPLACE
  FUNCTION HR_LINEARISE_SESSION(
      param IN VARCHAR2,
      sep   IN VARCHAR2)
    RETURN VARCHAR2
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
    requete VARCHAR2(2000) ;
  BEGIN
    requete := requete || 'select HR_LINEARISE_SEQUENCE(sq.codfor,sq.codses,sq.occseq,''<br>'') from for_ses FS,seqses SQ where fs.CODFOR= SQ.CODFOR AND FS.CODSES = SQ.CODSES and fs.codfor||''#''||fs.codses in ('||param||')' ;
    BEGIN
      OPEN cur FOR requete;
      LOOP
        FETCH cur INTO retourselect;
      EXIT
    WHEN cur % NOTFOUND;
      retour := retour || retourselect || sep;
    END LOOP ;
    CLOSE cur;
    RETURN retour;
  END;
END ; 
##
IS_BETWEEN_NLS_FRENCH
=SQL=
CREATE OR REPLACE FUNCTION IS_BETWEEN_NLS_FRENCH(
    VALCOMP  IN VARCHAR2 ,
    BORNEINF IN VARCHAR2 ,
    BORNESUP IN VARCHAR2 )
  RETURN VARCHAR2
AS
  nbr INT;
BEGIN
  SELECT COUNT(*)
  INTO nbr
  FROM
    (SELECT rownum AS pos,
      name
    FROM
      (SELECT *
      FROM
        (SELECT VALCOMP AS name FROM dual
        UNION ALL
        SELECT BORNEINF AS name FROM dual
        UNION ALL
        SELECT BORNESUP AS name FROM dual
        )
      ORDER BY NLSSORT(name, 'NLS_SORT = FRENCH')
      )
    )
  WHERE name=VALCOMP
  AND pos   =2;
  IF (nbr   =1) THEN
    RETURN 'TRUE';
  ELSE
    RETURN 'FALSE';
  END IF;
END IS_BETWEEN_NLS_FRENCH;
##
IS_DATE
=SQL=
create or replace FUNCTION IS_DATE ( p_string in varchar2, p_fmt in varchar2 := null) return number 
AS 
 retour number;
 d_date date;
begin
 retour :=0;
 IF (p_string is not null) THEN 
   d_date := to_date(p_string,p_fmt);
   retour := 1;
 END IF;
 return retour;
 
exception
 when others then
   return 0;
end;
##
TAG_CHARSET=@€éèç
##
IS_EQ
=SQL=
CREATE OR REPLACE FUNCTION IS_EQ(
  pVal1 VARCHAR2, 
  pVal2 VARCHAR2) 
RETURN BOOLEAN 
IS
BEGIN
  RETURN NVL(pVal1,'__NULL__')=NVL(pVal2,'__NULL__');
END IS_EQ;
##
TAG_CHARSET=@€éèç
##
IS_EQ_DATE
=SQL=
CREATE OR REPLACE FUNCTION IS_EQ_DATE(
  pVal1 in DATE, 
  pVal2 in DATE, 
  pFormat VARCHAR2 DEFAULT 'yyyymmdd') 
RETURN BOOLEAN 
IS
BEGIN
  RETURN NVL(TO_CHAR(pVal1,pFormat),'__NULL__')=NVL(TO_CHAR(pVal2,pFormat),'__NULL__');
END IS_EQ_DATE;
##
IS_NUMBER
=SQL=
create or replace FUNCTION "IS_NUMBER" (xvar_num IN varchar2) RETURN number AS wnumber number; begin wnumber := to_number(replace(xvar_num,'.',',')); RETURN wnumber ;
 exception 
 when others then
 begin 
  wnumber := to_number(replace(xvar_num,',','.')); RETURN wnumber ;
  exception 
  when others then RETURN null;
 end;
end;
##
LINEARISEREQ
=SQL=
CREATE OR REPLACE
  FUNCTION LINEARISEREQ(
      req IN VARCHAR2,
      sep IN VARCHAR2)
    RETURN CLOB
  IS
  type tcur
IS
  ref
  CURSOR;
    cur tcur;
    retourselect VARCHAR2(2000);
    retour CLOB;
  BEGIN
    OPEN cur FOR req;
    LOOP
      FETCH cur INTO retourselect;
    EXIT
  WHEN cur % NOTFOUND;
    retour := retour || retourselect || sep;
  END LOOP;
  CLOSE cur;
  RETURN retour;
END; 
##
LISTE_TAB_PH_ABS
=SQL=
CREATE OR REPLACE FUNCTION LISTE_TAB_PH_ABS RETURN TAB_PH_ABS AS 
  retour TAB_PH_ABS := TAB_PH_ABS();
  nom_table VARCHAR2(50);
  n INTEGER;
  v_quote VARCHAR2(1) := chr(39);
  p_where VARCHAR2(50);
  p_phph VARCHAR2(10) := 'PH_PH_';
  p_photo VARCHAR2(10) := 'PHOTO_';
BEGIN
  FOR une_ligne IN (SELECT DISTINCT TABLEPHY, ALLERRETOUR
                   FROM TGE_REF_MAPTA
                    WHERE ALLERRETOUR IN ('A','2'))
  LOOP
    BEGIN
      nom_table := NULL;
      n := 0;
      p_where := NULL;
      
      p_where := p_phph || une_ligne.TABLEPHY;
      SELECT COUNT(*) INTO n FROM USER_TAB_COLS WHERE TABLE_NAME = p_where;
      IF n = 0 THEN
        retour.extend;
        retour(retour.count) := TYP_TAB_ABS(p_where);
      END IF;
      
      n := 0;
      
      p_where := p_photo || une_ligne.TABLEPHY;
      SELECT COUNT(*) INTO n FROM USER_TAB_COLS WHERE TABLE_NAME = p_where;
      IF n = 0 THEN
        retour.extend;
        retour(retour.count) := TYP_TAB_ABS(p_where);
      END IF;
      EXCEPTION
        WHEN OTHERS THEN
          RAISE;
      END;
  END LOOP;
  RETURN retour;
END LISTE_TAB_PH_ABS;
##
LIST_HISTO_PENIB
=SQL=
create or replace FUNCTION LIST_HISTO_PENIB(  
  p_pacmat IN DIC_ADM_CONTRAT_HISTO.PACMAT%type,
  p_numpac IN DIC_ADM_CONTRAT_HISTO.NUMPAC%type) RETURN TAB_HISTO_PENIB AS pReturn TAB_HISTO_PENIB := TAB_HISTO_PENIB();
  v_date_eff DATE;
  v_date_fin DATE;
  v_date_stc DATE;
  v_actual_date DATE :=sysdate;
  yearEff integer;
  yearFin integer;
  yearSTSC integer;
  yearTmp integer;
  yearTmpFin integer;
  yearActuel integer;
  v_num_contrat_actu integer;
  v_num_contrat_futur integer;
  
BEGIN
  for r in (select PACMAT,NUMPAC,DSSTC,NUMCNT,DECODE(ZAB09,'O','Oui','Non') AS ZAB09 ,DECODE(ZAB10,'O','Oui','Non') AS ZAB10 ,DECODE(ZAB11,'O','Oui','Non') AS ZAB11, DECODE(ZAB12,'O','Oui','Non') AS ZAB12 ,DECODE(ZAB13,'O','Oui','Non') AS ZAB13 ,DECODE(ZAB14,'O','Oui','Non') AS ZAB14,DECODE(ZAB15,'O','Oui','Non') AS ZAB15,DECODE(ZAB16,'O','Oui','Non') AS ZAB16,DECODE(ZAB17,'O','Oui','Non') AS ZAB17,DECODE(ZAB18,'O','Oui','Non') AS ZAB18,DATE_EFF, DATE_FIN from DIC_ADM_CONTRAT_HISTO a where  a.pacmat = p_pacmat and a.numpac = p_numpac ORDER BY DATE_EFF)
  loop
    v_date_eff := r.DATE_EFF;
    v_date_fin := r.DATE_FIN;
    v_date_stc := r.DSSTC;
    yearFin := TO_NUMBER(TO_CHAR(v_date_fin ,'yyyy'));
    yearEff := TO_NUMBER(TO_CHAR(v_date_eff ,'yyyy'));
    yearActuel := TO_NUMBER(TO_CHAR(v_actual_date ,'yyyy'));
    yearTmp := yearEff;
    v_num_contrat_actu := r.NUMCNT;
    IF v_date_stc IS NOT NULL THEN
      BEGIN
        select NUMCNT INTO v_num_contrat_futur from (select NUMCNT from DIC_ADM_CONTRAT_HISTO a where  a.pacmat = p_pacmat and a.numpac = p_numpac and DATE_EFF > v_date_eff ORDER BY DATE_EFF) where rownum = 1;
      EXCEPTION 
        WHEN OTHERS THEN v_num_contrat_futur := 0;
      END;
      IF v_num_contrat_futur = v_num_contrat_actu THEN
        v_date_stc := NULL;
      END IF;
    END IF;
    -- traitement ou il n'y a pas du DSSTC positionné
    IF v_date_stc IS NULL THEN
        -- si la date de fin et plus au moins recente que la date du jour
        IF yearActuel >= yearFin THEN
          -- pour le 31/12 on prend tt l'année si no on aurait arreté a l'année precedent
          IF TO_CHAR(v_date_fin ,'mmdd') = '1231' THEN
               yearTmpFin := yearFin+1;
          ELSE
              yearTmpFin := yearFin;
          END IF;
        ELSE
          yearTmpFin := yearActuel+1;
        END IF;
        WHILE yearTmp < yearTmpFin LOOP
          pReturn.extend;
          pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,yearTmp, null , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
          yearTmp := yearTmp + 1;
        END LOOP;
     -- traitement ou il Y A un DSSTC positionné
     ELSE
       -- il Y A un DSSTC <= Date_fin
       IF v_date_stc <= v_date_fin THEN       
          WHILE yearTmp < TO_NUMBER(TO_CHAR(v_date_stc ,'yyyy')) LOOP
            pReturn.extend;
            pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,yearTmp, null , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
            yearTmp := yearTmp + 1;
          END LOOP;
          pReturn.extend;
          pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,TO_NUMBER(TO_CHAR(v_date_stc ,'yyyy')), r.DSSTC , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
       -- il Y A un DSSTC > Date_fin
       ELSE
          WHILE yearTmp < yearFin LOOP
            pReturn.extend;
            pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,yearTmp, null , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
            yearTmp := yearTmp + 1;
          END LOOP;
          IF v_num_contrat_futur != v_num_contrat_actu THEN 
            WHILE yearTmp < TO_NUMBER(TO_CHAR(v_date_stc ,'yyyy')) LOOP
              pReturn.extend;
              pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,yearTmp, null , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
              yearTmp := yearTmp + 1;
            END LOOP;
            pReturn.extend;
            pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC,TO_NUMBER(TO_CHAR(v_date_stc ,'yyyy')), r.DSSTC , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
          ELSE  
            IF TO_CHAR(v_date_fin ,'mmdd') = '1231' THEN
              pReturn.extend;
              pReturn(pReturn.COUNT) := HISTO_PENIB_ROW_DATA(r.PACMAT,r.NUMPAC, yearFin, null , r.NUMCNT ,r.ZAB09,r.ZAB10,r.ZAB11,r.ZAB12,r.ZAB13,r.ZAB14,r.ZAB15,r.ZAB16,r.ZAB17,r.ZAB18,r.DATE_EFF, r.DATE_FIN);  
            END IF;            
          END IF;
       END IF;
        
     END IF;
     
  end loop;
  return pReturn;
END;
##
LVRD_MAX_ORDRE_GROUPE_DONNEES
=SQL=
 create or replace FUNCTION LVRD_MAX_ORDRE_GROUPE_DONNEES(
 p_num_livrable VARCHAR2,
 p_company_id VARCHAR2,
 p_id_groupe  VARCHAR2)
 RETURN NUMBER
 IS
 v_nbSousGroupes NUMBER;
 v_retour        NUMBER;
 BEGIN
 SELECT MAX(ORDRE)
 INTO v_retour
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NUM_LIVRABLE  =p_num_livrable;
 DECLARE
 CURSOR v_tabSousGroupes
 IS
 SELECT *
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NOM_DONNEE LIKE '#GROUPE%'
 AND NUM_LIVRABLE  =p_num_livrable;
 v_ligneSousGroupe LVRD_GROUPE_DONNEES%ROWTYPE;
 BEGIN
 OPEN v_tabSousGroupes;
 LOOP
 FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
 EXIT
 WHEN v_tabSousGroupes%NOTFOUND OR v_retour>1000;
 v_retour                               := v_retour+LVRD_MAX_ORDRE_GROUPE_DONNEES(p_num_livrable,p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE);
 END LOOP;
 CLOSE v_tabSousGroupes;
 END;
 RETURN v_retour;
 END LVRD_MAX_ORDRE_GROUPE_DONNEES;
##
LVRD_ORDRE_DONNEE_IN_GROUPE
=SQL=
create or replace FUNCTION LVRD_ORDRE_DONNEE_IN_GROUPE(
 p_num_livrable VARCHAR2,
 p_company_id VARCHAR2,
 p_id_groupe  VARCHAR2,
 p_nom_donnee VARCHAR2)
 RETURN NUMBER
 IS
 v_ordreDonneeOuGroupe NUMBER;
 v_retour              NUMBER;
 BEGIN
 BEGIN
 IF NOT SUBSTR(p_nom_donnee,1,1)='#' OR INSTR(p_nom_donnee,'£')=0 THEN
 SELECT ORDRE
 INTO v_retour
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NOM_DONNEE  =p_nom_donnee
 AND NUM_LIVRABLE  =p_num_livrable;
 ELSE
 SELECT ORDRE
 INTO v_retour
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NOM_DONNEE  =SUBSTR(p_nom_donnee,1,INSTR(p_nom_donnee,'£')-1)
 AND ID_GROUPE   =SUBSTR(p_nom_donnee,INSTR(p_nom_donnee,'£')  +1)
 AND NUM_LIVRABLE  =p_num_livrable;
 END IF;
 v_ordreDonneeOuGroupe := v_retour;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 v_retour := 0;
 DECLARE
 CURSOR v_tabSousGroupes
 IS
 SELECT *
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NOM_DONNEE LIKE '#GROUPE%'
 AND NUM_LIVRABLE  =p_num_livrable;
 v_ligneSousGroupe LVRD_GROUPE_DONNEES%ROWTYPE;
 v_ordreTmp NUMBER;
 BEGIN
 OPEN v_tabSousGroupes;
 LOOP
 FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
 EXIT
 WHEN v_tabSousGroupes%NOTFOUND OR v_retour>0;
 v_ordreTmp                             := LVRD_ORDRE_DONNEE_IN_GROUPE(p_num_livrable, p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE, p_nom_donnee);
 IF v_ordreTmp                           >0 THEN
 v_retour                             := v_ligneSousGroupe.ORDRE+v_ordreTmp-1;
 v_ordreDonneeOuGroupe                := v_ligneSousGroupe.ORDRE;
 END IF;
 END LOOP;
 CLOSE v_tabSousGroupes;
 END;
 WHEN OTHERS THEN
 RETURN 0;
 END;
 IF v_retour IS NULL OR v_retour=0 THEN
 RETURN 0;
 END IF;
 DECLARE
 CURSOR v_tabSousGroupes
 IS
 SELECT *
 FROM LVRD_GROUPE_DONNEES
 WHERE COMPANY_ID=p_company_id
 AND ID_GROUPE   =p_id_groupe
 AND NOM_DONNEE LIKE '#GROUPE%'
 AND ORDRE<v_ordreDonneeOuGroupe
 AND NUM_LIVRABLE  =p_num_livrable;
 v_ligneSousGroupe LVRD_GROUPE_DONNEES%ROWTYPE;
 BEGIN
 OPEN v_tabSousGroupes;
 LOOP
 FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
 EXIT
 WHEN v_tabSousGroupes%NOTFOUND OR v_retour>1000;
 v_retour                               := v_retour+(LVRD_MAX_ORDRE_GROUPE_DONNEES(p_num_livrable,p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE)-1);
 END LOOP;
 CLOSE v_tabSousGroupes;
 END;
 RETURN v_retour;
 END LVRD_ORDRE_DONNEE_IN_GROUPE;
##
MAP_LISTE_COL
=SQL=
create or replace FUNCTION MAP_LISTE_COL RETURN TYP_TAB AS
  p_retour TYP_TAB := TYP_TAB();
  n INTEGER := 0;
BEGIN
  FOR une_ligne IN (SELECT DISTINCT TABLEGXP, DONNEEGXP, TABLE_NAME, NUMPAC, ELEMENT
                    FROM TGE_REF_MAPDO, USER_TAB_COLS
                    WHERE (TABLEGXP, DONNEEGXP) NOT IN (SELECT TABLE_NAME, COLUMN_NAME
                                                          FROM USER_TAB_COLS)
                    AND (TABLEGXP=TABLE_NAME
                    OR TABLE_NAME='PH_PH_'||TABLEGXP
                    OR TABLE_NAME='PHOTO_'||TABLEGXP
                    OR (DONNEEGXP IS NULL AND TABLEGXP IS NOT NULL))
                    UNION
                    SELECT DISTINCT TABLEGXP,DONNEEGXP,TABLE_NAME,D.NUMPAC,M.ELEMENT
                    FROM TGE_REF_MAPDO M, USER_TAB_COLS U ,TGE_REF_DICOZ D
                    WHERE 
                    D.ELEMENT     = M.ELEMENT
                    AND (M.TABLEGXP  = U.TABLE_NAME --OR U.TABLE_NAME  ='PH_PH_'||M.TABLEGXP OR U.TABLE_NAME='PHOTO_' ||M.TABLEGXP
                    )
                    AND  M.DONNEEGXP = U.COLUMN_NAME
                    AND (
                    (D.TYPE  = 'N' AND D.MASQUE in (1,2,3,4,5,6,7)  AND DATA_TYPE  <> 'DATE')
                    OR (D.TYPE      = 'A' AND (DATA_TYPE <> 'VARCHAR2' OR D.LONGUEUR > DATA_LENGTH))
                    OR ((D.TYPE     = 'N' AND D.MASQUE NOT in (1,2,3,4,5,6,7)  OR D.TYPE          = 'P') AND (DATA_TYPE    <> 'NUMBER' OR DATA_LENGTH < LONGUEUR OR DATA_PRECISION < NBDECI))
                   )
                   ORDER BY TABLEGXP,TABLE_NAME,DONNEEGXP)
  LOOP
    p_retour.extend;
    n := n + 1;
    --retour(n) := typ_obj(une_ligne.TABLEGXP, une_ligne.DONNEEGXP, une_ligne.TABLE_NAME, une_ligne.NUMPAC, une_ligne.ELEMENT);
    p_retour(p_retour.count) := TYP_OBJ(une_ligne.DONNEEGXP, une_ligne.TABLEGXP, une_ligne.TABLE_NAME, une_ligne.NUMPAC, une_ligne.ELEMENT);
  END LOOP;
  RETURN p_retour;
END MAP_LISTE_COL;
##
META_EST_DONNEE_UX
=SQL=
create or replace FUNCTION META_EST_DONNEE_UX 
(
  P_NOM_DONNEE IN VARCHAR2 
, P_COMPANY_ID IN VARCHAR2 
) RETURN NUMBER AS 

v_retour NUMBER;
BEGIN
  SELECT COUNT(NOM_DONNEE) into v_retour
  FROM META_DONNEE_MAPPING_UX 
  WHERE NOM_DONNEE = p_nom_donnee
  AND  COMPANY_ID = p_company_id;
  
 RETURN v_retour;
END META_EST_DONNEE_UX;
##
META_EST_PIECE_JOINTE
=SQL=
create or replace FUNCTION META_EST_PIECE_JOINTE 
(
  P_COMPANY_ID IN VARCHAR2
, P_NOM_DONNEE IN VARCHAR2 
, P_NOM_PAGE IN VARCHAR2 
)RETURN INTEGER IS

CURSOR CUR_PIECE
IS 
  SELECT MODE_SAISIE, NOM_PAGE
  FROM META_DONNEE_ECRAN 
  WHERE COMPANY_ID = p_company_id
  AND NOM_DONNEE = p_nom_donnee 
  AND NOM_PAGE IN ('*' , p_NOM_PAGE)
  ORDER BY NOM_PAGE DESC; 
  
 lignesRequetes CUR_PIECE%ROWTYPE; 
 
 BEGIN
  OPEN CUR_PIECE;
  LOOP
    FETCH CUR_PIECE INTO lignesRequetes; 
    EXIT WHEN CUR_PIECE%NOTFOUND;
      IF lignesRequetes.MODE_SAISIE = 'asynchroneUploadFile' THEN
        RETURN 1;
      ELSE 
        RETURN 0;
      END IF;
  END LOOP;
  CLOSE CUR_PIECE;
END META_EST_PIECE_JOINTE;
##
META_GET_PIECES_JOINTES
=SQL=
create or replace FUNCTION META_GET_PIECES_JOINTES 
(
  P_COMPANY_ID IN VARCHAR2
, P_NOM_PAGE IN VARCHAR2
, P_ID_GROUPE IN VARCHAR2 
) RETURN NUMBER 
 IS
   
  CURSOR CUR_DONNEES
  IS
  SELECT NOM_DONNEE, SUFFIXE_OU_LIBELLE
   FROM META_GROUPE_DONNEES 
   WHERE COMPANY_ID = p_company_id
   AND ID_GROUPE   =p_id_groupe
   AND NOM_DONNEE LIKE '#GROUPE%'
   UNION 
   SELECT NOM_DONNEE, SUFFIXE_OU_LIBELLE
   FROM META_GROUPE_DONNEES 
   WHERE COMPANY_ID = p_company_id
   AND ID_GROUPE   =p_id_groupe
   AND NOM_DONNEE NOT LIKE '#%';
   
   v_ligneDonnee CUR_DONNEES%ROWTYPE;
   v_retour  number:=0; 

 BEGIN
   OPEN CUR_DONNEES;
   LOOP
    FETCH  CUR_DONNEES INTO v_ligneDonnee;
    EXIT WHEN CUR_DONNEES%NOTFOUND;  
      IF  SUBSTR(v_ligneDonnee.NOM_DONNEE,1,7)='#GROUPE' THEN 
         v_retour  := v_retour+ META_GET_PIECES_JOINTES(p_company_id,p_nom_page,v_ligneDonnee.SUFFIXE_OU_LIBELLE);
      ELSE
        v_retour := v_retour+ META_EST_PIECE_JOINTE(p_company_id,v_ligneDonnee.NOM_DONNEE,p_nom_page);  
      END IF;
   END LOOP;
   CLOSE CUR_DONNEES;
  RETURN v_retour;
END META_GET_PIECES_JOINTES;
##
META_LISTE_DONNEES_UX_ECRAN
=SQL=
create or replace FUNCTION META_LISTE_DONNEES_UX_ECRAN 
(P_COMPANY_id IN VARCHAR2 
, P_ID_GROUPE IN VARCHAR2) 
RETURN TAB_DONNEES_UX AS retour TAB_DONNEES_UX := TAB_DONNEES_UX();
  CURSOR CUR_DONNEES_UX
  IS
  SELECT NOM_DONNEE, SUFFIXE_OU_LIBELLE
  FROM META_GROUPE_DONNEES 
  WHERE ID_GROUPE   =p_id_groupe
  AND COMPANY_ID = p_company_id 
  AND NOM_DONNEE NOT LIKE '#%'
  UNION 
  SELECT NOM_DONNEE, SUFFIXE_OU_LIBELLE
  FROM META_GROUPE_DONNEES 
  WHERE ID_GROUPE   = p_id_groupe
  AND COMPANY_ID = p_company_id
  AND NOM_DONNEE  LIKE '#GROUPE%';
  
   v_ligneDonnee CUR_DONNEES_UX%ROWTYPE;
   retourTmp TAB_DONNEES_UX;
 BEGIN
   OPEN CUR_DONNEES_UX;
   LOOP
    FETCH  CUR_DONNEES_UX INTO v_ligneDonnee;
    EXIT WHEN CUR_DONNEES_UX%NOTFOUND;
    IF NOT SUBSTR(v_ligneDonnee.NOM_DONNEE,1,1)='#' THEN 
         IF (META_EST_DONNEE_UX(v_ligneDonnee.NOM_DONNEE,p_company_id)<>0) THEN 
              retour.extend;
              retour(retour.count) := TYP_DONNEES_UX(v_ligneDonnee.NOM_DONNEE);   
          END IF;    
     ELSE 
         retourTmp := META_LISTE_DONNEES_UX_ECRAN(p_company_id,v_ligneDonnee.SUFFIXE_OU_LIBELLE);
         if (retourTmp.count>0) then
         FOR i IN retourTmp.FIRST..retourTmp.LAST LOOP 
              retour.extend;
              retour(retour.count) := retourTmp(i); 
          END LOOP;
          END IF;
      END IF;
   END LOOP;
   CLOSE CUR_DONNEES_UX;
   return retour;
END META_LISTE_DONNEES_UX_ECRAN;
##
META_LISTE_PREFIX_TABLE
=SQL=
CREATE OR REPLACE FUNCTION META_LISTE_PREFIX_TABLE RETURN TAB_VARCHAR
IS 
  listePrefix TAB_VARCHAR:=TAB_VARCHAR();
BEGIN
  listePrefix.extend();
  listePrefix(listePrefix.last):='META';
  listePrefix.extend();
  listePrefix(listePrefix.last):='REF';
  listePrefix.extend();
  listePrefix(listePrefix.last):='LVRD';
  listePrefix.extend();
  listePrefix(listePrefix.last):='MARQ';
  listePrefix.extend();
  listePrefix(listePrefix.last):='HIS';
  RETURN listePrefix;
END META_LISTE_PREFIX_TABLE;
##
META_MAX_ORDRE_GROUPE_DONNEES
=SQL=
create or replace
FUNCTION META_MAX_ORDRE_GROUPE_DONNEES(
      p_company_id VARCHAR2,
      p_id_groupe  VARCHAR2)
    RETURN NUMBER
  IS
    v_nbSousGroupes NUMBER;
    v_retour        NUMBER;
  BEGIN
    SELECT MAX(ORDRE)
    INTO v_retour
    FROM META_GROUPE_DONNEES
    WHERE COMPANY_ID=p_company_id
    AND ID_GROUPE   =p_id_groupe;
    DECLARE
      CURSOR v_tabSousGroupes
      IS
        SELECT *
        FROM META_GROUPE_DONNEES
        WHERE COMPANY_ID=p_company_id
        AND ID_GROUPE   =p_id_groupe
        AND NOM_DONNEE LIKE '#GROUPE%';
      v_ligneSousGroupe META_GROUPE_DONNEES%ROWTYPE;
    BEGIN
      OPEN v_tabSousGroupes;
      LOOP
        FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
        EXIT
      WHEN v_tabSousGroupes%NOTFOUND OR v_retour>1000;
        v_retour                               := v_retour+META_MAX_ORDRE_GROUPE_DONNEES(p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE);
      END LOOP;
      CLOSE v_tabSousGroupes;
    END;
    RETURN v_retour;
  END META_MAX_ORDRE_GROUPE_DONNEES;
##
META_ORDRE_DONNEE_IN_GROUPE
=SQL=
create or replace
FUNCTION META_ORDRE_DONNEE_IN_GROUPE(
      p_company_id VARCHAR2,
      p_id_groupe  VARCHAR2,
      p_nom_donnee VARCHAR2)
    RETURN NUMBER
  IS
    v_ordreDonneeOuGroupe NUMBER;
    v_retour              NUMBER;
  BEGIN
    BEGIN
      IF NOT SUBSTR(p_nom_donnee,1,1)='#' OR INSTR(p_nom_donnee,'£')=0 THEN
        SELECT ORDRE
        INTO v_retour
        FROM META_GROUPE_DONNEES
        WHERE COMPANY_ID=p_company_id
        AND ID_GROUPE   =p_id_groupe
        AND NOM_DONNEE  =p_nom_donnee;
      ELSE
        SELECT ORDRE
        INTO v_retour
        FROM META_GROUPE_DONNEES
        WHERE COMPANY_ID=p_company_id
        AND ID_GROUPE   =p_id_groupe
        AND NOM_DONNEE  =SUBSTR(p_nom_donnee,1,INSTR(p_nom_donnee,'£')-1)
        AND ID_GROUPE   =SUBSTR(p_nom_donnee,INSTR(p_nom_donnee,'£')  +1);
      END IF;
      v_ordreDonneeOuGroupe := v_retour;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_retour := 0;
      DECLARE
        CURSOR v_tabSousGroupes
        IS
          SELECT *
          FROM META_GROUPE_DONNEES
          WHERE COMPANY_ID=p_company_id
          AND ID_GROUPE   =p_id_groupe
          AND NOM_DONNEE LIKE '#GROUPE%';
        v_ligneSousGroupe META_GROUPE_DONNEES%ROWTYPE;
        v_ordreTmp NUMBER;
      BEGIN
        OPEN v_tabSousGroupes;
        LOOP
          FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
          EXIT
        WHEN v_tabSousGroupes%NOTFOUND OR v_retour>0;
          v_ordreTmp                             := META_ORDRE_DONNEE_IN_GROUPE(p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE, p_nom_donnee);
          IF v_ordreTmp                           >0 THEN
            v_retour                             := v_ligneSousGroupe.ORDRE+v_ordreTmp-1;
            v_ordreDonneeOuGroupe                := v_ligneSousGroupe.ORDRE;
          END IF;
        END LOOP;
        CLOSE v_tabSousGroupes;
      END;
    WHEN OTHERS THEN
      RETURN 0;
    END;
    IF v_retour IS NULL OR v_retour=0 THEN
      RETURN 0;
    END IF;
    DECLARE
      CURSOR v_tabSousGroupes
      IS
        SELECT *
        FROM META_GROUPE_DONNEES
        WHERE COMPANY_ID=p_company_id
        AND ID_GROUPE   =p_id_groupe
        AND NOM_DONNEE LIKE '#GROUPE%'
        AND ORDRE<v_ordreDonneeOuGroupe;
      v_ligneSousGroupe META_GROUPE_DONNEES%ROWTYPE;
    BEGIN
      OPEN v_tabSousGroupes;
      LOOP
        FETCH v_tabSousGroupes INTO v_ligneSousGroupe;
        EXIT
      WHEN v_tabSousGroupes%NOTFOUND OR v_retour>1000;
        v_retour                               := v_retour+(META_MAX_ORDRE_GROUPE_DONNEES(p_company_id, v_ligneSousGroupe.SUFFIXE_OU_LIBELLE)-1);
      END LOOP;
      CLOSE v_tabSousGroupes;
    END;
    RETURN v_retour;
  END META_ORDRE_DONNEE_IN_GROUPE;
  ##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_GET_TAB_ENTITES
=SQL=
CREATE OR REPLACE FUNCTION MP_CODELISTS_ESI_GET_TAB_ENTITES(p_TYPE_ENTITE VARCHAR2, p_CODVAR_TYPE_ENTITE VARCHAR2 DEFAULT NULL) RETURN MP_CODELISTS_ESI_TAB_ENTITES AS 
  v_retour MP_CODELISTS_ESI_TAB_ENTITES := MP_CODELISTS_ESI_TAB_ENTITES();
  v_TYPE_ENTITE VARCHAR2(15);
BEGIN
  v_TYPE_ENTITE := p_TYPE_ENTITE;
  IF v_TYPE_ENTITE IS NULL AND p_CODVAR_TYPE_ENTITE IS NOT NULL THEN
    SELECT VALVAR INTO v_TYPE_ENTITE FROM (SELECT VALVAR FROM SYS_VARSYS WHERE CODVAR=p_CODVAR_TYPE_ENTITE ORDER BY CASE WHEN MODULE='SYS' THEN 3 WHEN MODULE='STD' THEN 2 ELSE 1 END, MODULE) WHERE ROWNUM=1;
  END IF;
  IF v_TYPE_ENTITE IS NULL THEN
    RETURN v_retour;
  END IF;
  FOR une_entite IN (SELECT CID, CODE_ENTITE, LIBELLE_REDUIT, LIBELLE FROM STD_STRUC_ENTITE WHERE TYPE_ENTITE=v_TYPE_ENTITE AND TO_CHAR(SYSDATE,'yyyymmdd') BETWEEN DATE_EFF AND DATE_FIN)
  LOOP
    v_retour.extend;
    v_retour(v_retour.count) := MP_CODELISTS_ESI_ENTITE(une_entite.CID, une_entite.CODE_ENTITE, une_entite.LIBELLE_REDUIT, une_entite.LIBELLE);
  END LOOP;
  RETURN v_retour;
END MP_CODELISTS_ESI_GET_TAB_ENTITES;
##
MY_REGEXP_REPLACE
=SQL=
CREATE OR REPLACE FUNCTION MY_REGEXP_REPLACE(p1 VARCHAR2, p2 VARCHAR2,p3 varchar2 ) 
RETURN varchar2 
DETERMINISTIC IS
BEGIN
RETURN REGEXP_REPLACE(p1, p2, p3);
END MY_REGEXP_REPLACE; 
##
PAC_SEQUENCE_CHECK_EXISTS
=SQL=
create or replace
FUNCTION PAC_SEQUENCE_CHECK_EXISTS(
      p_numpac VARCHAR2)
    RETURN NUMBER
  IS
    v_existSequence NUMBER;
  BEGIN
    IF p_numpac IS NULL THEN
      RETURN 0;
    END IF;
    SELECT COUNT(*)
    INTO v_existSequence
    FROM USER_SEQUENCES
    WHERE SEQUENCE_NAME = PAC_SEQUENCE_GET_NAME(p_numpac);
    IF v_existSequence  >0 THEN
      RETURN 1;
    END IF;
    RETURN 0;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN 0;
  END PAC_SEQUENCE_CHECK_EXISTS;
##
PAC_SEQUENCE_GET_NAME
=SQL=
CREATE OR REPLACE
  FUNCTION PAC_SEQUENCE_GET_NAME(
      p_numpac VARCHAR2)
    RETURN VARCHAR2
  IS
  BEGIN
    IF p_numpac IS NULL THEN
      RETURN '';
    END IF;
    RETURN 'PACMAT_'||p_numpac||'_UID';
  END PAC_SEQUENCE_GET_NAME;
##
PAC_SEQUENCE_GET_NEXT
=SQL=
create or replace FUNCTION PAC_SEQUENCE_GET_NEXT(p_numpac VARCHAR2)
RETURN VARCHAR2
IS
 v_pacmat   NUMBER;
 v_retour   VARCHAR2(8);
 BEGIN
  v_retour := LPAD('0',8,'0');
  IF PAC_SEQUENCE_CHECK_EXISTS(p_numpac)=1 THEN
     EXECUTE IMMEDIATE 'SELECT LPAD('||PAC_SEQUENCE_GET_NAME(p_numpac)||'.NEXTVAL,'||8||',''0'') FROM DUAL' INTO v_retour;
   ELSE
     RAISE_APPLICATION_ERROR(-20000,'La séquence permettant de déterminer le PACMAT pour le PAC '''||p_numpac||''' n''existe pas');
   END IF;
 RETURN v_retour;
END PAC_SEQUENCE_GET_NEXT;
##
PHOTO_CONFORME
=SQL=
CREATE OR REPLACE FUNCTION PHOTO_CONFORME RETURN TAB_ERR AS 
	retour TAB_ERR := TAB_ERR();
	libelle_erreur VARCHAR2(50);
	nb_photo INTEGER;
	nb INTEGER;
BEGIN
	FOR une_ligne IN (SELECT DISTINCT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH
					FROM USER_TAB_COLS
                    WHERE COLUMN_NAME != 'TYPE_WRITER'
                    AND ( TABLE_NAME NOT LIKE 'PH_PH_%'
                    OR TABLE_NAME NOT LIKE 'PHOTO_%'))
	LOOP
		SELECT DISTINCT count(*) INTO nb_photo FROM USER_TAB_COLS WHERE TABLE_NAME = 'PHOTO_'||une_ligne.TABLE_NAME;
		IF nb_photo != 0 THEN
			SELECT DISTINCT count(*) INTO nb 
			FROM USER_TAB_COLS 
			WHERE TABLE_NAME = 'PHOTO_'||une_ligne.TABLE_NAME 
			AND COLUMN_NAME = une_ligne.COLUMN_NAME;
			
			IF nb = 0 THEN
				libelle_erreur := 'Colonne manquante';
				retour.extend;
				retour(retour.count) := TYP_ERR(une_ligne.TABLE_NAME, une_ligne.COLUMN_NAME, libelle_erreur);
			ELSE
				SELECT DISTINCT count(*) INTO nb 
				FROM USER_TAB_COLS 
				WHERE TABLE_NAME = 'PHOTO_'||une_ligne.TABLE_NAME 
				AND COLUMN_NAME = une_ligne.COLUMN_NAME
				AND DATA_TYPE = une_ligne.DATA_TYPE;
				IF nb = 0 THEN
					libelle_erreur := 'Type incohérent';
					retour.extend;
					retour(retour.count) := TYP_ERR(une_ligne.TABLE_NAME, une_ligne.COLUMN_NAME, libelle_erreur);
				ELSE
					SELECT DISTINCT count(*) INTO nb
					FROM USER_TAB_COLS 
					WHERE TABLE_NAME = 'PHOTO_'||une_ligne.TABLE_NAME 
					AND COLUMN_NAME = une_ligne.COLUMN_NAME
					AND DATA_TYPE = une_ligne.DATA_TYPE
					AND DATA_LENGTH = une_ligne.DATA_LENGTH;
					IF nb = 0 THEN
						libelle_erreur := 'Taille différente';
						retour.extend;
					retour(retour.count) := TYP_ERR(une_ligne.TABLE_NAME, une_ligne.COLUMN_NAME, libelle_erreur);
					END IF;
				END IF;
			END IF;
		END IF;
	END LOOP;
	
	FOR une_table IN (SELECT tablephy FROM TGE_REF_MAPTA TA WHERE 1=1 AND TA.allerretour in ('A','2') 
	and 'PHOTO_'||tablephy not in (select table_name from user_tables))
	LOOP 
	    IF nb > 0 THEN
	       libelle_erreur := 'Table PHOTO inexistante';
	       retour.extend;
	       retour(retour.count) := TYP_ERR(une_table.tablephy, 'ALL', libelle_erreur);
	    END IF; 
	END LOOP;
	
	FOR une_table IN (SELECT tablephy FROM TGE_REF_MAPTA TA WHERE 1=1 AND TA.allerretour in ('A','2') 
	and 'PH_PH_'||tablephy not in (select table_name from user_tables))
	LOOP 
	    IF nb > 0 THEN
	       libelle_erreur := 'Table PH_PH inexistante';
	       retour.extend;
	       retour(retour.count) := TYP_ERR(une_table.tablephy, 'ALL', libelle_erreur);
	    END IF; 
	END LOOP;
	
	RETURN retour;
END PHOTO_CONFORME;
##
REPLACE_CHR13
=SQL=
CREATE OR REPLACE
  FUNCTION REPLACE_CHR13(
      TEXT           IN CLOB,
      RETOUR_CHARIOT IN VARCHAR2)
    RETURN CLOB
  AS
  BEGIN
    RETURN REPLACE(TEXT, chr(13), RETOUR_CHARIOT);
  END REPLACE_CHR13;
  ##
REPLACE_CHR13FIX
=SQL=
CREATE OR REPLACE
  FUNCTION REPLACE_CHR13FIX(
      TEXT IN CLOB)
    RETURN CLOB
  AS
  BEGIN
    RETURN REPLACE_CHR13(TEXT, ' ');
  END REPLACE_CHR13FIX;
  ##
SANS_ACCENT
=SQL=
CREATE OR REPLACE
  FUNCTION SANS_ACCENT(
      p_chaine VARCHAR2 )
    RETURN VARCHAR2
  AS
  BEGIN
    RETURN TRANSLATE(p_chaine,'ÀÁÂÃÄÅàáâãäåÒÓÔÕÖØòóôõöøÈÉÊËèéêëÇçÌÍÎÏìíîïÙÚÛÜùúûüÝxýÿÑñ','AAAAAAaaaaaaOOOOOOooooooEEEEeeeeCcIIIIiiiiUUUUuuuuYYyyNn');
  END SANS_ACCENT; 
  ##
SEC_PRIO_SITU_FROM_WITH_FUTUR
=SQL=
CREATE OR REPLACE FUNCTION SEC_PRIO_SITU_FROM_WITH_FUTUR(p_matric VARCHAR2, p_prio_situ_with_futur NUMBER) RETURN NUMBER IS
  max_prio_situ NUMBER;
BEGIN
  IF p_prio_situ_with_futur=0 THEN
    RETURN 0;
  END IF;
  SELECT MAX(PRIORITE_SITUATION) INTO max_prio_situ FROM SECUPACMAT WHERE MATRIC=p_matric;
  IF max_prio_situ>0 THEN
    IF (p_prio_situ_with_futur * -1) <= max_prio_situ THEN
      RETURN p_prio_situ_with_futur * -1;
    END IF;
  END IF;
  RETURN p_prio_situ_with_futur + max_prio_situ;
END SEC_PRIO_SITU_FROM_WITH_FUTUR;
##
SEC_PRIO_SITU_WITH_FUTUR
=SQL=
CREATE OR REPLACE FUNCTION SEC_PRIO_SITU_WITH_FUTUR(p_matric VARCHAR2, p_prio_situ NUMBER) RETURN NUMBER IS
  max_prio_situ NUMBER;
BEGIN
  IF p_prio_situ>0 THEN
    RETURN p_prio_situ * -1;
  ELSIF p_prio_situ<0 THEN
    SELECT MAX(PRIORITE_SITUATION) INTO max_prio_situ FROM SECUPACMAT WHERE MATRIC=p_matric;
    IF max_prio_situ>0 THEN
      RETURN p_prio_situ - max_prio_situ;
    ELSE
      RETURN p_prio_situ;
    END IF;
  END IF;
  RETURN 0;
END SEC_PRIO_SITU_WITH_FUTUR;
##
SIMU_GET_SELECT_ELEMENTS_GAP
=SQL=
create or replace FUNCTION SIMU_GET_SELECT_ELEMENTS_GAP(
    p_numpac          IN VARCHAR2,
    p_nomTable        IN VARCHAR2,
    p_listeDonneesGxp IN VARCHAR2)
  RETURN CLOB
AS
  --curseur sur MAPDO
  CURSOR cur_mapdo
  IS
    SELECT a.*,
      b.*,
      c.type AS typeZADIG,
      c.longueur,
      c.MASQUE
    FROM
      (SELECT *
      FROM tge_ref_mapdo
      WHERE numpac =p_numpac
      AND INSTR(p_listeDonneesGxp,','
        ||donneegxp
        ||',')     >0
      AND tablegxp =
        (SELECT tableparam
        FROM tge_ref_mapta
        WHERE tablephy=p_nomTable
        AND (numpac   =p_numpac
        OR (numpac    ='*'
        AND NOT EXISTS
          (SELECT *
          FROM tge_ref_mapta z
          WHERE numpac  =p_numpac
          AND tableparam=tge_ref_mapta.tableparam
          )))
        )
      UNION ALL
      SELECT *
      FROM tge_ref_mapdo
      WHERE numpac ='*'
      AND INSTR(p_listeDonneesGxp,','
        ||donneegxp
        ||',')     >0
      AND tablegxp =
        (SELECT tableparam
        FROM tge_ref_mapta
        WHERE tablephy=p_nomTable
        AND (numpac   =p_numpac
        OR (numpac    ='*'
        AND NOT EXISTS
          (SELECT *
          FROM tge_ref_mapta z
          WHERE numpac  =p_numpac
          AND tableparam=tge_ref_mapta.tableparam
          )))
        )
      AND element NOT IN
        (SELECT element FROM tge_ref_mapdo WHERE numpac=p_numpac
        )
      ) a,
      (SELECT column_name,
        data_type
      FROM user_tab_columns
      WHERE table_name = p_nomTable
      ) b,
      (SELECT *
      FROM TGE_REF_DICOZ
      WHERE numpac=p_numpac
      ) C
    WHERE donneegxp  = column_name
    AND c.element    =a.element
    AND (donnfiltre IS NULL
    OR donnfiltre   IN
      (SELECT c.column_name
      FROM user_tab_columns c
      WHERE c.table_name = p_nomTable
      ))
    AND occurence NOT LIKE '%!%'
    ORDER BY a.element,
      a.occurence;
    lig_mapdo cur_mapdo%rowtype;
    clselect CLOB;
BEGIN
  clselect :=NULL;
  OPEN cur_mapdo;
  LOOP
    FETCH cur_mapdo INTO lig_mapdo;
    EXIT
  WHEN cur_mapdo%NOTFOUND ;
    clselect :=clselect||fsed.getClauseSelect(p_numpac, p_nomTable, lig_mapdo.DONNEEGXP, lig_mapdo.DONNFILTRE, lig_mapdo.OPERFILTRE, lig_mapdo.VALFILTRE, lig_mapdo.TRTPARTICULIER, lig_mapdo.ENVOI_SYSTEMATIQUE, lig_mapdo.data_type, lig_mapdo.typeZADIG, lig_mapdo.MASQUE, lig_mapdo.OCCURENCE, FALSE);
    clselect :=clselect||' as E_'||lig_mapdo.ELEMENT||',';
  END LOOP;
  CLOSE cur_mapdo;
  IF clselect IS NOT NULL THEN
    clselect  := SUBSTR(clselect,1,LENGTH(clselect)-1);
  END IF;
  RETURN clselect;
END SIMU_GET_SELECT_ELEMENTS_GAP;
##
SOUSREQ
=SQL=
CREATE OR REPLACE
  FUNCTION SOUSREQ(
      Req IN VARCHAR2)
    RETURN VARCHAR2
  IS
  TYPE TCur
IS
  REF
  CURSOR ;
    cur TCur ;
    RetourSelect VARCHAR2(80);
    Retour       VARCHAR2(600);
    cpt          INTEGER;
  BEGIN
    OPEN cur FOR Req ;
    cpt:=0;
    LOOP
      FETCH cur INTO RetourSelect ;
    EXIT
  WHEN cur%NOTFOUND ;
    cpt      :=cpt+1;
    IF (cpt  <=6) THEN
      Retour := Retour || RetourSelect || CHR(32);
    END IF;
  END LOOP ;
  CLOSE cur ;
  IF (cpt<6) THEN
    LOOP
      cpt    :=cpt+1;
      Retour := Retour || CHR(32);
      EXIT
    WHEN (cpt>=6) ;
    END LOOP ;
  END IF;
  RETURN Retour;
END ; 
##
SOUSREQ_PAIRIMPAIR
=SQL=
CREATE OR REPLACE
  FUNCTION SOUSREQ_PAIRIMPAIR(
      Req       IN VARCHAR2,
      libimpair IN VARCHAR2,
      libpair   IN VARCHAR2)
    RETURN VARCHAR2
  IS
  TYPE TCur
IS
  REF
  CURSOR ;
    cur TCur ;
    RetourSelect VARCHAR2(80);
    Retour       VARCHAR2(600);
    i            INTEGER:=0;
  BEGIN
    OPEN cur FOR Req ;
    LOOP
      FETCH cur INTO RetourSelect ;
    EXIT
  WHEN cur%NOTFOUND ;
    i         :=i+1;
    IF MOD(i,2)=0 THEN
      Retour  := Retour ||libpair;
    ELSE
      Retour := Retour ||libimpair;
    END IF;
    Retour := Retour || RetourSelect;
  END LOOP ;
  CLOSE cur ;
  RETURN Retour;
END ; 
##
SPLIT_STRING_INTO_TAB
=SQL=
CREATE OR REPLACE FUNCTION SPLIT_STRING_INTO_TAB (pStr IN VARCHAR2 ,pDelimiter IN VARCHAR2) RETURN TAB_VARCHAR
IS
malist TAB_VARCHAR;
BEGIN 
	malist := TAB_VARCHAR();
	for x in (select regexp_substr(pStr,'[^' || pDelimiter || ']+', 1, level) RES from dual connect by regexp_substr(pStr,'[^' || pDelimiter || ']+', 1, level) is not null) loop
		malist.extend;
		malist(malist.last) := x.RES;
	end loop;
RETURN malist;
END SPLIT_STRING_INTO_TAB;
##
TGE_CONTROLE_HEURE_TRAV
=SQL=
create or replace FUNCTION TGE_CONTROLE_HEURE_TRAV(
    p_valeur         IN VARCHAR2,
    tailleMaxPartEnt IN NUMBER,
    tailleMaxPartDec IN NUMBER,
    p_NLS_SEP        IN VARCHAR2)
  RETURN NUMBER
AS
  retour       NUMBER;
  cNLS_SEP_BAD VARCHAR2(1);
  nValeur      NUMBER;
  cValeur      VARCHAR2(40);
  cValeurEnt   VARCHAR2(40);
  cValeurDec   VARCHAR2(40);
  nPosSep      NUMBER;
BEGIN
  cNLS_SEP_BAD   :='.';
  nValeur        :=0;
  cValeur        :=' ';
  cValeurEnt     :=' ';
  cValeurDec     :=' ';
  nPosSep        :=0;
  IF (p_NLS_SEP   = '.') THEN
    cNLS_SEP_BAD :=',';
  END IF;
  -- on met le bon séparateur
  cValeur := REPLACE(p_valeur ,cNLS_SEP_BAD,p_NLS_SEP);
  -- on retire les + et -
  cValeur                  := REPLACE(cValeur ,'+');
  cValeur                  := REPLACE(cValeur ,'-');
  retour                   :=1;
  IF (cValeur              IS NOT NULL ) THEN
    IF (IS_NUMBER(cValeur) IS NOT NULL) THEN
      nPosSep              := INSTR(cValeur , p_NLS_SEP);
      -- partie entiere ne doit pas depasser taille max
      IF (nPosSep           = 0 ) THEN
        IF (LENGTH(cValeur) > tailleMaxPartEnt ) THEN
          retour           :=0;
        END IF;
      ELSE -- valeur avec decimal
        -- partie entiere ne doit pas depasser taille max
        cValeurEnt            := SUBSTR(cValeur ,0,INSTR(cValeur ,p_NLS_SEP )-1 );
        IF (LENGTH(cValeurEnt) > tailleMaxPartEnt ) THEN
          retour              :=0;
        END IF;
        -- partie decimaentiere ne doit pas depasser taille max
        cValeurDec            := SUBSTR(cValeur,INSTR(cValeur ,p_NLS_SEP)+1 );
        IF (LENGTH(cValeurDec) > tailleMaxPartDec ) THEN
          retour              :=0;
        END IF;
      END IF;
    ELSE
      retour:=0;
    END IF;
  END IF;
  RETURN retour;
EXCEPTION
WHEN OTHERS THEN
  RETURN 0;
END;
##
TAG_CHARSET=@€éèç
##
TGE_CREATE_TRIGGER_MP_NOTIF
=SQL=
CREATE OR REPLACE FUNCTION TGE_CREATE_TRIGGER_MP_NOTIF(NOM_TABLE IN VARCHAR2)
RETURN CLOB
AS
  v_retour CLOB;

  v_typeTable VARCHAR(1);
  date_eff_exists NUMBER;
  PROC_DEX_UPDATING CLOB;
  PROC_DEX_UPDATING_TMP CLOB;
  PROC_DEX_CONDITION CLOB;
  v_existeDonneeDex boolean;
  v_eventDexPrec VARCHAR(100);
  v_cleSecondaireDex VARCHAR(300);
  v_cle1SecondaireMP VARCHAR(100);
  v_cle2SecondaireMP VARCHAR(100);
  v_cle3SecondaireMP VARCHAR(100);
  v_action_acr varchar2(3);
  v_event_sans_acr MP_MAPPING_EVENT_DATA.EVENT%TYPE; 
  v_condition_acr_old_vide CLOB;
  v_condition_acr_new_vide CLOB;
  v_condition_donnee CLOB;
  v_condition_donnee_sql CLOB;
  -- Ce tableau indexé contient l'association entre un couple NOM_DONNEE/EVENT et le SOUS_EVENT à générer
  TYPE T_MAPPING_SPECIF_SOUS_EVENT IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(150);
  mappingSubEventByEventAndData T_MAPPING_SPECIF_SOUS_EVENT;
  -- Ce tableau indexé contient l'association entre un SOUS_EVENT et le IF qui conditionne sa génération
  TYPE T_SUB_EVENT_CONDITION IS TABLE OF CLOB INDEX BY VARCHAR2(100);
  subEventToGenWithCond T_SUB_EVENT_CONDITION;
  subEventToGen VARCHAR2(100);
  -- Ce tableau indexé contient l'association entre un EVENT et la liste des SOUS_EVENT de cet EVENT, et le IF qui conditionne sa génération
  TYPE T_SUB_EVENT_CONDITION_BY_EVENT IS TABLE OF T_SUB_EVENT_CONDITION INDEX BY VARCHAR2(100);
  subEventToGenWithCondByEvent T_SUB_EVENT_CONDITION_BY_EVENT;
  -- Ce tableau indexé contient l'association entre un couple EVENT(de type ACR)/CONDITION et la clause SQL de cette condition
  TYPE T_CONDITION_EVENT_ACR IS TABLE OF CLOB INDEX BY VARCHAR2(4000);
  conditionForEventAcr T_CONDITION_EVENT_ACR;

  CURSOR cur_donneesDex IS
    SELECT DISTINCT DMED.EVENT, RDMU.NOM_DONNEE, RDMU.CONDITION, DMED.NOM_DONNEE_DEX_OU_EVENT, LTRIM(REGEXP_SUBSTR(DMED.EVENT, '\.[acr]{1,3}$'),'.') ACTION_ACR, REGEXP_REPLACE(DMED.EVENT, '\.[acr]{1,3}$','') EVENT_SANS_ACR, UTC.DATA_TYPE 
    FROM MP_MAPPING_EVENT_DATA DMED, REF_DONNEE_MAPPING_UX RDMU, REF_DONNEE_GENERALE RDG, USER_TAB_COLS UTC 
    WHERE 
      UTC.COLUMN_NAME=RDMU.NOM_DONNEE AND UTC.TABLE_NAME=NOM_TABLE 
      AND DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX 
      AND RDMU.NOM_DONNEE=RDG.NOM_DONNEE 
      AND DMED.UTILISE_TRIGGER='O' 
      AND DMED.TYPE='D' 
      AND RDG.NOM_DICTIONNAIRE=NOM_TABLE 
    ORDER BY DMED.EVENT, RDMU.NOM_DONNEE;
  lig_donneeDex cur_donneesDex%rowtype;
  vFunctionCompare VARCHAR2(10);
  vFunctionCompareParam3 VARCHAR2(50);

  CURSOR cur_eventsDex IS
    SELECT DISTINCT DMED.EVENT, RDMU.CONDITION, LTRIM(REGEXP_SUBSTR(DMED.EVENT, '\.[acr]{1,3}$'),'.') ACTION_ACR, REGEXP_REPLACE(DMED.EVENT, '\.[acr]{1,3}$','') EVENT_SANS_ACR 
    FROM MP_MAPPING_EVENT_DATA DMED, REF_DONNEE_MAPPING_UX RDMU, REF_DONNEE_GENERALE RDG 
    WHERE 
      DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX 
      AND RDMU.NOM_DONNEE=RDG.NOM_DONNEE 
      AND DMED.UTILISE_TRIGGER='O' 
      AND DMED.TYPE='D' 
      AND RDG.NOM_DICTIONNAIRE=NOM_TABLE;
  lig_eventDex cur_eventsDex%rowtype;

  CURSOR cur_subEventsDex IS
    SELECT NOM_DONNEE, EVENT, SOUS_EVENT
    FROM MP_SPECIF_MAP_SOUS_EVENT_DATA
    WHERE 
      NOM_DONNEE IN (
        SELECT COLUMN_NAME 
        FROM USER_TAB_COLS 
        WHERE TABLE_NAME=NOM_TABLE
      );
  lig_subEventDex cur_subEventsDex%rowtype;

BEGIN

  BEGIN EXECUTE_IMMEDIATE_STRING( 'DROP PROCEDURE CHECK_MP_NOTIF_'||NOM_TABLE,0); EXCEPTION WHEN OTHERS THEN NULL; END;

  -- On vérifie si la table va générer des évènements pour DEX (au moins une donnée mappée, ou dictionnaire DIC_ADM_CONTRAT qui gère l'embauche et le départ)
  v_existeDonneeDex := false;
  IF nom_table='DIC_ADM_CONTRAT' THEN
    v_existeDonneeDex := TRUE;
  ELSE
    OPEN cur_donneesDex;
    LOOP FETCH cur_donneesDex INTO lig_donneeDex ;
      EXIT WHEN cur_donneesDex%NOTFOUND OR v_existeDonneeDex;
      v_existeDonneeDex := true;
    END LOOP;
    CLOSE cur_donneesDex;
  END IF;

  IF NOT v_existeDonneeDex THEN
    RETURN NULL;
  END IF;

  v_retour := 'CREATE OR REPLACE PROCEDURE CHECK_MP_NOTIF_'||NOM_TABLE||'(v_ligOld '||NOM_TABLE||'%ROWTYPE, v_ligNew '||NOM_TABLE||'%ROWTYPE) IS 
 v_matric VARCHAR2(32);
 v_paiezad VARCHAR2(8);
 v_dexaction varchar2(1);
 v_dexCleSecondaire VARCHAR2(100);
 exist_contrat_for_matric NUMBER ;
 TYPE eventsTabType is  table of MP_EVENTS%ROWTYPE ;
 eventsTab eventsTabType := eventsTabType();
 TYPE subEventsTabType is  table of MP_SPECIF_SOUS_EVENT%ROWTYPE ;
 subEventsTab subEventsTabType := subEventsTabType();
 v_processEventDex boolean;
 v_processEventDexTypeAcr varchar2(3);
 v_toutesLesNouvelleValVides boolean;
 v_toutesLesAnciennesValVides boolean;
BEGIN
';

  v_typeTable := fsed.getTypeTable(NOM_TABLE);

  date_eff_exists := 0;
  IF nom_table = 'DIC_ADM_PERSO_HISTO' OR nom_table = 'DIC_ADM_CONTRAT_HISTO' THEN
    date_eff_exists := 1;
  ELSIF nom_table <> 'DIC_ADM_PERSO' AND nom_table <> 'DIC_ADM_CONTRAT' THEN
    SELECT COUNT(*)
    INTO date_eff_exists
    FROM user_tab_cols
    WHERE column_name     = 'DATE_EFF'
    AND table_name        = NOM_TABLE;
  END IF;

  -- Au moins une donnée DEX = on va vérifier si le traitement pour DEX doit être effectué
  IF nom_table = 'DIC_ADM_CONTRAT_HISTO' THEN
    -- Date d'effet = traitement DEX seulement si modification à date du jour ou dans le futur (à revoir pour DACH ?)
    v_retour := v_retour||' 
IF (DELETING AND TRUNC(SYSDATE,''dd'') > v_ligOld.DATE_FIN) OR (NOT DELETING AND TRUNC(SYSDATE,''dd'') > v_ligNew.DATE_FIN) THEN
 RETURN;
END IF;
';
  ELSIF date_eff_exists>0 THEN
    -- Date d'effet = traitement DEX seulement si modification à date du jour ou dans le futur
    v_retour := v_retour||' 
IF TRUNC(SYSDATE,''dd'') > nvl(v_ligNew.DATE_FIN,v_ligOld.DATE_FIN) THEN
 RETURN;
END IF;
';
  END IF;

    v_retour := v_retour||' 
v_matric := NVL(v_ligNew.MATRIC,v_ligOld.MATRIC); ';

  -- Si traitement DEX sur une table de type PAIEZAD ou PACMAT, si on n'a pas de MATRIC, on le récupère
  IF v_typeTable ='z' THEN
    v_retour := v_retour||' 
IF v_matric IS NULL THEN
 IF DELETING THEN
  v_paiezad := v_ligOld.PAIEZAD;
 ELSE
  v_paiezad := v_ligNew.PAIEZAD;
 END IF;
 SELECT MAX(MATRIC) INTO v_matric FROM DIC_ADM_CONTRAT_SITU WHERE NUMPAC=nvl(v_ligNew.NUMPAC,v_ligOld.NUMPAC) AND PAIEZAD=v_paiezad; 
END IF;
';
  ELSIF v_typeTable ='p' THEN
    v_retour := v_retour||' 
IF v_matric IS NULL THEN
 BEGIN
  SELECT MATRIC INTO v_matric FROM SECUPACMAT WHERE NUMPAC=nvl(v_ligNew.NUMPAC,v_ligOld.NUMPAC) AND PACMAT=nvl(v_ligNew.PACMAT,v_ligOld.PACMAT);
 EXCEPTION 
  WHEN NO_DATA_FOUND THEN NULL; 
 END;
END IF;
';
  END IF;

  -- Le traitement en lui-même : certains évènements nécessitent d'avoir une clé secondaire spécifique, sinon on positionne '*'
  v_cleSecondaireDex := '''*''';

  -- On boucle sur les données générant un sous-événement (paramétrage spécifique)
  OPEN cur_subEventsDex;
  LOOP FETCH cur_subEventsDex INTO lig_subEventDex ;
    EXIT WHEN cur_subEventsDex%NOTFOUND;
    mappingSubEventByEventAndData(lig_subEventDex.NOM_DONNEE||'#'||lig_subEventDex.EVENT) := lig_subEventDex.SOUS_EVENT;
  END LOOP;
  CLOSE cur_subEventsDex;

  -- On boucle sur les données de l'évènement afin de calculer la CLE_SECONDAIRE si besoin 
  -- On en profite pour construire une partir du code de la partie UPDATING
  OPEN cur_donneesDex;
  LOOP FETCH cur_donneesDex INTO lig_donneeDex ;
    IF v_eventDexPrec IS NULL AND cur_donneesDex%NOTFOUND THEN
      PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
NULL;
';
    ELSIF v_eventDexPrec IS NOT NULL AND (cur_donneesDex%NOTFOUND OR NOT v_eventDexPrec=lig_donneeDex.EVENT) THEN
      -- Dernière donnée pour l'event
      PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
-- gestion evenement dex ' || v_eventDexPrec || '
v_processEventDex := FALSE; 
';

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF FALSE THEN -- DEBUT v_ligNew<>v_ligOld
 NULL; '||PROC_DEX_UPDATING_TMP||' 
END IF; -- FIN v_ligNew<>v_ligOld
';

      conditionForEventAcr(v_eventDexPrec||'#'||v_condition_donnee||'#OLD') := v_condition_acr_old_vide;
      conditionForEventAcr(v_eventDexPrec||'#'||v_condition_donnee||'#NEW') := v_condition_acr_new_vide;

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF v_processEventDex THEN
';

      IF v_action_acr IS NULL THEN
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
eventsTab.EXTEND ;
eventsTab(eventsTab.LAST).EVENT :='''||v_eventDexPrec||''';
eventsTab(eventsTab.LAST).ACTION :=''M'';
';
      ELSE
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
v_toutesLesAnciennesValVides := '||v_condition_acr_old_vide||v_condition_donnee_sql||';
v_toutesLesNouvelleValVides := '||v_condition_acr_new_vide||v_condition_donnee_sql||';
IF FALSE THEN
 v_processEventDex := FALSE; 
';
        IF INSTR(v_action_acr,'a') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF v_toutesLesAnciennesValVides AND NOT v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.add''; -- gestion add
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'a'

        IF INSTR(v_action_acr,'c') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF NOT v_toutesLesAnciennesValVides AND NOT v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.change''; -- gestion change
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'c'

        IF INSTR(v_action_acr,'r') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF NOT v_toutesLesAnciennesValVides AND v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.remove'';  -- gestion remove
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'r'

        PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
ELSE
 v_processEventDex := FALSE;
END IF;
';
      END IF; -- FIN v_action_acr IS NULL

      -- On boucle sur les sous-événements à générer (paramétrage spécifique)
      subEventToGen := subEventToGenWithCond.first;
      LOOP
        EXIT WHEN subEventToGen IS NULL;
        -- On concatène la condition, puis le sous-événements (si la condition est vérifiée)
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF v_processEventDex AND '; 

        PROC_DEX_UPDATING := PROC_DEX_UPDATING||' ('||subEventToGenWithCond(subEventToGen)||') ';

        PROC_DEX_UPDATING := PROC_DEX_UPDATING||' THEN 
 subEventsTab.EXTEND;
 subEventsTab(subEventsTab.LAST).EVENT := eventsTab(eventsTab.LAST).EVENT; 
 subEventsTab(subEventsTab.LAST).SOUS_EVENT :='''||subEventToGen||''';
END IF; -- FIN test génération sous-événement
';
        subEventToGen := subEventToGenWithCond.next(subEventToGen);
      END LOOP;

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
END IF; -- FIN v_processEventDex
';

      -- On vide le tableau pour recommencer un nouvel événément (on le sauvegarde avant, en l'associant à l'event)
      subEventToGenWithCondByEvent(v_eventDexPrec) := subEventToGenWithCond;
      subEventToGenWithCond.delete;
    END IF;

    -- Traitement spécifique à certains évènements qui stocke une CLE_SECONDAIRE
    IF nom_table ='DIC_ADM_CONTRAT' THEN
      -- Si le nom de table est DIC_ADM_CONTRAT on stocke la date de début de contrat (DSDCN) dans la colonne CLE_SECONDAIRE 
      v_cleSecondaireDex := '''DSDCN;'' || TO_CHAR(nvl(v_ligNew.DSDCN, v_ligOld.DSDCN), ''YYYY-MM-DD'')';

    ELSIF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
      -- Si le nom de table est DIC_ADM_CONTRAT_HISTO on stocke la date d'effet (DATE_EFF) dans la colonne CLE_SECONDAIRE 
      v_cleSecondaireDex := '''DATE_EFF;''|| TO_CHAR(nvl(v_ligNew.DATE_EFF, v_ligOld.DATE_EFF), ''YYYY-MM-DD'')';

    END IF;

    EXIT WHEN cur_donneesDex%NOTFOUND;

    IF v_eventDexPrec IS NULL OR NOT v_eventDexPrec=lig_donneeDex.EVENT THEN
      -- Première donnée pour l'event
      v_action_acr := lig_donneeDex.ACTION_ACR;
      v_event_sans_acr := lig_donneeDex.EVENT_SANS_ACR;
      PROC_DEX_UPDATING_TMP := NULL;
      v_condition_acr_old_vide := null;
      v_condition_acr_new_vide := null;
    END IF;

    -- Traitement spécifique à certains évènements qui stocke une CLE_SECONDAIRE
    IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'precedenceOrdCompteBancaire' THEN
      -- BANQUE : On parcourt les données de l'event et trouver celle qui correspond à la cle dont on a besoin
      v_cleSecondaireDex := 'nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';
      
     -- PERSONAL CONTACT : La clé secondaire pour les contacts d'urgence est composée de 3 éléments à mettre dans un certain ordre : rankEmergency;familyName1Emergency;givenNameEmergency   
    ELSIF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'rankEmergency' THEN
      v_cle1SecondaireMP := 'nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';
    
    ELSIF  lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'familyName1Emergency'  THEN
      v_cle2SecondaireMP := 'nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';
    
    ELSIF  lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'givenNameEmergency'  THEN
       v_cle3SecondaireMP := 'nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';
       
    ELSIF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentConjointBirthOrder' THEN
      -- CONJOINT : Dans le cas où une donnée 'dependentConjointBirthOrder' a été paramétrée, 
      -- c'est cette valeur qui va être prise
      v_cleSecondaireDex := '''C;''||nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';

    ELSIF INSTR(lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT, 'dependentConjoint') = 1 AND INSTR(v_cleSecondaireDex, 'C;') = 0 THEN
      -- CONJOINT : La première fois que l'on trouve une donnée commençant par 'dependentConjoint', on positionne la clé secondaire
      -- avec comme valeur "01" pour le "BirthOrder"
      v_cleSecondaireDex := '''C;01''';

    ELSIF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' OR lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthDate' THEN
      -- ENFANT : La clé secondaire pour les enfants est composée de 2 éléments à mettre dans un certain ordre : E;BirthOrder;BirthDate
      IF v_cleSecondaireDex = '''*''' THEN
        IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' THEN
          v_cleSecondaireDex := '''E;''||nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')';
        ELSE
          v_cleSecondaireDex := '||TO_CHAR(nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||'), ''YYYY-MM-DD'')';
        END IF;
      ELSE
        IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' THEN
          v_cleSecondaireDex := '''E;''||nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||')||'';''' || v_cleSecondaireDex;
        ELSE
          v_cleSecondaireDex := v_cleSecondaireDex || '||'';''||TO_CHAR(nvl(v_ligNew.'||lig_donneeDex.NOM_DONNEE||', v_ligOld.'||lig_donneeDex.NOM_DONNEE||'), ''YYYY-MM-DD'')';
        END IF;
      END IF;
    END IF;

    vFunctionCompare := 'IS_EQ';
    vFunctionCompareParam3 := NULL;
    IF lig_donneeDex.data_type = 'DATE' THEN
      vFunctionCompare := 'IS_EQ_DATE';
      vFunctionCompareParam3 := ',''yyyymmddhh24miss''';
    END IF;
    PROC_DEX_CONDITION := ' NOT '||vFunctionCompare||'(v_ligNew.'||lig_donneeDex.NOM_DONNEE||',v_ligOld.'||lig_donneeDex.NOM_DONNEE||vFunctionCompareParam3||') ';
    v_condition_donnee_sql := '1=1';
    v_condition_donnee := lig_donneeDex.CONDITION;
    IF v_condition_donnee IS NOT NULL THEN
      v_condition_donnee_sql := regexp_replace(regexp_replace(v_condition_donnee, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(v_ligNew.\1,v_ligOld.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(v_ligNew.\2,v_ligOld.\2)=\1');
      PROC_DEX_CONDITION := PROC_DEX_CONDITION||' AND '||v_condition_donnee_sql;
    END IF;

    PROC_DEX_UPDATING_TMP :=PROC_DEX_UPDATING_TMP||'
ELSIF '||PROC_DEX_CONDITION||' THEN
v_processEventDex := TRUE;';

    v_condition_acr_old_vide := v_condition_acr_old_vide||'v_ligOld.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND ';
    v_condition_acr_new_vide := v_condition_acr_new_vide||'v_ligNew.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND ';

    IF mappingSubEventByEventAndData.exists(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT) THEN
      IF NOT subEventToGenWithCond.exists(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) THEN
        subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) := '1=2';
      END IF;
      subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) := subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT))||' OR ('||PROC_DEX_CONDITION||') ';
    END IF;

    v_eventDexPrec:=lig_donneeDex.EVENT;
  END LOOP;
  CLOSE cur_donneesDex;

  IF v_cle1SecondaireMP IS NOT NULL AND v_cle2SecondaireMP IS NOT NULL AND v_cle3SecondaireMP IS NOT NULL THEN
    v_cleSecondaireDex := v_cle1SecondaireMP||'||'';''||'||v_cle2SecondaireMP||'||'';''||'||v_cle3SecondaireMP ;   
  END IF ;

  v_retour := v_retour||' 
v_dexCleSecondaire := '||v_cleSecondaireDex||';
eventsTab.delete;
subEventsTab.delete;
';

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- Pour DIC_ADM_CONTRAT_HISTO, pas de particularité
    NULL;
  ELSIF nom_table   ='DIC_ADM_CONTRAT' THEN
    -- Pour DIC_ADM_CONTRAT, on gère en spécifique 
    -- - La création --> Evènement worker.hire ou worker.rehire
    -- - La suppression --> Evènement worker.workAssignment.terminate
    -- - La mise à jour de DSFCN --> Evènement worker.workAssignment.terminate (ou autre pour la modification ou l'annulation de départ ???)
    v_retour := v_retour||' 
IF INSERTING THEN
 -- On vérifie si c''est une embauche ou bien réembauche : s''il existe déja  un contrat pour le MATRIC c''est un réembauche. 
 exist_contrat_for_matric := COUNT_CONTRAT_HORS_TRANSAC ( v_matric ) ;
 IF exist_contrat_for_matric>0 THEN
  -- Réembauche  --> Evénement worker.rehire
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.rehire'';
  eventsTab(eventsTab.LAST).ACTION :=''Z''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligNew.DSDCN;
 ELSE
  --  Embauche -->  Evénement worker.hire
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.hire'';
  eventsTab(eventsTab.LAST).ACTION :=''Z''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligNew.DSDCN;
 END IF ;
ELSIF DELETING THEN
 exist_contrat_for_matric := COUNT_CONTRAT_HORS_TRANSAC ( v_matric ) ;
 IF exist_contrat_for_matric>1 THEN
  -- Annulation Réembauche  --> Evénement workerRehire.cancel 
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerRehire.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligOld.DSDCN;
 ELSE
  -- Annulation Embauche -->  Evénement workerHire.cancel
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerHire.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligOld.DSDCN;
 END IF ;
ELSIF NOT IS_EQ_DATE(v_ligNew.DSFCN,v_ligOld.DSFCN) THEN
 IF v_ligNew.DSFCN IS NOT NULL AND v_ligOld.DSFCN IS NULL THEN
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.workAssignment.terminate'';
  eventsTab(eventsTab.LAST).ACTION :=''M''; 
  -- On n''envoie le départ que le jour où il devient effectif
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligNew.DSFCN;
 ELSIF v_ligNew.DSFCN<>v_ligOld.DSFCN THEN 
  -- mise à jour de DSFCN --> EVENEMENT worker.workerTerminationDate.change
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.workerTerminationDate.change'';
  eventsTab(eventsTab.LAST).ACTION :=''M'';
  -- On garde la date de départ initiale comme date d''envoi de la notif, comme ça le partenaire aura le départ et la modif de départ en même temps
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligOld.DSFCN;
 ELSIF v_ligNew.DSFCN IS NULL AND v_ligOld.DSFCN IS NOT NULL THEN
 -- Annulation Départ --> EVENEMENT workerTermination.cancel 
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerTermination.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  -- On garde la date de départ initiale comme date d''envoi de la notif, comme ça le partenaire aura le départ et l''annulation de départ en même temps
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=v_ligOld.DSFCN;
 ELSE
  NULL;
 END IF;
ELSE
';
  ELSE
    -- Partie insert pour les autres tables
    -- Pour les autres tables, en création et suppression, on insère une ligne par évènement potentiellement généré par la table, avec le bon code action
    v_retour := v_retour||' 
-- DEBUT INSERTING / DELETING
IF INSERTING OR DELETING THEN
 IF INSERTING THEN
  v_dexaction := ''C'';
 ELSE
  v_dexaction := ''S'';
 END IF;
';

    OPEN cur_eventsDex;
    LOOP FETCH cur_eventsDex INTO lig_eventDex ;
      EXIT WHEN cur_eventsDex%NOTFOUND;
      v_retour := v_retour||'-- gestion evenement dex ' || lig_eventDex.EVENT || '
';
      v_action_acr := lig_eventDex.ACTION_ACR;
      v_condition_donnee_sql := '1=1';
      IF lig_eventDex.CONDITION IS NOT NULL THEN
        v_condition_donnee_sql := regexp_replace(regexp_replace(lig_eventDex.CONDITION, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(v_ligNew.\1,v_ligOld.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(v_ligNew.\2,v_ligOld.\2)=\1');
        v_retour := v_retour||'
IF '||v_condition_donnee_sql||' THEN
';
      END IF;

      v_retour := v_retour||'
v_processEventDex := FALSE;
v_toutesLesAnciennesValVides := '||conditionForEventAcr(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#OLD')||'1=1;
v_toutesLesNouvelleValVides := '||conditionForEventAcr(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#NEW')||'1=1;
';
      IF v_action_acr IS NULL THEN
        v_retour := v_retour||'
IF (INSERTING AND NOT v_toutesLesNouvelleValVides) OR (DELETING AND NOT v_toutesLesAnciennesValVides) THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT :='''||lig_eventDex.EVENT||''';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction;
END IF; 
';
      ELSIF conditionForEventAcr.exists(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#OLD') THEN
        v_retour := v_retour||'
IF FALSE THEN NULL; 
';

        IF INSTR(v_action_acr,'a') > 0 THEN
          v_retour := v_retour||'
ELSIF INSERTING AND NOT v_toutesLesNouvelleValVides THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := '''||lig_eventDex.EVENT_SANS_ACR||'.add'';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction; 
';
        END IF; -- FIN v_action_acr = 'a'

        IF INSTR(v_action_acr,'r') > 0 THEN
          v_retour := v_retour||'
ELSIF DELETING AND NOT v_toutesLesAnciennesValVides THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := '''||lig_eventDex.EVENT_SANS_ACR||'.remove'';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction; 
';
        END IF; -- FIN v_action_acr = 'r'

        v_retour := v_retour||'
END IF;
';
      END IF;

      IF lig_eventDex.CONDITION IS NOT NULL THEN
        v_retour := v_retour||'
END IF; -- FIN '||v_condition_donnee_sql||'
';
      END IF;

      IF subEventToGenWithCondByEvent.exists(lig_eventDex.EVENT) THEN
        subEventToGenWithCond := subEventToGenWithCondByEvent(lig_eventDex.EVENT);
        -- On boucle sur les sous-événements à générer (paramétrage spécifique) pour l'événement courant
        subEventToGen := subEventToGenWithCond.first;
        LOOP
          EXIT WHEN subEventToGen IS NULL;
          -- On concatène la condition, puis le sous-événements (si la condition est vérifiée)
          v_retour := v_retour||'
IF v_processEventDex AND ('||subEventToGenWithCond(subEventToGen)||') THEN
 subEventsTab.EXTEND;
 subEventsTab(subEventsTab.LAST).EVENT := eventsTab(eventsTab.LAST).EVENT; 
 subEventsTab(subEventsTab.LAST).SOUS_EVENT :='''||subEventToGen||''';
END IF;
';
          subEventToGen := subEventToGenWithCond.next(subEventToGen);
        END LOOP;
      END IF;
    END LOOP;
    CLOSE cur_eventsDex;
    v_retour := v_retour||'
-- FIN INSERTING / DELETING
ELSE -- DEBUT UPDATING
 v_dexaction := ''M'';
';
  END IF;
  -- Début de l'updating commun à toutes les tables

  v_eventDexPrec := NULL;
  -- On rajoute ce qui a été calculé plus haut
  v_retour := v_retour||PROC_DEX_UPDATING;

  IF NOT nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- Pour DIC_ADM_CONTRAT_HISTO, il n'y a pas de gros IF qui encadre les tests de génération de notif
    v_retour := v_retour||'
END IF; -- FIN UPDATING
';
  END IF;

  v_retour := v_retour||' 
 IF eventsTab.count>0 THEN
  for i in 1..eventsTab.count loop
';

  IF nom_table = 'DIC_ADM_CONTRAT_HISTO' THEN
    v_retour := v_retour||' 
IF DELETING THEN
 eventsTab(i).DATE_ENVOI_MIN :=v_ligOld.DATE_EFF;
ELSE
 eventsTab(i).DATE_ENVOI_MIN :=v_ligNew.DATE_EFF;
END IF;
';
  ELSIF date_eff_exists>0 THEN
    v_retour := v_retour||' 
eventsTab(i).DATE_ENVOI_MIN :=NVL(v_ligNew.DATE_EFF,v_ligOld.DATE_EFF);
';
  END IF;

  v_retour := v_retour||' 
   MERGE INTO MP_EVENTS DE 
    USING (SELECT v_matric AS MATRIC,eventsTab(i).EVENT AS EVENT, v_dexCleSecondaire AS CLE_SECONDAIRE FROM DUAL) Z 
    ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT AND Z.CLE_SECONDAIRE=DE.CLE_SECONDAIRE)
    WHEN MATCHED THEN UPDATE SET ACTION=eventsTab(i).ACTION,DATE_MODIF=CURRENT_TIMESTAMP,DATE_ENVOI_MIN=eventsTab(i).DATE_ENVOI_MIN
    WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,CLE_SECONDAIRE,ACTION,DATE_MODIF,DATE_ENVOI_MIN) VALUES (v_matric,eventsTab(i).EVENT,v_dexCleSecondaire,eventsTab(i).ACTION,CURRENT_TIMESTAMP,eventsTab(i).DATE_ENVOI_MIN);
  end loop;
 END IF; -- FIN eventsTab.count>0

 IF subEventsTab.count>0 THEN
  for i in 1..subEventsTab.count loop
   MERGE INTO MP_SPECIF_SOUS_EVENT DE 
    USING (SELECT v_matric AS MATRIC, subEventsTab(i).EVENT AS EVENT, v_dexCleSecondaire AS CLE_SECONDAIRE, subEventsTab(i).SOUS_EVENT AS SOUS_EVENT FROM DUAL) Z 
    ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT AND Z.CLE_SECONDAIRE=DE.CLE_SECONDAIRE AND Z.SOUS_EVENT=DE.SOUS_EVENT)
    WHEN MATCHED THEN UPDATE SET DATE_MODIF=CURRENT_TIMESTAMP, STATUT_TRT=NULL, DATE_TRT=NULL
    WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,CLE_SECONDAIRE,SOUS_EVENT,DATE_MODIF) VALUES (v_matric,subEventsTab(i).EVENT,v_dexCleSecondaire,subEventsTab(i).SOUS_EVENT,CURRENT_TIMESTAMP);
  end loop;
 END IF; -- FIN subEventsTab.count>0
';

  v_retour := v_retour||'
END CHECK_MP_NOTIF_'||NOM_TABLE||';';

EXECUTE_IMMEDIATE_STRING( v_retour,0);

  v_retour :=  '
-- DEBUT TRAITEMENT DEX
IF v_type_writer<>''M'' THEN
 CHECK_MP_NOTIF_'||NOM_TABLE||'(v_ligOld, v_ligNew);
END IF;
-- FIN TRAITEMENT DEX';
 
  return v_retour;
END TGE_CREATE_TRIGGER_MP_NOTIF;
##
TAG_CHARSET=@€éèç
##
TGE_CREATE_TRIGGER_RECYCLAGE
=SQL=
CREATE OR REPLACE FUNCTION TGE_CREATE_TRIGGER_RECYCLAGE(NOM_TABLE IN VARCHAR2)
RETURN CLOB
AS
  v_retour CLOB;

  v_typeTable VARCHAR(1);
  date_eff_exists NUMBER;
  nom_col_date_test_recycl VARCHAR2(30);
  condition CLOB;

  CURSOR cur_mapdo IS
    SELECT LISTAGG(numpac,',') WITHIN GROUP (ORDER BY numpac) as numpacs, donneegxp, data_type from (
      with donnees_paie (numpac, donneegxp, tablegxp, data_type) as (
        SELECT numpac, donneegxp, tablegxp, data_type
        FROM TGE_REF_MAPDO_RESOLVED,user_tab_cols
        WHERE 
          column_name=donneegxp and table_name=nom_table and
          TABLEGXP IN (
            SELECT tableparam
            FROM tge_ref_mapta
            WHERE 
              tablephy = nom_table
              --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_REF_MAPDO
              --Ajout du type 'I'
              AND allerretour IN ('A','2','I')
              -- les occurences !! sont désactivés 
              AND tge_ref_mapdo_resolved.occurence != '!!'
          )
        UNION 
        SELECT numpac,donneegxp,(select min(tableparam) from tge_ref_mapta where tablephy = nom_table) as tablegxp,data_type 
        FROM TABLE(GET_GXP_TRT_PARTICULIER_DATAS(nom_table)),user_tab_cols
        WHERE 
          column_name=donneegxp and table_name=nom_table
      )
      SELECT distinct 
        case when not exists (select 1 from tge_ref_pac where numpac not in (select numpac from donnees_paie m where donneegxp=t.donneegxp and TABLEGXP=t.TABLEGXP)) then '*' else numpac end as numpac
        , donneegxp, data_type
      from donnees_paie t
    )
    GROUP BY donneegxp, data_type
    ORDER BY donneegxp;
  lig_mapdo cur_mapdo%rowtype;
  vFunctionCompare VARCHAR2(10);
  vFunctionCompareParam3 VARCHAR2(50);

BEGIN

  BEGIN EXECUTE_IMMEDIATE_STRING( 'DROP PROCEDURE CHECK_RECYCLAGE_'||NOM_TABLE,0); EXCEPTION WHEN OTHERS THEN NULL; END;

  v_retour := NULL;
  v_typeTable := fsed.getTypeTable(NOM_TABLE);

  date_eff_exists := 0;
  nom_col_date_test_recycl := NULL;
  IF nom_table='DIC_ADM_CONTRAT' THEN
    -- Pour DIC_ADM_CONTRAT c'est DSDCN qui fera office de DATE_EFF pour tester s'il faut mettre en recyclage
    nom_col_date_test_recycl := 'DSDCN';
  ELSE
    SELECT COUNT(*)
    INTO date_eff_exists
    FROM user_tab_cols
    WHERE column_name     = 'DATE_EFF'
    AND table_name        = NOM_TABLE;
    IF date_eff_exists>0 THEN
      nom_col_date_test_recycl := 'DATE_EFF';
    END IF;
  END IF;

  v_retour := 'CREATE OR REPLACE PROCEDURE CHECK_RECYCLAGE_'||NOM_TABLE||'(v_ligOld '||NOM_TABLE||'%ROWTYPE, v_ligNew IN OUT '||NOM_TABLE||'%ROWTYPE, v_numpac IN OUT VARCHAR2, v_pacmat IN OUT VARCHAR2, v_paiezad IN OUT VARCHAR2, tabRefPacByNumpac IN OUT ALIM_IDX.T_REF_PAC_BY_NUMPAC) IS 
 v_matric VARCHAR2(32);
type pacmats IS record (R_numpac VARCHAR2(6), R_pacmat VARCHAR2(8), R_periode_recycl number); 
TYPE TAB_pacmats IS TABLE OF pacmats INDEX BY binary_integer; 
tab TAB_pacmats; 
v_recycl varchar2(1); 
v_periode_recycl number; 
v_error_periode_recycl_3 number; 
v_retro VARCHAR2(1); 
v_nbOccForCnt number;
';

  IF nom_col_date_test_recycl IS NOT NULL THEN
    v_retour := v_retour||'
date_test_recycl DATE;
';
  END IF;

    v_retour := v_retour||'
BEGIN
 v_matric := NVL(v_ligNew.MATRIC,v_ligOld.MATRIC); ';

  -- Récupération du numpac si besoin
  IF v_typeTable = 'z' THEN
    v_retour := v_retour||' 
SELECT DISTINCT D.numpac as R_numpac, 
D.pacmat as R_pacmat, 
T.PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM DIC_ADM_CONTRAT_SITU D ,SECUPACMAT T 
WHERE D.NUMPAC=v_numpac AND D.PAIEZAD=v_paiezad AND D.NUMPAC=T.NUMPAC AND D.PACMAT=T.PACMAT;';
  elsif v_typeTable = 'm' THEN
    v_retour := v_retour||' 
SELECT numpac as R_numpac, 
pacmat as R_pacmat , 
PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM SECUPACMAT 
WHERE matric=v_matric;';
  elsif v_typeTable = 'p' THEN
    v_retour := v_retour||' 
SELECT numpac as R_numpac, 
pacmat as R_pacmat , 
PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM SECUPACMAT 
WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat;';
  END IF;

  v_retour := v_retour||'
if not tab.exists(1) then
 return;
end if;

v_retro := ''N'';
 FOR i IN 1..tab.last LOOP
  v_numpac:=tab(i).r_numpac;
   IF NOT v_numpac = ''TMPPAC'' THEN
    v_pacmat:=tab(i).r_pacmat;
    v_periode_recycl:=nvl(tab(i).R_periode_recycl,1);
';

  IF NOT nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- une valeur '3' dans PERIODE_RECYCLAGE retourne une erreur
    -- sauf en cas de réembauche (insertion dans DIC_ADM_CONTRAT et DIC_ADM_CONTRAT_HISTO)
    v_retour := v_retour||' IF v_periode_recycl = 3 THEN';
    IF nom_table ='DIC_ADM_CONTRAT' THEN
      v_retour := v_retour||'     IF UPDATING OR DELETING THEN';
    END IF;
    v_retour := v_retour||'     RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC02'');';
    IF nom_table ='DIC_ADM_CONTRAT' THEN
      v_retour := v_retour||'     END IF;';
    END IF;
    v_retour := v_retour||' END IF;';
  ELSE
    -- on positionne PERIODE_RECYCLAGE à '1' en cas de réembauche d'un salarié ayant une valeur '0' ou '3' dans PERIODE_RECYCLAGE et répondant aux critères suivants :
    -- - DRPAI2 est non-vide et différent de 'B'
    -- - NATCOL vaut 'SAL' ou 'STA'
    -- - DSDCN est antérieure ou égale à la période en cours
    v_retour := v_retour||'
IF v_periode_recycl IN (0,3) THEN
 IF v_periode_recycl = 3 THEN
  -- si PERIODE_RECYCLAGE vaut ''3'', on prévoit qu''il va falloir retourner une erreur (modification d''un contrat existant)
  v_error_periode_recycl_3 := 1;
 ELSE
  v_error_periode_recycl_3 := 0;
 END IF;
 IF INSERTING THEN
  -- insertion d''un historique de contrat : on vérifie s''il s''agit de la première occurrence du contrat (réembauche)
  v_nbOccForCnt := GET_NB_LIGNES(''DIC_ADM_CONTRAT_HISTO'', ''NUMPAC=''''''||v_ligNew.NUMPAC||'''''' AND PACMAT=''''''||v_ligNew.PACMAT||'''''' AND NUMCNT=''||v_ligNew.NUMCNT);
  IF v_nbOccForCnt = 0 THEN
   -- première occurrence du contrat (réembauche) : on ne retourne pas d''erreur, et, si PERIODE_RECYCLAGE = ''3'', on va réactiver le dossier
   IF v_periode_recycl = 3 THEN
    v_error_periode_recycl_3 := 0;
    v_ligNew.ZREACT := TO_DATE(TO_CHAR(v_ligNew.DATE_EFF,''yyyy'')||''0101'',''yyyymmdd'');
   END IF; -- FIN v_periode_recycl = ''3''
   -- vérification des critères pour positionner PERIODE_RECYCLAGE à ''1''
   IF CHECK_FORCAGE_RECYCLAGE(v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.NUMCNT, v_ligNew.DRPAI2, NULL) = 1 THEN
    -- OK pour PERIODE_RECYCLAGE = ''1''
    v_periode_recycl := 1;
   END IF; -- FIN CHECK_FORCAGE_RECYCLAGE
  END IF; -- FIN v_nbOccForCnt = 0
 ELSIF UPDATING THEN
  -- un update : on va vérifier si on doit réactiver le dossier
  IF UPDATING(''DRPAI2'') AND (NVL(v_ligOld.DRPAI2, ''B'') <> NVL(v_ligNew.DRPAI2, ''B'') AND (NVL(v_ligOld.DRPAI2, ''B'') =''B'' OR NVL(v_ligNew.DRPAI2, ''B'')=''B'')) THEN
   -- update de DRPAI2 pour déblocage paie : on ne retourne pas d''erreur, et on va réactiver le dossier
   v_error_periode_recycl_3 := 0;
   IF CHECK_FORCAGE_RECYCLAGE(v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.NUMCNT, v_ligNew.DRPAI2, NULL) = 1 THEN
    -- OK pour PERIODE_RECYCLAGE = ''1''
    v_periode_recycl := 1;
   END IF; -- FIN CHECK_FORCAGE_RECYCLAGE
  ELSIF UPDATING(''ZREACT'') AND v_ligOld.ZREACT IS NULL AND v_ligNew.ZREACT IS NOT NULL THEN
   -- update de ZREACT pour réactivation : si l''année de ZREACT est inférieure ou égale à l''année de la période en cours, on ne retourne pas d''erreur
   BEGIN
    IF NOT tabRefPacByNumpac.exists(v_ligNew.NUMPAC) THEN
     select * into tabRefPacByNumpac(v_ligNew.NUMPAC) from tge_ref_pac where numpac = v_ligNew.NUMPAC;
    END IF;
    IF TO_CHAR(v_ligNew.ZREACT,''yyyy'') <= SUBSTR(tabRefPacByNumpac(v_ligNew.NUMPAC).PERIODEENCOURS,1,4) THEN
     v_error_periode_recycl_3 := 0;
     IF CHECK_FORCAGE_RECYCLAGE(v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.NUMCNT, v_ligNew.DRPAI2, tabRefPacByNumpac(v_ligNew.NUMPAC).PERIODEENCOURS) = 1 THEN
      -- OK pour PERIODE_RECYCLAGE = ''1''
      v_periode_recycl := 1;
     END IF; -- FIN CHECK_FORCAGE_RECYCLAGE
    END IF; -- FIN ZREACT <= PERIODEENCOURS
   EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF; -- FIN UPDATING DRPAI2 ou ZREACT
 END IF; -- FIN INSERTING/UPDATING
 IF v_error_periode_recycl_3 = 1 THEN
  RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC02'');
 END IF;
END IF; -- FIN v_periode_recycl = 0 ou 3
';
  END IF;

  v_retour := v_retour||'
IF v_periode_recycl >= 10 THEN
 RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC01'');
ELSIF v_periode_recycl = 1 THEN
';

  -- on vérifie si des colonnes paies ont été modifié
  v_retour := v_retour||' v_recycl:=''N'';';
  IF nom_col_date_test_recycl IS NOT NULL THEN
    v_retour := v_retour||'
IF NOT tabRefPacByNumpac.exists(v_numpac) THEN
 select * into tabRefPacByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
END IF;
IF DELETING THEN
 date_test_recycl := v_ligOld.'||nom_col_date_test_recycl||';
ELSE
 date_test_recycl := v_ligNew.'||nom_col_date_test_recycl||';
END IF;
IF (NVL(TO_CHAR(date_test_recycl,''yyyymm''),''000000'') <= tabRefPacByNumpac(v_numpac).PERIODEENCOURS) THEN
';
  END IF;

  v_retour := v_retour||'
IF (INSERTING and v_ligOld.MATRIC IS NULL) OR (DELETING and v_ligNew.MATRIC IS NULL) THEN 
 -- En insertion, si on n''a pas récupéré de ''OLD'' (seulement dans le cas de DIC_ADM_CONTRAT_HISTO), on inscrit forcément en recyclage
 -- En suppression, si on n''a pas récupéré de ''NEW'' (seulement dans le cas de DIC_ADM_CONTRAT_HISTO), on inscrit forcément en recyclage
 v_recycl:=''O'';
ELSE 
  -- Sinon, on compare ''OLD'' et ''NEW''
';
  condition := NULL;
  OPEN cur_mapdo;
  LOOP FETCH cur_mapdo INTO lig_mapdo ;

    IF cur_mapdo%NOTFOUND AND condition IS NOT NULL THEN
      condition := condition||' 
END IF;';
    END IF;

    EXIT WHEN cur_mapdo%NOTFOUND;

    IF lig_mapdo.donneegxp IS NOT NULL THEN
      IF condition IS NOT NULL THEN
        condition := condition||' 
ELSIF ';
      ELSE
        condition := ' IF ';
        IF NOM_TABLE ='DIC_ADM_CONTRAT_HISTO' THEN
          condition := condition||' NVL(v_ligOld.DRPAI2, ''B'') <> NVL(v_ligNew.DRPAI2, ''B'') AND (NVL(v_ligOld.DRPAI2, ''B'') =''B'' OR NVL(v_ligNew.DRPAI2, ''B'')=''B'') THEN 
 v_recycl:=''O'';
ELSIF ';
        END IF;
      END IF;

      IF NOT lig_mapdo.numpacs = '*' THEN
        condition := condition||'INSTR('''||lig_mapdo.numpacs||''',v_numpac)>0 AND ';
      END IF;

      vFunctionCompare := 'IS_EQ';
      vFunctionCompareParam3 := NULL;
      IF lig_mapdo.data_type = 'DATE' THEN
        vFunctionCompare := 'IS_EQ_DATE';
        vFunctionCompareParam3 := ',''yyyymmddhh24miss''';
      END IF;
      condition := condition||' NOT '||vFunctionCompare||'(v_ligNew.'||lig_mapdo.donneegxp||',v_ligOld.'||lig_mapdo.donneegxp||vFunctionCompareParam3||') THEN
 v_recycl:=''O''; ';
    END IF;

  END LOOP;
  CLOSE cur_mapdo;

  IF condition IS NULL THEN
    RETURN NULL;
  END IF;

  v_retour := v_retour||condition;
  
  -- traitement du matricule pour recyclage
  v_retour := v_retour||'
END IF; -- FIN updating
IF v_recycl=''O'' THEN 
 MERGE INTO GAP_RECYCL_MATRIC a
  USING (SELECT v_numpac AS numpac,v_pacmat AS pacmat FROM dual) b
  ON (a.pacmat=b.pacmat AND a.numpac=b.numpac)
  WHEN NOT MATCHED THEN INSERT (a.numpac,a.pacmat) VALUES (b.numpac,b.pacmat);

 MERGE INTO TGE_MODIF_PACMAT_TORESEND a
  USING (SELECT v_numpac AS numpac,v_pacmat AS pacmat, '''||NOM_TABLE||''' as TABLE_TO_SEND FROM dual) b
  ON (a.pacmat=b.pacmat AND a.numpac=b.numpac and a.TABLE_TO_SEND=b.TABLE_TO_SEND)
  WHEN MATCHED THEN update set a.DATE_MAJ=sysdate 
  WHEN NOT MATCHED THEN INSERT (a.numpac,a.pacmat,a.TABLE_TO_SEND,a.DATE_MAJ) VALUES (b.numpac,b.pacmat,b.TABLE_TO_SEND, sysdate);
END IF; -- FIN v_recycl
';

  IF nom_col_date_test_recycl IS NOT NULL THEN
    v_retour := v_retour||' END IF; -- FIN test date recycl';
  END IF;
  v_retour := v_retour||'
END IF; -- FIN v_periode_recycl IN (''0'',''3'')
'|| TGE_CREATE_TRIGGER_RETRO(NOM_TABLE) ||'
END IF; -- FIN NOT v_numpac = ''TMPPAC''
END LOOP; -- FIN tab
END CHECK_RECYCLAGE_'||NOM_TABLE||';
';

  EXECUTE_IMMEDIATE_STRING( v_retour,0);

  v_retour := '
-- DEBUT TRAITEMENT RECYCLAGE
if v_type_writer<>''N'' AND v_type_writer<>''M'' THEN 
 CHECK_RECYCLAGE_'||NOM_TABLE||'(v_ligOld, v_ligNew, v_numpac, v_pacmat, v_paiezad, tabRefPacByNumpac); ';
  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    v_retour := v_retour || '
 IF INSERTING THEN 
  -- On récupère la valeur de ZREACT potentiellement mise à jour
  :NEW.ZREACT := v_ligNew.ZREACT; 
 END IF; ';
  END IF;
  v_retour := v_retour || '
end if;
-- FIN TRAITEMENT RECYCLAGE';
 
  return v_retour;
END TGE_CREATE_TRIGGER_RECYCLAGE;
##
TAG_CHARSET=@€éèç
##
TGE_CREATE_TRIGGER_RETRO
=SQL=
CREATE OR REPLACE FUNCTION TGE_CREATE_TRIGGER_RETRO(NOM_TABLE IN VARCHAR2)
RETURN CLOB
AS
  v_retour CLOB;

  champDateEffetRetro VARCHAR2(50);
  conditionRetro CLOB;
  procRetroPaiezadCodeChrono VARCHAR(4000);

  CURSOR cur_mapdoRetro IS
    SELECT LISTAGG(numpac,',') WITHIN GROUP (ORDER BY numpac) as numpacs, donneegxp, clause_date_eff_retro, data_type from (
      SELECT DISTINCT dz.numpac, md.donneegxp, REGEXP_REPLACE(mddr.clause_date_eff_retro,':(new|old)','v_lig\1',1,0,'i') as clause_date_eff_retro, utc.data_type
      FROM tge_ref_dicoz dz 
      INNER JOIN TGE_REF_MAPDO_RESOLVED md ON md.element = dz.element AND md.numpac = dz.numpac
      LEFT JOIN tge_ref_mapdo_dteff_retro mddr ON mddr.element = dz.element AND (mddr.numpac = dz.numpac OR (mddr.numpac = '*' AND NOT EXISTS (SELECT 1 FROM tge_ref_mapdo_dteff_retro zdr WHERE zdr.numpac= dz.numpac AND zdr.element = dz.element)))
      ,user_tab_cols utc
      WHERE 
        utc.column_name=md.donneegxp and utc.table_name=nom_table 
        and dz.calcul_retro = '1' 
        AND TABLEGXP IN (
          SELECT tableparam 
          FROM tge_ref_mapta 
          WHERE tablephy = NOM_TABLE
        )
    )
    GROUP BY donneegxp, clause_date_eff_retro, data_type
    ORDER BY donneegxp, clause_date_eff_retro;

  lig_mapdoRetro cur_mapdoRetro%rowtype;
  vFunctionCompare VARCHAR2(10);
  vFunctionCompareParam3 VARCHAR2(50);

BEGIN

  BEGIN EXECUTE_IMMEDIATE_STRING( 'DROP PROCEDURE CHECK_RETRO_'||NOM_TABLE,0); EXCEPTION WHEN OTHERS THEN NULL; END;

  v_retour := 'CREATE OR REPLACE PROCEDURE CHECK_RETRO_'||NOM_TABLE||'(v_ligOld '||NOM_TABLE||'%ROWTYPE, v_ligNew '||NOM_TABLE||'%ROWTYPE, v_numpac VARCHAR2, v_pacmat VARCHAR2, v_paiezad IN OUT VARCHAR2, v_retro IN OUT VARCHAR2, tabRefPacByNumpac IN OUT ALIM_IDX.T_REF_PAC_BY_NUMPAC) IS 
 v_matric VARCHAR2(32);
 existNumpacPaizad NUMBER; 
 V_DE_SSAAMM               VARCHAR2(6); 
 V_DE_SSAAMM_TMP           VARCHAR2(6); 
 V_DATE_EFFET_RETRO        DATE;
 V_DE_SSAAMM_DEFAULT	   VARCHAR2(6); 
 V_DATE_LIMITE_RETRO       VARCHAR2(6); 
 V_DEB_RETRO               VARCHAR2(6); 
 V_DEB_HISTO_RETRO         VARCHAR2(6); 
 V_PERIODEENCOURS          VARCHAR2(6); 
 V_CODE_CHRONO             VARCHAR2(6); 
 v_nb_mois_retro           NUMBER; 
 V_DATE_EFF                VARCHAR2(6); 

BEGIN
 v_matric := NVL(v_ligNew.MATRIC,v_ligOld.MATRIC);
';

  IF NOM_TABLE           = 'DIC_ADM_CONTRAT' THEN
    champDateEffetRetro := 'DSDCN' ;
  ELSE
    BEGIN
      SELECT a.column_name
      INTO champDateEffetRetro
      FROM SYS.USER_CONS_COLUMNS a, USER_TAB_COLUMNS b
      WHERE 
        a.table_name = NOM_TABLE
        AND a.table_name=b.table_name
        AND a.column_name=b.column_name
        AND b.data_type = 'DATE'
        AND constraint_name IN (
          SELECT c.constraint_name
          FROM user_constraints c
          WHERE c.table_name =a.table_name AND CONSTRAINT_TYPE='P'
        );
    EXCEPTION
      WHEN OTHERS THEN
        champDateEffetRetro := NULL;
    END;
  END IF;

  IF champDateEffetRetro IS NULL THEN
  	RETURN NULL;
  END IF;

  procRetroPaiezadCodeChrono := NULL;
  IF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
    -- Traitement spécifique pour DIC_ADM_CONTRAT_HISTO : dans un trigger, il n'est pas possible de lire la table en cours de modification
    -- De toute façon il n'y a pas besoin : on a le paiezad dans le v_ligNew/v_ligOld, il faut juste lire DIC_ADM_CONTRAT_SITU pour récupérer le CODE_CHRONO
    procRetroPaiezadCodeChrono := ' 
BEGIN 
 IF DELETING THEN
  V_PAIEZAD := v_ligOld.PAIEZAD;
 ELSE
  V_PAIEZAD := v_ligNew.PAIEZAD;
 END IF;
 SELECT dacs.code_chrono 
 INTO V_CODE_CHRONO 
 FROM dic_adm_contrat_situ dacs 
 WHERE dacs.numpac = V_NUMPAC AND dacs.pacmat = V_PACMAT AND dacs.numcnt = NVL(v_ligNew.NUMCNT,v_ligOld.NUMCNT) AND dacs.paiezad = V_PAIEZAD; 
EXCEPTION 
 WHEN OTHERS THEN 
  v_retro := ''N''; 
END;
';
  ELSE
    procRetroPaiezadCodeChrono := ' 
BEGIN 
 SELECT dacs.code_chrono, dach.paiezad, TO_CHAR(dach.DATE_EFF, ''YYYYMM'') 
 INTO V_CODE_CHRONO, V_PAIEZAD, V_DATE_EFF 
 FROM dic_adm_contrat_histo dach , dic_adm_contrat_situ dacs 
 WHERE dach.numpac = V_NUMPAC AND dach.pacmat = V_PACMAT AND dach.matric = v_matric AND dacs.numpac = dach.numpac AND dacs.pacmat = dach.pacmat AND dacs.numcnt = dach.numcnt AND dacs.paiezad = dach.paiezad AND dach.date_eff = (
  select min(z.date_eff) 
  from dic_adm_contrat_histo z 
  where z.matric = dach.matric AND z.date_sortie_sit_bo >= NVL(v_ligNew.' || champDateEffetRetro ||',v_ligOld.' || champDateEffetRetro || ') 
 );  

 -- La période rétro doit être >= à la 1ère date d''effet du salarié
 IF (V_DE_SSAAMM < V_DATE_EFF) THEN
  V_DE_SSAAMM := V_DATE_EFF; 
 END IF;
EXCEPTION 
 WHEN OTHERS THEN 
  v_retro := ''N''; 
END; 
';
  END IF;

  conditionRetro  :=NULL;
  OPEN cur_mapdoRetro;
  LOOP FETCH cur_mapdoRetro INTO lig_mapdoRetro ;
  
    EXIT WHEN cur_mapdoRetro%NOTFOUND;

    IF lig_mapdoRetro.donneegxp IS NOT NULL THEN
      conditionRetro := conditionRetro||'
IF ';
      IF NOT lig_mapdoRetro.numpacs = '*' THEN
        conditionRetro := conditionRetro||'INSTR('''||lig_mapdoRetro.numpacs||''',v_numpac)>0 AND ';
      END IF;

      vFunctionCompare := 'IS_EQ';
      vFunctionCompareParam3 := NULL;
      IF lig_mapdoRetro.data_type = 'DATE' THEN
        vFunctionCompare := 'IS_EQ_DATE';
        vFunctionCompareParam3 := ',''yyyymmddhh24miss''';
      END IF;
      conditionRetro  :=conditionRetro||' NOT '||vFunctionCompare||'(v_ligNew.'||lig_mapdoRetro.donneegxp||',v_ligOld.'||lig_mapdoRetro.donneegxp||vFunctionCompareParam3||') THEN 
 v_retro :=''O''; ';
      IF lig_mapdoRetro.clause_date_eff_retro IS NULL THEN
        conditionRetro :=conditionRetro||' 	
 V_DE_SSAAMM := LEAST(NVL(V_DE_SSAAMM_DEFAULT, V_DE_SSAAMM), NVL(V_DE_SSAAMM, V_DE_SSAAMM_DEFAULT)); ';
      ELSE
        conditionRetro := conditionRetro || ' 
 ' || lig_mapdoRetro.clause_date_eff_retro || '; 
V_DE_SSAAMM := LEAST(NVL(V_DE_SSAAMM_TMP, V_DE_SSAAMM), NVL(V_DE_SSAAMM, V_DE_SSAAMM_TMP));	';
      END IF;
      conditionRetro := conditionRetro || ' 
END IF; ';
    END IF;
  END LOOP;
  CLOSE cur_mapdoRetro;

  IF conditionRetro IS NULL THEN
    RETURN NULL;
  END IF;

  v_retour := v_retour||' 
 IF NVL(v_retro,''N'') = ''Z'' THEN 
  RETURN; 
 END IF;

 IF NOT tabRefPacByNumpac.exists(V_NUMPAC) THEN
  SELECT * 
  INTO tabRefPacByNumpac(V_NUMPAC) 
  FROM TGE_REF_PAC 
  WHERE NUMPAC = V_NUMPAC; 
 END IF;
 V_PERIODEENCOURS := tabRefPacByNumpac(V_NUMPAC).PERIODEENCOURS;
 V_DEB_RETRO := tabRefPacByNumpac(V_NUMPAC).DEB_RETRO;
 V_DEB_HISTO_RETRO := GET_DEB_HISTO_PACMAT(V_NUMPAC,V_PACMAT);
 V_NB_MOIS_RETRO := NVL(tabRefPacByNumpac(V_NUMPAC).NB_MOIS_RETRO, 0);

 IF V_PERIODEENCOURS < V_DEB_RETRO OR V_DEB_RETRO IS NULL THEN 
  RETURN; 
 END IF;

 -- La période rétro doit être >= à : 
 -- - La date de début des histos de rétro 
 -- - La période en cours - le nombre de mois de rétro 
 -- On prend donc la plus grande de ces 2 dates + la date d''effet
 IF DELETING THEN
  V_DATE_EFFET_RETRO := v_ligOld.'||champDateEffetRetro||';
 ELSE
  V_DATE_EFFET_RETRO := v_ligNew.'||champDateEffetRetro||';
 END IF;
 V_DE_SSAAMM_DEFAULT       := GREATEST(TO_CHAR(V_DATE_EFFET_RETRO ,''YYYYMM''),V_DEB_HISTO_RETRO,TO_CHAR(ADD_MONTHS(to_date(V_PERIODEENCOURS,''YYYYMM''),-V_NB_MOIS_RETRO),''YYYYMM''));
 V_DE_SSAAMM := NULL;

 IF V_DE_SSAAMM_DEFAULT >= V_PERIODEENCOURS THEN 
  RETURN; 
 END IF;

 v_retro :=''N''; 
 IF (INSERTING and v_ligOld.MATRIC IS NULL) OR (DELETING and v_ligNew.MATRIC IS NULL) THEN 
  -- En insertion, si on n''a pas récupéré de ''OLD'' (seulement dans le cas de DIC_ADM_CONTRAT_HISTO), on inscrit forcément en rétro
  -- En suppression, si on n''a pas récupéré de ''NEW'' (seulement dans le cas de DIC_ADM_CONTRAT_HISTO), on inscrit forcément en rétro
  v_retro:=''O''; 
  V_DE_SSAAMM := V_DE_SSAAMM_DEFAULT;
 ELSE 
  -- Sinon, on compare ''OLD'' et ''NEW''
  '|| conditionRetro ||'
 END IF; -- FIN updating

 IF NOT v_retro = ''O'' THEN 
  RETURN; 
 END IF;

 '|| procRetroPaiezadCodeChrono ||' 
 IF V_DE_SSAAMM IS NULL OR V_DE_SSAAMM >= V_PERIODEENCOURS OR NOT v_retro = ''O'' THEN 
  RETURN; 
 END IF;

 -- On positionne une valeur reconnaissable pour savoir qu''on a déjà trouvé notre bonheur 
 -- Pas la peine de refaire tous les select pour les autres couples NUMPAC/PACMAT 
 v_retro := ''Z''; 
 TGE_RETRO_INSCRIPTION(V_NUMPAC, V_PACMAT, V_DE_SSAAMM, V_CODE_CHRONO, V_PAIEZAD, ''' || NOM_TABLE ||'''); 
END CHECK_RETRO_'||NOM_TABLE||';';

  EXECUTE_IMMEDIATE_STRING( v_retour,0);

  v_retour :=  '
-- DEBUT TRAITEMENT RETRO
CHECK_RETRO_'||NOM_TABLE||'(v_ligOld, v_ligNew, v_numpac, v_pacmat, v_paiezad, v_retro, tabRefPacByNumpac);
-- FIN TRAITEMENT RETRO';
 
  return v_retour;
END TGE_CREATE_TRIGGER_RETRO;
##
TAG_CHARSET=@€éèç
##
TGE_CTRL40_GET_ETATS_ABSENCE
=SQL=
create or replace FUNCTION TGE_CTRL40_GET_ETATS_ABSENCE(v_heures_ip IN varchar,v_demi_journee  IN  NUMBER, v_inf_abs IN TGE_CTRL40_info_absence,  date_debut IN varchar,  date_fin IN varchar) RETURN TGE_CTRL40_prop_absence  IS
etats_absence TGE_CTRL40_prop_absence:=TGE_CTRL40_prop_absence(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
duree varchar2(500);
  BEGIN
   duree :=REPLACE(NVL(v_heures_ip,'0'), '.', ',') ;
  IF v_inf_abs.debut_ma='J' AND v_inf_abs.fin_ma ='J' AND date_debut=date_fin AND v_demi_journee !=1  AND (duree='0,5' OR duree='0,50') THEN
    etats_absence.isDemiJourneeSurUnSeulJour:=1;
  ELSIF v_inf_abs.debut_ma='J' AND v_inf_abs.fin_ma ='J' AND date_debut < date_fin AND v_demi_journee !=1  AND (duree='0,5' OR duree='0,50') THEN
    etats_absence.isDemiJourneeSurPlusieursJour:=1;
  ELSIF v_inf_abs.debut_ma='J' AND v_inf_abs.fin_ma ='J' AND date_debut=date_fin AND v_demi_journee !=1 THEN
    etats_absence.isJourneeCompleteSurUnSeulJour:=1;
  ELSIF v_inf_abs.debut_ma='D' AND v_inf_abs.fin_ma='D' AND date_debut=date_fin THEN
    etats_absence.isEnDureeSurUnSeulJour :=1;
  ELSIF v_inf_abs.debut_ma='J' AND v_inf_abs.fin_ma='J' AND date_debut < date_fin AND v_demi_journee !=1 THEN 
    etats_absence.isJourneCompletSurPlusieurJour:=1;
  ELSIF v_inf_abs.debut_ma='D' AND v_inf_abs.fin_ma='D' AND date_debut<date_fin THEN
    etats_absence.isEnDureeSurPlusieursJour:=1;
  ELSIF v_inf_abs.debut_ma='M' AND v_inf_abs.fin_ma='M' AND date_debut=date_fin THEN
    etats_absence.isMatinSurUnSeulJour:=1;--
  ELSIF v_inf_abs.debut_ma='M' AND v_inf_abs.fin_ma='M' AND date_debut<date_fin THEN
    etats_absence.isMatinSurPlusieursJour:=1;--
  ELSIF v_inf_abs.debut_ma='A' AND v_inf_abs.fin_ma='A' AND date_debut=date_fin THEN
    etats_absence.isApresMidiSurUnSeulJour:=1;
  ELSIF v_inf_abs.debut_ma='A' AND v_inf_abs.fin_ma='A' AND date_debut<date_fin THEN
    etats_absence.isApresMidiSurPlusieursJour:=1;
  ELSIF v_inf_abs.debut_ma='A' AND v_inf_abs.fin_ma='J' AND date_debut<date_fin THEN
    etats_absence.isStatApremdAndFinitToutJourne:=1;
  ELSIF v_inf_abs.debut_ma='A' AND v_inf_abs.fin_ma='M' AND date_debut<date_fin THEN
    etats_absence.isStartApremidiAndFinitMatin:=1;
  ELSIF v_inf_abs.debut_ma='J' AND v_inf_abs.fin_ma='M' AND date_debut<date_fin THEN
    etats_absence.isStartToutJourneAndFinitMatin:=1;
  ELSIF v_demi_journee=1 THEN
    etats_absence.estDemiJournee:=1;
  ELSE
    etats_absence.erreur:=1;
   -- DBMS_OUTPUT.PUT_LINE('Pas de type trouvé');
  END IF;


  return etats_absence ;
END TGE_CTRL40_GET_ETATS_ABSENCE;##
TAG_CHARSET=@€éèç
##
TGE_CTRL40_GET_INFO_ABSENCE
=SQL=
create or replace FUNCTION TGE_CTRL40_GET_INFO_ABSENCE(p_absence  IN  TGE_CTRL40_abs_row_cursor,dateDebutSQL IN OUT varchar2, dateFinSQL IN OUT varchar) RETURN TGE_CTRL40_info_absence  IS
info TGE_CTRL40_info_absence:=TGE_CTRL40_info_absence(null,null,null) ;
duree varchar2(500);
BEGIN
dateDebutSQL:=p_absence.DATE_DEBUT;
dateFinSQL:=p_absence.DATE_FIN;
duree :=REPLACE(NVL(p_absence.heures_ip,'0'), '.', ',') ;


IF p_absence.UNITE='J' THEN
  IF IS_NUMBER(p_absence.HEURES_IP) IS NOT NULL THEN
    IF duree='1,0' OR duree='1' OR duree='1,00' THEN
        info.DEBUT_MA:='J'; info.FIN_MA:='J';
    ELSIF duree='0,5' OR duree='0,50' THEN
        info.DEBUT_MA:='J';
        info.FIN_MA:='J';
    END IF;
  END IF;
ELSIF p_absence.UNITE='H' THEN
  IF IS_NUMBER(p_absence.HEURES_IP) IS NOT NULL THEN
     info.DEBUT_MA:='D';
     info.FIN_MA:='D';
  ELSE
     info.DEBUT_MA:='J';
     info.FIN_MA:='J';
  END IF;
END IF;
IF p_absence.DEMI_JOURNEE=1 THEN
  info.DEBUT_MA:='J';
  info.FIN_MA:='J';
END IF;

IF p_absence.RUB_ECHANGE IS NOT NULL AND duree>'0' THEN
  info.DEBUT_MA:='J';
  info.FIN_MA:='J';  
ELSIF info.DEBUT_MA IS NULL AND  duree>'0'  THEN
  info.DEBUT_MA:='D';
  info.FIN_MA:='D'; 
END IF;

IF dateFinSQL IS NULL THEN 
  dateFinSQL:=dateDebutSQL;
  IF info.FIN_MA IS NULL THEN info.FIN_MA:=info.DEBUT_MA; END IF;
ELSIF info.FIN_MA IS NULL AND dateDebutSQL IS NOT NULL AND dateFinSQL IS NOT NULL AND dateDebutSQL=dateFinSQL THEN 
  info.FIN_MA:=info.DEBUT_MA;
END IF;

IF (duree IS NULL OR duree='0' OR duree='0,0')  AND dateFinSQL IS NOT NULL AND dateDebutSQL IS NOT NULL AND  NOT(dateFinSQL=dateDebutSQL)   THEN 
  IF info.DEBUT_MA IS NULL THEN info.DEBUT_MA:='J'; END IF;
  IF info.FIN_MA IS NULL THEN info.FIN_MA:='J'; END IF;
END IF;

IF info.DEBUT_MA IS NULL AND info.FIN_MA IS NULL AND (duree IS NULL OR duree='0' OR duree='0,0' ) THEN 
 info.DEBUT_MA:='J';
  info.FIN_MA:='J';
END IF;

return info;
END TGE_CTRL40_GET_INFO_ABSENCE;##
TGE_GAP_IS_DONNEE_RETRO
=SQL=
CREATE OR REPLACE FUNCTION tge_gap_is_donnee_retro (
    pnumpac      IN   VARCHAR2,
    pdonneegxp   IN   VARCHAR2
) RETURN VARCHAR2 AS
    v_element   VARCHAR2(5);
    v_count     NUMBER;
BEGIN
    BEGIN
        SELECT
            element
        INTO v_element
        FROM
            (
                SELECT
                    m.element
                FROM
                    tge_ref_mapdo   m,
                    tge_ref_def     d
                WHERE
                    d.numpac = m.numpac
                    AND m.element = d.element
                    AND m.numpac = pnumpac
                    AND donneegxp = pdonneegxp
                ORDER BY
                    m.occurence,
                    m.element
            )
        WHERE
            ROWNUM <= 1;

    EXCEPTION
        WHEN OTHERS THEN
            v_element := '';
    END;

    IF v_element IS NULL THEN
        BEGIN
            SELECT
                element
            INTO v_element
            FROM
                (
                    SELECT
                        m.element
                    FROM
                        tge_ref_mapdo   m,
                        tge_ref_def     d
                    WHERE
                        m.numpac = '*'
                        AND d.numpac = pnumpac
                        AND m.element = d.element
                        AND donneegxp = pdonneegxp
                    ORDER BY
                        m.occurence,
                        m.element
                )
            WHERE
                ROWNUM <= 1;

        EXCEPTION
            WHEN OTHERS THEN
                RETURN 'Non';
        END;

    END IF;

    IF v_element IS NOT NULL THEN
        BEGIN
            SELECT
                COUNT(*)
            INTO v_count
            FROM
                tge_ref_def d
            WHERE
                d.numpac = pnumpac
                AND element = v_element;

        EXCEPTION
            WHEN OTHERS THEN
                v_count := 0;
        END;

        IF v_count = 0 THEN
            BEGIN
                SELECT
                    COUNT(*)
                INTO v_count
                FROM
                    tge_ref_def d
                WHERE
                    d.numpac = '*'
                    AND element = v_element;

            EXCEPTION
                WHEN OTHERS THEN
                    RETURN 'Non';
            END;

        END IF;

    END IF;

    IF v_count > 0 THEN
        RETURN 'Oui';
    END IF;
    RETURN 'Non';
END tge_gap_is_donnee_retro;
##
TGE_GET_MESSAGE_ERREUR
=SQL=
create or replace FUNCTION TGE_GET_MESSAGE_ERREUR 
(
  p_ERRPREC in VARCHAR2,
  p_MESSAGE IN VARCHAR2 
, p_PARAMS IN VARCHAR2
, P_CODLANG in VARCHAR2
) RETURN VARCHAR2 AS 
message clob;
messageTropLong varchar2(5000);
BEGIN
  
  message:=p_ERRPREC||GET_MESSAGE_ERREUR_PARAM(p_message,p_params)||CHR(10);
  
  if length(message)>3000 then  
    messageTropLong:=get_message_erreur('TGE','TGE00094',P_CODLANG);  
    message:=substr(message,0,3000-length(messageTropLong)-5);
    message:=message||'...'||messageTropLong||CHR(10);  
  end if;
  return message;
END TGE_GET_MESSAGE_ERREUR;
##
TGE_IMPORT_FORMATE_DATE
=SQL=
create or replace FUNCTION TGE_IMPORT_FORMATE_DATE (
 P_DATE IN VARCHAR2,
 P_LOGIN_IMPORT IN VARCHAR2,
 P_IN_TEMPLATE_DATE IN VARCHAR2,
 P_OUT_TEMPLATE IN VARCHAR2
 ) RETURN VARCHAR2 AS
 /**
   Fonction permettant de formater une date dans les imports TGE.
   Lorsque l'import n'est pas un import 'BATCH' (déterminé à partir du paramètre P_LOGIN_IMPORT), la date 
   va être formatée spécialement sinon en mode 'BATCH', la date est retournée dans le format d'entrée.
   Dans le cas où la date à formater serait dans un format incorrect, on ne retourne pas d'exception mais une valeur vide.
 **/
 BEGIN
   IF P_LOGIN_IMPORT = 'BATCH' THEN
     RETURN P_DATE;
   ELSE
     RETURN FORMATE_DATE(P_DATE, P_IN_TEMPLATE_DATE, P_OUT_TEMPLATE);
   END IF;
 EXCEPTION
   WHEN OTHERS THEN
     RETURN '';
 END TGE_IMPORT_FORMATE_DATE;
##
TGE_SEQ_NUM_ECHANGE
=SQL=
create or replace
FUNCTION TGE_SEQ_NUM_ECHANGE (
 p_NUMPAC IN VARCHAR2  ,
 p_PERIODEENCOURS IN VARCHAR2
 ) RETURN VARCHAR2 AS
 num_echange number;
 num_echange_str varchar2(4);
 BEGIN
 TGE_SEQ_NUM_ECHANGE_UP(p_NUMPAC,p_PERIODEENCOURS,num_echange_str);
 --update TGE_REF_PER set DERNIER_NUM_ECHANGE=num_echange_str where numpac=p_NUMPAC and PERIODEENCOURS=p_PERIODEENCOURS;
 RETURN num_echange_str;
 END TGE_SEQ_NUM_ECHANGE;
##
TAG_CHARSET=@€éèç
##
TGE_VALEUR_FORMAT_DATE
=SQL=
create or replace FUNCTION TGE_VALEUR_FORMAT_DATE 
(
  pMasqueElement in VARCHAR2
) RETURN VARCHAR2 AS 

BEGIN
  /**
   Fonction permettant de retourner le masque de date attendu pour un élément TGE en fonction du masque de la colonne TGE_REF_DICOZ.MASQUE
 **/
	IF (pMasqueElement = '1') THEN
  		return 'JJMMSSAA';
  	ELSIF (pMasqueElement = '2') THEN
  		return 'MMSSAA';
  	ELSIF (pMasqueElement = '3') THEN
	  	return 'SSAAMM';
	ELSIF (pMasqueElement = '4') THEN
  		return 'JJ';  	
  	ELSIF (pMasqueElement = '5') THEN
  		return 'MM';
  	ELSIF (pMasqueElement = '6') THEN
  		return 'SSAA';
  	ELSIF (pMasqueElement = '7') THEN
  		return 'SSAAMMJJ';
  	ELSIF (pMasqueElement = '8') THEN
  		return 'JJMMAA';
  	ELSIF (pMasqueElement = '9') THEN
  		return 'MMAA';
  	ELSIF (pMasqueElement = '10') THEN
  		return 'AAMM';
  	ELSIF (pMasqueElement = '11') THEN
  		return 'AA';
  	ELSIF (pMasqueElement = '12') THEN
  		return 'AAMMJJ';
  	ELSIF (pMasqueElement = '13') THEN
  		return 'JJAA';
  	ELSIF (pMasqueElement = '14') THEN
  		return 'JJMM';
  	ELSIF (pMasqueElement = '15') THEN
  		return 'MMJJ';
  	ELSIF (pMasqueElement = '16') THEN
  		return 'MMJJSSAA';
  	END IF;
END TGE_VALEUR_FORMAT_DATE;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_AFTER_STMNT RETURN CLOB AS 
BEGIN
  RETURN '
  IF DELETING THEN
    -- On a supprimé des lignes : on va parcourir les couples NUMPAC/PACMAT supprimés pour voir si c''était le seul contrat du couple
    IF v_TAB_NUMPAC_PACMAT IS NOT NULL THEN
      FOR i IN v_TAB_NUMPAC_PACMAT.first..v_TAB_NUMPAC_PACMAT.last LOOP
        SELECT COUNT(*) INTO v_nbLig FROM DIC_ADM_CONTRAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
        IF v_nbLig=0 THEN
          -- On vient de supprimer le dernier contrat du couple NUMPAC/PACMAT : on va vérifier s''il faut le supprimer de SECUPACMAT
          SELECT COUNT(*) INTO v_nbLig FROM SECUPACMAT WHERE MATRIC=v_TAB_NUMPAC_PACMAT(i).MATRIC AND NOT (NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT);
          IF v_nbLig>0 THEN
            -- Il existe dans SECUPACMAT au moins une ligne pour le MATRIC, avec un autre couple NUMPAC/PACMAT que celui dont on vient de supprimer le dernier contrat : on supprime ce couple de SECUPACMAT
            DELETE FROM SECUPACMAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
          END IF;
        END IF;
        IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_TAB_NUMPAC_PACMAT(i).MATRIC)<=0 THEN
          -- On stocke la liste des NUMPAC/PACMAT modifiés
          IF v_nbMatricToUpdate=1000 THEN
            v_nbMatricToUpdate := 0;
            v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
          ELSIF v_nbMatricToUpdate>0 THEN
            v_listMatricToUpdate := v_listMatricToUpdate||'','';
          END IF;
          v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_TAB_NUMPAC_PACMAT(i).MATRIC||'''''''';
          v_nbMatricToUpdate := v_nbMatricToUpdate+1;
        END IF;
      END LOOP;
    END IF;
  END IF;
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- On insère dans la table temporaire les NUMPAC/PACMAT/MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''CONTRAT UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_CONTRAT(''DO_MAJ'', 1, 0, 0);
    DELETE FROM SECUPACMAT_TMP_CONTRAT;
    IF INSERTING THEN
      v_actionIdx := ''I'';
    ELSIF UPDATING THEN
      v_actionIdx := ''U'';
    ELSIF DELETING THEN
      v_actionIdx := ''D'';
    END IF;
    DBMS_JOB.SUBMIT(v_jobIdx , ''BEGIN NULL; END;'' , sysdate+1);
    DBMS_JOB.WHAT(v_jobIdx , ''ALIM_IDX.COMPARE_CONTRAT_JOB(''||v_jobIdx||'', ''''''||v_actionIdx||'''''');'');
 	DBMS_JOB.NEXT_DATE(v_jobIdx ,  sysdate-1);
    INSERT INTO DIC_IDX_JOB_KEYS SELECT v_jobIdx, T.* FROM TABLE(v_cles_idx_contrat) T;
    IF INSERTING OR UPDATING THEN
      INSERT INTO DIC_IDX_JOB_OLD_DATAS VALUES (v_jobIdx, ANYDATA.CONVERTCOLLECTION(GET_DAC_MULTI_HORS_TRANSAC(v_cles_idx_contrat)));
    END IF;
    IF v_doMajPerso=1 THEN
      EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
      SECNAV_MAJ_CURRENT_PERSO(''DO_MAJ'', 1, 1, 0);
      DELETE FROM SECUPACMAT_TMP_PERSO;
    END IF;
  END IF;
';
END TRG_CONTRAT_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_BEFORE_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_BEFORE_ROW RETURN CLOB AS 
BEGIN
  RETURN '
  -- On vérifie qu''on ne modifie ni le NUMPAC, ni le PACMAT, ni le NUMCNT
  IF UPDATING AND (NOT v_ligOld.NUMPAC=v_ligNew.NUMPAC OR NOT v_ligOld.PACMAT=v_ligNew.PACMAT OR NOT v_ligOld.NUMCNT=v_ligNew.NUMCNT) THEN
    -- Message d''erreur --> On interdit la mise à jour du NUMPAC, du PACMAT et du NUMCNT : il faut faire un delete puis un insert
    RAISE_APPLICATION_ERROR(-20000,''La mise à jour des colonnes NUMPAC, PACMAT et NUMCNT n''''est pas autorisée : vous devez supprimer puis recréer le contrat'');
  END IF;
  -- On vérifie qu''on ne modifie pas le RHID et qu''il n''est pas vide
  IF (INSERTING OR UPDATING) AND v_ligNew.MATRIC IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000,''La colonne MATRIC doit être renseignée dans DIC_ADM_CONTRAT'');
  END IF;
  IF UPDATING AND NOT v_ligOld.MATRIC=v_ligNew.MATRIC THEN
    RAISE_APPLICATION_ERROR(-20000,''La mise à jour de la colonne MATRIC n''''est pas autorisée'');
  END IF;
  -- On vérifie qu''on ne modifie pas la date de début de contrat et qu''elle n''est pas vide
  IF (INSERTING OR UPDATING) AND v_ligNew.DSDCN IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000,''La colonne DSDCN doit être renseignée dans DIC_ADM_CONTRAT'');
  END IF;
  IF UPDATING AND NOT v_ligOld.DSDCN=v_ligNew.DSDCN THEN
    RAISE_APPLICATION_ERROR(-20000,''La mise à jour de la colonne DSDCN n''''est pas autorisée'');
  END IF;
  
  IF INSERTING THEN
    -- On regarde si le couple NUMPAC/PACMAT existe dans SECUPACMAT (premier contrat du couple ?), et si un NUMPAC temporaire est positionné pour le MATRIC (premier contrat du MATRIC ?)
    BEGIN
      SELECT NVL(MATRIC,''NO_MATRIC'') INTO v_matricForPacmat FROM SECUPACMAT WHERE NUMPAC=v_ligNew.NUMPAC AND PACMAT=v_ligNew.PACMAT;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN v_matricForPacmat:=NULL;
      WHEN OTHERS THEN RAISE;
    END;
    IF v_matricForPacmat IS NULL THEN
      v_nbLig:=0;
    ELSE
      IF NOT v_matricForPacmat=v_ligNew.MATRIC THEN
        -- Le couple NUMPAC/PACMAT existe pour un autre MATRIC
        RAISE_APPLICATION_ERROR(-20000,''Erreur lors de l''''attribution du PACMAT pour le matricule ''||v_ligNew.MATRIC||'' sur le PAC ''||v_ligNew.NUMPAC||'' : le PACMAT ''||v_ligNew.PACMAT||'' est déjà associé au matricule ''||v_matricForPacmat);
      END IF;
      v_nbLig:=1;
    END IF;
    IF v_nbLig=0 THEN
      -- Premier contrat pour le couple NUMPAC/PACMAT : on insère dans SECUPACMAT (ou on met à jour la ligne ayant un NUMPAC temporaire, si elle existe)
      SELECT COUNT(*) INTO v_nbLig FROM SECUPACMAT WHERE NUMPAC=''TMPPAC'' AND MATRIC=v_ligNew.MATRIC;
      IF v_nbLig=1 THEN
        -- Il y a un couple NUMPAC/PACMAT temporaire dans SECUPACMAT pour ce MATRIC : on le met à jour
        UPDATE SECUPACMAT SET NUMPAC=v_ligNew.NUMPAC, PACMAT=v_ligNew.PACMAT WHERE NUMPAC=''TMPPAC'' AND MATRIC=v_ligNew.MATRIC;
      ELSE
        -- On insère le couple NUMPAC/PACMAT dans SECUPACMAT
        INSERT INTO SECUPACMAT (NUMPAC, PACMAT, MATRIC) VALUES (v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.MATRIC);
        v_doMajPerso := 1;
      END IF;
    ELSE
        IF v_nbLig = 1 THEN
            update SECUPACMAT set FLAG_MASQUAGE_RGPD = 0 where NUMPAC = v_ligNew.NUMPAC and PACMAT = v_ligNew.PACMAT;
        END IF;
    END IF;
    -- Si la colonne NUMCNT_ORIGINE est vide, on la valorise avec NUMCNT
    IF v_ligNew.NUMCNT_ORIGINE IS NULL THEN
      :NEW.NUMCNT_ORIGINE := v_ligNew.NUMCNT;
      v_ligNew.NUMCNT_ORIGINE := :NEW.NUMCNT_ORIGINE;
    END IF;
    -- On stocke la liste des NUMPAC/PACMAT modifiés
    IF v_type_writer<>''N'' AND v_type_writer<>''M'' THEN
      IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_ligNew.MATRIC)<=0 THEN
        IF v_nbMatricToUpdate=1000 THEN
          v_nbMatricToUpdate := 0;
          v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
        ELSIF v_nbMatricToUpdate>0 THEN
          v_listMatricToUpdate := v_listMatricToUpdate||'','';
        END IF;
        v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_ligNew.MATRIC||'''''''';
        v_nbMatricToUpdate := v_nbMatricToUpdate+1;
      END IF;
      -- On stocke la liste des NUMPAC/PACMAT/NUMCNT/DATE_EFF insérés
      v_cle_idx_contrat := T_CLE_IDX_CONTRAT_HISTO(v_ligNew.MATRIC, v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.NUMCNT, v_ligNew.DSDCN);
      v_cles_idx_contrat.extend;
      v_cles_idx_contrat(v_cles_idx_contrat.last) := v_cle_idx_contrat;
    END IF;
    
   IF NOT tabRefPacByNumpac.exists(v_ligNew.NUMPAC) THEN
       SELECT * INTO tabRefPacByNumpac(v_ligNew.NUMPAC) FROM TGE_REF_PAC WHERE NUMPAC = v_ligNew.NUMPAC;
   END IF;
   
   	v_date_debut_periode_paie := to_date(tabRefPacByNumpac(v_ligNew.NUMPAC).PERIODEENCOURS || ''01'',''YYYYMMDD''); 

   	IF v_ligNew.DSDCN < v_date_debut_periode_paie THEN
    	:NEW.ENTREE_RETRO := ''O'';
   	ELSE
	   	:NEW.ENTREE_RETRO := ''N'';
    END IF;
    v_ligNew.ENTREE_RETRO := :NEW.ENTREE_RETRO;

    IF v_ligNew.DSFCN < v_date_debut_periode_paie THEN
    	:NEW.SORTIE_RETRO := ''O'';
   	ELSE
	   	:NEW.SORTIE_RETRO := ''N'';
    END IF;
    v_ligNew.SORTIE_RETRO := :NEW.SORTIE_RETRO;

    
  ELSIF UPDATING AND (NOT UPDATING(''DATE_EFF_CONTRAT'') AND NOT UPDATING(''CURRENT_PAIEZAD'')) THEN
    -- On considère que c''est une "vraie" mise à jour si ce n''est pas de la mise à jour de DATE_EFF_CONTRAT ou CURRENT_PAIEZAD
    -- On stocke la liste des NUMPAC/PACMAT modifiés
    IF v_type_writer<>''N'' AND v_type_writer<>''M'' THEN
      IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_ligNew.MATRIC)<=0 THEN
        IF v_nbMatricToUpdate=1000 THEN
          v_nbMatricToUpdate := 0;
          v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
        ELSIF v_nbMatricToUpdate>0 THEN
          v_listMatricToUpdate := v_listMatricToUpdate||'','';
        END IF;
        v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_ligNew.MATRIC||'''''''';
        v_nbMatricToUpdate := v_nbMatricToUpdate+1;
      END IF;
      -- On stocke la liste des NUMPAC/PACMAT/NUMCNT/DATE_EFF modifiés
      v_cle_idx_contrat := T_CLE_IDX_CONTRAT_HISTO(v_ligNew.MATRIC, v_ligNew.NUMPAC, v_ligNew.PACMAT, v_ligNew.NUMCNT, v_ligNew.DSDCN);
      v_cles_idx_contrat.extend;
      v_cles_idx_contrat(v_cles_idx_contrat.last) := v_cle_idx_contrat;
    END IF;

    IF UPDATING(''DSFCN'') THEN
       IF NOT tabRefPacByNumpac.exists(v_ligOld.NUMPAC) THEN
         SELECT * INTO tabRefPacByNumpac(v_ligOld.NUMPAC) FROM TGE_REF_PAC WHERE NUMPAC = v_ligOld.NUMPAC;
       END IF;
    	v_date_debut_periode_paie := to_date(tabRefPacByNumpac(v_ligNew.NUMPAC).PERIODEENCOURS || ''01'',''YYYYMMDD''); 
    	IF v_ligNew.DSFCN < v_date_debut_periode_paie THEN
    		:NEW.SORTIE_RETRO := ''O'';
    	ELSE
	    	:NEW.SORTIE_RETRO := ''N'';
    	END IF;
    	v_ligNew.SORTIE_RETRO := :NEW.SORTIE_RETRO;
    END IF;
  ELSIF DELETING THEN
    IF (v_listNumpacPacmatToDelete IS NULL OR INSTR(v_listNumpacPacmatToDelete, '',''||v_ligOld.NUMPAC||v_ligOld.PACMAT||'','')<=0) THEN
      -- On liste les couples NUMPAC/PACMAT supprimés pour les traiter par la suite
      v_NUMPAC_PACMAT.MATRIC:=v_ligOld.MATRIC;
      v_NUMPAC_PACMAT.NUMPAC:=v_ligOld.NUMPAC;
      v_NUMPAC_PACMAT.PACMAT:=v_ligOld.PACMAT;
      IF v_TAB_NUMPAC_PACMAT IS NULL THEN
        v_TAB_NUMPAC_PACMAT:=TAB_NUMPAC_PACMAT_TO_DELETE(v_NUMPAC_PACMAT);
      ELSE
        v_TAB_NUMPAC_PACMAT.EXTEND();
        v_TAB_NUMPAC_PACMAT(v_TAB_NUMPAC_PACMAT.last):=v_NUMPAC_PACMAT;
      END IF;
      v_listNumpacPacmatToDelete := v_listNumpacPacmatToDelete||v_ligOld.NUMPAC||v_ligOld.PACMAT||'','';
    END IF;
    -- On stocke la liste des NUMPAC/PACMAT/NUMCNT/DATE_EFF supprimés
    v_cle_idx_contrat := T_CLE_IDX_CONTRAT_HISTO(v_ligOld.MATRIC, v_ligOld.NUMPAC, v_ligOld.PACMAT, v_ligOld.NUMCNT, v_ligOld.DSDCN);
    v_cles_idx_contrat.extend;
    v_cles_idx_contrat(v_cles_idx_contrat.last) := v_cle_idx_contrat;
  END IF;
';
END TRG_CONTRAT_BEFORE_ROW;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_HISTO_AFTER_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_HISTO_AFTER_ROW
  RETURN CLOB
AS
  v_retour CLOB;
  v_prec_donneegxp VARCHAR2(4000);
  CURSOR cur_mapdo
  IS
    SELECT
      NUMPAC,
      ELEMENT,
      DONNEEGXP,
      data_type
    FROM
      TGE_REF_MAPDO,user_tab_cols
    WHERE
      column_name=donneegxp and table_name='DIC_ADM_CONTRAT_HISTO' and
      ELEMENT IN
      (
        SELECT
          'A301'
        FROM
          dual
      UNION ALL
      SELECT
        'A302'
      FROM
        dual
      UNION
      SELECT
        nom_elt
      FROM
        tge_map_arg_elt
      WHERE
        code_table = 'LTP'
      )
    ORDER BY
      ELEMENT,
      NUMPAC DESC;
    lig_mapdo cur_mapdo%rowtype;
    lig_mapdo_prec cur_mapdo%rowtype := NULL;
    v_selectDeb VARCHAR2(100);
    v_selectFin VARCHAR2(100);
  BEGIN
    v_retour :=
    ' 
v_numpac := NVL(v_ligNew.NUMPAC,v_ligOld.NUMPAC); 

v_pacmat :=NVL(v_ligNew.PACMAT,v_ligOld.PACMAT);
IF DELETING THEN
 v_paiezad := v_ligOld.paiezad;
 v_periode := TO_CHAR(v_ligOld.date_eff, ''YYYYMM'');
ELSE
 v_paiezad := v_ligNew.paiezad;
 v_periode := TO_CHAR(v_ligNew.date_eff, ''YYYYMM'');
END IF; 
-- On ne traite que l''UPDATE, et on n''ajoute chaque couple NUMPAC/PAIEZAD qu''une seule fois 
IF NOT tabTrtPeriodesIndividuelles.exists(v_numpac||v_paiezad) THEN 
 tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := ''O''; 
 IF INSERTING OR DELETING THEN 
  alimPeriodesIndiv := TRUE; 
 ELSE 
  alimPeriodesIndiv := FALSE; '
    ;
    OPEN cur_mapdo;
    LOOP
      FETCH
        cur_mapdo
      INTO
        lig_mapdo ;
        
      IF lig_mapdo_prec.element IS NOT NULL AND
        (
          cur_mapdo%NOTFOUND OR NOT lig_mapdo_prec.element=lig_mapdo.element
        )
        THEN
        -- La dernière ligne traitée était la dernière ligne de mapping pour l'
        -- élément précédent
        -- Si c'était le PAC *, c'est le cas par défaut (ELSE), sinon, on
        -- continue de tester le PAC
       
        IF lig_mapdo_prec.numpac='*' THEN
          v_retour             := v_retour||' 
ELSE ';
        ELSE
          v_retour := v_retour||' 
ELSIF v_numpac='''||lig_mapdo_prec.numpac||
          ''' THEN ';
        END IF;
        v_retour := v_retour||' 
tabValToCompare(''old'||lig_mapdo_prec.element
        ||''') := '||v_prec_donneegxp||'; 
tabValToCompare(''new'||
        lig_mapdo_prec.element||''') := '||REPLACE(v_prec_donneegxp,'v_ligOld','v_ligNew')||'; 
END IF; ';
        IF NOT lig_mapdo_prec.numpac='*' THEN
          -- Pas de ligne avec un PAC * : cas par défaut --> NULL
          v_retour := v_retour||' 
ELSE 
tabValToCompare(''old'||
          lig_mapdo_prec.element||''') := NULL; 
tabValToCompare(''new'||
          lig_mapdo_prec.element||''') := NULL; 
END IF; ';
        END IF;
      END IF;
      EXIT
    WHEN cur_mapdo%NOTFOUND;

    v_selectDeb := 'v_ligOld.';
    v_selectFin := NULL;
    IF lig_mapdo.data_type = 'DATE' THEN
      v_selectDeb := 'TO_CHAR(v_ligOld.';
      v_selectFin := ',''yyyymmddhh24miss'')';
    END IF;
       SELECT
          v_selectDeb
          ||LISTAGG(donneegxp,v_selectFin||'||'||v_selectDeb) WITHIN GROUP (
        ORDER BY
          donneegxp)
          ||v_selectFin
        INTO
          v_prec_donneegxp
        FROM
          (
            SELECT
              numpac,
              donneegxp
            FROM
              TABLE (get_gxp_trt_particulier_datas('DIC_ADM_CONTRAT_HISTO',lig_mapdo.element))
            UNION
            SELECT
              lig_mapdo.numpac,
              lig_mapdo.donneegxp
            FROM
              dual
          );  
    
    
      -- C'est la toute première ligne, ou bien la ligne précédente était la
      -- dernière ligne de mapping pour l'élément précédent
      -- On recommence un nouveau bloc IF
      IF lig_mapdo_prec.element IS NULL OR NOT lig_mapdo_prec.element=
        lig_mapdo.element THEN
        v_retour := v_retour||' 
tabValToCompare(''old'||lig_mapdo.element||
        ''') := NULL; 
tabValToCompare(''new'||lig_mapdo.element||
        ''') := NULL; 
IF v_numpac IS NULL THEN NULL; ';
      END IF;
      IF NOT lig_mapdo.numpac='*' THEN
        v_retour            := v_retour||' 
ELSIF v_numpac='''||
        lig_mapdo.numpac||''' THEN 
tabValToCompare(''old'||lig_mapdo.element||
        ''') := '||v_prec_donneegxp||'; 
tabValToCompare(''new'||
        lig_mapdo.element||''') := '||REPLACE(v_prec_donneegxp,'v_ligOld','v_ligNew')||';  ';
      END IF;
      lig_mapdo_prec := lig_mapdo;
    END LOOP;
    CLOSE cur_mapdo;
    IF lig_mapdo_prec.element IS NOT NULL THEN
      -- On est passé au moins une fois dans la boucle
      lig_mapdo_prec := NULL;
      OPEN cur_mapdo;
      LOOP
        FETCH
          cur_mapdo
        INTO
          lig_mapdo ;
        EXIT
      WHEN cur_mapdo%NOTFOUND;
        -- C'est la toute première ligne, ou bien la ligne précédente était la
        -- dernière ligne de mapping pour l'élément précédent
        IF lig_mapdo_prec.element IS NULL OR NOT lig_mapdo_prec.element=lig_mapdo.element THEN
          v_retour := v_retour||' 
IF NOT IS_EQ(tabValToCompare(''new'||lig_mapdo.element||'''),tabValToCompare(''old'||lig_mapdo.element||''')) THEN 
alimPeriodesIndiv := TRUE; 
END IF; ';
        END IF;
        lig_mapdo_prec := lig_mapdo;
      END LOOP;
      CLOSE cur_mapdo;
    END IF;
    v_retour := v_retour||
    ' 
END IF; 
IF alimPeriodesIndiv THEN 
-- Modification de la date de début ou de fin de suspension : on met à jour la table des périodes individuelles 
idxPeriodesIndiv := null; 
FOR i IN 1..paiezadTab.count LOOP 
IF numpacTab(i) = v_numpac AND paiezadTab(i) = v_paiezad THEN 
idxPeriodesIndiv := i; 
EXIT; 
END IF; 
end LOOP ;  

IF idxPeriodesIndiv IS NOT NULL THEN 
periodeTab(idxPeriodesIndiv) := LEAST(periodeTab(idxPeriodesIndiv), v_periode); 
ELSE 
paiezadTab.EXTEND ; 
paiezadTab(paiezadTab.LAST) := v_paiezad; 
numpacTab.EXTEND ; 
numpacTab(numpacTab.LAST) := v_numpac; 
periodeTab.EXTEND ; 
periodeTab(periodeTab.LAST) := v_periode; 
END IF; 
END IF; 
END IF; 
IF NOT tabPresenceFichierPacmat.exists(v_numpac||v_pacmat) THEN
  tabPresenceFichierPacmat(v_numpac||v_pacmat).NUMPAC := v_numpac; 
  tabPresenceFichierPacmat(v_numpac||v_pacmat).PACMAT := v_pacmat;
END IF; 
IF  v_lanceRecalculHp THEN 
 in_calc_hp := T_TRAITEMENT_PERIODES_INDIV();
 in_calc_hp(''P_NUMPAC''):=NVL(v_ligNew.NUMPAC,v_ligOld.NUMPAC); 
 in_calc_hp(''P_PACMAT''):=NVL(v_ligNew.PACMAT,v_ligOld.PACMAT); 
 in_calc_hp(''P_NUMCNT''):=TO_CHAR(NVL(v_ligNew.NUMCNT,v_ligOld.NUMCNT)); 
 IF DELETING THEN
  in_calc_hp(''P_PAIEZAD''):=v_ligOld.PAIEZAD; 
  in_calc_hp(''P_DATE_EFF''):=TO_CHAR(v_ligOld.DATE_EFF,''DD/MM/YYYY''); 
  in_calc_hp(''P_DATE_SORTIE_SIT_BO''):=TO_CHAR(v_ligOld.date_sortie_sit_bo,''DD/MM/YYYY'');
 ELSE
  in_calc_hp(''P_PAIEZAD''):=v_ligNew.PAIEZAD; 
  in_calc_hp(''P_DATE_EFF''):=TO_CHAR(v_ligNew.DATE_EFF,''DD/MM/YYYY''); 
  in_calc_hp(''P_DATE_SORTIE_SIT_BO''):=TO_CHAR(v_ligNew.date_sortie_sit_bo,''DD/MM/YYYY'');
 END IF; 
 in_calc_hp(''P_LOGIN'') :=''TRIGGER''; 
 in_calc_hp(''p_isDeleting'') :=v_isDeleting;
 calcHpTab.EXTEND ;
 calcHpTab(calcHpTab.LAST) := in_calc_hp;
END IF; 
'
    ;
    RETURN v_retour;
  END TRG_CONTRAT_HISTO_AFTER_ROW;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_HISTO_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_HISTO_AFTER_STMNT RETURN CLOB AS 
BEGIN
  RETURN '
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- Insère dans la table temporaire les NUMPAC/PACMAT/MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''CONTRAT_HISTO UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING (''INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_CONTRAT(''DO_MAJ'', 0, 1, 0);
    DELETE FROM SECUPACMAT_TMP_CONTRAT;
    IF INSERTING THEN
      v_actionIdx := ''I'';
    ELSIF UPDATING THEN
      v_actionIdx := ''U'';
    ELSIF DELETING THEN
      v_actionIdx := ''D'';
    END IF;
    DBMS_JOB.SUBMIT(v_jobIdx , ''BEGIN NULL; END;'' , sysdate+1);
 	DBMS_JOB.WHAT(v_jobIdx , ''ALIM_IDX.COMPARE_CONTRAT_HISTO_JOB(''||v_jobIdx||'', ''''''||v_actionIdx||'''''');'');
 	DBMS_JOB.NEXT_DATE(v_jobIdx ,  sysdate-1);
    INSERT INTO DIC_IDX_JOB_KEYS SELECT v_jobIdx, T.* FROM TABLE(v_cles_idx_contrat) T;
    IF INSERTING OR UPDATING THEN
      INSERT INTO DIC_IDX_JOB_OLD_DATAS VALUES (v_jobIdx, ANYDATA.CONVERTCOLLECTION(GET_DACH_MULTI_HORS_TRANSAC(v_cles_idx_contrat)));
    END IF;
  END IF;
   --CRF RSI 
  select count(*) into v1_bypass_DACH from bypass_trg_DACH_on_session;
  IF v1_bypass_DACH =0 THEN
  FOR i IN 1..paiezadTab.count
  LOOP
    IF v_type_writer = ''M'' THEN
      listJobMasseAsyncTab.extend();
      listJobMasseAsyncTab(listJobMasseAsyncTab.last):='' TGE_ALIM_PERIODE_INDIV(0, '''''' || numpacTab(i) || '''''', '''''' || periodeTab(i) || '''''', '''''' || paiezadTab(i) || '''''');'';
    ELSE
      TGE_ALIM_PERIODE_INDIV(0, numpacTab(i), periodeTab(i), paiezadTab(i));
    END IF;
  END LOOP ;
  
  FOR i IN 1..calcHpTab.count
  LOOP
  	in_calc_hp := calcHpTab(i);
	IF in_calc_hp.exists(''P_NUMPAC'') THEN
	  	IF v_type_writer = ''M'' THEN
	      	listJobMasseAsyncTab.extend();
	      	listJobMasseAsyncTab(listJobMasseAsyncTab.last):='' CALC_HP.PRINCIPAL(
			    '''''' || in_calc_hp(''P_NUMPAC'') || '''''',
			    '''''' || in_calc_hp(''P_PACMAT'') || '''''',
			    '''''' || in_calc_hp(''P_PAIEZAD'') || '''''',
			     	'' || in_calc_hp(''P_NUMCNT'') || '',
			    '''''' || in_calc_hp(''P_DATE_EFF'') || '''''',
			    '''''' || in_calc_hp(''P_DATE_SORTIE_SIT_BO'') || '''''',
			    '''''' || in_calc_hp(''P_LOGIN'') || '''''', 
			    '''''' || in_calc_hp(''p_isDeleting'')  || ''''''
			  	);'';
	    ELSE
	        CALC_HP.PRINCIPAL(
			    in_calc_hp(''P_NUMPAC''),
			    in_calc_hp(''P_PACMAT''),
			    in_calc_hp(''P_PAIEZAD''),
			    TO_NUMBER(in_calc_hp(''P_NUMCNT'')),
			    in_calc_hp(''P_DATE_EFF''),
			    in_calc_hp(''P_DATE_SORTIE_SIT_BO''),
			    in_calc_hp(''P_LOGIN'') , 
			    in_calc_hp(''p_isDeleting'') 
			  );
	    END IF;
	 END IF;
 END LOOP ;
 END IF; 
 --FIN CRF RSI
  -- maj secupacmat.PRESENCE_FICHIER
  indexTabPresFicPacmat := tabPresenceFichierPacmat.FIRST;
  WHILE indexTabPresFicPacmat IS NOT NULL LOOP
    IF v_type_writer = ''M'' THEN
      listJobMasseAsyncTab.extend();
      listJobMasseAsyncTab(listJobMasseAsyncTab.last):='' R_PRESENT_FICHIER_PAIE('''''' || tabPresenceFichierPacmat(indexTabPresFicPacmat).NUMPAC || '''''','''''' || tabPresenceFichierPacmat(indexTabPresFicPacmat).PACMAT || '''''');'';
    ELSE
      R_PRESENT_FICHIER_PAIE(tabPresenceFichierPacmat(indexTabPresFicPacmat).NUMPAC,tabPresenceFichierPacmat(indexTabPresFicPacmat).PACMAT);
    END IF;
    indexTabPresFicPacmat := tabPresenceFichierPacmat.NEXT(indexTabPresFicPacmat);
  end loop;
  --Lancement du job async lors d''une mise à jour Manuelle, en Masse (type_writer = ''M'')
  IF v_type_writer = ''M'' THEN
    DBMS_JOB_SUBMIT_MASSE(listJobMasseAsyncTab, ''TRG_DACH'');
  END IF;
';
END TRG_CONTRAT_HISTO_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_HISTO_BEFORE_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_HISTO_BEFORE_ROW RETURN CLOB AS 
BEGIN
  RETURN '
  -- On vérifie qu''on ne modifie ni le NUMPAC, ni le PACMAT, ni le NUMCNT, ni la date d''effet
  IF UPDATING AND (NOT v_ligOld.NUMPAC=v_ligNew.NUMPAC OR NOT v_ligOld.PACMAT=v_ligNew.PACMAT OR NOT v_ligOld.NUMCNT=v_ligNew.NUMCNT OR NOT v_ligOld.DATE_EFF=v_ligNew.DATE_EFF) THEN
    -- Message d''erreur --> On interdit la mise à jour du NUMPAC, du PACMAT et de la date d''effet : il faut faire un delete puis un insert
    RAISE_APPLICATION_ERROR(-20000,''La mise à jour des colonnes NUMPAC, PACMAT, NUMCNT et DATE_EFF n''''est pas autorisée : vous devez supprimer puis recréer l''''occurrence'');
  END IF;
  IF INSERTING OR UPDATING THEN
    IF v_ligNew.DATE_FIN IS NULL THEN
      :NEW.DATE_FIN := TO_DATE(''20991231'',''yyyymmdd'');
      v_ligNew.DATE_FIN := :NEW.DATE_FIN;
    END IF;
  END IF;
  IF v_type_writer<>''N'' AND v_type_writer<>''M'' THEN
    IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,NVL(v_ligNew.MATRIC,v_ligOld.MATRIC))<=0 THEN
      -- On stocke la liste des NUMPAC/PACMAT modifiés
      IF v_nbMatricToUpdate=1000 THEN
        v_nbMatricToUpdate := 0;
        v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
      ELSIF v_nbMatricToUpdate>0 THEN
        v_listMatricToUpdate := v_listMatricToUpdate||'','';
      END IF;
      v_listMatricToUpdate := v_listMatricToUpdate||''''''''||NVL(v_ligNew.MATRIC,v_ligOld.MATRIC)||'''''''';
      v_nbMatricToUpdate := v_nbMatricToUpdate+1;
    END IF;
    -- On stocke la liste des NUMPAC/PACMAT/NUMCNT/DATE_EFF insérés/modifiés/supprimés
    IF DELETING THEN
     v_date_eff := v_ligOld.DATE_EFF;
    ELSE
     v_date_eff := v_ligNew.DATE_EFF;
    END IF;
    v_cle_idx_contrat := T_CLE_IDX_CONTRAT_HISTO(NVL(v_ligNew.MATRIC,v_ligOld.MATRIC), NVL(v_ligNew.NUMPAC,v_ligOld.NUMPAC), NVL(v_ligNew.PACMAT,v_ligOld.PACMAT), NVL(v_ligNew.NUMCNT,v_ligOld.NUMCNT), v_date_eff);
    v_cles_idx_contrat.extend;
    v_cles_idx_contrat(v_cles_idx_contrat.last) := v_cle_idx_contrat;
  END IF;
  v_isDeleting := 0;
  IF DELETING THEN
    v_isDeleting := 1; 
  END IF;
  v_lanceRecalculHp := FALSE;
  IF IS_EQ(v_ligNew.ZA996,''Z'') AND ( NOT IS_EQ(v_ligNew.ZA820,v_ligOld.ZA820) OR NOT IS_EQ(v_ligNew.PAIEZAD,v_ligOld.PAIEZAD) OR NOT IS_EQ(v_ligNew.ZA819,v_ligOld.ZA819)) THEN
    v_lanceRecalculHp:=true;
  END IF;
';
END TRG_CONTRAT_HISTO_BEFORE_ROW;
##
TRG_PERSO_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_PERSO_AFTER_STMNT RETURN CLOB AS 
BEGIN
  RETURN '
  IF v_listMatricToDelete IS NOT NULL THEN
    -- On supprime de SECUPACMAT les MATRIC supprimés
    --DBMS_OUTPUT.PUT_LINE(''PERSO DELETING ''||v_listMatricToDelete);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING( ''DELETE FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToDelete||'')'',0);
  END IF;
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- On insère dans la table temporaire les MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''PERSO UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING (''INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'') AND MATRIC NOT IN (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO)'',0);
    SECNAV_MAJ_DATA_PERSO(0);
    EXECUTE_IMMEDIATE_STRING (''DELETE FROM SECUPACMAT_TMP_PERSO'',0);
  END IF;
';
END TRG_PERSO_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
TRG_PERSO_BEFORE_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_PERSO_BEFORE_ROW RETURN CLOB AS 
BEGIN
  RETURN '
  IF INSERTING THEN
    -- On vérifie que le NUMPAC soit renseigné : si ce n''est pas le cas, on positionne un NUMPAC temporaire
    IF v_ligNew.CURRENT_NUMPAC IS NULL THEN
      :NEW.CURRENT_NUMPAC:=''TMPPAC'';
      v_ligNew.CURRENT_NUMPAC:=:NEW.CURRENT_NUMPAC;
    END IF;
    -- On vérifie que le PACMAT soit renseigné : si ce n''est pas le cas, on va cherche le prochain PACMAT du NUMPAC
    IF v_ligNew.CURRENT_PACMAT IS NULL THEN
      :NEW.CURRENT_PACMAT:=PAC_SEQUENCE_GET_NEXT(v_ligNew.CURRENT_NUMPAC);
      v_ligNew.CURRENT_PACMAT:=:NEW.CURRENT_PACMAT;
    END IF;
    -- On regarde si le couple NUMPAC/PACMAT n''existe pas déjà dans SECUPACMAT pour un autre MATRIC
    BEGIN
      SELECT NVL(MATRIC,''NO_MATRIC'') INTO v_matricForPacmat FROM SECUPACMAT WHERE NUMPAC=v_ligNew.CURRENT_NUMPAC AND PACMAT=v_ligNew.CURRENT_PACMAT;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN v_matricForPacmat:=NULL;
      WHEN OTHERS THEN RAISE;
    END;
    IF v_matricForPacmat IS NOT NULL AND NOT v_matricForPacmat=v_ligNew.MATRIC THEN
      -- Le couple NUMPAC/PACMAT existe pour un autre MATRIC
      RAISE_APPLICATION_ERROR(-20000,''Erreur lors de l''''attribution du PACMAT pour le matricule ''||v_ligNew.MATRIC||'' sur le PAC ''||v_ligNew.CURRENT_NUMPAC||'' : le PACMAT ''||v_ligNew.CURRENT_PACMAT||'' est déjà associé au matricule ''||v_matricForPacmat);
    END IF;
    -- On insère dans SECUPACMAT
    --INSERT INTO SECUPACMAT (NUMPAC, PACMAT, MATRIC, PRIORITE_SITUATION) VALUES (v_ligNew.CURRENT_NUMPAC, v_ligNew.CURRENT_PACMAT, v_ligNew.MATRIC, 0);
    merge into SECUPACMAT a using (select v_ligNew.CURRENT_NUMPAC as numpac, v_ligNew.CURRENT_PACMAT as pacmat, v_ligNew.MATRIC as matric , 0 as PRIORITE_SITUATION from dual) b on (a.numpac=b.numpac and a.pacmat=b.pacmat )
    when not matched then
    insert (a.NUMPAC, a.PACMAT, a.MATRIC, a.PRIORITE_SITUATION) values (b.NUMPAC, b.PACMAT, b.MATRIC, b.PRIORITE_SITUATION);

    -- On stocke la liste des MATRIC modifiés
    IF v_type_writer<>''N'' AND v_type_writer<>''M'' AND (v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_ligNew.MATRIC)<=0) THEN
      IF v_nbMatricToUpdate=1000 THEN
        v_nbMatricToUpdate := 0;
        v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
      ELSIF v_nbMatricToUpdate>0 THEN
        v_listMatricToUpdate := v_listMatricToUpdate||'','';
      END IF;
      v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_ligNew.MATRIC||'''''''';
      v_nbMatricToUpdate := v_nbMatricToUpdate+1;
    END IF;
  ELSIF UPDATING THEN
    -- On vérifie qu''on ne modifie pas le RHID
    IF NOT v_ligOld.MATRIC=v_ligNew.MATRIC THEN
      -- Message d''erreur --> On interdit la mise à jour du RHID : il faut faire un delete puis un insert
      RAISE_APPLICATION_ERROR(-20000,''La mise à jour de la colonne MATRIC n''''est pas autorisée : vous devez supprimer puis recréer le dossier'');
    END IF;
    IF (NOT UPDATING(''DATE_EFF_PERSO'') AND NOT UPDATING(''CURRENT_NUMPAC'') AND NOT UPDATING(''CURRENT_PACMAT'') AND NOT UPDATING(''CURRENT_NUMCNT'') AND NOT UPDATING(''DATE_EFF_CONTRAT'')) THEN
      -- On considère que c''est une "vraie" mise à jour si ce n''est pas de la mise à jour de DATE_EFF_PERSO, CURRENT_NUMPAC, CURRENT_PACMAT, CURRENT_NUMCNT ou DATE_EFF_CONTRAT
      -- On stocke la liste des MATRIC modifiés
      IF v_type_writer<>''N'' AND v_type_writer<>''M'' AND (v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_ligNew.MATRIC)<=0) THEN
        IF v_nbMatricToUpdate=1000 THEN
          v_nbMatricToUpdate := 0;
          v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
        ELSIF v_nbMatricToUpdate>0 THEN
          v_listMatricToUpdate := v_listMatricToUpdate||'','';
        END IF;
        v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_ligNew.MATRIC||'''''''';
        v_nbMatricToUpdate := v_nbMatricToUpdate+1;
      END IF;
    END IF;
  ELSIF DELETING THEN
    -- On stocke la liste des MATRIC supprimés
    IF v_listMatricToDelete IS NULL OR INSTR(v_listMatricToDelete,v_ligOld.MATRIC)<=0 THEN
      IF v_nbMatricToDelete=1000 THEN
        v_nbMatricToDelete := 0;
        v_listMatricToDelete := v_listMatricToDelete||'') OR MATRIC IN ('';
      ELSIF v_nbMatricToDelete>0 THEN
        v_listMatricToDelete := v_listMatricToDelete||'','';
      END IF;
      v_listMatricToDelete := v_listMatricToDelete||''''''''||v_ligOld.MATRIC||'''''''';
      v_nbMatricToDelete := v_nbMatricToDelete+1;
    END IF;
  END IF;
';
END TRG_PERSO_BEFORE_ROW;
##
TRG_PERSO_HISTO_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_PERSO_HISTO_AFTER_STMNT RETURN CLOB AS 
BEGIN
  RETURN '
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- On insère dans la table temporaire les MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''PERSO_HISTO UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING (''INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_PERSO(''DO_MAJ'', 0, 1, 0);
    ALIM_IDX_PERSO_HISTO(1);
    EXECUTE_IMMEDIATE_STRING( ''DELETE FROM SECUPACMAT_TMP_PERSO'',0);
  END IF;
';
END TRG_PERSO_HISTO_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
TRG_PERSO_HISTO_BEFORE_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_PERSO_HISTO_BEFORE_ROW RETURN CLOB AS 
BEGIN
  RETURN '
  -- On vérifie qu''on ne modifie ni le RHID, ni la date d''effet
  IF UPDATING AND (NOT v_ligOld.MATRIC=v_ligNew.MATRIC OR NOT v_ligOld.DATE_EFF=v_ligNew.DATE_EFF) THEN
    -- Message d''erreur --> On interdit la mise à jour du RHID et de la date d''effet : il faut faire un delete puis un insert
    RAISE_APPLICATION_ERROR(-20000,''La mise à jour des colonnes MATRIC et DATE_EFF n''''est pas autorisée : vous devez supprimer puis recréer l''''occurrence'');
  END IF;
  IF INSERTING OR UPDATING THEN
    IF v_ligNew.DATE_FIN IS NULL THEN
      :NEW.DATE_FIN := TO_DATE(''20991231'',''yyyymmdd'');
      v_ligNew.DATE_FIN := :NEW.DATE_FIN;
    END IF;
  END IF;
  IF v_type_writer<>''N'' AND v_type_writer<>''M'' AND (v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,NVL(v_ligNew.MATRIC,v_ligOld.MATRIC))<=0) THEN
    -- On stocke la liste des MATRIC modifiés
    IF v_nbMatricToUpdate=1000 THEN
      v_nbMatricToUpdate := 0;
      v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
    ELSIF v_nbMatricToUpdate>0 THEN
      v_listMatricToUpdate := v_listMatricToUpdate||'','';
    END IF;
    v_listMatricToUpdate := v_listMatricToUpdate||''''''''||NVL(v_ligNew.MATRIC,v_ligOld.MATRIC)||'''''''';
    v_nbMatricToUpdate := v_nbMatricToUpdate+1;
  END IF;
';
END TRG_PERSO_HISTO_BEFORE_ROW;
##
VERIF_COL_VALUE
=SQL=
create or replace FUNCTION VERIF_COL_VALUE (P_TRT IN NUMBER , P_TABLEGXP IN VARCHAR2 )RETURN TYP_TAB_VERIF AS 

p_retour TYP_TAB_VERIF := TYP_TAB_VERIF();
n INTEGER := 0; 
 BEGIN
 FOR une_ligne IN 
 (SELECT NUMPAC,TABLEGXP,DONNEEGXP,PACMAT,PAIEZAD,VALEUR 
  FROM   TGE_IMPORT_FSED_30 T 
  WHERE  ID_TRT =P_TRT 
  AND    TABLEGXP=P_TABLEGXP 
  AND    IS_NUMBER(VALEUR) >= (SELECT POWER(10,(DATA_PRECISION-DATA_SCALE )) 
                               FROM   USER_TAB_COLS  
                               WHERE  TABLE_NAME=P_TABLEGXP 
                               AND    DATA_TYPE='NUMBER' 
                               AND    COLUMN_NAME=T.DONNEEGXP )
  )
 LOOP
 p_retour.extend;
 n := n + 1;
 p_retour(p_retour.count) := TYP_VERIF(une_ligne.numpac,  une_ligne.TABLEGXP,une_ligne.DONNEEGXP, une_ligne.pacmat, une_ligne.paiezad, une_ligne.valeur);
 END LOOP;
 RETURN p_retour;
 END VERIF_COL_VALUE;
##
VERIF_TRTPARTICULIER
=SQL=
CREATE OR REPLACE FUNCTION VERIF_TRTPARTICULIER RETURN T_TABLE AS 
  p_traitement VARCHAR2(1000);
  p_retour T_TABLE := T_TABLE();
  n INTEGER := 0;
  w_date tab_varchar;
BEGIN
  FOR un_traitement IN (SELECT distinct TRTPARTICULIER, DONNEEGXP, TABLEGXP, TGE_REF_MAPDO.NUMPAC, TGE_REF_MAPDO.ELEMENT ,
                        case when masque >0 and masque <8 and TYPE='N' THEN 'D' else   'NOTDATE' end as type_donnee,
                        LONGUEUR 
                        FROM TGE_REF_MAPDO ,TGE_REF_DICOZ 
                        WHERE TGE_REF_DICOZ.element =TGE_REF_MAPDO.element AND TRTPARTICULIER  IS NOT NULL
                        ORDER BY TRTPARTICULIER)
  LOOP
    BEGIN
      p_traitement := un_traitement.TRTPARTICULIER;
      p_traitement := REPLACE(p_traitement,''''||'$DONNEEGXP'||'''',''''||un_traitement.DONNEEGXP||'''');
      p_traitement := REPLACE(p_traitement,'$DONNEEGXP',un_traitement.DONNEEGXP);
      p_traitement := REPLACE(p_traitement,'$TABLE',un_traitement.TABLEGXP);
      p_traitement := REPLACE(p_traitement,'$NUMPAC',un_traitement.NUMPAC);
      IF p_traitement IS NOT NULL THEN
        IF un_traitement.type_donnee ='D' AND un_traitement.LONGUEUR >=8 THEN
          p_traitement := 'SELECT to_char(' || p_traitement || ',''yyyymmddHH24MISS'') FROM ' || un_traitement.TABLEGXP ||' where rownum<1000';
          EXECUTE IMMEDIATE p_traitement bulk collect INTO w_date;
        ELSE
          p_traitement := 'SELECT ' || p_traitement || ' FROM ' || un_traitement.TABLEGXP ||' where rownum<1000 ';
          EXECUTE_IMMEDIATE_STRING (p_traitement,0) ;
        END IF;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      p_retour.extend;
      n                        := n + 1;
      p_retour(p_retour.count) := T_COL(un_traitement.NUMPAC, un_traitement.ELEMENT, un_traitement.TRTPARTICULIER);
    END;
  END LOOP;
  RETURN p_retour;
END VERIF_TRTPARTICULIER;
##
TAG_CHARSET=@€éèç
##
AFFECT_REQ
=SQL=
create or replace PACKAGE AFFECT_REQ
AS
  PROCEDURE maj_requetesimple(
      p_id             NUMBER,
      p_application    VARCHAR2,
      p_nomrequete     VARCHAR2,
      p_requeteecr_gsi VARCHAR2 );
  PROCEDURE principal(
      p_application VARCHAR2) ;
TYPE requeteSimple
IS
  RECORD
  (
    nomrequete     VARCHAR2(50 BYTE),
    requeteEcr_Gsi VARCHAR2(4000 BYTE));
TYPE STD_REQUETESAISIE
IS
  RECORD
  (
    bloc      VARCHAR2(999),
    etou      VARCHAR2(100),
    operateur VARCHAR2(20),
    parapres  VARCHAR2(5),
    paravant  VARCHAR2(5),
    selection VARCHAR2(100),
    valeur    VARCHAR2(100));
TYPE type_List_arr IS VARRAY(999) OF STD_REQUETESAISIE;
TYPE type_listNomRequete IS VARRAY(999)OF REQUETESIMPLE;
p_requetesimple REQUETESIMPLE;
END AFFECT_REQ;   
##
AFFECT_REQ
=SQL=
CREATE OR REPLACE PACKAGE BODY AFFECT_REQ
AS
  PROCEDURE maj_requetesimple(
      p_id             NUMBER,
      p_application    VARCHAR2,
      p_nomrequete     VARCHAR2,
      p_requeteecr_gsi VARCHAR2 )
  IS
    cpt      NUMBER;
    p_prefix NUMBER;
    p_txtreq VARCHAR2(4000);
    p_retour type_List_arr;
    p_retourReqSplit TAB_VARCHAR;
    parOuvrante   NUMBER;
    indexNomTable NUMBER;
    listParam type_List_arr;
    p_requeteSaisie STD_REQUETESAISIE;
    withClausePac NUMBER;
    noUpdate      NUMBER;
    valeurPac     VARCHAR2(20);
  BEGIN
    SELECT AVECNOMTABLE
    INTO p_prefix
    FROM REQUETEURAPP
    WHERE application =p_application ;
    /* découpage de la requete*/
    p_txtreq                    := p_requeteecr_gsi;
    p_txtreq                    := REPLACE(p_txtreq,'@@', '{{OR{{');
    p_txtreq                    :=REPLACE(p_txtreq, '##', '{{AND{{');
    p_txtreq                    := REPLACE(p_txtreq,'{{', '¿');
    IF ( p_txtreq               IS NOT NULL ) THEN
      p_retourReqSplit          := split_string_into_tab(p_txtreq, '¿');
      IF (p_retourReqSplit.COUNT >1) THEN
        listParam               := type_List_arr();
        FOR i IN 1..p_retourReqSplit.COUNT
        LOOP
          parOuvrante:=0;
          IF i mod 4  =1 THEN
            listParam.extend;
            p_requeteSaisie       := STD_REQUETESAISIE(NULL,NULL, NULL,NULL,NULL,NULL,NULL);
            IF (i                  > 0) THEN
              p_requeteSaisie.ETOU:= p_retourReqSplit(i);
            END IF ;
            p_requeteSaisie.SELECTION                       := trim (p_retourReqSplit(i+1));
            IF ( LENGTH ( trim ( p_requeteSaisie.SELECTION)) > 0 AND '('= SUBSTR ( trim ( p_requeteSaisie.SELECTION),0,1) )THEN
              p_requeteSaisie.SELECTION                     := trim (SUBSTR ( p_requeteSaisie.SELECTION ,1));
              p_requeteSaisie.PARAVANT                      := '(';
              parOuvrante                                   :=1;
            END IF;
            IF ( p_prefix                  = 1) THEN
              indexNomTable               := INSTR( p_requeteSaisie.SELECTION , '.') ;
              IF ( indexNomTable           > 0) THEN
                p_requeteSaisie.SELECTION := SUBSTR ( p_requeteSaisie.SELECTION ,indexNomTable);
              END IF ;
            END IF;
            p_requeteSaisie.OPERATEUR  := p_retourReqSplit(i                                                                                                                       + 2);
            p_requeteSaisie.VALEUR     :=trim (p_retourReqSplit(i                                                                                                                  + 3));
            IF ( parOuvrante            =1 AND LENGTH ( trim (p_requeteSaisie.VALEUR) )>0 AND ')'=SUBSTR ( TRIM (p_requeteSaisie.VALEUR ), LENGTH( trim ( p_requeteSaisie.VALEUR) )-1 , LENGTH( trim ( p_requeteSaisie.VALEUR) ))) THEN
              p_requeteSaisie.VALEUR   :=SUBSTR (trim ( p_requeteSaisie.VALEUR) , 0 , LENGTH( trim ( p_requeteSaisie.VALEUR))                                                      -1) ;
              p_requeteSaisie.PARAPRES := ')';
              parOuvrante              :=0;
            END IF;
            IF (i          =1) THEN
              listParam(1):= p_requeteSaisie;
            ELSE
              listParam(listParam.count):=p_requeteSaisie;
            END IF;
          ELSE
            CONTINUE;
          END IF;
        END LOOP;
        /*Si la requête contient une seule clause de sécurité de type Numpac = 'xxx' ou Numpac in ('xxx') et qu'elle n'est pas précédée par l'opérateur 'OR'
        on l'affecte au numpac xxx
        */
        noUpdate:=0;
        FOR k IN 1..listParam.COUNT
        LOOP         
          IF listParam(k).ETOU != 'AND' THEN
   			 noUpdate           :=1;
    		 EXIT;
 		  END IF ;
          IF trim(listParam(k).SELECTION) ='PAC' THEN
            IF (withClausePac      IS NULL )THEN
              withClausePac        := 1;
            ELSE
              withClausePac :=withClausePac+1;
            END IF;
            IF listParam(k).OPERATEUR NOT IN ( 'EQUAL','Egal à', 'IN','Dans la liste') THEN
              noUpdate :=1;
              EXIT;
            END IF;
            IF ( INSTR( listParam(k).VALEUR ,',')>0) THEN
              noUpdate                          :=1;
              EXIT;
            END IF ;
            valeurPac := listParam(k).VALEUR;
          END IF;
        END LOOP;
        IF ( withClausePac = 1 AND valeurPac IS NOT NULL AND noUpdate =0 ) THEN
          UPDATE REQUETESIMPLE
          SET NUMPAC       = valeurPac
          WHERE application=p_application
          AND NOMREQUETE   =p_nomrequete ;
          FSED.FSED_AVANCEMENT_PLSQL(p_id,'AFFECT_REC ','MAJ de la requete '||p_nomrequete);
        END IF;
      END IF;
    END IF;
  END;
  PROCEDURE principal(
      p_application VARCHAR2)
  IS
    p_id NUMBER;
    cpt  NUMBER;
    cur_1 SYS_REFCURSOR;
    sql_1 VARCHAR2(200);
    listRequete type_listNomRequete;
    p_userManagementByPac VARCHAR2(10);
  BEGIN
    SELECT GAP_TRT_SEQ_ID.nextval INTO p_id FROM DUAL;
    SELECT UPPER(valvar)
    INTO p_userManagementByPac
    FROM sys_varsys
    WHERE codvar ='USER_MANAGEMENT_BY_PAC'
    AND module   ='STD' ;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'AFFECT_REC (Begin)','Début d''affectation des requetes de sécurités aux pacs adéquats pour application: '|| p_application);
    IF (p_application IN ('SEC_LOC', 'GAP_NAT_TRT_PAIE_SEC_EXP') AND p_userManagementByPac='TRUE' ) THEN
      listRequete                                                                        := type_listNomRequete();
      sql_1                                                                              :='SELECT nomrequete, requeteecr_gsi  from requetesimple where  application = '''||p_application ||'''';
      cpt                                                                                :=0;
      OPEN cur_1 FOR sql_1;
      LOOP
        FETCH cur_1 INTO p_requetesimple;
        EXIT
      WHEN cur_1%NOTFOUND;
        cpt :=cpt+1;
        listRequete.extend;
        listRequete(cpt) :=p_requetesimple;
        begin
			maj_requetesimple(p_id, p_application, listRequete(cpt).nomRequete, listRequete(cpt).requeteEcr_GSI);
			exception
			when others then
			FSED.FSED_AVANCEMENT_PLSQL(p_id, 'AFFECT_REQ (Erreur)', listRequete(cpt).nomRequete || ' :' || SQLCODE || '-' || SQLERRM);
		end;
      END LOOP;
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'AFFECT_REC (End)','Fin d''affectation des requetes de sécurités aux pacs adéquats pour application: '|| p_application);
    ELSE
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'AFFECT_REC (End)','USER_MANAGEMENT_BY_PAC est non activée ou application n''est pas dans la liste (population, nature de traitement de paie ) ');
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    FSED.FSED_AVANCEMENT_PLSQL(p_id ,'AFFECT_REQ (Erreur)', SQLCODE||'-'||SQLERRM );
  END;
END AFFECT_REQ;
##
PACKAGE_BODY_ALERT
=SQL=
create or replace PACKAGE Alert IS
  PROCEDURE exec(pDateExec VARCHAR2,pAlertID VARCHAR2);
  PROCEDURE exec_login(pDateExec VARCHAR2,pAlertID VARCHAR2);
  PROCEDURE exec_user(pLogin VARCHAR2,pDateExec VARCHAR2);
END Alert;
##
PACKAGE_ALERT
=SQL=
create or replace PACKAGE BODY Alert IS
  
  FUNCTION notify_Alert_Begin(pDateExec DATE , pAlertNbToExecute INTEGER) RETURN BOOLEAN;
  
  FUNCTION notify_Alert_User_Begin(pLogin VARCHAR2 , pDateExec DATE) RETURN BOOLEAN;

  FUNCTION notify_LoginAlert_Begin(pDateExec DATE , pAlertLoginNbToExecute INTEGER) RETURN BOOLEAN;

  FUNCTION notify_Alert_Processed(pDateExec DATE , pAlertProcessed INTEGER ) RETURN BOOLEAN;
  
  FUNCTION notify_LoginAlert_Processed(pDateExec DATE , pLoginAlertProcessed INTEGER ) RETURN BOOLEAN;

  FUNCTION set_Alert_Elapsed_Time(pDateExec DATE , pOrderNb INTEGER , pElapsedTime INTEGER)  RETURN BOOLEAN;
  
  FUNCTION set_Alert_User_Elapsed_Time(pLogin VARCHAR2 , pDateExec DATE , pOrderNb INTEGER , pElapsedTime INTEGER)  RETURN BOOLEAN;

  FUNCTION notify_Alert_End_OK(pDateExec DATE) RETURN BOOLEAN;
  
  FUNCTION notify_Alert_User_End_OK(pLogin VARCHAR2,pDateExec DATE) RETURN BOOLEAN;

  PROCEDURE notify_Alert_End_KO(pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2);
  
  FUNCTION notify_LoginAlert_End_OK(pDateExec DATE) RETURN BOOLEAN;

  PROCEDURE notify_LoginAlert_End_KO(pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2);

  PROCEDURE insert_Error(pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2);

  PROCEDURE update_User_Error (pLogin VARCHAR2 , pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2);
  
/*
Cette procédure est lancée par fr.adp.com.gxp.std.modules.lib.alert.batch.Traitement_Alerte
Elle a pour but d'exécuter les requêtes de ALERT_BATCH_EXEC
*/
  PROCEDURE exec(pDateExec VARCHAR2,pAlertID VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
    dateExec DATE;
    endProcForced BOOLEAN;
    TYPE TypeAlertBatchExec IS TABLE OF ALERT_BATCH_EXEC%ROWTYPE;
    listAlertBatchExec TypeAlertBatchExec;
    CURSOR cursorAlertBatchExec (pDate DATE) IS 
    SELECT * FROM ALERT_BATCH_EXEC WHERE DATE_EXEC = pDate ORDER BY ORDER_NB;
    alertNb INTEGER  := 0;
    alertProcessed INTEGER := 0;
    elapsedTime NUMBER;
    orderNb NUMBER;
    time01 NUMBER;
    time02 NUMBER;
    rowNb INTEGER;
    params VARCHAR2(1000);
    stSql CLOB;
  
  BEGIN
    --DBMS_OUTPUT.PUT_LINE('BEGIN exec:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
    dateExec := TO_DATE(pDateExec,'YYYYMMDDHH24MISS');

    OPEN cursorAlertBatchExec(dateExec);
    FETCH cursorAlertBatchExec BULK COLLECT INTO listAlertBatchExec;
    CLOSE cursorAlertBatchExec;

    endProcForced := notify_Alert_Begin(dateExec,listAlertBatchExec.COUNT);
    IF (endProcForced) THEN
      GOTO END_EXEC;
    END IF;

    BEGIN
      DELETE FROM ALERT_BATCH WHERE DATE_EXEC < TRUNC(ADD_MONTHS(SYSDATE,-2));
      DELETE FROM ALERT_BATCH_STATS WHERE DATE_EXEC < ADD_MONTHS(TRUNC (SYSDATE, 'month'),-25);
    EXCEPTION
      WHEN OTHERS THEN
        insert_Error(dateExec,'Erreur de suppression des traitements obsolètes: ' || SQLERRM,'');
        GOTO END_EXEC;
    END;
    
    BEGIN
      DELETE FROM ALERT_BATCH_ERROR WHERE DATE_EXEC = dateExec;
    EXCEPTION
      WHEN OTHERS THEN
        insert_Error(dateExec,'Erreur de suppression des erreurs batch: ' || SQLERRM,'');
        GOTO END_EXEC;
    END;

    IF pAlertID IS NULL THEN
      BEGIN
        EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE ALERT_BATCH1',0);
      EXCEPTION
        WHEN OTHERS THEN
          insert_Error(dateExec,'Erreur de suppression (PLSQL001) : ' || SQLERRM,'');
          GOTO END_EXEC;
      END;
    ELSE
      BEGIN
        DELETE FROM ALERT_BATCH1 WHERE ALERT_ID = pAlertID;
        COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          insert_Error(dateExec,'Erreur de suppression (PLSQL002) : ' || SQLERRM,'');
          GOTO END_EXEC;
      END;
    END IF;

    rowNb := -1;
    IF (listAlertBatchExec.FIRST IS NOT NULL) THEN
      BEGIN
        FOR i IN listAlertBatchExec.FIRST..listAlertBatchExec.LAST LOOP
          rowNb := i;
          orderNb := listAlertBatchExec(rowNb).ORDER_NB;
          time01 := TO_CHAR(SYSDATE,'SSSSS');
          EXECUTE_IMMEDIATE_STRING( listAlertBatchExec(rowNb).ALERT_SQL,0);
          alertNb := SQL%ROWCOUNT;
          time02 := TO_CHAR(SYSDATE,'SSSSS');
          IF (time01 > time02) THEN
            elapsedTime := 86400 - time01 + time02;
          ELSE
           elapsedTime := time02 - time01;
          END IF;
          endProcForced := set_Alert_Elapsed_Time(dateExec,orderNb,elapsedTime);
          IF (endProcForced) THEN
           GOTO END_EXEC;
          END IF;
          alertProcessed := alertProcessed + 1;
          endProcForced := notify_Alert_Processed(dateExec,alertProcessed);
          IF (endProcForced) THEN
            GOTO END_EXEC;
          END IF;
        END LOOP;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          IF (rowNb > -1) THEN
            params := '[ORDER_NB=' || listAlertBatchExec(rowNb).ORDER_NB || ';ALERT_ID=' || listAlertBatchExec(rowNb).ALERT_ID || ']';
          END IF;
          notify_Alert_End_KO(dateExec,SQLERRM,params);
          GOTO END_EXEC;
      END;
    END IF;

    COMMIT;

    IF pAlertID IS NULL THEN
      INSERT INTO ALERT_BATCH_STATS SELECT dateExec ,ALERT_ID,COUNT(*) FROM ALERT_BATCH1 GROUP BY ALERT_ID;
      COMMIT;
    END IF;
    
    endProcForced := notify_Alert_End_OK(dateExec);
    IF (endProcForced) THEN
      GOTO END_EXEC;
    END IF;
    
    exec_login(pDateExec,pAlertID);
    <<END_EXEC>>
    --DBMS_OUTPUT.PUT_LINE('END exec:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
    NULL;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(dateExec,SQLERRM,'[exec]');
  END exec;

  PROCEDURE exec_login(pDateExec VARCHAR2,pAlertID VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
    dateExec DATE;
    endProcForced BOOLEAN;
    TYPE TypeLoginAlert IS RECORD (login SYS_USR_PROFIL.LOGIN%TYPE ,alertID ALERT_PROP.ALERT_ID%TYPE ,stWhere ALERT_PROP.SQL_WHERE_2%TYPE,peopleID ALERT_PROP.PEOPLE_ID%TYPE,pacmatID ALERT_PROP.PACMAT_ID%TYPE,strID ALERT_PROP.STR_ID%TYPE);
    TYPE TypeTableLoginAlert IS TABLE OF TypeLoginAlert;
    listLoginAlert TypeTableLoginAlert;

    CURSOR cursorLoginAlert1 IS 
    SELECT DISTINCT SYS_USR_PROFIL.LOGIN,ALERT_PROP.ALERT_ID,ALERT_PROP.SQL_WHERE_2,ALERT_PROP.PEOPLE_ID,ALERT_PROP.PACMAT_ID,ALERT_PROP.STR_ID
    FROM SYS_USR_PROFIL
    JOIN SYS_USR_CONNU ON (SYS_USR_PROFIL.LOGIN = SYS_USR_CONNU.LOGIN)
    JOIN ALERT_PROFILE ON (SYS_USR_PROFIL.CODE_PROFIL = ALERT_PROFILE.PROFILE_ID)
    JOIN ALERT_BATCH1 ON (ALERT_PROFILE.ALERT_ID = ALERT_BATCH1.ALERT_ID)
    JOIN ALERT_PROP ON (ALERT_BATCH1.ALERT_ID = ALERT_PROP.ALERT_ID)
    WHERE SYS_USR_CONNU.ACTIF = '1'
    ORDER BY SYS_USR_PROFIL.LOGIN,ALERT_PROP.ALERT_ID;

    CURSOR cursorLoginAlert2(pAlertID VARCHAR2) IS 
    SELECT DISTINCT SYS_USR_PROFIL.LOGIN,ALERT_PROP.ALERT_ID,ALERT_PROP.SQL_WHERE_2,ALERT_PROP.PEOPLE_ID,ALERT_PROP.PACMAT_ID,ALERT_PROP.STR_ID
    FROM SYS_USR_PROFIL
    JOIN SYS_USR_CONNU ON (SYS_USR_PROFIL.LOGIN = SYS_USR_CONNU.LOGIN)
    JOIN ALERT_PROFILE ON (SYS_USR_PROFIL.CODE_PROFIL = ALERT_PROFILE.PROFILE_ID)
    JOIN ALERT_BATCH1 ON (ALERT_PROFILE.ALERT_ID = ALERT_BATCH1.ALERT_ID)
    JOIN ALERT_PROP ON (ALERT_BATCH1.ALERT_ID = ALERT_PROP.ALERT_ID)
    WHERE SYS_USR_CONNU.ACTIF = '1' AND ALERT_BATCH1.ALERT_ID = pAlertID
    ORDER BY SYS_USR_PROFIL.LOGIN,ALERT_PROP.ALERT_ID;

    varsysCodts INTEGER;
    found INTEGER;
    alertNb INTEGER  := 0;
    loginAlertProcessed INTEGER := 0;
    rowNb INTEGER;
    params VARCHAR2(1000);
    currentLogin SYS_USR_PROFIL.LOGIN%TYPE;
    previousLogin SYS_USR_PROFIL.LOGIN%TYPE;
    alertID ALERT_PROP.ALERT_ID%TYPE;
    STSQL_LOGIN CLOB :='INSERT INTO ALERT_BATCH2_TMP SELECT :1 ,ALERT_BATCH1.ALERT_ID,ALERT_BATCH1.ID1,ALERT_BATCH1.ID2,ALERT_BATCH1.ID3,ALERT_BATCH1.ID4,ALERT_BATCH1.ID5,ALERT_BATCH1.ID6 FROM ALERT_BATCH1 WHERE ALERT_BATCH1.ALERT_ID = :2';
    stSql CLOB;
    stPeople VARCHAR2(4000);
    stPacmat VARCHAR2(4000);
    stStr VARCHAR2(4000);
    securityPeople INTEGER;
    securityStr INTEGER;
    schemaDB VARCHAR2(250);
  BEGIN
    --DBMS_OUTPUT.PUT_LINE('BEGIN exec_login:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
    dateExec := TO_DATE(pDateExec,'YYYYMMDDHH24MISS');
    
    BEGIN
      SELECT TO_NUMBER(NVL(VALVAR,'0')) INTO varsysCodts FROM SYS_VARSYS WHERE MODULE = 'STD' AND CODVAR = 'DEFAULT_CODTS' ;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        BEGIN
          SELECT TO_NUMBER(NVL(VALVAR,'0')) INTO varsysCodts FROM SYS_VARSYS WHERE MODULE = 'SYS' AND CODVAR = 'DEFAULT_CODTS' ;
        EXCEPTION
          WHEN OTHERS THEN
            insert_Error(dateExec,'Erreur d''accès (PLSQL003) : ' || SQLERRM,'');
            GOTO END_EXEC;
        END;
      WHEN OTHERS THEN
        insert_Error(dateExec,'Erreur d''accès (PLSQL004) : ' || SQLERRM,'');
        GOTO END_EXEC;
    END;

    IF pAlertID IS NULL THEN
      OPEN cursorLoginAlert1;
      FETCH cursorLoginAlert1 BULK COLLECT INTO listLoginAlert;
      CLOSE cursorLoginAlert1;
    ELSE
      OPEN cursorLoginAlert2(pAlertID);
      FETCH cursorLoginAlert2 BULK COLLECT INTO listLoginAlert;
      CLOSE cursorLoginAlert2;
    END IF;
    IF pAlertID IS NULL THEN
      BEGIN
        EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE ALERT_BATCH2_TMP',0);
      EXCEPTION
        WHEN OTHERS THEN
          insert_Error(dateExec,'Erreur de suppression (PLSQL005) : ' || SQLERRM,'');
          GOTO END_EXEC;
      END;
    ELSE
      BEGIN
        DELETE FROM ALERT_BATCH2_TMP WHERE ALERT_ID = pAlertID;
        COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          insert_Error(dateExec,'Erreur de suppression (PLSQL006) : ' || SQLERRM,'');
          GOTO END_EXEC;
      END;
    END IF;
    endProcForced := notify_LoginAlert_Begin(dateExec,listLoginAlert.COUNT);
    IF (endProcForced) THEN
      GOTO END_EXEC;
    END IF;

    rowNb := -1;
    currentLogin := NULL;
    previousLogin := NULL;

    IF (listLoginAlert.FIRST IS NOT NULL) THEN
      BEGIN
        FOR i IN listLoginAlert.FIRST..listLoginAlert.LAST LOOP
          rowNb := i;
          currentLogin := listLoginAlert(rowNb).login;
          alertID := listLoginAlert(rowNb).alertID;
          IF previousLogin IS NULL OR currentLogin != previousLogin THEN
            BEGIN
              SELECT ID_SECU INTO securityPeople FROM SYS_SEC_RESOLUE_POP_REQ WHERE LOGIN = currentLogin;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                securityPeople := NULL;
              WHEN OTHERS THEN
                params := '[LOGIN=' || currentLogin || ';ALERT_ID=' || alertID || ']';
                notify_LoginAlert_End_KO(dateExec,SQLERRM,params);
                GOTO END_EXEC;
            END;
            BEGIN
              SELECT ID_SECU INTO securityStr FROM SYS_SEC_RESOLUE_STRUCT_REQ WHERE LOGIN = currentLogin AND CODTS = varsysCodts;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                securityStr := NULL;
              WHEN OTHERS THEN
                params := '[LOGIN=' || currentLogin || ';ALERT_ID=' || alertID || ']';
                notify_LoginAlert_End_KO(dateExec,SQLERRM,params);
                GOTO END_EXEC;
            END;
          END IF;

          IF listLoginAlert(rowNb).peopleID IS NULL OR listLoginAlert(rowNb).peopleID = 0 THEN
            stPeople := '';
          ELSE
            IF securityPeople IS NULL OR securityPeople = -1 THEN
              GOTO NEXT_LOGIN_ALERT;
            ELSIF securityPeople = 0 THEN
              stPeople := '';
            ELSE
              stPeople := ' AND ID' || listLoginAlert(rowNb).peopleID || ' IN ( SELECT MATRIC FROM SYS_SEC_RESOLUE_POP_MAT WHERE ID_SECU = '||securityPeople||')';
            END IF;
          END IF;
          
          IF listLoginAlert(rowNb).pacmatID IS NULL OR listLoginAlert(rowNb).pacmatID = 0 THEN
            stPacmat := '';
          ELSE
            IF securityPeople IS NULL OR securityPeople = -1 THEN
              GOTO NEXT_LOGIN_ALERT;
            ELSIF securityPeople = 0 THEN
              stPacmat := '';
            ELSE
              stPacmat := ' AND ID' || listLoginAlert(rowNb).pacmatID || ' IN ( SELECT IDPACMAT FROM SYS_SEC_RESOLUE_POP_PAC WHERE ID_SECU = '||securityPeople||')';
            END IF;
          END IF;

          IF listLoginAlert(rowNb).strID IS NULL OR listLoginAlert(rowNb).strID = 0 THEN
            stStr := '';
          ELSE
            IF securityStr IS NULL OR securityStr = -1 THEN
              GOTO NEXT_LOGIN_ALERT;
            ELSIF securityStr = 0 THEN
              stStr := '';
            ELSE
              stStr := ' AND ID' || listLoginAlert(rowNb).strID || ' IN ( SELECT CODE_ENTITE FROM SYS_SEC_RESOLUE_STRUCT WHERE ID_SECU = '||securityStr||' AND CODTS = '|| varsysCodts || ')';
            END IF;
          END IF;
          
          stSql := STSQL_LOGIN || stPeople || stPacmat || stStr;
          
          IF listLoginAlert(rowNb).stWhere IS NOT NULL THEN
             stSql := stSql  || ' AND ( ' || REPLACE(listLoginAlert(rowNb).stWhere,'$LOGIN','''' ||currentLogin ||'''') || ' ) ';
          END IF;
          
          EXECUTE IMMEDIATE stSql USING currentLogin,alertID;
          <<NEXT_LOGIN_ALERT>>
          previousLogin :=currentLogin;
          loginAlertProcessed := loginAlertProcessed + 1;
          MERGE INTO ALERT_BATCH_USER USING (SELECT 1 FROM DUAL) ON (ALERT_BATCH_USER.LOGIN = previousLogin AND ALERT_BATCH_USER.DATE_EXEC = dateExec)
          WHEN MATCHED THEN
            UPDATE SET DATE_BEGIN = NULL, DATE_END = NULL, STATUS_ID = 'END_OK', ERROR_MESSAGE = NULL, ERROR_PARAMS = NULL
          WHEN NOT MATCHED THEN INSERT VALUES (previousLogin,dateExec,NULL,NULL,NULL,NULL,NULL);
          endProcForced := notify_LoginAlert_Processed(dateExec,loginAlertProcessed);
          IF (endProcForced) THEN
            GOTO END_EXEC;
          END IF;
        END LOOP;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          IF (rowNb > -1) THEN
            params := '[LOGIN=' || currentLogin || ';ALERT_ID=' || alertID || ']';
          END IF;
          notify_LoginAlert_End_KO(dateExec,SQLERRM,params);
          GOTO END_EXEC;
      END;
    END IF;
    
    COMMIT;--COMMIT ALERT_BATCH2_TMP
    
    BEGIN
      IF pAlertID IS NULL THEN
          EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE ALERT_BATCH2',0);
          INSERT INTO ALERT_BATCH2 SELECT * FROM ALERT_BATCH2_TMP;
      ELSE
        DELETE FROM ALERT_BATCH2 WHERE ALERT_ID = pAlertID;
        INSERT INTO ALERT_BATCH2 SELECT * FROM ALERT_BATCH2_TMP WHERE ALERT_ID = pAlertID;
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        insert_Error(dateExec,'Erreur de bascule (PLSQL015) : ' || SQLERRM,'[ALERT_ID=' || pAlertID || ']');
        GOTO END_EXEC;
    END;

    endProcForced := notify_LoginAlert_End_OK(dateExec);
    <<END_EXEC>>

    COMMIT;
    SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') INTO schemaDB FROM DUAL;
    --DBMS_STATS.GATHER_TABLE_STATS(schemaDB,'ALERT_BATCH2', ESTIMATE_PERCENT=>NULL,METHOD_OPT=>'FOR ALL COLUMNS SIZE 1',CASCADE=>FALSE);
    --DBMS_OUTPUT.PUT_LINE('END exec_login:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(dateExec,SQLERRM,'[exec_login]');
  END exec_login;

  PROCEDURE exec_user(pLogin VARCHAR2,pDateExec VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
    dateExec DATE;
    endProcForced BOOLEAN;
    TYPE TypeAlertBatchUserExec IS TABLE OF ALERT_BATCH_USER_EXEC%ROWTYPE;
    listAlertBatchUserExec TypeAlertBatchUserExec;
    CURSOR cursorAlertBatchUserExec (pLogin VARCHAR2,pDateExec DATE) IS 
    SELECT * FROM ALERT_BATCH_USER_EXEC WHERE LOGIN = pLogin AND DATE_EXEC = pDateExec ORDER BY ORDER_NB;
    elapsedTime NUMBER;
    orderNb NUMBER;
    time01 NUMBER;
    time02 NUMBER;
    rowNb INTEGER;
    params VARCHAR2(1000);
    stSql CLOB;
  
  BEGIN
    --DBMS_OUTPUT.PUT_LINE('BEGIN exec_user:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
    dateExec := TO_DATE(pDateExec,'YYYYMMDDHH24MISS');

    OPEN cursorAlertBatchUserExec(pLogin,dateExec);
    FETCH cursorAlertBatchUserExec BULK COLLECT INTO listAlertBatchUserExec;
    CLOSE cursorAlertBatchUserExec;

    endProcForced := notify_Alert_User_Begin(pLogin,dateExec);
    IF (endProcForced) THEN
      GOTO END_EXEC;
    END IF;

    BEGIN
      DELETE FROM ALERT_BATCH_USER WHERE DATE_EXEC < TRUNC(ADD_MONTHS(SYSDATE,-2));
    EXCEPTION
      WHEN OTHERS THEN
        --DBMS_OUTPUT.PUT_LINE('exec_user : Erreur de suppression des traitements obsolètes [pLogin='|| pLogin || ';pDateExec=' || TO_CHAR(pDateExec,'YYYYMMDDHH24MISS') || ']: ' || SQLERRM);
        --FIXME utiliser la procédure trace_dbms_output()
        GOTO END_EXEC;
    END;
    
    DELETE FROM ALERT_BATCH2 WHERE LOGIN = pLogin;
    
    rowNb := -1;
    IF (listAlertBatchUserExec.FIRST IS NOT NULL) THEN
      BEGIN
        FOR i IN listAlertBatchUserExec.FIRST..listAlertBatchUserExec.LAST LOOP
          rowNb := i;
          orderNb := listAlertBatchUserExec(rowNb).ORDER_NB;
          time01 := TO_CHAR(SYSDATE,'SSSSS');
          EXECUTE_IMMEDIATE_STRING( listAlertBatchUserExec(rowNb).ALERT_SQL,0);
          time02 := TO_CHAR(SYSDATE,'SSSSS');
          IF (time01 > time02) THEN
            elapsedTime := 86400 - time01 + time02;
          ELSE
           elapsedTime := time02 - time01;
          END IF;
          endProcForced := set_Alert_User_Elapsed_Time(pLogin,dateExec,orderNb,elapsedTime);
          IF (endProcForced) THEN
           GOTO END_EXEC;
          END IF;
        END LOOP;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          IF (rowNb > -1) THEN
            params := '[ORDER_NB=' || listAlertBatchUserExec(rowNb).ORDER_NB || ';ALERT_ID=' || listAlertBatchUserExec(rowNb).ALERT_ID || ']';
          END IF;
          update_User_Error(pLogin,dateExec,SQLERRM,params);
          GOTO END_EXEC;
      END;
    END IF;
    
    endProcForced := notify_Alert_User_End_OK(pLogin,dateExec);
    COMMIT;
    
    <<END_EXEC>>
    --DBMS_OUTPUT.PUT_LINE('END exec_user:'||TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS'));
    --FIXME utiliser la procédure trace_dbms_output()
    NULL;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      update_User_Error(pLogin,dateExec,SQLERRM,'[exec_user]');
  END exec_user;

  FUNCTION notify_Alert_Begin(pDateExec DATE , pAlertNbToExecute INTEGER) RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET DATE_BEGIN_1 = SYSDATE , STATUS_ID = 'EXEC_1_P' , EXEC_NB_12 = pAlertNbToExecute WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL007).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_Alert_Begin;

  FUNCTION notify_Alert_User_Begin(pLogin VARCHAR2 , pDateExec DATE) RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH_USER SET DATE_BEGIN = SYSDATE , STATUS_ID = 'EXEC_1_P' WHERE LOGIN = pLogin AND DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      --DBMS_OUTPUT.PUT_LINE('notify_Alert_User_Begin NO_DATA_FOUND :[pLogin='|| pLogin || ';pDateExec=' || TO_CHAR(pDateExec,'YYYYMMDDHH24MISS') || ']');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      update_User_Error(pLogin,pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_Alert_User_Begin;

  FUNCTION notify_LoginAlert_Begin(pDateExec DATE , pAlertLoginNbToExecute INTEGER) RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET DATE_BEGIN_2 = SYSDATE , STATUS_ID = 'EXEC_2_P' , EXEC_NB_22 = pAlertLoginNbToExecute WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL008).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_LoginAlert_Begin;

  FUNCTION set_Alert_Elapsed_Time(pDateExec DATE , pOrderNb INTEGER , pElapsedTime INTEGER)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  params VARCHAR2(1000);
  BEGIN
    UPDATE ALERT_BATCH_EXEC SET ELAPSED_TIME = pElapsedTime WHERE DATE_EXEC = pDateExec AND ORDER_NB = pOrderNb;
    
    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      params := '[DATE_EXEC=' || pDateExec || ';ORDER_NB=' || pOrderNb || ']';
      insert_Error(pDateExec,'Batch absent (PLSQL009).',params);
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      params := '[DATE_EXEC=' || pDateExec || ';ORDER_NB=' || pOrderNb || ']';
      insert_Error(pDateExec,SQLERRM,params);
      RETURN TRUE;
  END set_Alert_Elapsed_Time;

  FUNCTION set_Alert_User_Elapsed_Time(pLogin VARCHAR2 , pDateExec DATE , pOrderNb INTEGER , pElapsedTime INTEGER)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  params VARCHAR2(1000);
  BEGIN
    UPDATE ALERT_BATCH_USER_EXEC SET ELAPSED_TIME = pElapsedTime WHERE LOGIN = pLogin AND DATE_EXEC = pDateExec AND ORDER_NB = pOrderNb;
    
    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      --DBMS_OUTPUT.PUT_LINE('set_Alert_User_Elapsed_Time NO_DATA_FOUND :[pLogin='|| pLogin || ';pDateExec=' || TO_CHAR(pDateExec,'YYYYMMDDHH24MISS')  || ';pOrderNb=' || pOrderNb ||']');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      update_User_Error(pLogin,pDateExec,SQLERRM,'[ORDER_NB=' || pOrderNb || ']');
      RETURN TRUE;
  END set_Alert_User_Elapsed_Time;

  FUNCTION notify_Alert_Processed(pDateExec DATE , pAlertProcessed INTEGER)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET EXEC_NB_11 = pAlertProcessed WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL010).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_Alert_Processed;

  FUNCTION notify_LoginAlert_Processed(pDateExec DATE , pLoginAlertProcessed INTEGER)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET EXEC_NB_21 = pLoginAlertProcessed WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL011).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_LoginAlert_Processed;

  FUNCTION notify_Alert_End_OK(pDateExec DATE)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  
  ERRMSG VARCHAR2(4000);
  
  BEGIN
    UPDATE ALERT_BATCH SET DATE_END_1 = SYSDATE , STATUS_ID = 'EXEC_1_OK' , TOTAL_ALERT = (SELECT COUNT(*) FROM ALERT_BATCH1) WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL012).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_Alert_End_OK;

  FUNCTION notify_Alert_User_End_OK(pLogin VARCHAR2,pDateExec DATE)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  
  ERRMSG VARCHAR2(4000);
  
  BEGIN
    UPDATE ALERT_BATCH_USER SET DATE_END = SYSDATE , STATUS_ID = 'END_OK' WHERE LOGIN = pLogin AND DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      --DBMS_OUTPUT.PUT_LINE('notify_Alert_User_End_OK NO_DATA_FOUND :[pLogin='|| pLogin || ';pDateExec=' || TO_CHAR(pDateExec,'YYYYMMDDHH24MISS')  ||']');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
       update_User_Error(pLogin,pDateExec,SQLERRM,'[notify_Alert_User_End_OK]');
      RETURN TRUE;
  END notify_Alert_User_End_OK;

  PROCEDURE notify_Alert_End_KO (pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET DATE_END_1 = SYSDATE ,STATUS_ID = 'EXEC_1_KO' WHERE DATE_EXEC = pDateExec;
    INSERT INTO ALERT_BATCH_ERROR VALUES(pDateExec,pErrorMessage,pErrorParams);
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('notify_Alert_End_KO='|| SQLERRM);
      --FIXME utiliser la procédure trace_dbms_output()
      ROLLBACK;
  END notify_Alert_End_KO;

  FUNCTION notify_LoginAlert_End_OK(pDateExec DATE)  RETURN BOOLEAN IS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  
  ERRMSG VARCHAR2(4000);
  
  BEGIN
    UPDATE ALERT_BATCH SET DATE_END_2 = SYSDATE , STATUS_ID = 'END_OK' WHERE DATE_EXEC = pDateExec;

    IF (SQL%ROWCOUNT <=0 ) THEN
      RAISE NO_DATA_FOUND;
    END IF;
    COMMIT;
    RETURN FALSE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      insert_Error(pDateExec,'Batch absent (PLSQL013).','');
      RETURN TRUE;
    WHEN OTHERS THEN
      ROLLBACK;
      insert_Error(pDateExec,SQLERRM,'');
      RETURN TRUE;
  END notify_LoginAlert_End_OK;

  PROCEDURE notify_LoginAlert_End_KO (pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET DATE_END_2 = SYSDATE ,STATUS_ID = 'EXEC_2_KO' WHERE DATE_EXEC = pDateExec;
    INSERT INTO ALERT_BATCH_ERROR VALUES(pDateExec,pErrorMessage,pErrorParams);
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('notify_LoginAlert_End_KO='|| SQLERRM);
      --FIXME utiliser la procédure trace_dbms_output()
      ROLLBACK;
  END notify_LoginAlert_End_KO;

  PROCEDURE insert_Error (pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH SET STATUS_ID = 'END_KO' WHERE DATE_EXEC = pDateExec;
    INSERT INTO ALERT_BATCH_ERROR VALUES(pDateExec,pErrorMessage,pErrorParams);
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('insert_Error='|| SQLERRM);
      --FIXME utiliser la procédure trace_dbms_output()
      ROLLBACK;
  END insert_Error;

  PROCEDURE update_User_Error (pLogin VARCHAR2 , pDateExec DATE , pErrorMessage VARCHAR2 , pErrorParams VARCHAR2) IS 
  PRAGMA AUTONOMOUS_TRANSACTION ;
  BEGIN
    UPDATE ALERT_BATCH_USER SET STATUS_ID = 'END_KO',ERROR_MESSAGE = pErrorMessage,ERROR_PARAMS = pErrorParams WHERE LOGIN = pLogin AND DATE_EXEC = pDateExec;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('update_User_Error_End_KO='|| SQLERRM);
      --FIXME utiliser la procédure trace_dbms_output()
      ROLLBACK;
  END update_User_Error;

END Alert;
##
TAG_CHARSET=@€éèç
##
ALIM_IDX
=SQL=
CREATE OR REPLACE PACKAGE ALIM_IDX
AS
  TYPE T_IDX_DONNEE IS TABLE OF DIC_IDX_CONTRAT_HISTO%ROWTYPE INDEX BY VARCHAR2(32);

  TYPE T_EXISTE_RUPT_DONNEE IS TABLE OF INTEGER INDEX BY VARCHAR2(30);

  TYPE T_EXISTE_IDX_DONNEE IS TABLE OF INTEGER INDEX BY VARCHAR2(32);

  TYPE T_REF_PAC_BY_NUMPAC IS TABLE OF TGE_REF_PAC%ROWTYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;

  PROCEDURE COMPARE_CONTRAT_JOB(
    p_job_number NUMBER,
    p_action VARCHAR2);

  PROCEDURE COMPARE_CONTRAT(
    p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO, 
    p_action VARCHAR2, 
    p_tabDac T_TAB_DAC, 
    p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE);

  PROCEDURE COMPARE_CONTRAT_HISTO_JOB(
    p_job_number NUMBER,
    p_action VARCHAR2);

  PROCEDURE COMPARE_CONTRAT_HISTO(
    p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO, 
    p_action VARCHAR2, 
    p_tabDach T_TAB_DACH, 
    p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE);

  PROCEDURE INSERT_DATA_CONTRAT(
    p_nomDonnee VARCHAR2, 
    p_emptyValue VARCHAR2, 
    p_valueLignePrec CLOB, 
    p_valueLigne CLOB, 
    p_ligne T_LIG_DAC);

  PROCEDURE UPDATE_DATA_CONTRAT(
    p_nomDonnee VARCHAR2, 
    p_emptyValue VARCHAR2, 
    p_valueLignePrec CLOB, 
    p_valueLigne CLOB, 
    p_valueLigneSuiv CLOB, 
    p_valueOldContrat CLOB, 
    p_lignePrec T_LIG_DAC, 
    p_ligne T_LIG_DAC, 
    p_ligneSuiv T_LIG_DAC, 
    p_listeDonneesIdx T_EXISTE_IDX_DONNEE, 
    p_listeDonneesRupt T_EXISTE_RUPT_DONNEE);

  PROCEDURE INSERT_DATA_CONTRAT_HISTO(
    p_nomDonnee VARCHAR2, 
    p_emptyValue VARCHAR2, 
    p_valueLignePrec CLOB, 
    p_valueLigne CLOB, 
    p_valueLigneSuiv CLOB, 
    p_ligne T_LIG_DACH, 
    p_ligneSuiv T_LIG_DACH, 
    p_dsfcn DATE, 
    p_listeDonneesIdx T_IDX_DONNEE, 
    p_listeDonneesRupt T_EXISTE_RUPT_DONNEE);

  PROCEDURE UPDATE_DATA_CONTRAT_HISTO(
    p_nomDonnee VARCHAR2, 
    p_emptyValue VARCHAR2, 
    p_valueLignePrec CLOB, 
    p_valueLigne CLOB, 
    p_valueLigneSuiv CLOB, 
    p_valueOldContratHisto CLOB, 
    p_lignePrec T_LIG_DACH, 
    p_ligne T_LIG_DACH, 
    p_ligneSuiv T_LIG_DACH, 
    p_dsdcn DATE, 
    p_dsfcn DATE, 
    p_listeDonneesIdx T_IDX_DONNEE, 
    p_listeDonneesRupt T_EXISTE_RUPT_DONNEE);
END ALIM_IDX;
##
ALIM_IDX
=SQL=
CREATE OR REPLACE PACKAGE BODY ALIM_IDX AS 

  PROCEDURE COMPARE_CONTRAT_JOB(
      p_job_number NUMBER,
      p_action     VARCHAR2) IS
    v_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO := T_CLES_IDX_CONTRAT_HISTO();
    v_anyData ANYDATA;
    v_tabDac T_TAB_DAC;
    TYPE tcur IS REF CURSOR; 
    cur tcur; 
    v_nomDonnee VARCHAR2(30); 
    v_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE;
  BEGIN
    SELECT T_CLE_IDX_CONTRAT_HISTO(MATRIC, NUMPAC, PACMAT, NUMCNT, DATE_IDX) BULK COLLECT INTO v_listeClesIdxContrat FROM DIC_IDX_JOB_KEYS WHERE JOB_NUMBER=p_job_number;
    DELETE FROM DIC_IDX_JOB_KEYS WHERE JOB_NUMBER=p_job_number;
    IF p_action = 'D' THEN
      ALIM_IDX_DELETE_CONTRAT(v_listeClesIdxContrat);
    ELSE
      SELECT OLD_DATAS INTO v_anyData FROM DIC_IDX_JOB_OLD_DATAS WHERE JOB_NUMBER=p_job_number;
      IF NOT v_anyData.getCollection(v_tabDac) = dbms_types.success THEN
        v_tabDac := T_TAB_DAC();
      END IF;
      DELETE FROM DIC_IDX_JOB_OLD_DATAS WHERE JOB_NUMBER=p_job_number;
      OPEN cur FOR SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT;
      LOOP
        FETCH cur INTO v_nomDonnee;
        EXIT WHEN cur % NOTFOUND;
        v_listeDonneesRupt(v_nomDonnee) := 1;
      END LOOP;
      CLOSE cur;
      COMPARE_CONTRAT(v_listeClesIdxContrat, p_action, v_tabDac, v_listeDonneesRupt);
    END IF;
  END COMPARE_CONTRAT_JOB;

  PROCEDURE COMPARE_CONTRAT(
      p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO, 
      p_action VARCHAR2, 
      p_tabDac T_TAB_DAC, 
      p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE) IS 
    TYPE T_EXISTE_MATRIC IS TABLE OF INTEGER INDEX BY VARCHAR2(32);
    v_listeMatricules T_EXISTE_MATRIC;
    TYPE T_EXISTE_CLES_CONTRAT IS TABLE OF T_CLE_IDX_CONTRAT_HISTO INDEX BY VARCHAR2(40);
    v_listeClesIdxContrat T_EXISTE_CLES_CONTRAT;
    v_matric VARCHAR(32);
    v_cpt NUMBER;
    TYPE tcur IS REF CURSOR;
    cur tcur;
    v_dacMatric T_TAB_DAC;
    v_lignePrec T_LIG_DAC := GET_EMPTY_LIG_DAC();
    v_ligne T_LIG_DAC := GET_EMPTY_LIG_DAC();
    v_ligneSuiv T_LIG_DAC := GET_EMPTY_LIG_DAC();
  BEGIN
    FOR i in 1..p_listeClesIdxContrat.count LOOP
      v_listeMatricules(p_listeClesIdxContrat(i).MATRIC) := 1;
      v_listeClesIdxContrat(LPAD(p_listeClesIdxContrat(i).MATRIC,32,'0')||TO_CHAR(p_listeClesIdxContrat(i).DATE_IDX,'yyyymmdd')) := p_listeClesIdxContrat(i);
    END LOOP;
    -- Pour chaque salarié (MATRIC) ayant été mis à jour
    v_matric := v_listeMatricules.FIRST;
    WHILE v_matric IS NOT NULL LOOP
      v_dacMatric := GET_DAC_MATRIC(v_matric);
      v_cpt := 0;
      LOOP
        EXIT WHEN v_dacMatric.COUNT=0;
        v_cpt := v_cpt+1;
        IF v_cpt = 1 THEN
          -- Premier passage dans la boucle : le premier contrat est le "courant" (celui qu'on va traiter)
          v_ligne := v_dacMatric(v_cpt);
          v_cpt := v_cpt+1;
        END IF;
        EXIT WHEN v_cpt>v_dacMatric.COUNT;
        -- On récupère le contrat suivant
        v_ligneSuiv := v_dacMatric(v_cpt);
        IF v_listeClesIdxContrat.exists(LPAD(v_matric,32,'0')||TO_CHAR(v_ligne.DSDCN,'yyyymmdd')) THEN
          -- Le contrat "courant" vient d'être inséré ou modifié : on appelle la procédure en passant le contrat précédent et le contrat suivant
          IF p_action = 'I' THEN
            ALIM_IDX_INSERT_CONTRAT(v_lignePrec, v_ligne, v_ligneSuiv);
          ELSIF p_action = 'U' THEN
            ALIM_IDX_UPDATE_CONTRAT(v_lignePrec, v_ligne, v_ligneSuiv, p_tabDac, p_listeDonneesRupt);
          END IF;
        END IF;
        -- Le contrat "courant" devient le précédent
        v_lignePrec := v_ligne;
        -- Le contrat suivant devient le "courant"
        v_ligne := v_ligneSuiv;
      END LOOP;
      v_ligneSuiv := NULL;
      IF v_listeClesIdxContrat.exists(LPAD(v_matric,32,'0')||TO_CHAR(v_ligne.DSDCN,'yyyymmdd')) THEN
        -- Le dernier contrat vient d'être inséré ou modifié : on appelle la procédure en passant le contrat précédent (et le contrat suivant, même s'il est vide)
        IF p_action = 'I' THEN
          ALIM_IDX_INSERT_CONTRAT(v_lignePrec, v_ligne, v_ligneSuiv);
        ELSIF p_action = 'U' THEN
          ALIM_IDX_UPDATE_CONTRAT(v_lignePrec, v_ligne, v_ligneSuiv, p_tabDac, p_listeDonneesRupt);
        END IF;
      END IF;
      -- Salarié suivant
      v_matric := v_listeMatricules.NEXT(v_matric);
    END LOOP;
  END COMPARE_CONTRAT;

  PROCEDURE COMPARE_CONTRAT_HISTO_JOB(
      p_job_number NUMBER,
      p_action     VARCHAR2) IS
    v_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO := T_CLES_IDX_CONTRAT_HISTO();
    v_anyData ANYDATA;
    v_tabDach T_TAB_DACH;
    TYPE tcur IS REF CURSOR; 
    cur tcur; 
    v_nomDonnee VARCHAR2(30); 
    v_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE;
  BEGIN
    SELECT T_CLE_IDX_CONTRAT_HISTO(MATRIC, NUMPAC, PACMAT, NUMCNT, DATE_IDX) BULK COLLECT INTO v_listeClesIdxContrat FROM DIC_IDX_JOB_KEYS WHERE JOB_NUMBER=p_job_number;
    DELETE FROM DIC_IDX_JOB_KEYS WHERE JOB_NUMBER=p_job_number;
    IF p_action = 'D' THEN
      ALIM_IDX_DELETE_CONTRAT_HISTO(v_listeClesIdxContrat);
    ELSE
      SELECT OLD_DATAS INTO v_anyData FROM DIC_IDX_JOB_OLD_DATAS WHERE JOB_NUMBER=p_job_number;
      IF NOT v_anyData.getCollection(v_tabDach) = dbms_types.success THEN
        v_tabDach := T_TAB_DACH();
      END IF;
      DELETE FROM DIC_IDX_JOB_OLD_DATAS WHERE JOB_NUMBER=p_job_number;
      OPEN cur FOR SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT;
      LOOP
        FETCH cur INTO v_nomDonnee;
        EXIT WHEN cur % NOTFOUND;
        v_listeDonneesRupt(v_nomDonnee) := 1;
      END LOOP;
      CLOSE cur;
      COMPARE_CONTRAT_HISTO(v_listeClesIdxContrat, p_action, v_tabDach, v_listeDonneesRupt);
    END IF;
  END COMPARE_CONTRAT_HISTO_JOB;

  PROCEDURE COMPARE_CONTRAT_HISTO(
      p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO, 
      p_action VARCHAR2, 
      p_tabDach T_TAB_DACH, 
      p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE) IS 
    TYPE T_EXISTE_MATRIC IS TABLE OF INTEGER INDEX BY VARCHAR2(32);
    v_listeMatricules T_EXISTE_MATRIC;
    TYPE T_EXISTE_CLES_CONTRAT IS TABLE OF T_CLE_IDX_CONTRAT_HISTO INDEX BY VARCHAR2(40);
    v_listeClesIdxContrat T_EXISTE_CLES_CONTRAT;
    v_matric VARCHAR(32);
    v_cpt NUMBER;
    TYPE tcur IS REF CURSOR;
    cur tcur;
    v_dachMatric T_TAB_DACH;
    v_lignePrec T_LIG_DACH := GET_EMPTY_LIG_DACH();
    v_ligne T_LIG_DACH := GET_EMPTY_LIG_DACH();
    v_ligneSuiv T_LIG_DACH := GET_EMPTY_LIG_DACH();
    v_ligneSupp T_LIG_DACH := GET_EMPTY_LIG_DACH();
    v_cleRechercheSupp VARCHAR(40);
  BEGIN
    FOR i in 1..p_listeClesIdxContrat.count LOOP
      v_listeMatricules(p_listeClesIdxContrat(i).MATRIC) := 1;
      v_listeClesIdxContrat(LPAD(p_listeClesIdxContrat(i).MATRIC,32,'0')||TO_CHAR(p_listeClesIdxContrat(i).DATE_IDX,'yyyymmdd')) := p_listeClesIdxContrat(i);
    END LOOP;
    -- Pour chaque salarié (MATRIC) ayant été mis à jour
    v_matric := v_listeMatricules.FIRST;
    WHILE v_matric IS NOT NULL LOOP
      v_dachMatric := GET_DACH_MATRIC(v_matric);
      v_cpt := 0;
      LOOP
        EXIT WHEN v_dachMatric.COUNT=0;
        v_cpt := v_cpt+1;
        IF v_cpt = 1 THEN
          -- Premier passage dans la boucle : la première occurrence est la "courante" (celle qu'on va traiter)
          v_ligne := v_dachMatric(v_cpt);
          v_cpt := v_cpt+1;
        END IF;
        EXIT WHEN v_cpt>v_dachMatric.COUNT;
        -- On récupère l'occurrence suivante
        v_ligneSuiv := v_dachMatric(v_cpt);
        IF p_action = 'D' THEN
          IF v_cpt > 1 THEN
            -- Ce n'est pas le premier passage dans la boucle : on va vérifier qu'on n'a pas un contrat supprimé entre l'occurrence précédente et la "courante"
            v_cleRechercheSupp := v_listeClesIdxContrat.NEXT(LPAD(v_matric,32,'0')||TO_CHAR(v_lignePrec.DATE_EFF,'yyyymmdd'));
            WHILE v_cleRechercheSupp < LPAD(v_matric,32,'0')||TO_CHAR(v_ligne.DATE_EFF,'yyyymmdd') LOOP
              -- On a dans v_listeClesIdxContrat une clé qui n'existe plus : on va faire comme si on avait mis à jour la ligne suivante
              v_ligneSupp.NUMPAC := '_SUPP_';
              ALIM_IDX_UPDATE_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSupp, p_tabDach, p_listeDonneesRupt);
              v_cleRechercheSupp := v_listeClesIdxContrat.NEXT(v_cleRechercheSupp);
            END LOOP;
          END IF;
        ELSIF v_listeClesIdxContrat.exists(LPAD(v_matric,32,'0')||TO_CHAR(v_ligne.DATE_EFF,'yyyymmdd')) THEN
          -- L'occurrence "courante" vient d'être insérée ou modifiée : on appelle la procédure en passant l'occurrence précédente et l'occurrence suivante
          IF p_action = 'I' THEN
            ALIM_IDX_INSERT_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSuiv);
          ELSIF p_action = 'U' THEN
            ALIM_IDX_UPDATE_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSuiv, p_tabDach, p_listeDonneesRupt);
          END IF;
        END IF;
        -- L'occurrence "courante" devient la précédente
        v_lignePrec := v_ligne;
        -- L'occurrence suivante devient la "courante"
        v_ligne := v_ligneSuiv;
        -- Pas d'occurrence suivante
        v_ligneSuiv := NULL;
      END LOOP;
      IF p_action = 'D' THEN
        v_cleRechercheSupp := v_listeClesIdxContrat.NEXT(LPAD(v_matric,32,'0')||TO_CHAR(v_lignePrec.DATE_EFF,'yyyymmdd'));
        WHILE v_cleRechercheSupp IS NOT NULL LOOP
          -- On a dans v_listeClesIdxContrat une clé qui n'existe plus : on va faire comme si on avait mis à jour la ligne suivante
          v_ligneSupp.NUMPAC := '_SUPP_';
          ALIM_IDX_UPDATE_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSupp, p_tabDach, p_listeDonneesRupt);
          v_cleRechercheSupp := v_listeClesIdxContrat.NEXT(v_cleRechercheSupp);
        END LOOP;
      ELSIF v_listeClesIdxContrat.exists(LPAD(v_matric,32,'0')||TO_CHAR(v_ligne.DATE_EFF,'yyyymmdd')) THEN
        -- La dernière occurrence vient d'être insérée ou modifiée : on appelle la procédure en passant l'occurrence précédente (et l'occurrence suivante, même si elle est vide)
        IF p_action = 'I' THEN
          ALIM_IDX_INSERT_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSuiv);
        ELSIF p_action = 'U' THEN
          ALIM_IDX_UPDATE_CONTRAT_HISTO(v_lignePrec, v_ligne, v_ligneSuiv, p_tabDach, p_listeDonneesRupt);
        END IF;
      END IF;
      -- Salarié suivant
      v_matric := v_listeMatricules.NEXT(v_matric);
    END LOOP;
  END COMPARE_CONTRAT_HISTO;

  PROCEDURE INSERT_DATA_CONTRAT(
      p_nomDonnee VARCHAR2, 
      p_emptyValue VARCHAR2, 
      p_valueLignePrec CLOB, 
      p_valueLigne CLOB, 
      p_ligne T_LIG_DAC) IS
    v_valueLignePrec CLOB;
    v_valueLigne CLOB;
  BEGIN
    v_valueLignePrec := NVL(p_valueLignePrec, p_emptyValue);
    v_valueLigne := NVL(p_valueLigne, p_emptyValue);
    IF NOT v_valueLignePrec = v_valueLigne THEN
    BEGIN
      MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')), DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DSDCN,p_nomDonnee,NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')),SYSDATE);
      EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN NULL; 
      WHEN OTHERS THEN 
	 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
	 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligne.NUMPAC || p_ligne.PACMAT);
	 END;
    END IF; 
  END INSERT_DATA_CONTRAT;

  PROCEDURE UPDATE_DATA_CONTRAT(
      p_nomDonnee VARCHAR2, 
      p_emptyValue VARCHAR2, 
      p_valueLignePrec CLOB, 
      p_valueLigne CLOB, 
      p_valueLigneSuiv CLOB, 
      p_valueOldContrat CLOB, 
      p_lignePrec T_LIG_DAC, 
      p_ligne T_LIG_DAC, 
      p_ligneSuiv T_LIG_DAC, 
      p_listeDonneesIdx T_EXISTE_IDX_DONNEE, 
      p_listeDonneesRupt T_EXISTE_RUPT_DONNEE) IS
    v_valueLignePrec CLOB;
    v_valueLigne CLOB;
    v_valueLigneSuiv CLOB;
    v_valueOldContrat CLOB;
  BEGIN
    v_valueLignePrec := NVL(p_valueLignePrec, p_emptyValue);
    v_valueLigne := NVL(p_valueLigne, p_emptyValue);
    v_valueLigneSuiv := NVL(p_valueLigneSuiv, p_emptyValue);
    v_valueOldContrat := NVL(p_valueOldContrat, p_emptyValue);
    IF NOT v_valueOldContrat = v_valueLigne THEN
      IF p_lignePrec.NUMPAC IS NOT NULL THEN
        IF NOT v_valueLignePrec = v_valueLigne THEN
          IF p_listeDonneesIdx.exists(p_nomDonnee) THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=p_nomDonnee;
          ELSE
          	BEGIN
            MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')), DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DSDCN,p_nomDonnee,NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')),SYSDATE);
             EXCEPTION
             WHEN DUP_VAL_ON_INDEX THEN NULL;
              WHEN OTHERS THEN 
			 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
			 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligne.NUMPAC || p_ligne.PACMAT);
			 END;
          END IF;
        ELSIF p_listeDonneesIdx.exists(p_nomDonnee) THEN
          IF p_listeDonneesRupt.exists(p_nomDonnee) THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT='O' WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=p_nomDonnee;
          ELSE
            DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=p_nomDonnee;
          END IF;
        END IF;
      END IF;
      IF p_ligneSuiv.NUMPAC IS NOT NULL THEN
        IF NOT v_valueLigne = v_valueLigneSuiv THEN
          IF NOT p_listeDonneesIdx.exists(p_nomDonnee||'+1') THEN
          	BEGIN
            MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DSDCN AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')), DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligneSuiv.NUMPAC,p_ligneSuiv.PACMAT,p_ligneSuiv.NUMCNT,p_ligneSuiv.DSDCN,p_nomDonnee,NVL(p_ligne.DSFCN,TO_DATE('20991231','yyyymmdd')),SYSDATE);
             EXCEPTION 
             WHEN DUP_VAL_ON_INDEX THEN NULL;
             WHEN OTHERS THEN 
			 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
			 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligneSuiv.NUMPAC || p_ligneSuiv.PACMAT);
			 END;
          ELSIF p_listeDonneesRupt.exists(p_nomDonnee) THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DSDCN AND NOM_DONNEE=p_nomDonnee;
          END IF;
        ELSIF p_listeDonneesIdx.exists(p_nomDonnee||'+1') THEN
          IF p_listeDonneesRupt.exists(p_nomDonnee) THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT='O' WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DSDCN AND NOM_DONNEE=p_nomDonnee;
          ELSE
            DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DSDCN AND NOM_DONNEE=p_nomDonnee;
          END IF;
        END IF;
      END IF;
    END IF; 
  END UPDATE_DATA_CONTRAT;

  PROCEDURE INSERT_DATA_CONTRAT_HISTO(
      p_nomDonnee VARCHAR2, 
      p_emptyValue VARCHAR2, 
      p_valueLignePrec CLOB, 
      p_valueLigne CLOB, 
      p_valueLigneSuiv CLOB, 
      p_ligne T_LIG_DACH, 
      p_ligneSuiv T_LIG_DACH, 
      p_dsfcn DATE, 
      p_listeDonneesIdx T_IDX_DONNEE, 
      p_listeDonneesRupt T_EXISTE_RUPT_DONNEE) IS
    v_valueLignePrec CLOB;
    v_valueLigne CLOB;
    v_valueLigneSuiv CLOB;
    v_idxContratHistoPrec DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
    v_idxContratHisto DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
    v_idxContratHistoSuiv DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
  BEGIN
    v_valueLignePrec := NVL(p_valueLignePrec, p_emptyValue);
    v_valueLigne := NVL(p_valueLigne, p_emptyValue);
    v_valueLigneSuiv := NVL(p_valueLigneSuiv, p_emptyValue);
    IF p_listeDonneesIdx.exists(p_nomDonnee||'-1') THEN
      v_idxContratHistoPrec := p_listeDonneesIdx(p_nomDonnee||'-1');
    END IF;
    IF p_listeDonneesIdx.exists(p_nomDonnee) THEN
      v_idxContratHisto := p_listeDonneesIdx(p_nomDonnee);
    END IF;
    IF p_listeDonneesIdx.exists(p_nomDonnee||'+1') THEN
      v_idxContratHistoSuiv := p_listeDonneesIdx(p_nomDonnee||'+1');
    END IF;
    IF NOT v_valueLignePrec = v_valueLigne THEN
      IF v_idxContratHisto.NUMPAC IS NOT NULL THEN
        UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
      ELSE
        v_idxContratHisto.NUMPAC := p_ligne.NUMPAC;
        IF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
          v_idxContratHisto.DATE_FIN := v_idxContratHistoPrec.DATE_FIN;
          UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligne.DATE_EFF-1 WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
        ELSIF v_idxContratHistoSuiv.NUMPAC IS NOT NULL AND v_idxContratHistoSuiv.DATE_EFF < p_dsfcn THEN
          v_idxContratHisto.DATE_FIN := v_idxContratHistoSuiv.DATE_EFF-1;
        ELSE
          v_idxContratHisto.DATE_FIN := p_dsfcn;
        END IF;
        BEGIN
        MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=v_idxContratHisto.DATE_FIN, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DATE_EFF,p_nomDonnee,v_idxContratHisto.DATE_FIN,SYSDATE);
         EXCEPTION 
         WHEN DUP_VAL_ON_INDEX THEN NULL;
         WHEN OTHERS THEN 
		 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
		 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligne.NUMPAC || p_ligne.PACMAT);
		 END;
      END IF;
    END IF;
    IF p_ligneSuiv.NUMPAC IS NOT NULL THEN
      IF NOT v_valueLigne = v_valueLigneSuiv THEN
        IF v_idxContratHistoSuiv.NUMPAC IS NULL OR NOT v_idxContratHistoSuiv.DATE_EFF = p_ligneSuiv.DATE_EFF THEN
          BEGIN
          IF v_idxContratHistoSuiv.NUMPAC IS NULL OR p_dsfcn < v_idxContratHistoSuiv.DATE_EFF THEN
            MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=p_dsfcn, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligneSuiv.NUMPAC,p_ligneSuiv.PACMAT,p_ligneSuiv.NUMCNT,p_ligneSuiv.DATE_EFF,p_nomDonnee,p_dsfcn,SYSDATE);
          ELSE
            MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=v_idxContratHistoSuiv.DATE_EFF-1, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligneSuiv.NUMPAC,p_ligneSuiv.PACMAT,p_ligneSuiv.NUMCNT,p_ligneSuiv.DATE_EFF,p_nomDonnee,v_idxContratHistoSuiv.DATE_EFF-1,SYSDATE);
          END IF;
           EXCEPTION 
           WHEN DUP_VAL_ON_INDEX THEN NULL;
           WHEN OTHERS THEN 
			 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
			 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligneSuiv.NUMPAC || p_ligneSuiv.PACMAT);
			 END;
          IF v_idxContratHisto.NUMPAC IS NOT NULL THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligneSuiv.DATE_EFF-1 WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          ELSIF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligneSuiv.DATE_EFF-1 WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          END IF;
        ELSIF p_listeDonneesRupt.exists(p_nomDonnee) THEN
          UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
        END IF;
      END IF;
    END IF; 
  END INSERT_DATA_CONTRAT_HISTO;

  PROCEDURE UPDATE_DATA_CONTRAT_HISTO(
      p_nomDonnee VARCHAR2, 
      p_emptyValue VARCHAR2, 
      p_valueLignePrec CLOB, 
      p_valueLigne CLOB, 
      p_valueLigneSuiv CLOB, 
      p_valueOldContratHisto CLOB, 
      p_lignePrec T_LIG_DACH, 
      p_ligne T_LIG_DACH, 
      p_ligneSuiv T_LIG_DACH, 
      p_dsdcn DATE, 
      p_dsfcn DATE, 
      p_listeDonneesIdx T_IDX_DONNEE, 
      p_listeDonneesRupt T_EXISTE_RUPT_DONNEE) IS
    v_valueLignePrec CLOB;
    v_valueLigne CLOB;
    v_valueLigneSuiv CLOB;
    v_valueOldContratHisto CLOB;
    v_idxContratHistoPrec DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
    v_idxContratHisto DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
    v_idxContratHistoSuiv DIC_IDX_CONTRAT_HISTO%ROWTYPE := NULL;
  BEGIN
    v_valueLignePrec := NVL(p_valueLignePrec, p_emptyValue);
    v_valueLigne := NVL(p_valueLigne, p_emptyValue);
    v_valueLigneSuiv := NVL(p_valueLigneSuiv, p_emptyValue);
    v_valueOldContratHisto := NVL(p_valueOldContratHisto, p_emptyValue);
    IF p_listeDonneesIdx.exists(p_nomDonnee||'-1') THEN
      v_idxContratHistoPrec := p_listeDonneesIdx(p_nomDonnee||'-1');
    END IF;
    IF p_listeDonneesIdx.exists(p_nomDonnee) THEN
      v_idxContratHisto := p_listeDonneesIdx(p_nomDonnee);
    END IF;
    IF p_listeDonneesIdx.exists(p_nomDonnee||'+1') THEN
      v_idxContratHistoSuiv := p_listeDonneesIdx(p_nomDonnee||'+1');
    END IF;
    IF p_ligneSuiv.NUMPAC='_SUPP_' OR NOT v_valueOldContratHisto = v_valueLigne THEN
      IF p_lignePrec.NUMPAC IS NOT NULL THEN
        IF NOT v_valueLignePrec = v_valueLigne THEN
          IF v_idxContratHisto.NUMPAC IS NOT NULL THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          ELSE
            v_idxContratHisto.NUMPAC := p_ligne.NUMPAC;
            IF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
              v_idxContratHisto.DATE_FIN := v_idxContratHistoPrec.DATE_FIN;
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligne.DATE_EFF-1 WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            ELSIF v_idxContratHistoSuiv.NUMPAC IS NOT NULL AND v_idxContratHistoSuiv.DATE_EFF < p_dsfcn THEN
              v_idxContratHisto.DATE_FIN := v_idxContratHistoSuiv.DATE_EFF-1;
            ELSE
              v_idxContratHisto.DATE_FIN := p_dsfcn;
            END IF;
            BEGIN
            MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=v_idxContratHisto.DATE_FIN, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DATE_EFF,p_nomDonnee,v_idxContratHisto.DATE_FIN,SYSDATE);
             EXCEPTION 
             WHEN DUP_VAL_ON_INDEX THEN NULL;
             WHEN OTHERS THEN 
			 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
			 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligne.NUMPAC || p_ligne.PACMAT);
			 END;
          END IF;
        ELSIF v_idxContratHisto.NUMPAC IS NOT NULL THEN
          IF p_listeDonneesRupt.exists(p_nomDonnee) AND p_ligne.DATE_EFF = p_dsdcn THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT='O' WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          ELSE
            IF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=v_idxContratHisto.DATE_FIN WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            END IF;
            DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=v_idxContratHisto.NUMPAC AND PACMAT=v_idxContratHisto.PACMAT AND NUMCNT=v_idxContratHisto.NUMCNT AND DATE_EFF=v_idxContratHisto.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          END IF;
        END IF;
      ELSIF p_listeDonneesRupt.exists(p_nomDonnee) THEN
        UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
      ELSIF p_ligne.NUMPAC IS NOT NULL THEN
      	BEGIN
        MERGE INTO DIC_IDX_CONTRAT_HISTO_COMP USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC, p_ligne.PACMAT, p_ligne.NUMCNT, p_ligne.DATE_EFF, p_nomDonnee, SYSDATE);
         EXCEPTION 
         WHEN DUP_VAL_ON_INDEX THEN NULL;
         WHEN OTHERS THEN 
		 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
		 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligne.NUMPAC || p_ligne.PACMAT);
		 END;
      END IF;
      IF p_ligneSuiv.NUMPAC IS NOT NULL AND NOT NVL(p_ligneSuiv.NUMPAC,'_EMPTY_')='_SUPP_' THEN
        IF NOT v_valueLigne = v_valueLigneSuiv THEN
          IF v_idxContratHistoSuiv.NUMPAC IS NULL OR NOT v_idxContratHistoSuiv.DATE_EFF = p_ligneSuiv.DATE_EFF THEN
            BEGIN
            IF v_idxContratHistoSuiv.NUMPAC IS NULL OR p_dsfcn < v_idxContratHistoSuiv.DATE_EFF THEN
              MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=p_dsfcn, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligneSuiv.NUMPAC,p_ligneSuiv.PACMAT,p_ligneSuiv.NUMCNT,p_ligneSuiv.DATE_EFF,p_nomDonnee,p_dsfcn,SYSDATE);
            ELSE
              MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee) WHEN MATCHED THEN UPDATE SET DATE_FIN=v_idxContratHistoSuiv.DATE_EFF-1, DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,DATE_DERNIERE_MODIF) VALUES (p_ligneSuiv.NUMPAC,p_ligneSuiv.PACMAT,p_ligneSuiv.NUMCNT,p_ligneSuiv.DATE_EFF,p_nomDonnee,v_idxContratHistoSuiv.DATE_EFF-1,SYSDATE);
            END IF;
             EXCEPTION 
             WHEN DUP_VAL_ON_INDEX THEN NULL;
             WHEN OTHERS THEN 
			 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
			 TGE_IMPORT_AVANCEMENT_proc('ALIM_IDX','Erreur merge idpacmat ' || p_ligneSuiv.NUMPAC || p_ligneSuiv.PACMAT);
			 END;
            IF v_idxContratHisto.NUMPAC IS NOT NULL THEN
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligneSuiv.DATE_EFF-1 WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            ELSIF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=p_ligneSuiv.DATE_EFF-1 WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            END IF;
          ELSIF p_listeDonneesRupt.exists(p_nomDonnee) THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT=NULL WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          END IF;
        ELSIF v_idxContratHistoSuiv.DATE_EFF = p_ligneSuiv.DATE_EFF THEN
          IF p_listeDonneesRupt.exists(p_nomDonnee) AND NOT p_ligne.NUMCNT = p_ligneSuiv.NUMCNT THEN
            UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, RUPTURE_CONTRAT='O' WHERE NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          ELSE
            IF v_idxContratHisto.NUMPAC IS NOT NULL THEN
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=v_idxContratHistoSuiv.DATE_FIN WHERE NUMPAC=v_idxContratHisto.NUMPAC AND PACMAT=v_idxContratHisto.PACMAT AND NUMCNT=v_idxContratHisto.NUMCNT AND DATE_EFF=v_idxContratHisto.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            ELSIF v_idxContratHistoPrec.NUMPAC IS NOT NULL THEN
              UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=v_idxContratHistoSuiv.DATE_FIN WHERE NUMPAC=v_idxContratHistoPrec.NUMPAC AND PACMAT=v_idxContratHistoPrec.PACMAT AND NUMCNT=v_idxContratHistoPrec.NUMCNT AND DATE_EFF=v_idxContratHistoPrec.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
            END IF;
            DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=v_idxContratHistoSuiv.NUMPAC AND PACMAT=v_idxContratHistoSuiv.PACMAT AND NUMCNT=v_idxContratHistoSuiv.NUMCNT AND DATE_EFF=v_idxContratHistoSuiv.DATE_EFF AND NOM_DONNEE=p_nomDonnee;
          END IF;
        END IF;
      END IF;
    END IF; 
  END UPDATE_DATA_CONTRAT_HISTO;
END ALIM_IDX;
##
CAD
=SQL=
CREATE OR REPLACE
PACKAGE CAD
AS
 FUNCTION CAD_RESOLUTION_POP_REGLES_MAJ(
 p_dteffet VARCHAR2)
 RETURN CAD_TYPE_POP_REGLES_MAJ;
 PROCEDURE CAD_CALCUL(
 matric  IN VARCHAR2 ,
 idrub   IN NUMBER ,
 DATEDEB IN VARCHAR2 ,
 DATEFIN IN VARCHAR2 );
 PROCEDURE CAD_CONTROLE_SOLDE(
 idrub  IN VARCHAR2,
 matric IN VARCHAR2 );
 PROCEDURE CAD_MAJ_VALEUR_LISTE_RUBJOUR(
 idMat         IN NUMBER,
 dtdeb         IN VARCHAR2,
 dtfin         IN VARCHAR2,
 forcage       IN VARCHAR2,
 ispreviousCAD IN VARCHAR2);
 PROCEDURE CAD_IMPORT(
 p_numseq        IN  NUMBER,
 nom_Fichier   IN VARCHAR2,
 avec_Rollback IN VARCHAR2);
 PROCEDURE CAD_ROLLBACK_IMPORT(
 numseq IN NUMBER);
 FUNCTION CAD_INTERRO_THEME(
 MATRIC       IN VARCHAR2 ,
 p_CODE_THEME IN VARCHAR2 ,
 p_DJOUR      IN VARCHAR2,
 collectif    IN VARCHAR2,
 finPeriode   IN NUMBER DEFAULT NULL)
 RETURN CAD_RESULTAT_THEME;
 FUNCTION CAD_INTERRO_THEME_COLL(
 idPop      IN NUMBER ,
 CODE_THEME IN VARCHAR2 ,
 DJOUR      IN VARCHAR2,
 collectif  IN VARCHAR2)
 RETURN CAD_RESULTAT_THEME;
 FUNCTION CAD_SOLDE(
 MATRIC   IN VARCHAR2 ,
 DATEJOUR IN VARCHAR2 ,
 RUB      IN VARCHAR2 )
 RETURN NUMBER;
 FUNCTION CAD_CALCUL_DATE_RELATIVE_AV(
 DATE_RELATIVE     IN VARCHAR2,
 DATE_COMPARAISON  IN VARCHAR2,
 DATE_VALIDITE_REL IN VARCHAR2 )
 RETURN VARCHAR2;
 FUNCTION CAD_CALCUL_DATE_REL_AV_FIN(
 DATE_ACQ_FIN   IN VARCHAR2,
 DATE_ACQ_DEBUT IN VARCHAR2,
 DATE_COMPARE   IN VARCHAR2,
 DATE_VAL_DEBUT IN VARCHAR2)
 RETURN VARCHAR2;
 FUNCTION cad_formate_date_relative(
 DATE_RELATIVE    IN VARCHAR2,
 DATE_COMPARAISON IN VARCHAR2 )
 RETURN VARCHAR2;
 FUNCTION CAD_CALCUL_DATE_RELATIVE_FIN(
 DATE_RELATIVE_FIN   IN VARCHAR2,
 DATE_RELATIVE_DEBUT IN VARCHAR2,
 DATE_COMPARE        IN VARCHAR2 )
 RETURN VARCHAR2;
 FUNCTION cad_calcul_date_relative(
 DATE_RELATIVE    IN VARCHAR2,
 DATE_COMPARAISON IN VARCHAR2 )
 RETURN VARCHAR2;
 PROCEDURE CAD_BASCULE_UNIQUE(
 IDMATRIC    IN NUMBER ,
 BASCULE     IN VARCHAR2 ,
 DATEBAS     IN VARCHAR2 ,
 SUPPRESSION IN VARCHAR2);
 FUNCTION CAD_UNITE_CPT(
    MATRIC   IN VARCHAR2,
    DATEJOUR IN VARCHAR2,
    CPT      IN VARCHAR2)
    RETURN VARCHAR;
END CAD;
##
CAD
=SQL=
create or replace PACKAGE BODY CAD AS
 err_msg  VARCHAR(200);
 err_code VARCHAR(200);
 valdebug VARCHAR2(1); 
 
 FUNCTION CAD_RESOLUTION_POP_REGLES_MAJ(
 p_dteffet VARCHAR2)
 RETURN CAD_TYPE_POP_REGLES_MAJ
 AS
 retour CAD_TYPE_POP_REGLES_MAJ:=CAD_TYPE_POP_REGLES_MAJ();
 CURSOR cur
 IS
 SELECT POPULATION,
 CODE_BASCULE,
 DATE_THEO_BASCULE,
 ORDRE_A_PROPAGER
 FROM CAD_PARAM_POP_REGLES_MAJ;
 lig cur%rowtype;
 numlig  NUMBER:=0;
 DIC     VARCHAR2(8);
 NBJC    NUMBER;
 NBC     NUMBER;
 nbjours NUMBER;
 dteffet VARCHAR2(8);
 BEGIN
 IF p_dteffet IS NULL THEN
 dteffet    :=TO_CHAR(sysdate,'yyyymmdd');
 ELSE
 dteffet:=p_dteffet;
 END IF;
 OPEN cur;
 LOOP
 FETCH cur INTO lig;
 EXIT
 WHEN cur%NOTFOUND ;
 IF instr(lig.DATE_THEO_BASCULE,'DIC')>0 THEN
 DIC                               :=SUBSTR(lig.DATE_THEO_BASCULE,5,8);
 lig.DATE_THEO_BASCULE             :=REPLACE(lig.DATE_THEO_BASCULE, 'DIC='||DIC||' ','');
 NBJC                              :=to_number(SUBSTR(lig.DATE_THEO_BASCULE,6,instr(lig.DATE_THEO_BASCULE,'NBC=')-6));
 lig.DATE_THEO_BASCULE             :=REPLACE(lig.DATE_THEO_BASCULE, 'NBJC='||NBJC||' ','');
 NBC                               :=to_number(SUBSTR(lig.DATE_THEO_BASCULE,5));
 nbjours                           :=ABS(to_date(dteffet,'yyyyMMdd')-to_date(DIC,'yyyyMMdd'));
 IF (DIC                           >=dteffet) THEN
 numlig                          :=numlig+1;
 retour.extend;
 retour(numlig)                  :=CAD_LIG_TYPE_POP_REGLES_MAJ(NULL,NULL,NULL,NULL);
 retour(numlig).POPULATION       :=lig.population;
 retour(numlig).CODE_BASCULE     :=lig.CODE_BASCULE;
 retour(numlig).DATE_THEO_BASCULE:=TO_CHAR(to_date(DIC,'yyyyMMdd'),'yyyymmdd');
 retour(numlig).ORDRE_A_PROPAGER :=lig.ORDRE_A_PROPAGER;
 END IF;
 FOR i IN 1..nbc
 LOOP
 numlig:=numlig+1;
 retour.extend;
 retour(numlig)                  :=CAD_LIG_TYPE_POP_REGLES_MAJ(NULL,NULL,NULL,NULL);
 retour(numlig).POPULATION       :=lig.population;
 retour(numlig).CODE_BASCULE     :=lig.CODE_BASCULE;
 retour(numlig).DATE_THEO_BASCULE:=TO_CHAR(to_date(DIC,'yyyyMMdd')+(TRUNC (nbjours/nbjc,0)+i)*nbjc,'yyyymmdd');
 retour(numlig).ORDRE_A_PROPAGER :=lig.ORDRE_A_PROPAGER;
 END LOOP;
 ELSE
 numlig:=numlig+1;
 retour.extend;
 retour(numlig)                  :=CAD_LIG_TYPE_POP_REGLES_MAJ(NULL,NULL,NULL,NULL);
 retour(numlig).POPULATION       :=lig.population;
 retour(numlig).CODE_BASCULE     :=lig.CODE_BASCULE;
 retour(numlig).DATE_THEO_BASCULE:=cad_formate_date_relative(lig.DATE_THEO_BASCULE, p_dteffet );
 retour(numlig).ORDRE_A_PROPAGER :=lig.ORDRE_A_PROPAGER;
 END IF;
 END LOOP;
 CLOSE cur;
 RETURN retour;
 END;
 PROCEDURE CAD_AVANCEMENT(
 id  IN NUMBER,
 txt IN VARCHAR2)
 AS
 PRAGMA AUTONOMOUS_TRANSACTION;
 line   VARCHAR(32672);
 status INT;
 BEGIN
 IF valdebug='O' THEN
 INSERT INTO CAD_AVANCEMENT_proc VALUES
 (id,sysdate,txt
 );
 COMMIT;
 END IF;
 END CAD_AVANCEMENT;
 PROCEDURE CAD_AVANCEMENT_INFO
 (
 id  IN NUMBER,
 txt IN VARCHAR2
 )
 AS
 PRAGMA AUTONOMOUS_TRANSACTION;
 line   VARCHAR(32672);
 status INT;
 BEGIN
 IF valdebug='O' OR valdebug='I' THEN
 INSERT INTO CAD_AVANCEMENT_proc VALUES
 (id,sysdate,txt
 );
 COMMIT;
 END IF;
 END CAD_AVANCEMENT_INFO;
 PROCEDURE   CAD_ERREUR(
 p_id      IN NUMBER,
 p_nomproc IN VARCHAR2,
 p_idDate  IN VARCHAR2,
 p_erreur  IN VARCHAR2)
 AS
 PRAGMA AUTONOMOUS_TRANSACTION;
 line      VARCHAR(32672);
 status    INT;
 BEGIN
 INSERT INTO CAD_CALCUL_ERR (ID, PROC, PARAM, MESSAGE, DATE_ERR)
 VALUES(p_id, p_nomproc, p_idDate, p_erreur, SYSDATE);
 COMMIT;
 END CAD_ERREUR;
 PROCEDURE CAD_DEBUG
 (
 IDPOP        IN NUMBER ,
 paramREQUETE IN CLOB
 )
 AS
 ordreR NUMBER;
 BEGIN
 IF valdebug='O' THEN
 SELECT NVL(MAX(ordre),0)+1 INTO ordreR FROM cad_trace_req WHERE id=idpop;
 INSERT
 INTO cad_trace_req
 (
 id,
 date_req,
 ordre,
 requete
 )
 VALUES
 (
 idpop,
 sysdate,
 ordreR ,
 paramREQUETE
 );
 END IF;
 END CAD_DEBUG;
 FUNCTION CAD_CALCUL_JOUR_SEMAINE
 (
 JourSemaine VARCHAR2,
 numSemaine  VARCHAR2,
 annee       VARCHAR2,
 mois        VARCHAR2
 )
 RETURN VARCHAR2
 AS
 jour VARCHAR2
 (
 2
 )
 ;
 BEGIN
 IF JourSemaine   ='L' THEN
 jour          :=TO_CHAR( next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121001','yyyymmdd'),'DAY')) + (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='M' THEN
 jour          :=TO_CHAR(next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121002','yyyymmdd'),'DAY') ) + (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='W' THEN
 jour          :=TO_CHAR(next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121003','yyyymmdd'),'DAY') )+ (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='J' THEN
 jour          :=TO_CHAR(next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121004','yyyymmdd'),'DAY') ) + (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='V' THEN
 jour          :=TO_CHAR( next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121005','yyyymmdd'),'DAY') )+ (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='S' THEN
 jour          :=TO_CHAR(next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121006','yyyymmdd'),'DAY') ) + (to_number( numSemaine)-1 )*7 ,'dd') ;
 elsif JourSemaine='D' THEN
 jour          :=TO_CHAR(next_day(to_date(annee||mois||'01','yyyymmdd' ), TO_CHAR(to_date('20121001','yyyymmdd'),'DAY') ) + (to_number( numSemaine)-1 )*7 ,'dd') ;
 END IF;
 RETURN jour;
 END CAD_CALCUL_JOUR_SEMAINE;
 FUNCTION CAD_CONDITION_NON_AFF
 (
 DATEJOUR   IN VARCHAR2 ,
 typeCalcul IN VARCHAR2 ,
 condition  IN VARCHAR2 ,
 valeur     IN VARCHAR2
 )
 RETURN NUMBER
 AS
 retour NUMBER;
 BEGIN
 retour      :=0;
 IF condition ='NEG' THEN
 IF valeur IS NULL OR (typeCalcul IN ('R','VP','P','COL','C') AND to_number(valeur)<0) THEN
 retour  :=1;
 END IF;
 elsif condition='ZER' THEN
 IF valeur   IS NULL OR (typeCalcul IN ('R','VP','P','COL','C') AND to_number(valeur)=0) THEN
 retour    :=1;
 END IF;
 elsif condition='IEQ' THEN
 IF valeur   IS NULL OR (typeCalcul IN ('R','VP','P','COL','C') AND to_number(valeur)<=0) THEN
 retour    :=1;
 END IF;
 elsif condition='IEQD' THEN
 IF valeur   IS NULL OR valeur<=DATEJOUR THEN
 retour    :=1;
 END IF;
 elsif condition='SEQ' THEN
 IF valeur   IS NULL OR (typeCalcul IN ('R','VP','P','COL','C') AND to_number(valeur)>=0) THEN
 retour    :=1;
 END IF;
 elsif condition='SEQD' THEN
 IF valeur   IS NULL OR valeur>=DATEJOUR THEN
 retour    :=1;
 END IF;
 elsif condition='INF' THEN
 IF valeur   IS NULL OR valeur<DATEJOUR THEN
 retour    :=1;
 END IF;
 elsif condition='SUP' THEN
 IF valeur   IS NULL OR valeur>DATEJOUR THEN
 retour    :=1;
 END IF;
 END IF;
 RETURN retour;
 END CAD_CONDITION_NON_AFF;
 FUNCTION CAD_UNITE
 (
 MATRIC   IN VARCHAR2 ,
 DATEJOUR IN VARCHAR2 ,
 RUB      IN VARCHAR2
 )
 RETURN VARCHAR
 AS
 r_unite VARCHAR
 (
 1
 )
 ;
 BEGIN
 BEGIN
 SELECT unite_tenue
 INTO r_unite
 FROM
 (SELECT unite_tenue
 FROM cad_matric_datevalid a,
 CAD_PARAM_LIEN_RUB_CPT b
 WHERE a.matricule  =matric
 AND a.code_compteur=b.code_compteur
 AND a.DATE_EFFET   =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid c
 WHERE c.date_effet<=datejour
 AND c.code_compteur=a.code_compteur
 AND a.matricule    =c.matricule
 )
 AND b.rub_val_jour=rub
 ORDER BY date_effet DESC
 )
 WHERE rownum=1 ;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 BEGIN
 SELECT unite
 INTO r_unite
 FROM
 (SELECT a.unite
 FROM CAD_PARAM_STRUCT_CPT a,
 CAD_PARAM_LIEN_RUB_CPT b
 WHERE a.code_compteur=b.code_compteur
 AND b.rub_val_jour   =rub
 ORDER BY a.code_compteur DESC
 )
 WHERE rownum=1 ;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 ROLLBACK;
 raise_application_error(-20000, 'CAD00056#'||matric||'#'||datejour||'#'||rub);
 END;
 END;
 IF r_unite IS NULL THEN
 ROLLBACK;
 raise_application_error(-20000, 'CAD00056#'||matric||'#'||datejour||'#'||rub);
 END IF;
 RETURN r_unite;
 END CAD_UNITE;
 FUNCTION CAD_UNITE_CPT(
 MATRIC   IN VARCHAR2 ,
 DATEJOUR IN VARCHAR2 ,
 CPT      IN VARCHAR2 )
 RETURN VARCHAR
 AS
 r_unite   VARCHAR(1);
 gestionHj VARCHAR(1);
 visuHouJ  VARCHAR(1);
 BEGIN
 SELECT GESTIONHJ
 INTO GESTIONHJ
 FROM CAD_PARAM_STRUCT_CPT
 WHERE code_compteur=CPT;
 IF GESTIONHJ       ='H' THEN
 r_unite         :='H';
 ELSE
 BEGIN
 SELECT
 CASE
 WHEN visuhouj='H'
 THEN 'H'
 ELSE unite_tenue
 END
 INTO r_unite
 FROM cad_matric_datevalid a
 WHERE a.matricule=matric
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<=datejour
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 )
 AND a.code_compteur=cpt
 AND rownum         =1
 ORDER BY date_effet DESC ;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 IF r_unite IS NULL THEN
 SELECT a.unite
 INTO r_unite
 FROM CAD_PARAM_STRUCT_CPT a
 WHERE a.code_compteur=cpt
 AND rownum           =1
 ORDER BY a.code_compteur DESC ;
 END IF;
 END;
 END IF;
 RETURN r_unite;
 END CAD_UNITE_CPT;
 PROCEDURE CAD_INIT_BASCULES(
 numSeq  IN NUMBER ,
 matric  IN VARCHAR2,
 DATEDEB IN VARCHAR2 ,
 DATEFIN IN VARCHAR2 )
 AS
 CURSOR cur_test
 IS
 SELECT a.matricule AS MATRICULE,
 a.COMPTEUR_DEST,
 a.DATE_THEO_BASCULE,
 a.TYPE_BASCULE,
 b.matricule AS matric_cpt,
 b.djour,
 b.code_compteur,
 b.typemj,
 b.rowid_cpt,
 b.NorM
 FROM
 (SELECT DISTINCT mat.matricule AS MATRICULE,
 maj.COMPTEUR_DEST,
 bas.DATE_THEO_BASCULE,
 bas.TYPE_BASCULE
 FROM CAD_CALCUL_EN_COURS_MATRIC mat,
 CAD_REGLES_PREVUES_REALISEES bas,
 cad_param_regles_maj maj
 WHERE mat.id         = numSeq
 AND mat.matricule    =NVL(matric,mat.matricule)
 AND bas.matricule    =mat.matricule
 AND maj.code_bascule = bas.code_bascule
 AND DATE_THEO_BASCULE BETWEEN DATEDEB AND NVL(DATEfin,'20991231')
 ) a
 FULL OUTER JOIN
 (SELECT cpt.matricule,
 cpt.djour,
 cpt.code_compteur,
 cpt.rowid AS rowid_cpt,
 cpt.typemj,
 (SELECT COUNT(*)
 FROM CAD_COMPTEUR cpt2
 WHERE cpt.matricule  =cpt2.matricule
 AND cpt.code_compteur=cpt2.code_compteur
 AND cpt.djour        =cpt2.djour
 AND cpt2.typemj     IN ('M','N')
 ) AS NorM
 FROM CAD_COMPTEUR cpt,CAD_CALCUL_EN_COURS_MATRIC
 WHERE cpt.TYPEMJ  IN ('B','S')
 AND cpt.matricule= CAD_CALCUL_EN_COURS_MATRIC.matricule and CAD_CALCUL_EN_COURS_MATRIC.id = numSeq
 AND cpt.matricule=NVL(matric,cpt.matricule)
 AND djour BETWEEN DATEDEB AND NVL(DATEfin,'20991231')
 ) b
 ON a.matricule          =b.matricule
 AND a.date_theo_bascule =b.djour
 AND b.code_compteur     =a.compteur_dest
 AND a.type_bascule      =b.typemj
 WHERE djour            IS NULL
 OR djour BETWEEN DATEDEB AND NVL(DATEfin,'20991231');
 lig_test cur_test%rowtype;
 TYPE Tab_Rowid
 IS
 TABLE OF VARCHAR(100);
 --tableau pour update
 T_up Tab_Rowid;
 --tableau pour insert
 -- tableau pour delete
 T_del Tab_Rowid;
 T_replace Tab_Rowid;
 TYPE Type_bascules
 IS
 RECORD
 (
 matricule cad_compteur.matricule%type,
 code_compteur cad_compteur.code_compteur%type,
 djour cad_compteur.djour%type,
 typemj cad_compteur.typemj%type,
 date_maj cad_compteur.date_maj%type );
 type tab_bascules
 IS
 TABLE OF type_bascules;
 t_ins tab_bascules;
 tmpIns type_bascules;
 BEGIN
 OPEN cur_test;
 LOOP
 FETCH cur_test INTO lig_test;
 EXIT
 WHEN cur_test%NOTFOUND ;
 -- si on a la bascule dans prévue/réalisée, on met la ligne à 0 sinon on delete
 IF lig_test.matricule IS NOT NULL AND lig_test.rowid_cpt IS NULL THEN
 -- insertion
 IF t_ins              IS NULL THEN
 tmpIns.matricule    :=lig_test.matricule;
 tmpIns.code_compteur:=lig_test.compteur_dest;
 tmpIns.djour        :=lig_test.DATE_THEO_BASCULE;
 tmpIns.typemj       :=lig_test.type_bascule;
 tmpIns.date_maj     :=sysdate;
 t_ins               :=tab_bascules(tmpIns);
 ELSE
 t_ins.extend();
 t_ins(t_ins.last).matricule    :=lig_test.matricule;
 t_ins(t_ins.last).code_compteur:=lig_test.compteur_dest;
 t_ins(t_ins.last).djour        :=lig_test.DATE_THEO_BASCULE;
 t_ins(t_ins.last).typemj       :=lig_test.type_bascule;
 t_ins(t_ins.last).date_maj     :=sysdate;
 END IF;
 elsif lig_test.matricule IS NULL AND lig_test.rowid_cpt IS NOT NULL THEN
 IF lig_test.NorM        >0 THEN
 IF t_del             IS NULL THEN
 t_del              :=Tab_Rowid(lig_test.rowid_cpt);
 ELSE
 t_del.extend();
 t_del(t_del.last):=lig_test.rowid_cpt;
 END IF;
 ELSE
 IF T_replace IS NULL THEN
 T_replace  :=Tab_Rowid(lig_test.rowid_cpt);
 ELSE
 T_replace.extend();
 T_replace(T_replace.last):=lig_test.rowid_cpt;
 END IF;
 END IF;
 -- delete
 -- delete from cad_compteur where rowid=lig_test.rowid_cpt;
 ELSE
 IF t_up IS NULL THEN
 t_up  :=Tab_Rowid(lig_test.rowid_cpt);
 ELSE
 t_up.extend();
 t_up(t_up.last):=lig_test.rowid_cpt;
 END IF;
 --update
 /* update cad_compteur set POT1_VALEURJ=null,POT1_VALEURH=null,
 POT2_VALEURJ=null,POT2_VALEURH=null,
 POT3_VALEURJ=null,POT3_VALEURH=null,
 POT4_VALEURJ=null,POT4_VALEURH=null,
 POT5_VALEURJ=null,POT5_VALEURH=null,
 POT6_VALEURJ=null,POT6_VALEURH=null,
 POT7_VALEURJ=null,POT7_VALEURH=null,
 POT8_VALEURJ=null,POT8_VALEURH=null,
 POT9_VALEURJ=null,POT9_VALEURH=null,
 POT10_VALEURJ=null,POT10_VALEURH=null,
 POT11_VALEURJ=null,POT11_VALEURH=null,
 POT12_VALEURJ=null,POT12_VALEURH=null
 where rowid=lig_test.rowid_cpt;*/
 END IF;
 END LOOP;
 CLOSE cur_test;
 IF t_up IS NOT NULL THEN
 FORALL i IN T_up.first..T_up.last
 UPDATE cad_compteur
 SET DATE_MAJ    =sysdate,
 POT1_VALEURJ  =NULL,
 POT1_VALEURH  =NULL,
 POT2_VALEURJ  =NULL,
 POT2_VALEURH  =NULL,
 POT3_VALEURJ  =NULL,
 POT3_VALEURH  =NULL,
 POT4_VALEURJ  =NULL,
 POT4_VALEURH  =NULL,
 POT5_VALEURJ  =NULL,
 POT5_VALEURH  =NULL,
 POT6_VALEURJ  =NULL,
 POT6_VALEURH  =NULL,
 POT7_VALEURJ  =NULL,
 POT7_VALEURH  =NULL,
 POT8_VALEURJ  =NULL,
 POT8_VALEURH  =NULL,
 POT9_VALEURJ  =NULL,
 POT9_VALEURH  =NULL,
 POT10_VALEURJ =NULL,
 POT10_VALEURH =NULL,
 POT11_VALEURJ =NULL,
 POT11_VALEURH =NULL,
 POT12_VALEURJ =NULL,
 POT12_VALEURH =NULL
 WHERE rowid     =t_up(i);
 END IF;
 IF T_replace IS NOT NULL THEN
 FORALL i IN T_replace.first..T_replace.last
 UPDATE cad_compteur a
 SET DATE_MAJ    =sysdate,
 typemj        ='N',
 POT1_VALEURJ  =NULL,
 POT1_VALEURH  =NULL,
 POT2_VALEURJ  =NULL,
 POT2_VALEURH  =NULL,
 POT3_VALEURJ  =NULL,
 POT3_VALEURH  =NULL,
 POT4_VALEURJ  =NULL,
 POT4_VALEURH  =NULL,
 POT5_VALEURJ  =NULL,
 POT5_VALEURH  =NULL,
 POT6_VALEURJ  =NULL,
 POT6_VALEURH  =NULL,
 POT7_VALEURJ  =NULL,
 POT7_VALEURH  =NULL,
 POT8_VALEURJ  =NULL,
 POT8_VALEURH  =NULL,
 POT9_VALEURJ  =NULL,
 POT9_VALEURH  =NULL,
 POT10_VALEURJ =NULL,
 POT10_VALEURH =NULL,
 POT11_VALEURJ =NULL,
 POT11_VALEURH =NULL,
 POT12_VALEURJ =NULL,
 POT12_VALEURH =NULL
 WHERE rowid     =T_replace(i);
 END IF;
 IF T_del IS NOT NULL THEN
 FORALL i IN T_del.first..T_del.last
 UPDATE cad_compteur a
 SET DATE_MAJ                               =sysdate
 WHERE (a.matricule,a.code_compteur,a.djour)=
 (SELECT b.matricule,
 b.code_compteur,
 b.djour
 FROM cad_compteur b
 WHERE rowid =T_del(i)
 )
 AND typemj IN ('N','M') ;
 FORALL i   IN T_del.first..T_del.last
 DELETE FROM cad_compteur WHERE rowid =T_del(i);
 END IF;
 IF t_ins IS NOT NULL THEN
 FORALL i IN t_ins.first..t_ins.last
 INSERT
 INTO CAD_COMPTEUR
 (
 matricule,
 code_compteur,
 djour,
 typemj,
 date_maj
 )
 VALUES
 (
 t_ins(i).matricule,
 t_ins(i).code_compteur,
 t_ins(i).djour,
 t_ins(i).typemj,
 t_ins(i).date_maj
 );
 END IF;
 END CAD_INIT_BASCULES;
 PROCEDURE CAD_UNIT_PROPAGATION
 (
 IDMATRIC    IN NUMBER ,
 p_matric    IN VARCHAR2,
 DATEDEB     IN VARCHAR2 ,
 DATEFIN     IN VARCHAR2 ,
 CODECPT     IN VARCHAR2 ,
 AvecBascule IN VARCHAR2
 )
 AS
 CURSOR cur_cpt
 IS
 SELECT cpt.*,
 cpt.rowid
 FROM CAD_COMPTEUR cpt,
 CAD_CALCUL_EN_COURS_MATRIC mat
 WHERE cpt.matricule   =mat.matricule
 AND mat.id            =idmatric
 AND mat.matricule     =NVL(p_matric,mat.matricule)
 AND cpt.code_compteur =codecpt
 AND cpt.djour        >=nvl(datedeb,'19000101')
 AND (cpt.djour       <=NVL(datefin,'20991231')
 OR (avecbascule       ='BASCULE'
 AND cpt.djour        <=NVL(
 (SELECT MIN(a.djour)
 FROM cad_compteur a
 WHERE a.matricule  =cpt.matricule
 AND a.code_compteur=cpt.code_compteur
 AND a.typemj NOT  IN ('B','S')
 AND a.djour        >datefin
 ),'20991231')))
 ORDER BY cpt.matricule,
 cpt.code_compteur,
 cpt.djour,
 cpt.typemj FOR UPDATE OF POT1_VALEURJ,
 POT1_VALEURH,
 POT2_VALEURJ,
 POT2_VALEURH,
 POT3_VALEURJ,
 POT3_VALEURH,
 POT4_VALEURJ,
 POT4_VALEURH,
 POT5_VALEURJ,
 POT5_VALEURH,
 POT6_VALEURJ,
 POT6_VALEURH,
 POT7_VALEURJ,
 POT7_VALEURH,
 POT8_VALEURJ,
 POT8_VALEURH,
 POT9_VALEURJ,
 POT9_VALEURH,
 POT10_VALEURJ,
 POT10_VALEURH,
 POT11_VALEURJ,
 POT11_VALEURH,
 POT12_VALEURJ,
 POT12_VALEURH ;
 lig_cpt cur_cpt%ROWTYPE;
 lig_cpt_prec cur_cpt%ROWTYPE;
 lig_cptori cur_cpt%ROWTYPE;
 TYPE TYP_tabPot is table of varchar2(3000) index by BINARY_INTEGER ;
 TYPE typ_Tab_ligcpt
 IS
 TABLE OF cur_cpt%ROWTYPE;
 Tab_ligcpt typ_Tab_ligcpt:=Typ_Tab_ligcpt();
 TYPE Tab_Rowid
 IS
 TABLE OF VARCHAR(100);
 T_Id Tab_Rowid;
 reqpropagation CLOB;
 ssreq CLOB;
 nbssreq                 NUMBER;
 listPotANePasPropage    VARCHAR(100):='';
 listPotANePasPropageCPT VARCHAR(100):='';
 premier                 BOOLEAN;
 dtprec                  VARCHAR(8):=DATEDEB;
 typprec                 VARCHAR(1):='B';
 listPotAPropage         VARCHAR(100);
 req                     VARCHAR2(1000);
 pos                     NUMBER:=0;
 subs                    VARCHAR2(1000);
 un_index                INT;
 requpdate               VARCHAR2(1000);
 calcul                  VARCHAR2(100);
 lig_param CAD_PARAM_CALCUL%rowtype;
 tabreqcpt TYP_tabPot;
 
 TYPE TYP_tabStruct is table of CAD_PARAM_CALCUL%rowtype index by varchar2(32) ;
 tabstructcpt  TYP_tabStruct;
 TYPE TYP_PotANePasPropageCPT is table of varchar2(1000) index by varchar2(32) ;
 tablistPotANePasPropageCPT TYP_PotANePasPropageCPT;
 TYPE TYP_PotAPropage is table of varchar2(1000) index by varchar2(32) ;
 tablistPotAPropage TYP_PotAPropage;
 
 BEGIN
 
 if not tabstructcpt.exists(codecpt) then
 SELECT *
 INTO tabstructcpt(codecpt)
 FROM CAD_PARAM_CALCUL
 WHERE code_compteur      =codecpt;
 end if;
 lig_param:=tabstructcpt(codecpt);
 
 req                     :=lig_param.REQUETES;
 
 
 listPotANePasPropageCPT :=' ' ;
 if not tablistPotANePasPropageCPT.exists(codecpt) then
 FOR x IN
 (SELECT NUM_POT
 FROM CAD_PARAM_STRUCT_POT
 WHERE code_compteur=codecpt
 AND MAJ_BATCH      ='O'
 )
 LOOP
 if  tablistPotANePasPropageCPT.exists(codecpt) then
 tablistPotANePasPropageCPT(codecpt):=tablistPotANePasPropageCPT(codecpt)||' '||x.NUM_POT||' ';
 else
 tablistPotANePasPropageCPT(codecpt):=' '||x.NUM_POT||' ';
 end if;
 END LOOP;
 end if;
 if  tablistPotANePasPropageCPT.exists(codecpt) then
 listPotANePasPropageCPT:=tablistPotANePasPropageCPT(codecpt);
 end if;
 listPotAPropage:=' ' ;
 if not tablistPotAPropage.exists(codecpt) then
 FOR x IN
 (SELECT NUM_POT
 FROM CAD_PARAM_STRUCT_POT
 WHERE code_compteur     =codecpt
 AND TYPE_VARIATION NOT IN ('S','V')
 )
 LOOP
 if tablistPotAPropage.exists(codecpt) then
 tablistPotAPropage(codecpt):=tablistPotAPropage(codecpt)||' '||x.NUM_POT||' ';
 else
 tablistPotAPropage(codecpt):=' '||x.NUM_POT||' ';
 end if;
 END LOOP;
 end if;
 if tablistPotAPropage.exists(codecpt) then
 listPotAPropage:=tablistPotAPropage(codecpt);
 end if;
 
 
 
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt ;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 
 
 
 
 lig_cptori:=lig_cpt;
 
 
 --  IF (lig_cpt_prec.matricule IS  NULL) or  lig_cpt_prec.code_compteur<>lig_cpt.code_compteur THEN
 
 
 -- end if;
 
 IF (lig_cpt_prec.matricule IS NOT NULL) AND lig_cpt_prec.matricule=lig_cpt.matricule and lig_cpt_prec.code_compteur=lig_cpt.code_compteur THEN
 -- si bascule, on ne fait pas de propagation
 IF lig_cpt.typemj NOT IN ('B','S') THEN
 IF lig_cpt.typemj      ='M' THEN
 listPotANePasPropage:=listPotANePasPropageCPT;
 ELSE
 listPotANePasPropage:=' ';
 END IF;
 -- Propagation des pots sans variations
 IF listPotAPropage <>' ' THEN
 nbssreq          :=0;
 FOR i IN 1..12
 LOOP
 IF instr(listPotAPropage,' '||i||' ')>0 AND instr(listPotANePasPropage,' '||i||' ')=0 THEN
 IF i                               =1 THEN
 lig_cpt.POT1_VALEURJ            :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH            :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0));
 elsif i                            =2 THEN
 lig_cpt.POT2_VALEURJ            :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH            :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0));
 elsif i                            =3 THEN
 lig_cpt.POT3_VALEURJ            :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH            :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0));
 elsif i                            =4 THEN
 lig_cpt.POT4_VALEURJ            :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH            :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0));
 elsif i                            =5 THEN
 lig_cpt.POT5_VALEURJ            :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH            :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0));
 elsif i                            =6 THEN
 lig_cpt.POT6_VALEURJ            :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH            :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0));
 elsif i                            =7 THEN
 lig_cpt.POT7_VALEURJ            :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH            :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0));
 elsif i                            =8 THEN
 lig_cpt.POT8_VALEURJ            :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH            :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0));
 elsif i                            =9 THEN
 lig_cpt.POT9_VALEURJ            :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH            :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0));
 elsif i                            =10 THEN
 lig_cpt.POT10_VALEURJ           :=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH           :=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0));
 elsif i                            =11 THEN
 lig_cpt.POT11_VALEURJ           :=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH           :=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0));
 elsif i                            =12 THEN
 lig_cpt.POT12_VALEURJ           :=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0));
 lig_cpt.POT12_VALEURH           :=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0));
 END IF;
 END IF;
 END LOOP;
 END IF;
 -- Propagation des variations
 nbssreq                  :=0;
 IF lig_param.POTV1       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV1||' ')=0 THEN
 IF lig_param.POTV1      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 elsif lig_param.POTV1   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV1_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV1_VALEURH,0);
 END IF;
 END IF;
 IF lig_param.POTV2       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV2||' ')=0 THEN
 IF lig_param.POTV2      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 elsif lig_param.POTV2   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV2_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV2_VALEURH,0);
 END IF;
 END IF;
 IF lig_param.POTV3       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV3||' ')=0 THEN
 IF lig_param.POTV3      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 elsif lig_param.POTV3   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV3_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV3_VALEURH,0);
 END IF;
 END IF;
 IF lig_param.POTV4       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV4||' ')=0 THEN
 IF lig_param.POTV4      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 elsif lig_param.POTV4   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV4_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV4_VALEURH,0);
 END IF;
 END IF;
 IF lig_param.POTV5       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV5||' ')=0 THEN
 IF lig_param.POTV5      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 elsif lig_param.POTV5   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV5_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV5_VALEURH,0);
 END IF;
 END IF;
 IF lig_param.POTV6       IS NOT NULL AND instr(listPotANePasPropage,' '||lig_param.POTV6||' ')=0 THEN
 IF lig_param.POTV6      =1 THEN
 lig_cpt.POT1_VALEURJ :=NVL(lig_cpt_prec.POT1_FJ,NVL(lig_cpt_prec.POT1_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT1_VALEURH :=NVL(lig_cpt_prec.POT1_FH,NVL(lig_cpt_prec.POT1_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =2 THEN
 lig_cpt.POT2_VALEURJ :=NVL(lig_cpt_prec.POT2_FJ,NVL(lig_cpt_prec.POT2_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT2_VALEURH :=NVL(lig_cpt_prec.POT2_FH,NVL(lig_cpt_prec.POT2_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =3 THEN
 lig_cpt.POT3_VALEURJ :=NVL(lig_cpt_prec.POT3_FJ,NVL(lig_cpt_prec.POT3_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT3_VALEURH :=NVL(lig_cpt_prec.POT3_FH,NVL(lig_cpt_prec.POT3_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =4 THEN
 lig_cpt.POT4_VALEURJ :=NVL(lig_cpt_prec.POT4_FJ,NVL(lig_cpt_prec.POT4_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT4_VALEURH :=NVL(lig_cpt_prec.POT4_FH,NVL(lig_cpt_prec.POT4_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =5 THEN
 lig_cpt.POT5_VALEURJ :=NVL(lig_cpt_prec.POT5_FJ,NVL(lig_cpt_prec.POT5_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT5_VALEURH :=NVL(lig_cpt_prec.POT5_FH,NVL(lig_cpt_prec.POT5_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =6 THEN
 lig_cpt.POT6_VALEURJ :=NVL(lig_cpt_prec.POT6_FJ,NVL(lig_cpt_prec.POT6_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT6_VALEURH :=NVL(lig_cpt_prec.POT6_FH,NVL(lig_cpt_prec.POT6_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =7 THEN
 lig_cpt.POT7_VALEURJ :=NVL(lig_cpt_prec.POT7_FJ,NVL(lig_cpt_prec.POT7_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT7_VALEURH :=NVL(lig_cpt_prec.POT7_FH,NVL(lig_cpt_prec.POT7_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =8 THEN
 lig_cpt.POT8_VALEURJ :=NVL(lig_cpt_prec.POT8_FJ,NVL(lig_cpt_prec.POT8_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT8_VALEURH :=NVL(lig_cpt_prec.POT8_FH,NVL(lig_cpt_prec.POT8_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =9 THEN
 lig_cpt.POT9_VALEURJ :=NVL(lig_cpt_prec.POT9_FJ,NVL(lig_cpt_prec.POT9_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT9_VALEURH :=NVL(lig_cpt_prec.POT9_FH,NVL(lig_cpt_prec.POT9_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =10 THEN
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt_prec.POT10_FJ,NVL(lig_cpt_prec.POT10_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt_prec.POT10_FH,NVL(lig_cpt_prec.POT10_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =11 THEN
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt_prec.POT11_FJ,NVL(lig_cpt_prec.POT11_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt_prec.POT11_FH,NVL(lig_cpt_prec.POT11_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 elsif lig_param.POTV6   =12 THEN
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt_prec.POT12_FJ,NVL(lig_cpt_prec.POT12_VALEURJ,0))+NVL(lig_cpt.POTV6_VALEURJ,0);
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt_prec.POT12_FH,NVL(lig_cpt_prec.POT12_VALEURH,0))+NVL(lig_cpt.POTV6_VALEURH,0);
 END IF;
 END IF;
 END IF;
 END IF;
 
 IF lig_cpt.djour   <=NVL(datefin,'20991231') THEN
 
 for i in 1..12 loop
 
 --pot 1 
 if i=1 then
 -- si qu'une seule commande
 if instr(lig_param.POT1,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT1 is not null and instr(lig_param.POT1,'=')>0 then
 lig_param.POT1:=replace(lig_param.POT1,'=0','=');
 if lig_param.POT1='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT1 is not null then
 lig_param.POT1:=replace(lig_param.POT1,'+0','+');
 lig_param.POT1:=replace(lig_param.POT1,'-0','-');
 if lig_param.POT1='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif lig_param.POT1='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT1,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT1,0,instr(lig_param.POT1,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT1,instr(lig_param.POT1,';') + 1, length(lig_param.POT1));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT1_FJ,NVL(lig_cpt.POT1_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT1_FH,NVL(lig_cpt.POT1_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 
 --pot 2 
 if i=2 then
 -- si qu'une seule commande
 if instr(lig_param.POT2,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT2 is not null and instr(lig_param.POT2,'=')>0 then
 lig_param.POT2:=replace(lig_param.POT2,'=0','=');
 if lig_param.POT2='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT2 is not null then
 lig_param.POT2:=replace(lig_param.POT2,'+0','+');
 lig_param.POT2:=replace(lig_param.POT2,'-0','-');
 if lig_param.POT2='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif lig_param.POT2='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT2,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT2,0,instr(lig_param.POT2,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT2,instr(lig_param.POT2,';') + 1, length(lig_param.POT2));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT2_FJ,NVL(lig_cpt.POT2_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT2_FH,NVL(lig_cpt.POT2_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 3 
 if i=3 then
 -- si qu'une seule commande
 if instr(lig_param.POT3,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT3 is not null and instr(lig_param.POT3,'=')>0 then
 lig_param.POT3:=replace(lig_param.POT3,'=0','=');
 if lig_param.POT3='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT3 is not null then
 lig_param.POT3:=replace(lig_param.POT3,'+0','+');
 lig_param.POT3:=replace(lig_param.POT3,'-0','-');
 if lig_param.POT3='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif lig_param.POT3='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT3,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT3,0,instr(lig_param.POT3,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT3,instr(lig_param.POT3,';') + 1, length(lig_param.POT3));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT3_FJ,NVL(lig_cpt.POT3_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT3_FH,NVL(lig_cpt.POT3_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 4 
 if i=4 then
 -- si qu'une seule commande
 if instr(lig_param.POT4,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT4 is not null and instr(lig_param.POT4,'=')>0 then
 lig_param.POT4:=replace(lig_param.POT4,'=0','=');
 if lig_param.POT4='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT4 is not null then
 lig_param.POT4:=replace(lig_param.POT4,'+0','+');
 lig_param.POT4:=replace(lig_param.POT4,'-0','-');
 if lig_param.POT4='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif lig_param.POT4='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT4,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT4,0,instr(lig_param.POT4,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT4,instr(lig_param.POT4,';') + 1, length(lig_param.POT4));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT4_FJ,NVL(lig_cpt.POT4_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT4_FH,NVL(lig_cpt.POT4_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 5 
 if i=5 then
 -- si qu'une seule commande
 if instr(lig_param.POT5,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT5 is not null and instr(lig_param.POT5,'=')>0 then
 lig_param.POT5:=replace(lig_param.POT5,'=0','=');
 if lig_param.POT5='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT5 is not null then
 lig_param.POT5:=replace(lig_param.POT5,'+0','+');
 lig_param.POT5:=replace(lig_param.POT5,'-0','-');
 if lig_param.POT5='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif lig_param.POT5='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT5,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT5,0,instr(lig_param.POT5,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT5,instr(lig_param.POT5,';') + 1, length(lig_param.POT5));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT5_FJ,NVL(lig_cpt.POT5_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT5_FH,NVL(lig_cpt.POT5_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 6 
 if i=6 then
 -- si qu'une seule commande
 if instr(lig_param.POT6,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT6 is not null and instr(lig_param.POT6,'=')>0 then
 lig_param.POT6:=replace(lig_param.POT6,'=0','=');
 if lig_param.POT6='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT6 is not null then
 lig_param.POT6:=replace(lig_param.POT6,'+0','+');
 lig_param.POT6:=replace(lig_param.POT6,'-0','-');
 if lig_param.POT6='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif lig_param.POT6='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT6,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT6,0,instr(lig_param.POT6,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT6,instr(lig_param.POT6,';') + 1, length(lig_param.POT6));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT6_FJ,NVL(lig_cpt.POT6_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT6_FH,NVL(lig_cpt.POT6_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 7 
 if i=7 then
 -- si qu'une seule commande
 if instr(lig_param.POT7,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT7 is not null and instr(lig_param.POT7,'=')>0 then
 lig_param.POT7:=replace(lig_param.POT7,'=0','=');
 if lig_param.POT7='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT7 is not null then
 lig_param.POT7:=replace(lig_param.POT7,'+0','+');
 lig_param.POT7:=replace(lig_param.POT7,'-0','-');
 if lig_param.POT7='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT7='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT7,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT7,0,instr(lig_param.POT7,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT7,instr(lig_param.POT7,';') + 1, length(lig_param.POT7));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT7_FJ,NVL(lig_cpt.POT7_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 8 
 if i=8 then
 -- si qu'une seule commande
 if instr(lig_param.POT8,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT8 is not null and instr(lig_param.POT8,'=')>0 then
 lig_param.POT8:=replace(lig_param.POT8,'=0','=');
 if lig_param.POT8='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif lig_param.POT8='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT8 is not null then
 lig_param.POT8:=replace(lig_param.POT8,'+0','+');
 lig_param.POT8:=replace(lig_param.POT8,'-0','-');
 if lig_param.POT8='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT8='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT8,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT8,0,instr(lig_param.POT8,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT8,instr(lig_param.POT8,';') + 1, length(lig_param.POT8));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT8_FH,NVL(lig_cpt.POT8_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT8_FJ,NVL(lig_cpt.POT8_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 9 
 if i=9 then
 -- si qu'une seule commande
 if instr(lig_param.POT9,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT9 is not null and instr(lig_param.POT9,'=')>0 then
 lig_param.POT9:=replace(lig_param.POT9,'=0','=');
 if lig_param.POT9='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif lig_param.POT9='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT9 is not null then
 lig_param.POT9:=replace(lig_param.POT9,'+0','+');
 lig_param.POT9:=replace(lig_param.POT9,'-0','-');
 if lig_param.POT9='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT9='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT9,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT9,0,instr(lig_param.POT9,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT9,instr(lig_param.POT9,';') + 1, length(lig_param.POT9));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT9_FH,NVL(lig_cpt.POT9_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT9_FJ,NVL(lig_cpt.POT9_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 10 
 if i=10 then
 -- si qu'une seule commande
 if instr(lig_param.POT10,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT10 is not null and instr(lig_param.POT10,'=')>0 then
 lig_param.POT10:=replace(lig_param.POT10,'=0','=');
 if lig_param.POT10='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif lig_param.POT10='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT10 is not null then
 lig_param.POT10:=replace(lig_param.POT10,'+0','+');
 lig_param.POT10:=replace(lig_param.POT10,'-0','-');
 if lig_param.POT10='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT10='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT10,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT10,0,instr(lig_param.POT10,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT10,instr(lig_param.POT10,';') + 1, length(lig_param.POT10));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT10_FH,NVL(lig_cpt.POT10_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT10_FJ,NVL(lig_cpt.POT10_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
 
 --pot 11 
 if i=11 then
 -- si qu'une seule commande
 if instr(lig_param.POT11,';')<=0 then
 -- si qu'une commande =
 if lig_param.POT11 is not null and instr(lig_param.POT11,'=')>0 then
 lig_param.POT11:=replace(lig_param.POT11,'=0','=');
 if lig_param.POT11='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif lig_param.POT11='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 end if;
 
 
 -- si qu'une commande avec + ou -
 elsif lig_param.POT11 is not null then
 lig_param.POT11:=replace(lig_param.POT11,'+0','+');
 lig_param.POT11:=replace(lig_param.POT11,'-0','-');
 if lig_param.POT11='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif lig_param.POT11='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 -- si deux commandes
 elsif instr(lig_param.POT11,';')>0 then
 -- on fait le même calcul mais deux fois de suite pour traiter les deux commandes
 for j in 1..2 loop
 calcul := '';
 
 if j = 1 then
 calcul:=substr(lig_param.POT11,0,instr(lig_param.POT11,';') -1);
 elsif j = 2 then
 calcul:=substr(lig_param.POT11,instr(lig_param.POT11,';') + 1, length(lig_param.POT11));
 end if;
 -- d'abord si instruction =
 if calcul is not null and instr(calcul,'=')>0 then
 calcul:=replace(calcul,'=0','=');
 if calcul='=1' then
 lig_cpt.POT1_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=2' then
 lig_cpt.POT2_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=3' then
 lig_cpt.POT3_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=4' then
 lig_cpt.POT4_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=5' then
 lig_cpt.POT5_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=6' then
 lig_cpt.POT6_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=7' then
 lig_cpt.POT7_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=8' then
 lig_cpt.POT8_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=9' then
 lig_cpt.POT9_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=10' then
 lig_cpt.POT10_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=11' then
 lig_cpt.POT11_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 elsif calcul='=12' then
 lig_cpt.POT12_VALEURJ:=NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=NVL(lig_cpt.POT11_FH,NVL(lig_cpt.POT11_VALEURH,0));
 end if;
 
 
 -- ensuite si commande + ou -
 elsif calcul is not null then
 calcul:=replace(calcul,'+0','+');
 calcul:=replace(calcul,'-0','-');
 if calcul='+1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='+12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) + NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) + NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-1' then
 lig_cpt.POT1_VALEURJ:=nvl(lig_cpt.POT1_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT1_VALEURH:=nvl(lig_cpt.POT1_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-2' then
 lig_cpt.POT2_VALEURJ:=nvl(lig_cpt.POT2_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT2_VALEURH:=nvl(lig_cpt.POT2_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-3' then
 lig_cpt.POT3_VALEURJ:=nvl(lig_cpt.POT3_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT3_VALEURH:=nvl(lig_cpt.POT3_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-4' then
 lig_cpt.POT4_VALEURJ:=nvl(lig_cpt.POT4_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT4_VALEURH:=nvl(lig_cpt.POT4_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-5' then
 lig_cpt.POT5_VALEURJ:=nvl(lig_cpt.POT5_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT5_VALEURH:=nvl(lig_cpt.POT5_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-6' then
 lig_cpt.POT6_VALEURJ:=nvl(lig_cpt.POT6_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT6_VALEURH:=nvl(lig_cpt.POT6_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-7' then
 lig_cpt.POT7_VALEURJ:=nvl(lig_cpt.POT7_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT7_VALEURH:=nvl(lig_cpt.POT7_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-8' then
 lig_cpt.POT8_VALEURJ:=nvl(lig_cpt.POT8_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT8_VALEURH:=nvl(lig_cpt.POT8_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-9' then
 lig_cpt.POT9_VALEURJ:=nvl(lig_cpt.POT9_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT9_VALEURH:=nvl(lig_cpt.POT9_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-10' then
 lig_cpt.POT10_VALEURJ:=nvl(lig_cpt.POT10_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT10_VALEURH:=nvl(lig_cpt.POT10_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-11' then
 lig_cpt.POT11_VALEURJ:=nvl(lig_cpt.POT11_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT11_VALEURH:=nvl(lig_cpt.POT11_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 elsif calcul='-12' then
 lig_cpt.POT12_VALEURJ:=nvl(lig_cpt.POT12_VALEURJ,0) - NVL(lig_cpt.POT11_FJ,NVL(lig_cpt.POT11_VALEURJ,0));
 lig_cpt.POT12_VALEURH:=nvl(lig_cpt.POT12_VALEURH,0) - NVL(lig_cpt.POT7_FH,NVL(lig_cpt.POT7_VALEURH,0));
 end if;
 end if;
 
 
 end loop;
 end if;
 end if;
  
 
 END LOOP;
 END IF;
 
 
 if (nvl(lig_cptori.POT1_VALEURJ,0)<>nvl(lig_cpt.POT1_VALEURJ,0)
 OR nvl(lig_cptori.POT1_VALEURH,0)   <>nvl(lig_cpt.POT1_VALEURH,0)
 OR nvl(lig_cptori.POT2_VALEURJ,0)   <>nvl(lig_cpt.POT2_VALEURJ,0)
 OR nvl(lig_cptori.POT2_VALEURH,0)   <>nvl(lig_cpt.POT2_VALEURH,0)
 OR nvl(lig_cptori.POT3_VALEURJ,0)   <>nvl(lig_cpt.POT3_VALEURJ,0)
 OR nvl(lig_cptori.POT3_VALEURH,0)   <>nvl(lig_cpt.POT3_VALEURH,0)
 OR nvl(lig_cptori.POT4_VALEURJ,0)   <>nvl(lig_cpt.POT4_VALEURJ,0)
 OR nvl(lig_cptori.POT4_VALEURH ,0)  <>nvl(lig_cpt.POT4_VALEURH,0)
 OR nvl(lig_cptori.POT5_VALEURJ ,0)  <>nvl(lig_cpt.POT5_VALEURJ,0)
 OR nvl(lig_cptori.POT5_VALEURH ,0)  <>nvl(lig_cpt.POT5_VALEURH,0)
 OR nvl(lig_cptori.POT6_VALEURJ ,0)  <>nvl(lig_cpt.POT6_VALEURJ,0)
 OR nvl(lig_cptori.POT6_VALEURH ,0)  <>nvl(lig_cpt.POT6_VALEURH,0)
 OR nvl(lig_cptori.POT7_VALEURJ ,0)  <>nvl(lig_cpt.POT7_VALEURJ,0)
 OR nvl(lig_cptori.POT7_VALEURH ,0)  <>nvl(lig_cpt.POT7_VALEURH,0)
 OR nvl(lig_cptori.POT8_VALEURJ ,0)  <>nvl(lig_cpt.POT8_VALEURJ,0)
 OR nvl(lig_cptori.POT8_VALEURH ,0)  <>nvl(lig_cpt.POT8_VALEURH,0)
 OR nvl(lig_cptori.POT9_VALEURJ ,0)  <>nvl(lig_cpt.POT9_VALEURJ,0)
 OR nvl(lig_cptori.POT9_VALEURH ,0)  <>nvl(lig_cpt.POT9_VALEURH,0)
 OR nvl(lig_cptori.POT10_VALEURJ ,0) <>nvl(lig_cpt.POT10_VALEURJ,0)
 OR nvl(lig_cptori.POT10_VALEURH ,0) <>nvl(lig_cpt.POT10_VALEURH,0)
 OR nvl(lig_cptori.POT11_VALEURJ ,0) <>nvl(lig_cpt.POT11_VALEURJ,0)
 OR nvl(lig_cptori.POT11_VALEURH ,0) <>nvl(lig_cpt.POT11_VALEURH,0)
 OR nvl(lig_cptori.POT12_VALEURJ ,0) <>nvl(lig_cpt.POT12_VALEURJ,0)
 OR nvl(lig_cptori.POT12_VALEURH,0)  <>nvl(lig_cpt.POT12_VALEURH,0)) then
 
 UPDATE cad_compteur
 SET DATE_MAJ=(
 CASE
 WHEN (POT1_VALEURJ<>lig_cpt.POT1_VALEURJ
 OR POT1_VALEURH   <>lig_cpt.POT1_VALEURH
 OR POT2_VALEURJ   <>lig_cpt.POT2_VALEURJ
 OR POT2_VALEURH   <>lig_cpt.POT2_VALEURH
 OR POT3_VALEURJ   <>lig_cpt.POT3_VALEURJ
 OR POT3_VALEURH   <>lig_cpt.POT3_VALEURH
 OR POT4_VALEURJ   <>lig_cpt.POT4_VALEURJ
 OR POT4_VALEURH   <>lig_cpt.POT4_VALEURH
 OR POT5_VALEURJ   <>lig_cpt.POT5_VALEURJ
 OR POT5_VALEURH   <>lig_cpt.POT5_VALEURH
 OR POT6_VALEURJ   <>lig_cpt.POT6_VALEURJ
 OR POT6_VALEURH   <>lig_cpt.POT6_VALEURH
 OR POT7_VALEURJ   <>lig_cpt.POT7_VALEURJ
 OR POT7_VALEURH   <>lig_cpt.POT7_VALEURH
 OR POT8_VALEURJ   <>lig_cpt.POT8_VALEURJ
 OR POT8_VALEURH   <>lig_cpt.POT8_VALEURH
 OR POT9_VALEURJ   <>lig_cpt.POT9_VALEURJ
 OR POT9_VALEURH   <>lig_cpt.POT9_VALEURH
 OR POT10_VALEURJ  <>lig_cpt.POT10_VALEURJ
 OR POT10_VALEURH  <>lig_cpt.POT10_VALEURH
 OR POT11_VALEURJ  <>lig_cpt.POT11_VALEURJ
 OR POT11_VALEURH  <>lig_cpt.POT11_VALEURH
 OR POT12_VALEURJ  <>lig_cpt.POT12_VALEURJ
 OR POT12_VALEURH  <>lig_cpt.POT12_VALEURH)
 THEN sysdate
 ELSE DATE_MAJ
 END),
 POT1_VALEURJ  =lig_cpt.POT1_VALEURJ,
 POT1_VALEURH  =lig_cpt.POT1_VALEURH,
 POT2_VALEURJ  =lig_cpt.POT2_VALEURJ,
 POT2_VALEURH  =lig_cpt.POT2_VALEURH,
 POT3_VALEURJ  =lig_cpt.POT3_VALEURJ,
 POT3_VALEURH  =lig_cpt.POT3_VALEURH,
 POT4_VALEURJ  =lig_cpt.POT4_VALEURJ,
 POT4_VALEURH  =lig_cpt.POT4_VALEURH,
 POT5_VALEURJ  =lig_cpt.POT5_VALEURJ,
 POT5_VALEURH  =lig_cpt.POT5_VALEURH,
 POT6_VALEURJ  =lig_cpt.POT6_VALEURJ,
 POT6_VALEURH  =lig_cpt.POT6_VALEURH,
 POT7_VALEURJ  =lig_cpt.POT7_VALEURJ,
 POT7_VALEURH  =lig_cpt.POT7_VALEURH,
 POT8_VALEURJ  =lig_cpt.POT8_VALEURJ,
 POT8_VALEURH  =lig_cpt.POT8_VALEURH,
 POT9_VALEURJ  =lig_cpt.POT9_VALEURJ,
 POT9_VALEURH  =lig_cpt.POT9_VALEURH,
 POT10_VALEURJ =lig_cpt.POT10_VALEURJ,
 POT10_VALEURH =lig_cpt.POT10_VALEURH,
 POT11_VALEURJ =lig_cpt.POT11_VALEURJ,
 POT11_VALEURH =lig_cpt.POT11_VALEURH,
 POT12_VALEURJ =lig_cpt.POT12_VALEURJ,
 POT12_VALEURH =lig_cpt.POT12_VALEURH
 WHERE CURRENT OF cur_cpt ;
 end if;
 dtprec      :=lig_cpt.DJour;
 typprec     :=lig_cpt.typemj;
 lig_cpt_prec:=lig_cpt;
 /*  IF Tab_ligcpt     IS NULL THEN
 Tab_ligcpt      :=Typ_Tab_ligcpt(lig_cpt);
 ELSE
 Tab_ligcpt.extend();
 Tab_ligcpt(Tab_ligcpt.last):=lig_cpt;
 END IF;*/
 END LOOP;
 CLOSE cur_cpt;
 
 /* forall i in Tab_ligcpt.first..Tab_ligcpt.last
 UPDATE cad_compteur
 SET DATE_MAJ=(
 CASE
 WHEN (POT1_VALEURJ<>lig_cpt.POT1_VALEURJ
 OR POT1_VALEURH   <>Tab_ligcpt(i).POT1_VALEURH
 OR POT2_VALEURJ   <>Tab_ligcpt(i).POT2_VALEURJ
 OR POT2_VALEURH   <>Tab_ligcpt(i).POT2_VALEURH
 OR POT3_VALEURJ   <>Tab_ligcpt(i).POT3_VALEURJ
 OR POT3_VALEURH   <>Tab_ligcpt(i).POT3_VALEURH
 OR POT4_VALEURJ   <>Tab_ligcpt(i).POT4_VALEURJ
 OR POT4_VALEURH   <>Tab_ligcpt(i).POT4_VALEURH
 OR POT5_VALEURJ   <>Tab_ligcpt(i).POT5_VALEURJ
 OR POT5_VALEURH   <>Tab_ligcpt(i).POT5_VALEURH
 OR POT6_VALEURJ   <>Tab_ligcpt(i).POT6_VALEURJ
 OR POT6_VALEURH   <>Tab_ligcpt(i).POT6_VALEURH
 OR POT7_VALEURJ   <>Tab_ligcpt(i).POT7_VALEURJ
 OR POT7_VALEURH   <>Tab_ligcpt(i).POT7_VALEURH
 OR POT8_VALEURJ   <>Tab_ligcpt(i).POT8_VALEURJ
 OR POT8_VALEURH   <>Tab_ligcpt(i).POT8_VALEURH
 OR POT9_VALEURJ   <>Tab_ligcpt(i).POT9_VALEURJ
 OR POT9_VALEURH   <>Tab_ligcpt(i).POT9_VALEURH
 OR POT10_VALEURJ  <>Tab_ligcpt(i).POT10_VALEURJ
 OR POT10_VALEURH  <>Tab_ligcpt(i).POT10_VALEURH
 OR POT11_VALEURJ  <>Tab_ligcpt(i).POT11_VALEURJ
 OR POT11_VALEURH  <>Tab_ligcpt(i).POT11_VALEURH
 OR POT12_VALEURJ  <>Tab_ligcpt(i).POT12_VALEURJ
 OR POT12_VALEURH  <>Tab_ligcpt(i).POT12_VALEURH)
 THEN sysdate
 ELSE DATE_MAJ
 END),
 POT1_VALEURJ  =Tab_ligcpt(i).POT1_VALEURJ,
 POT1_VALEURH  =Tab_ligcpt(i).POT1_VALEURH,
 POT2_VALEURJ  =Tab_ligcpt(i).POT2_VALEURJ,
 POT2_VALEURH  =Tab_ligcpt(i).POT2_VALEURH,
 POT3_VALEURJ  =Tab_ligcpt(i).POT3_VALEURJ,
 POT3_VALEURH  =Tab_ligcpt(i).POT3_VALEURH,
 POT4_VALEURJ  =Tab_ligcpt(i).POT4_VALEURJ,
 POT4_VALEURH  =Tab_ligcpt(i).POT4_VALEURH,
 POT5_VALEURJ  =Tab_ligcpt(i).POT5_VALEURJ,
 POT5_VALEURH  =Tab_ligcpt(i).POT5_VALEURH,
 POT6_VALEURJ  =Tab_ligcpt(i).POT6_VALEURJ,
 POT6_VALEURH  =Tab_ligcpt(i).POT6_VALEURH,
 POT7_VALEURJ  =Tab_ligcpt(i).POT7_VALEURJ,
 POT7_VALEURH  =Tab_ligcpt(i).POT7_VALEURH,
 POT8_VALEURJ  =Tab_ligcpt(i).POT8_VALEURJ,
 POT8_VALEURH  =Tab_ligcpt(i).POT8_VALEURH,
 POT9_VALEURJ  =Tab_ligcpt(i).POT9_VALEURJ,
 POT9_VALEURH  =Tab_ligcpt(i).POT9_VALEURH,
 POT10_VALEURJ =Tab_ligcpt(i).POT10_VALEURJ,
 POT10_VALEURH =Tab_ligcpt(i).POT10_VALEURH,
 POT11_VALEURJ =Tab_ligcpt(i).POT11_VALEURJ,
 POT11_VALEURH =Tab_ligcpt(i).POT11_VALEURH,
 POT12_VALEURJ =Tab_ligcpt(i).POT12_VALEURJ,
 POT12_VALEURH =Tab_ligcpt(i).POT12_VALEURH where rowid=Tab_ligcpt(i).rowid;*/
 
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  := SQLERRM;
 CAD_ERREUR(IDMATRIC ,'CAD_UNIT_PROPAGATION', IDMATRIC ||','|| p_matric ||','|| DATEDEB ||','||DATEFIN ||','|| CODECPT ||','|| AvecBascule ,err_code||'-'||err_msg);
 raise;
 END CAD_UNIT_PROPAGATION;
 PROCEDURE CAD_UNIT_MAJ_VALEUR_RUBJOUR(
 idMat               IN NUMBER,
 matric              IN VARCHAR2 ,
 DATEJOUR            IN VARCHAR2 ,
 rub                 IN VARCHAR2,
 unite               IN VARCHAR2,
 nbh                 IN NUMBER,
 j_cal               IN NUMBER,
 j_ouvrable          IN NUMBER,
 j_oeuvr             IN NUMBER,
 j_ouvre             IN NUMBER,
 nbjour              IN OUT NUMBER,
 nbheures            IN OUT NUMBER,
 forcage             IN VARCHAR2,
 limitazero          IN BOOLEAN,
 forcageDuResteEnFin IN VARCHAR2)
 AS
 CURSOR cur_cpt
 IS
 SELECT *
 FROM
 (SELECT a.code_compteur,
 a.pot_solde,
 a.pot_variation,
 a.min_soldej,
 a.min_soldeh,
 a.ordre
 FROM CAD_PARAM_LIEN_RUB_CPT a,
 CAD_MATRIC_DATEVALID b
 WHERE a.RUB_VAL_JOUR =rub
 AND a.code_compteur  =b.code_compteur
 AND b.matricule      =matric
 AND b.date_deb_per  <=datejour
 AND b.date_fin_per  >=datejour
 AND b.DATE_EFFET     =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid c
 WHERE c.date_effet<=datejour
 AND c.code_compteur=b.code_compteur
 AND b.matricule    =c.matricule
 AND b.date_deb_per =c.date_deb_per
 AND b.date_fin_per =c.date_fin_per
 )
 )
 ORDER BY
 CASE
 WHEN forcageDuResteEnFin='true'
 THEN ordre
 END DESC,
 CASE
 WHEN forcageDuResteEnFin='false'
 THEN ordre
 END
 --  ordre
 ;
 ligne_cpt cur_cpt%ROWTYPE;
 numpotSolde    NUMBER;
 numpotPris     NUMBER;
 pot_Var        NUMBER;
 valSoldeJ      NUMBER:=0;
 valSoldeH      NUMBER:=0;
 valVarJ        NUMBER:=0;
 valVarH        NUMBER:=0;
 valPrisJ       NUMBER:=0;
 valPrisH       NUMBER:=0;
 req            VARCHAR(2000);
 djourcpt       VARCHAR(8);
 typemjcp       VARCHAR(1);
 gestionHJ      VARCHAR(1);
 soldeJ         NUMBER :=0;
 variationJ     NUMBER :=0;
 soldeH         NUMBER :=0;
 variationH     NUMBER :=0;
 reqpropagation VARCHAR(4000);
 reqinsert      VARCHAR(4000);
 pasdeCpt       BOOLEAN;
 cptValide      BOOLEAN:=false;
 l_rowid        VARCHAR2(100);
 BEGIN
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO ligne_cpt;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 cptValide    :=true;
 IF gestionHJ IS NULL THEN
 SELECT cpt.gestionHJ
 INTO gestionHJ
 FROM CAD_PARAM_STRUCT_CPT cpt
 WHERE cpt.CODE_COMPTEUR=ligne_cpt.code_compteur;
 IF nbjour              =0 AND nbheures=0 THEN
 IF gestionHJ         ='H' THEN
 nbjour            :=0;
 nbheures          :=nbh;
 ELSE
 IF gestionHJ='A' THEN
 nbheures :=nbh;
 ELSE
 nbheures:=0;
 END IF;
 IF unite   ='C' THEN
 nbjour  :=j_cal;
 elsif unite='U' THEN
 nbjour  :=j_ouvre;
 elsif unite='S' THEN
 nbjour  :=j_ouvrable;
 elsif unite='O' THEN
 nbjour  :=j_oeuvr;
 END IF;
 END IF;
 END IF;
 END IF;
 -- Récupération du pot de variation
 SELECT
 CASE
 WHEN POTV1=ligne_cpt.pot_variation
 THEN 1
 WHEN POTV2=ligne_cpt.pot_variation
 THEN 2
 WHEN POTV3=ligne_cpt.pot_variation
 THEN 3
 WHEN POTV4=ligne_cpt.pot_variation
 THEN 4
 WHEN POTV5=ligne_cpt.pot_variation
 THEN 5
 WHEN POTV6=ligne_cpt.pot_variation
 THEN 6
 END
 INTO pot_Var
 FROM CAD_PARAM_CALCUL
 WHERE code_compteur=ligne_cpt.code_compteur;
 IF pot_Var        IS NOT NULL THEN
 -- Récupération du solde, du pris et de la variation
 req:= 'select djour,typemj,nvl(POT'||ligne_cpt.pot_solde||'_VALEURJ,0), nvl(POT'||ligne_cpt.pot_solde||'_VALEURH,0),nvl(POTV'||pot_Var||'_VALEURJ,0), nvl(POTV'||pot_Var||'_VALEURH,0),nvl(POT'||ligne_cpt.pot_variation||'_VALEURJ,0), nvl(POT'||ligne_cpt.pot_variation||'_VALEURH,0),rowid from CAD_COMPTEUR c where c.matricule      = :matric
 and code_COMPTEUR= :codecpt
 AND djour||typemj          =
 (SELECT MAX(c2.djour||c2.typemj)
 FROM CAD_COMPTEUR c2
 WHERE c.code_compteur=c2.code_compteur
 AND c.matricule      =c2.matricule
 AND ( c2.djour        <:datejour
 or
 (
 c2.djour=:datejour and c2.typemj<''S''
 ))) ' ;
 BEGIN
 IF ligne_cpt.pot_solde<>0 THEN
 EXECUTE immediate req INTO djourcpt,
 typemjcp,
 valSoldeJ,
 valSoldeH,
 valVarJ,
 valVarH,
 valprisJ,
 valprisH,
 l_rowid USING matric,
 ligne_cpt.code_compteur,
 datejour,
 datejour;
 END IF;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 pasdeCpt:=true;
 CONTINUE;
 END;
 pasdeCpt:=false;
 -- Solde suffisant
 IF djourcpt <>datejour THEN
 valVarJ   :=0;
 valVarH   :=0;
 END IF;
 -- Si le solde est est déjà au min  et pas de forçage on ne fait rien
 IF ligne_cpt.pot_solde<>0 AND (NOT (forcage='true' AND forcageduresteenfin='true' ) AND ((gestionHJ='A' AND ( (limitazero AND (valSoldeJ<=greatest(ligne_cpt.MIN_SOLDEJ,0)) OR (NOT limitazero AND (valSoldeJ<=ligne_cpt.MIN_SOLDEJ) ))) AND ( (limitazero AND (valSoldeH<=greatest(ligne_cpt.MIN_SOLDEH,0)) OR (NOT limitazero AND (valSoldeH<=ligne_cpt.MIN_SOLDEH) )))) OR (gestionHJ='J' AND (limitazero AND (valSoldeJ<=greatest(ligne_cpt.MIN_SOLDEJ,0)) OR (NOT limitazero AND (valSoldeJ<=ligne_cpt.MIN_SOLDEJ) ) )) OR (gestionHJ='H' AND (limitazero AND (valSoldeH<=greatest(ligne_cpt.MIN_SOLDEH,0)) OR (NOT limitazero AND (valSoldeH<=ligne_cpt.MIN_SOLDEH) ) )))) THEN
 CONTINUE;
 -- si solde suffisant
 elsIF ligne_cpt.pot_solde=0 OR ((forcage='true' AND forcageduresteenfin='true' ) OR (gestionHJ='A' AND ( (limitazero AND valSoldeJ-(nbjour+valVarJ)>=greatest(ligne_cpt.MIN_SOLDEJ,0)) OR (NOT limitazero AND valSoldeJ-(nbjour+valVarJ)>=ligne_cpt.MIN_SOLDEJ)) AND ( (limitazero AND valSoldeH-(nbheures+valVarH)>=greatest(ligne_cpt.MIN_SOLDEH,0) ) OR (NOT limitazero AND valSoldeH-(nbheures+valVarH)>=ligne_cpt.MIN_SOLDEH) ) ) OR (gestionHJ='H' AND ( (limitazero AND valSoldeH-(nbheures+valVarH)>=greatest(ligne_cpt.MIN_SOLDEH,0) ) OR (NOT limitazero AND valSoldeH-(nbheures+valVarH)>=ligne_cpt.MIN_SOLDEH) )) OR (gestionHJ='J' AND ( (limitazero AND valSoldeJ-(nbjour+valVarJ)>=greatest(ligne_cpt.MIN_SOLDEJ,0)) OR (NOT limitazero AND valSoldeJ-(nbjour+valVarJ)>=ligne_cpt.MIN_SOLDEJ))) ) THEN
 -- mise à jour de la variation et sortie
 IF (djourcpt  =datejour AND (typemjcp='N' OR typemjcp='M' )) THEN
 variationJ := valVarJ+ nbjour;
 variationH := valVarH+ nbheures;
 req        :='UPDATE CAD_COMPTEUR set date_maj=sysdate,POTV'||pot_Var||'_VALEURJ=:1,POT'||ligne_cpt.pot_variation||'_VALEURJ=nvl(POT'||ligne_cpt.pot_variation||'_VALEURJ,0)+:2
 ,POTV'||pot_Var||'_VALEURh=:3,POT'||ligne_cpt.pot_variation||'_VALEURh=nvl(POT'||ligne_cpt.pot_variation||'_VALEURh,0)+:4
 where
 rowid=:5';
 EXECUTE immediate req USING variationJ,
 nbjour,
 variationH,
 nbheures,
 l_rowid;
 ELSE
 IF gestionHJ  ='A' OR gestionHJ='J' THEN
 variationJ := NVL(nbjour,0);
 END IF;
 IF gestionHJ  ='A' OR gestionHJ='H' THEN
 variationH := NVL(nbheures,0);
 END IF;
 IF variationJ>0 OR variationH>0 THEN
 reqinsert := 'INSERT into CAD_COMPTEUR (MATRICULE,CODE_COMPTEUR,DJOUR,TYPEMJ,date_maj,POT'||ligne_cpt.pot_variation||'_VALEURJ,POTV'||pot_Var||'_VALEURJ,POT'||ligne_cpt.pot_variation||'_VALEURH,POTV'||pot_Var||'_VALEURH)
 values ('''||matric||''','''||ligne_cpt.code_compteur||''','''||datejour||''',''N'',sysdate,:1,:2,:3,:4)';
 EXECUTE immediate reqinsert USING NVL(valPrisJ,0)+ NVL(nbjour,0),
 NVL(variationJ,0),
 NVL(valPrisH,0)+ NVL(nbheures,0),
 NVL(variationH,0) ;
 END IF;
 END IF;
 nbheures:=0;
 nbjour  :=0;
 EXIT;
 ELSE -- on n'a pas assez on prend la partie possible et on calcule le reste
 IF gestionHJ='A' OR gestionHJ='J' THEN
 IF limitazero THEN
 nbjour := nbjour - greatest(0,valSoldeJ);
 ELSE
 nbjour := nbjour - greatest(0,(valSoldeJ-ligne_cpt.MIN_SOLDEJ));
 END IF;
 END IF;
 IF limitazero THEN
 nbheures := nbheures - greatest(0,valSoldeH);
 ELSE
 nbheures := nbheures - greatest(0,(valSoldeH-ligne_cpt.MIN_SOLDEH));
 END IF;
 IF (djourcpt =datejour AND (typemjcp='N' OR typemjcp='M' )) THEN
 IF limitazero THEN
 req:= 'UPDATE CAD_COMPTEUR set date_maj=sysdate,POTV'||pot_Var||'_VALEURJ=POT'||ligne_cpt.pot_solde||'_VALEURJ-('||greatest(0,ligne_cpt.MIN_SOLDEJ)||'),POT'||ligne_cpt.pot_variation||'_VALEURJ=nvl(POT'||ligne_cpt.pot_variation||'_VALEURJ,0)+ nvl(POT'||ligne_cpt.pot_solde||'_VALEURJ,0)-'||greatest(0,ligne_cpt.MIN_SOLDEJ)||'
 ,POTV'||pot_Var||'_VALEURH=POT'||ligne_cpt.pot_solde||'_VALEURH-('||greatest(0,ligne_cpt.MIN_SOLDEH)||'),POT'||ligne_cpt.pot_variation||'_VALEURH=nvl(POT'||ligne_cpt.pot_variation||'_VALEURH,0)+ nvl(POT'||ligne_cpt.pot_solde||'_VALEURH,0)-('||greatest(0,ligne_cpt.MIN_SOLDEH)||')
 where rowid=:1';
 ELSE
 req:='UPDATE CAD_COMPTEUR set date_maj=sysdate,POTV'||pot_Var||'_VALEURJ=POT'||ligne_cpt.pot_solde||'_VALEURJ-('||ligne_cpt.MIN_SOLDEJ||'),POT'||ligne_cpt.pot_variation||'_VALEURJ=nvl(POT'||ligne_cpt.pot_variation||'_VALEURJ,0)+ nvl(POT'||ligne_cpt.pot_solde||'_VALEURJ,0)-('||ligne_cpt.MIN_SOLDEJ||')
 ,POTV'||pot_Var||'_VALEURH=POT'||ligne_cpt.pot_solde||'_VALEURH-('||ligne_cpt.MIN_SOLDEH||'),POT'||ligne_cpt.pot_variation||'_VALEURH=nvl(POT'||ligne_cpt.pot_variation||'_VALEURH,0)+ nvl(POT'||ligne_cpt.pot_solde||'_VALEURH,0)-('||ligne_cpt.MIN_SOLDEH||')
 where rowid=:1';
 END IF;
 EXECUTE immediate req USING l_rowid;
 ELSE
 IF gestionHJ ='A' OR gestionHJ='J' THEN
 IF limitazero THEN
 soldeJ     := greatest(0,ligne_cpt.MIN_SOLDEJ);
 variationJ :=valSoldeJ-greatest(0,ligne_cpt.MIN_SOLDEJ) ;
 ELSE
 soldeJ     := ligne_cpt.MIN_SOLDEJ;
 variationJ :=valSoldeJ-ligne_cpt.MIN_SOLDEJ ;
 END IF;
 END IF;
 IF gestionHJ ='A' OR gestionHJ='H' THEN
 IF limitazero THEN
 soldeH     :=greatest(0,ligne_cpt.MIN_SOLDEH);
 variationH :=valSoldeH-greatest(0,ligne_cpt.MIN_SOLDEH) ;
 ELSE
 soldeH     := ligne_cpt.MIN_SOLDEH;
 variationH :=valSoldeH-ligne_cpt.MIN_SOLDEH ;
 END IF;
 END IF;
 IF variationJ>0 OR variationH>0 THEN
 req       := 'INSERT into CAD_COMPTEUR (MATRICULE,CODE_COMPTEUR,DJOUR,TYPEMJ,date_maj,POT'||ligne_cpt.pot_variation||'_VALEURJ,POTV'||pot_Var||'_VALEURJ,POT'||ligne_cpt.pot_variation||'_VALEURH,POTV'||pot_Var||'_VALEURH)
 values ('''||matric||''','''||ligne_cpt.code_compteur||''','''||datejour||''',''N'',sysdate,:1,:2,:3, :4)';
 EXECUTE immediate req USING valprisJ+soldeJ+variationJ,
 variationJ,
 valprish+soldeH+variationH,
 variationH;
 END IF;
 END IF;
 END IF;
 END IF;
 END LOOP;
 CLOSE cur_cpt;
 -- si mode interactif (pas recalcul) on renvoie une erreur si le solde est insuffisant
 --    - mode recalcul : on passe en solde négatif ( que faire d'autre :1)
 --    - mode interactif : on renvoie une erreur pas assez de solde : erreur de type CAD-00001
 IF NOT limitazero AND forcage<>'true' THEN
 IF pasdecpt THEN
 ROLLBACK;
 raise_application_error(-20000, 'CAD00117#'||matric||'#'||datejour||'#'||rub);
 END IF;
 IF ( nbheures>0 OR nbjour>0) THEN
 ROLLBACK;
 raise_application_error(-20000, 'CAD00055#'||datejour||'#'||rub);
 END IF;
 END IF;
 IF NOT cptValide AND forcage<>'true' THEN
 ROLLBACK;
 raise_application_error(-20000, 'CAD00117#'||matric||'#'||datejour||'#'||rub);
 END IF;
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  := SQLERRM;
 CAD_ERREUR(idMat ,'CAD_UNIT_MAJ_VALEUR', idMat ||','|| matric ||','|| DATEJOUR ||','|| rub ||','|| unite ||','|| nbh ||','|| j_cal ||','|| j_ouvrable ||','|| j_oeuvr ||','|| j_ouvre ||','|| nbjour ||','|| nbheures ||','|| forcage ,err_code||'-'||err_msg);
 raise;
 END CAD_UNIT_MAJ_VALEUR_RUBJOUR;
 PROCEDURE         CAD_MAJ_VALEUR_RUBJOUR(
 idmat           IN NUMBER,
 pmatric         IN VARCHAR2,
 dateprec        IN VARCHAR2,
 datejour        IN VARCHAR2,
 nbh             IN NUMBER,
 j_cal           IN NUMBER,
 j_ouvrable      IN NUMBER,
 j_oeuvr         IN NUMBER,
 j_ouvre         IN NUMBER,
 rub             IN VARCHAR2,
 forcage         IN VARCHAR2)
 AS
 nbjour          NUMBER:=0;
 nbheures        NUMBER:=0;
 unite           VARCHAR(1);
 dtrecalc        VARCHAR(8);
 dtdebrecalc     VARCHAR(8);
 CURSOR cur_cpt
 IS
 SELECT code_compteur, MAX(djour) AS djour
 FROM cad_compteur cpt
 WHERE djour < datejour
 AND  matricule = pmatric
 AND code_compteur IN (SELECT DISTINCT code_compteur FROM cad_param_lien_rub_cpt lien /*WHERE rub_val_jour = rub*/)
 GROUP BY code_compteur;
 lig_cpt cur_cpt%rowtype;
 BEGIN
 nbjour := 0;
 nbheures := 0;
 unite := cad_unite(pmatric, datejour, rub);
 
 /*
 SELECT MAX(djour) INTO dtrecalc
 FROM (SELECT code_compteur, MIN(djour) AS djour
 FROM cad_compteur cpt
 WHERE djour > datejour
 AND matricule = matric
 AND code_compteur IN (SELECT code_compteur FROM cad_param_lien_rub_cpt WHERE rub_val_jour = rub)
 GROUP BY code_compteur
 );
 */
 
 BEGIN
 SELECT djour INTO dtrecalc
 FROM (SELECT TO_CHAR(ip.date_effet, 'yyyymmdd') AS djour
 FROM tge_incidents_paie     ip,
 dic_adm_contrat        dac,
 -- MONOP DIT 50818
 DIC_ADM_CONTRAT_SITU   s
 WHERE dac.matric = pmatric
 AND dac.NUMPAC=s.NUMPAC
 AND dac.PACMAT=s.PACMAT
 AND dac.NUMCNT=s.NUMCNT
 AND ip.date_effet > TO_DATE(datejour, 'yyyymmdd')
 AND ip.idpacmat = dac.idpacmat
 AND ip.paiezad = s.paiezad
 AND ip.date_effet BETWEEN dac.dsdcn AND NVL(dac.dsfcn, TO_DATE('20991231', 'yyyymmdd'))
 AND ip.code_ip IN (SELECT DISTINCT (rub_val_jour) FROM cad_param_lien_rub_cpt)
 ORDER BY ip.date_effet
 )
 WHERE ROWNUM = 1;
 EXCEPTION
 WHEN OTHERS THEN
 CAD_ERREUR(idmat ,'CAD_MAJ_VALEUR_RUBJOUR', idmat ||','|| pmatric || ',' || dateprec || ',' || datejour || ',' || nbh || ',' || j_cal || ',' || j_ouvrable || ',' || j_oeuvr || ',' || j_ouvre || ',' || rub || ',' || forcage, err_code || '-' || err_msg );
 dtrecalc := datejour;
 END;
 dtdebrecalc := datejour;
 
 /*
 IF dateprec IS NOT NULL THEN
 dtDebrecalc := DATEJOUR;
 ELSE
 SELECT MIN(djour) INTO dtDebrecalc
 FROM (SELECT code_compteur, max(DJOUR) as djour
 FROM cad_compteur cpt
 WHERE djour < datejour
 AND matricule = matric
 AND code_compteur IN (SELECT code_compteur FROM cad_param_lien_rub_cpt WHERE rub_val_jour = rub)
 GROUP BY CODE_COMPTEUR);
 END IF;
 */
 
 cad_avancement(idmat, '    Début rub : ' || datejour || ',' || rub);
 cad_unit_maj_valeur_rubjour(idmat, pmatric , datejour, rub ,unite , nbh , j_cal , j_ouvrable , j_oeuvr , j_ouvre ,nbjour,nbheures , forcage, TRUE, 'false');
 cad_avancement(idmat, '    Fin rub : ' || datejour);
 cad_avancement(idmat, '    Début calcul : ' || datejour);
 cad_avancement(idmat, '    Début propag : ' || datejour);
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt;
 EXIT
 WHEN cur_cpt%notfound;
 cad_unit_propagation(idmat, pmatric, lig_cpt.djour, datejour, lig_cpt.code_compteur, 'BASCULE');
 END LOOP;
 CLOSE cur_cpt;
 --cad_unit_propagation(idmat, matric, null, DATEJOUR, null, 'BASCULE');
 --cad_avancement(idmat, '    Fin propag : ' || datejour);
 --cad_calcul(matric, idmat, dtDebrecalc, dtrecalc);
 --cad_avancement(idmat, '    Fin calcul : ' || datejour);
 IF nbjour > 0 OR nbheures > 0 THEN
 cad_unit_maj_valeur_rubjour(idmat, pmatric , datejour,rub ,unite , nbh , j_cal , j_ouvrable , j_oeuvr , j_ouvre ,nbjour,nbheures , forcage, FALSE,'false');
 cad_avancement(idmat, '    Début propag : ' || datejour);
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt ;
 EXIT
 WHEN cur_cpt%notfound;
 cad_unit_propagation(idmat, pmatric, lig_cpt.djour, datejour, lig_cpt.code_compteur, 'BASCULE');
 END LOOP;
 CLOSE cur_cpt;
 --cad_unit_propagation(idmat, matric, null, DATEJOUR, null, 'BASCULE');
 cad_avancement(idmat,'    Fin propag : '|| datejour);
 --cad_calcul(matric,idmat, dtDebrecalc, dtrecalc);
 END IF;
 IF (nbjour > 0 OR nbheures > 0) AND forcage = 'true' THEN
 cad_unit_maj_valeur_rubjour(idmat, pmatric , datejour,rub ,unite , nbh , j_cal , j_ouvrable , j_oeuvr , j_ouvre ,nbjour,nbheures , forcage, FALSE, 'true');
 cad_avancement(idmat, '    Début propag : ' || datejour);
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt ;
 EXIT
 WHEN cur_cpt%notfound ;
 cad_unit_propagation(idmat, pmatric, lig_cpt.djour, datejour, lig_cpt.code_compteur, 'BASCULE');
 END LOOP;
 CLOSE cur_cpt;
 --cad_unit_propagation(idmat, matric, null, DATEJOUR, null, 'BASCULE');
 cad_avancement(idmat, '    Fin propag : ' || datejour);
 --cad_calcul(matric, idmat, dtDebrecalc, dtrecalc);
 END IF;
 cad_calcul(pmatric, idmat, dtdebrecalc, dtrecalc);
 END CAD_MAJ_VALEUR_RUBJOUR;
 PROCEDURE CAD_MISE_A_0_VAR(
 idMat IN NUMBER,
 dtdeb IN VARCHAR2 )
 AS
 CURSOR cur_cpt
 IS
 SELECT cpt.code_compteur,
 MAX(DJOUR) AS djour,
 cpt.matricule
 FROM CAD_COMPTEUR cpt,cad_calcul_en_cours_matric d,(SELECT DISTINCT code_compteur FROM CAD_PARAM_LIEN_RUB_CPT
 ) lien
 WHERE DJOUr    <dtdeb
 and d.id=idMat
 AND cpt.MATRICULE =d.matricule
 AND cpt.CODE_COMPTEUR = lien.code_compteur
 GROUP BY cpt.CODE_COMPTEUR,
 cpt.matricule;
 lig_cpt cur_cpt%ROWTYPE;
 dtrecalc VARCHAR(8);
 BEGIN
 CAD_AVANCEMENT(idMat,'Début Mise à 0');
 -- remise à 0 des pots de variation
 CAD_AVANCEMENT(idMat,'  Début Mise à 0 des pots');
 UPDATE CAD_COMPTEUR a
 SET potv1_valeurJ=0 ,
 potv1_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv1
 );
 UPDATE CAD_COMPTEUR a
 SET potv2_valeurJ=0 ,
 potv2_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv2
 );
 UPDATE CAD_COMPTEUR a
 SET potv3_valeurJ=0 ,
 potv3_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv3
 );
 UPDATE CAD_COMPTEUR a
 SET potv4_valeurJ=0 ,
 potv4_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv4
 );
 UPDATE CAD_COMPTEUR a
 SET potv5_valeurJ=0 ,
 potv5_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv5
 );
 UPDATE CAD_COMPTEUR a
 SET potv6_valeurJ=0 ,
 potv6_valeurH  =0,
 date_maj       =sysdate
 WHERE typemj    <>'I'
 AND DJOUr       >=dtdeb
 AND MATRICULE   IN
 (SELECT d.matricule FROM cad_calcul_en_cours_matric d WHERE d.id=idMat
 )
 AND code_compteur IN
 (SELECT DISTINCT b.CODE_COMPTEUR
 FROM cad_param_lien_rub_cpt b,
 cad_PARAM_calcul c
 WHERE B.code_compteur =c.code_compteur
 AND a.code_compteur   =b.code_compteur
 AND b.pot_variation   =c.potv6
 );
 CAD_AVANCEMENT(idMat,'  Fin Mise à 0 des pots');
 /*for i in 1..6
 loop*/
 -- But : Mettre à 0 seulement les pots de variations utilisées par les rubriques
 /* execute immediate 'merge into ( select * from CAD_COMPTEUR cpt where typemj<>''I'' and DJOUr >='||dtdeb||' AND MATRICULE in (select matricule from cad_calcul_en_cours_matric d where d.id='||idMat||' )) a using (select b.CODE_COMPTEUR from cad_param_lien_rub_cpt b, cad_PARAM_calcul c where  B.code_compteur=c.code_compteur
 and b.pot_variation=c.potv'||i||'  group by  b.CODE_COMPTEUR ) e on ( a.code_COMPTeur=e.code_compteur  )
 when matched then
 update set a.potv'||i||'_valeurJ=0 , a.potv'||i||'_valeurH=0,date_maj=sysdate' ;
 end loop;*/
 CAD_AVANCEMENT(idMat,'  Début propag');
 -- reprise des valeurs précédentes puis calcul
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt ;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 cad_unit_propagation(idmat,lig_cpt.matricule,lig_cpt.djour,dtdeb,lig_cpt.code_compteur,'BASCULE');
 END LOOP;
 CLOSE cur_cpt;
 CAD_AVANCEMENT(idMat,'  Fin propag');
 -- calcul jusqu'à première rubrique sinon fin ??
 /*  BEGIN
 SELECT djour
 INTO dtrecalc
 FROM
 (SELECT TO_CHAR(je.jour,'yyyymmdd') AS djour
 FROM gta_jou_contrat cnt,
 gta_jou_jouremploi je,
 gta_jou_valjour val
 WHERE je.employe_id IN
 (SELECT matricule FROM cad_calcul_en_cours_matric WHERE id=idmat
 )
 AND je.jour        >to_date(dtdeb,'yyyymmdd')
 AND je.id          =val.jour_emploi_id
 AND cnt.employe_id =je.employe_id
 AND je.code_contrat=cnt.code_contrat
 AND je.jour BETWEEN cnt.date_deb_valid AND NVL(cnt.date_fin_valid,to_date('20991231','yyyymmdd') )
 AND val.rub_val_jour IN
 (SELECT DISTINCT (RUB_VAL_JOUR) FROM CAD_PARAM_LIEN_RUB_CPT
 )
 ORDER BY je.jour
 )
 WHERE rownum=1;
 EXCEPTION
 WHEN OTHERS THEN
 dtrecalc:=NULL;
 END;*/
 CAD_AVANCEMENT(idMat,'  Début calcul suite mise à 0 ');
 CAD_CALCUL(NULL,idMat,dtdeb,NULL);
 CAD_AVANCEMENT(idMat,'  Fin calcul suite mise à 0 ');
 CAD_AVANCEMENT(idMat,'Fin Mise à 0');
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  := SQLERRM;
 CAD_ERREUR(idMat ,'CAD_MISE_A_0_VAR', idMat ||','|| dtdeb ,err_code||'-'||err_msg );
 raise;
 END CAD_MISE_A_0_VAR;
 PROCEDURE CAD_UNIT_BASCULE(
 IDMATRIC   IN NUMBER ,
 p_matric   IN VARCHAR2,
 BASCULE    IN VARCHAR2 ,
 DATEBAS    IN VARCHAR2 ,
 p_ordre    IN NUMBER,
 p_typebasc IN VARCHAR2)
 AS
 CURSOR cur_Bascule
 IS
 SELECT a.*,
 b.compteur_dest,
 b.compteur_ori,
 requetes,
 a.rowid,
 (select max(d.djour||'#'||d.typemj)  from CAD_COMPTEUR d where d.MATRICULE=a.MATRICULE and d.CODE_COMPTEUR= b.compteur_ori AND d.DJOUR||d.typemj<DATE_THEO_BASCULE||p_typebasc ) as djourFirst,
 -- (select max(typemj) from CAD_COMPTEUR d where d.code_compteur = b.compteur_ori and d.djour <(select max(e.djour)  from CAD_COMPTEUR e where e.MATRICULE=d.MATRICULE and e.CODE_COMPTEUR= d.code_compteur AND e.DJOUR||e.typemj<=DATEBAS||p_typebasc ) and d.matricule = a.matricule) as typemjFirst,
 (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=a.MATRICULE and d.CODE_COMPTEUR= b.compteur_ori AND d.DJOUR||d.typemj<=DATE_THEO_BASCULE||p_typebasc ) as djourAutre,
 p_typebasc as typemjautre
 
 FROM CAD_REGLES_PREVUES_REALISEES a,
 cad_param_regles_maj b,CAD_CALCUL_EN_COURS_MATRIC mat
 WHERE a.code_bascule =b.code_bascule
 AND a.code_bascule   =bascule
 AND DATE_THEO_BASCULE=DATEBAS
 AND a.type_bascule   =p_typebasc
 -- and requetes is not null
 AND (ordre           =p_ordre
 OR (ordre           IS NULL
 AND p_ordre         IS NULL))
 AND a.matricule= mat.matricule
 and mat.id     =idmatric
 AND mat.matricule=NVL(p_matric,mat.matricule);
 ligneBascule cur_Bascule%ROWTYPE;
 pos  NUMBER:=0;
 subs VARCHAR2(4000);
 req CLOB;
 requpdate clob;
 djourReq  VARCHAR2(1000);
 TYPE T_REC IS RECORD (
 idRow varchar2(100),
 dte  CAD_COMPTEUR.djour%TYPE,
 typemj  CAD_COMPTEUR.typemj%TYPE );
 
 TYPE Tab_Rowid
 IS
 TABLE OF T_REC index by pls_integer;
 T_Id Tab_Rowid;
 T_IdBasc Tab_Rowid;
 code_basc_prec VARCHAR(20);
 code_dest_prec VARCHAR(20);
 code_ori_prec  VARCHAR(20);
 mat_prec       VARCHAR(20);
 type_mj_req varchar(1);
 sizeTab number;
 withdjour boolean;
 reqwithoutDate clob;
 nbdjour number;
 TYPE TYP_compteur_dest is table of varchar2(1) index by varchar2(32) ;
 tab_compteur_dest TYP_compteur_dest;
 BEGIN
 OPEN cur_Bascule;
 LOOP
 FETCH cur_Bascule INTO ligneBascule;
 
 --req              :=ligneBascule.REQUETES;
 IF code_basc_prec                                                     IS NOT NULL AND (lignebascule.code_bascule <>code_basc_prec OR cur_Bascule%NOTFOUND) THEN
 reqwithoutDate:='';
 requpdate:='';
 nbdjour:=0;
 BEGIN
 WHILE LENGTH(req) >0
 LOOP
 IF instr(req,';')>0 THEN
 subs          :=SUBSTR(req,0,instr(req,';'));
 ELSE
 subs:=req;
 END IF;
 req      :=REPLACE(req,subs,'');
 req      :=REPLACE(req,subs,'');
 IF instr(subs,'_DJOUR_')>0 THEN
 nbdjour:=nbdjour+1;
 withdjour:=true;
 subs     :=REPLACE(subs,'_DJOUR_',':date'||trunc(dbms_random.value(1,100))||' and typemj=:type'||trunc(dbms_random.value(1,100)));
 subs     :=REPLACE(subs,';','');
 -- requpdate:='update CAD_COMPTEUR ca set '||subs||' where rowid=:1' ;
 if requpdate is not null then
 requpdate:=requpdate||',';
 end if;
 requpdate:=requpdate||subs;
 else
 withdjour:=false;
 subs     :=REPLACE(subs,';','');
 if reqwithoutDate is not null then
 reqwithoutDate:=reqwithoutDate||',';
 end if;
 reqwithoutDate:=reqwithoutDate||subs;
 end if;
 
 
 -- CAD_DEBUG(idmatric,requpdate);
 /* if withdjour then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 end if;*/
 END LOOP;
 if reqwithoutDate is not null then
 reqwithoutDate:='update CAD_COMPTEUR ca set '||reqwithoutDate||' where rowid=:1' ;
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate reqwithoutDate USING t_id(i).idrow;
 end if;
 
 if requpdate is not null then
 requpdate:='update CAD_COMPTEUR ca set '||requpdate||' where rowid=:1' ;
 if nbdjour=1 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=2 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=3 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=4 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=5 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=6 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=7 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=8 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=9 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=10 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=11 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 elsif nbdjour=12 then
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).dte,t_id(i).typemj,t_id(i).idrow;
 end if;
 end if;
 
 
 FORALL i IN T_IdBasc.first..T_IdBasc.last
 UPDATE CAD_REGLES_PREVUES_REALISEES a
 SET statut        ='OK',
 DERNIERE_BASCULE=SYSTIMESTAMP
 WHERE rowid       =T_IdBasc(i).idrow;
 EXCEPTION
 WHEN OTHERS THEN
 IF T_IdBasc IS NOT NULL THEN
 FORALL i IN T_IdBasc.first..T_IdBasc.last
 UPDATE CAD_REGLES_PREVUES_REALISEES a
 SET statut        ='KO',
 DERNIERE_BASCULE=SYSTIMESTAMP
 WHERE rowid       =T_IdBasc(i).idrow;
 END IF;
 raise;
 END;
 END IF;
 EXIT
 WHEN cur_Bascule%NOTFOUND ;
 code_dest_prec := lignebascule.compteur_dest;
 code_ori_prec  := lignebascule.compteur_ori;
 mat_prec       := lignebascule.matricule ;
 IF p_typebasc                                                        ='B' THEN
 IF not tab_compteur_dest.exists(mat_prec||'#'||code_ori_prec) THEN
 -- djourReq                                                        :=' (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=ca.MATRICULE and d.CODE_COMPTEUR=ori.code_compteur AND d.DJOUR<'''||datebas||'''  )  and typemj=(select max(typemj) from CAD_COMPTEUR d where d.code_compteur = ori.code_compteur and d.djour = ori.djour and d.matricule = ori.matricule) ';
 djourReq :=substr(lignebascule.djourFirst,1,8);
 type_mj_req:=substr(lignebascule.djourFirst,10,1);
 --listecompteur_dest                                              :=listecompteur_dest||';'||mat_prec||'#'||code_dest_prec||';';
 tab_compteur_dest(mat_prec||'#'||code_dest_prec):='Y';
 ELSE
 --DBMS_OUTPUT.PUT_LINE (listecompteur_dest);
 --FIXME utiliser la procédure trace_dbms_output()
 djourReq :=lignebascule.djourAUTRE;
 type_mj_req:=lignebascule.typemjAUTRE ;
 -- djourReq :=' (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=ca.MATRICULE and d.CODE_COMPTEUR=ori.code_compteur AND d.DJOUR||d.typemj<='''||datebas||'B''  ) and typemj=''B'' ';
 END IF;
 ELSE
 IF not tab_compteur_dest.exists(mat_prec||'#'||code_ori_prec) THEN
 -- djourReq                                                        :=' (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=ca.MATRICULE and d.CODE_COMPTEUR=ori.code_compteur AND d.DJOUR||d.typemj<'''||datebas||'S''  )  and typemj=(select max(typemj) from CAD_COMPTEUR d where d.code_compteur = ori.code_compteur and d.djour = ori.djour and d.matricule = ori.matricule and (d.DJOUR<'''||datebas||''' or ( d.DJOUR='''||datebas||''' and typemj<>''S''))) ';
 djourReq :=substr(lignebascule.djourFirst,1,8);
 type_mj_req:=substr(lignebascule.djourFirst,10,1);
 -- listecompteur_dest                                              :=listecompteur_dest||';'||mat_prec||'#'||code_dest_prec||';';
 tab_compteur_dest(mat_prec||'#'||code_dest_prec):='Y';
 ELSE
 --djourReq :=' (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=ca.MATRICULE and d.CODE_COMPTEUR=ori.code_compteur AND d.DJOUR||d.typemj<='''||datebas||'S''  )  and typemj=''S'' ';
 djourReq :=lignebascule.djourAUTRE;
 type_mj_req:=lignebascule.typemjAUTRE ;
 END IF;
 END IF;
 
 
 DECLARE
 CURSOR cur_cpt
 IS
 SELECT cad_compteur.*,
 rowid
 FROM cad_compteur
 WHERE TYPEMJ     =p_typebasc
 AND CODE_COMPTEUR=ligneBascule.compteur_dest
 AND DJOUR        =DATEBAS
 AND MATRICULE    =ligneBascule.matricule;
 lig_cpt cur_cpt%rowtype;
 BEGIN
 IF code_basc_prec IS NULL OR lignebascule.code_bascule <>code_basc_prec THEN
 t_id.delete;
 T_IdBasc.delete;
 req             :=ligneBascule.REQUETES;
 if req is null then
 req:='POT1_VALEURJ=0,POT1_VALEURH=0 ;POT2_VALEURJ=0,POT2_VALEURH=0 ;POT3_VALEURJ=0,POT3_VALEURH=0 ;POT4_VALEURJ=0,POT4_VALEURH=0 ;POT5_VALEURJ=0,POT5_VALEURH=0 ;POT6_VALEURJ=0,POT6_VALEURH=0 ;POT7_VALEURJ=0,POT7_VALEURH=0 ;POT8_VALEURJ=0,POT8_VALEURH=0 ;POT9_VALEURJ=0,POT9_VALEURH=0 ;POT10_VALEURJ=0,POT10_VALEURH=0 ;POT11_VALEURJ=0,POT11_VALEURH=0 ;POT12_VALEURJ=0,POT12_VALEURH=0 ;';
 end if;
 END IF;
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 -- select max(d.djour)  into djourReq from CAD_COMPTEUR d where d.MATRICULE=lig_cpt.MATRICULE and d.CODE_COMPTEUR=lignebascule.COMPTEUR_ORI AND DJOUR<DATEBAS;
 sizeTab:=t_id.count+1;
 t_id(sizeTab).idrow:=lig_cpt.rowid;
 t_id(sizeTab).dte:=djourReq;
 t_id(sizeTab).typemj:=type_mj_req;
 sizeTab:=T_IdBasc.count+1;
 T_IdBasc(sizeTab).idrow:=lignebascule.rowid;
 
 END LOOP;
 CLOSE cur_cpt;
 code_basc_prec := lignebascule.code_bascule;
 
 END;
 END LOOP;
 CLOSE cur_Bascule;
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  :=SQLERRM;
 CAD_ERREUR(IDMATRIC ,'CAD_UNIT_BASCULE', IDMATRIC||','|| p_matric||','|| BASCULE ||','|| DATEBAS ||','|| p_ordre ||','|| p_typebasc ,err_code||'-'||err_msg);
 raise;
 END CAD_UNIT_BASCULE;
 PROCEDURE CAD_UNIT_CALCUL(
 IDMATRIC   IN NUMBER ,
 p_MATRIC   IN VARCHAR2 ,
 DATEDEB    IN VARCHAR2 ,
 DATEFIN    IN VARCHAR2,
 AvecBacule IN VARCHAR2)
 AS
 CURSOR tabRequetes
 IS
 SELECT cptcal.CODE_COMPTEUR
 FROM CAD_CALCUL_EN_COURS_CPT cptcal
 WHERE cptcal.id =IDMATRIC
 /* AND cptcal.code_compteur IN
 (SELECT code_compteur
 FROM cad_compteur cpt,
 CAD_CALCUL_EN_COURS_MATRIC mat
 WHERE cpt.matricule=mat.matricule
 AND mat.id         =cptcal.id
 AND mat.matricule  =NVL(p_matric,mat.matricule)
 AND djour BETWEEN datedeb AND NVL(datefin,'20991231')
 ) */
 ;
 lignesRequetes tabRequetes%ROWTYPE;
 pos              NUMBER:=0;
 subs             VARCHAR2(1000);
 req              VARCHAR2(1000);
 requpdate        VARCHAR2(1000);
 cptPrec          VARCHAR2(20);
 reqpropagation   VARCHAR(4000);
 numpot           VARCHAR(2);
 listPotVariation VARCHAR(100):='';
 listPotAPropage  VARCHAR(100);
 un_index         INT;
 nbcounter        NUMBER;
 nbcounterFin     NUMBER;
 tdeb             TIMESTAMP;
 tfin             TIMESTAMP;
 debcalc          NUMBER;
 fincalc          NUMBER;
 totalcalc        NUMBER:=0;
 BEGIN
 OPEN tabRequetes;
 LOOP
 FETCH tabRequetes INTO lignesRequetes;
 EXIT
 WHEN tabRequetes%NOTFOUND ;
 --propagation
 IF cptprec IS NULL OR cptprec <>lignesRequetes.CODE_COMPTEUR THEN
 CAD_AVANCEMENT(idmatric,'Propag var du cpt '||lignesRequetes.CODE_COMPTEUR||' du '||datedeb||' au '|| datefin);
 CAD_UNIT_PROPAGATION(idmatric,p_matric,datedeb,datefin,lignesRequetes.CODE_COMPTEUR,AvecBacule);
 cptprec:=lignesRequetes.CODE_COMPTEUR;
 END IF;
 END LOOP;
 CLOSE tabRequetes;
 END CAD_UNIT_CALCUL;
 PROCEDURE CAD_CALCUL_MATRIC(
 numSeq  IN NUMBER ,
 matric  IN VARCHAR2,
 DATEDEB IN VARCHAR2 ,
 DATEFIN IN VARCHAR2 )
 AS
 idCpt        NUMBER:=numSeq ;
 dateprec     VARCHAR2(8);
 typeBascPrec VARCHAR2(1);
 typeBasc     VARCHAR2(1);
 DATEBASC     VARCHAR2(8);
 CURSOR tabBasculesDeLaPop
 IS
 SELECT DISTINCT bpr.code_bascule,
 '' AS MATRICULE,
 bpr.DATE_THEO_BASCULE,
 ''   AS STATUT,
 NULL AS derniere_bascule,
 bpr.ordre,
 NULL AS MAJ_CONTRAT,
 bpr.type_bascule
 FROM CAD_REGLES_PREVUES_REALISEES bpr ,
 CAD_CALCUL_EN_COURS_MATRIC mat
 WHERE bpr.matricule=mat.matricule
 AND mat.id         =numseq
 AND bpr.date_theo_bascule BETWEEN DATEDEB AND NVL(datefin,'20991231')
 AND bpr.matricule=NVL(matric,bpr.matricule)
 ORDER BY bpr.DATE_THEO_BASCULE,
 bpr.type_bascule,
 bpr.ORDRE;
 ligneBasculesDeLaPop CAD_REGLES_PREVUES_REALISEES%ROWTYPE;
 listebascules CLOB:='';
 deb       NUMBER;
 fin       NUMBER;
 total     NUMBER:=0;
 debcalc   NUMBER;
 fincalc   NUMBER;
 totalcalc NUMBER:=0;
 listecompteur_dest CLOB:=';';
 TYPE TYP_compteur_dest is table of varchar2(1) index by varchar2(32) ;
 tab_compteur_dest TYP_compteur_dest;
 BEGIN
 CAD_AVANCEMENT(numseq,'Depart calcul');
 --CAD_DEBUG(numSeq,'');
 -- insert into CAD_CALCUL_EN_COURS_CPT (ID,CODE_COMPTEUR) select distinct idCpt as ID,COMPTEUR_DEST as CODE_COMPTEUR  from CAD_REGLES_PREVUES_REALISEES bpr , CAD_PARAM_REGLES_MAJ bdef , CAD_CALCUL_EN_COURS_MATRIC mat where bpr.matricule=mat.matricule and bpr.CODE_BASCULE=bdef.code_bascule;
 /*if numseq is null then
 DELETE
 FROM CAD_CALCUL_EN_COURS_CPT
 WHERE id=numseq;
 end if;*/
 OPEN tabBasculesDeLaPop;
 dateprec    :=datedeb;
 typebascprec:='B';
 LOOP
 FETCH tabBasculesDeLaPop INTO ligneBasculesDeLaPop;
 IF tabBasculesDeLaPop%NOTFOUND THEN
 DATEBASC:=NULL;
 typebasc:=NULL;
 ELSE
 DATEBASC:=ligneBasculesDeLaPop.DATE_THEO_BASCULE;
 typebasc:=ligneBasculesDeLaPop.type_bascule;
 END IF;
 --DBMS_OUTPUT.PUT_LINE('-BASCULE-'||' - '||NVL(DATEBASC,'*')||TO_CHAR(sysdate,'HH24:MI:SS'));
 --FIXME utiliser la procédure trace_dbms_output()
 -- si la date précédente est la même que la date de la bascule : pas de recalcul
 IF (dateprec        <>ligneBasculesDeLaPop.DATE_THEO_BASCULE OR DATEBASC IS NULL) OR (typebasc<> typebascprec OR typebasc IS NULL) THEN
 listecompteur_dest:=';';
 tab_compteur_dest.delete;
 IF listebascules  IS NOT NULL AND DATEBASC IS NOT NULL THEN
 --  CAD_UNIT_Faussebascule(idCpt,dateprec,listebascules);
 listebascules:='';
 -- On a au moins une bascule donc on calcule jusqu'au jour précédant la bascule
 -- et propagation jusqu'à la situation suivante après la bascule
 CAD_UNIT_CALCUL(idCpt,matric,DATEPREC, DATEBASC,'BASCULE');
 --  CAD_UNIT_PROPAGATION (idCpt,matric,DATEPREC, DATEBASC,null,'BASCULE');
 
 ELSE
 IF DATEBASC IS NOT NULL THEN
 -- première bascule : calcul jusqu'au jour précédant la bascule
 -- et propagation jusqu'à la situation suivante après la bascule
 CAD_UNIT_CALCUL(idCpt,matric,DATEPREC,DATEBASC,'BASCULE');
 -- CAD_UNIT_PROPAGATION (idCpt,matric,DATEPREC, DATEBASC,null,'BASCULE');
 ELSE
 -- pas de bascule, on calcule jusqu'à la fin
 CAD_UNIT_CALCUL(idCpt,matric,DATEPREC, datefin,'');
 --  CAD_UNIT_PROPAGATION (idCpt,matric,DATEPREC, DATEBASC,null,'BASCULE');
 END IF;
 END IF;
 END IF;
 EXIT
 WHEN tabBasculesDeLaPop%NOTFOUND ;
 --DBMS_OUTPUT.PUT_LINE('-CAD_CALCUL_MATRIC-CAD_UNIT_4-'||TO_CHAR(sysdate,'HH24:MI:SS'));
 --FIXME utiliser la procédure trace_dbms_output()
 CAD_AVANCEMENT(numseq,'Bascule '||ligneBasculesDeLaPop.CODE_BASCULE||' du '||DATEBASC);
 CAD_UNIT_BASCULE(numSeq,matric,ligneBasculesDeLaPop.CODE_BASCULE, DATEBASC,ligneBasculesDeLaPop.ordre,typebasc);
 IF dateprec         =DATEBASC THEN
 IF listebascules IS NULL OR listebascules='' THEN
 listebascules  :=''''||ligneBasculesDeLaPop.CODE_BASCULE||'''';
 ELSE
 IF (instr(listebascules,ligneBasculesDeLaPop.CODE_BASCULE)=0) THEN
 listebascules                                          := listebascules||','''||ligneBasculesDeLaPop.CODE_BASCULE||'''';
 END IF;
 END IF;
 ELSE
 IF listebascules IS NULL OR listebascules='' THEN
 listebascules  :=''''||ligneBasculesDeLaPop.CODE_BASCULE||'''';
 END IF;
 END IF;
 dateprec    := DATEBASC;
 typebascprec:=typebasc;
 END LOOP;
 CLOSE tabBasculesDeLaPop;
 END CAD_CALCUL_MATRIC;
 PROCEDURE CAD_CALCUL(
 matric  IN VARCHAR2 ,
 idrub   IN NUMBER ,
 DATEDEB IN VARCHAR2 ,
 DATEFIN IN VARCHAR2 )
 AS
 id_calc NUMBER;
 deb     NUMBER;
 fin     NUMBER;
 total   NUMBER:=0;
 BEGIN
 deb:= DBMS_UTILITY.get_time;
 BEGIN
 SELECT is_debug INTO valdebug FROM CAD_IS_DEBUG;
 EXCEPTION
 WHEN OTHERS THEN
 valdebug:='N';
 END;
 -- TODO les delete sera fait plus tard par purge
 IF valdebug='O' THEN
 DELETE FROM CAD_TRACE_REQ WHERE id=idrub;
 END IF;
 --delete from CAD_CALCUL_EN_COURS_MATRIC  where id=idrub;
 IF matric IS NOT NULL AND idrub IS NULL THEN
 SELECT CAD_SEQ_CALCUL.nextVAL INTO id_calc FROM dual;
 --ne fonctionne qu'avec un matricule
 INSERT
 INTO CAD_CALCUL_EN_COURS_MATRIC
 (
 id,
 matricule
 )
 VALUES
 (
 id_calc,
 matric
 );
 --CAD_DEBUG(id_calc,'');
 CAD_AVANCEMENT(id_calc,'Bascules '||datedeb);
 CAD_INIT_BASCULES( id_calc , matric , DATEDEB, DATEFIN) ;
 CAD_AVANCEMENT(id_calc,'Fin Bascules '||datedeb);
 CAD_AVANCEMENT(id_calc,'Début insert calcul cpt '||datedeb);
 INSERT
 INTO CAD_CALCUL_EN_COURS_CPT
 (
 ID,
 CODE_COMPTEUR
 )
 (SELECT DISTINCT id_calc AS ID,
 CODE_COMPTEUR        AS CODE_COMPTEUR
 FROM CAD_COMPTEUR cpt,
 CAD_CALCUL_EN_COURS_MATRIC mat
 WHERE cpt.matricule=mat.matricule
 AND mat.id         =id_calc
 ) ;
 CAD_AVANCEMENT(id_calc,'Fin insert calcul cpt '||datedeb);
 END IF;
 IF idrub IS NOT NULL THEN
 id_calc:=idrub;
 --     insert into CAD_CALCUL_EN_COURS_MATRIC(id,matricule) select distinct id,matricule from CAD_CALCUL_EN_COURS_RUB  where id=idrub and matricule not in (select distinct matricule from CAD_CALCUL_EN_COURS_MATRIC where id=idrub);
 END IF;
 fin  := DBMS_UTILITY.get_time;
 total:=total+(fin-deb);
 --DBMS_OUTPUT.put_line('Avant CAD_CALCUL_MATRIC : '||total);
 --FIXME utiliser la procédure trace_dbms_output()
 CAD_CALCUL_MATRIC(id_calc,matric,DATEDEB,DATEFIN);
 EXCEPTION
 WHEN OTHERS THEN
 raise_application_error(-20000, 'Problème(s) durant le recalcul des compteurs');
 END CAD_CALCUL;
 PROCEDURE CAD_CONTROLE_SOLDE
 (
 idrub  IN VARCHAR2,
 matric IN VARCHAR2
 )
 AS
 dtdeb VARCHAR2
 (
 8
 )
 ;
 dtfin     VARCHAR2(8);
 solde     NUMBER;
 unite     NUMBER;
 nbBas     NUMBER;
 variation NUMBER;
 TYPE TYP_RUB
 IS
 TABLE OF cad_calcul_en_cours_rub.rub_val_jour%type ;
 Tabrub TYP_RUB;
 BEGIN
 -- cas sans bascule
 SELECT MIN(date_jour)
 INTO dtdeb
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id     =idrub
 AND matricule=matric;
 SELECT MAX(date_jour)
 INTO dtfin
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id     =idrub
 AND matricule=matric;
 SELECT COUNT(*)
 INTO nbBas
 FROM CAD_MATRIC_DATEVALID
 WHERE DATE_FIN_PER BETWEEN dtdeb AND dtfin
 AND matricule=matric;
 IF nbBas     =0 THEN
 SELECT rub_val_jour BULK COLLECT
 INTO Tabrub
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id     = idrub
 AND matricule=matric
 AND date_jour=dtdeb
 ORDER BY rub_val_jour;
 FOR i IN Tabrub.first..Tabrub.last
 LOOP
 solde   :=CAD_SOLDE(MATRIC,DTDEB,Tabrub(i));
 unite   := cad_unite(matric,DTDEB,Tabrub(i));
 IF unite = 'H' THEN
 SELECT SUM(heure)
 INTO variation
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id        =idrub
 AND matric      =matricule
 AND rub_val_jour=tabrub(i);
 elsif unite       = 'C' THEN
 SELECT SUM(calend)
 INTO variation
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id        =idrub
 AND matric      =matricule
 AND rub_val_jour=tabrub(i);
 elsif unite       = 'U' THEN
 SELECT SUM(ouvre)
 INTO variation
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id        =idrub
 AND matric      =matricule
 AND rub_val_jour=tabrub(i);
 elsif unite       = 'O' THEN
 SELECT SUM(oeuvre)
 INTO variation
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id        =idrub
 AND matric      =matricule
 AND rub_val_jour=tabrub(i);
 elsif unite       = 'S' THEN
 SELECT SUM(ouvrable)
 INTO variation
 FROM CAD_CALCUL_EN_COURS_RUB
 WHERE id        =idrub
 AND matric      =matricule
 AND rub_val_jour=tabrub(i);
 END IF;
 solde  :=solde - variation;
 IF solde<0 THEN
 raise_application_error(-20000, 'CAD_0001');
 END IF ;
 END LOOP ;
 ELSE
 CAD_MAJ_VALEUR_LISTE_RUBJOUR(idrub,dtdeb,NULL,'false','true');
 ROLLBACK;
 END IF;
 END CAD_CONTROLE_SOLDE;
 PROCEDURE CAD_IMPORT(
 p_numseq      IN NUMBER,
 nom_Fichier   IN VARCHAR2,
 avec_Rollback IN VARCHAR2)
 AS
 CURSOR tab
 IS
 SELECT * FROM CAD_TABLE_IMPORT ORDER BY donnees;
 ligne CAD_TABLE_IMPORT%ROWTYPE;
 cpt CAD_COMPTEUR%ROWTYPE;
 TYPE tableau
 IS
 TABLE OF VARCHAR(50);
 tabDonnees tableau :=tableau();
 pos          NUMBER;
 indice       NUMBER;
 subs         VARCHAR(100);
 datemin      VARCHAR(10);
 requete      VARCHAR(4000);
 updatePots   VARCHAR(1000);
 insertCol    VARCHAR(1000);
 insertValue  VARCHAR(1000);
 ligneEnCours VARCHAR(1000);
 numligne     NUMBER;
 numseq       NUMBER;
 newnumseq    number;
 TYPE liste_pot_type
 IS
 TABLE OF NUMBER INDEX BY binary_integer ;
 TYPE strut_pot_type
 IS
 TABLE OF liste_pot_type INDEX BY VARCHAR2(5);
 map_strut_pot strut_pot_type;
 BEGIN
 IF p_numseq IS NULL THEN
 SELECT CAD_SEQ_CALCUL.nextval INTO numseq FROM dual;
 ELSE
 numseq:=p_numseq;
 END IF;
 numligne:=0;
 OPEN tab;
 LOOP
 FETCH tab
 INTO ligne;
 EXIT
 WHEN tab%NOTFOUND ;
 numligne    :=numligne+1;
 ligneEnCours:=ligne.donnees;
 -- Création du tableau de donnees
 indice :=0;
 -- Suppression des espaces
 ligne.donnees:=REPLACE(ligne.donnees,' ','');
 BEGIN
 WHILE LENGTH(ligne.donnees) >0
 LOOP
 indice               :=indice+1;
 pos                  :=instr(ligne.donnees,';');
 IF (pos               >0) THEN
 subs               :=SUBSTR(ligne.donnees,0,pos);
 ligne.donnees      :=SUBSTR(ligne.donnees,LENGTH(subs)+1);
 subs               :=REPLACE(subs,';','');
 IF tabDonnees.last IS NULL OR tabDonnees.last<=indice THEN
 tabDonnees.extend;
 END IF;
 tabDonnees(indice):=subs;
 ELSE
 IF tabDonnees.last IS NULL OR tabDonnees.last<=indice THEN
 tabDonnees.extend;
 END IF;
 tabDonnees(indice):=ligne.donnees;
 ligne.donnees     :='';
 END IF;
 END LOOP;
 IF tabdonnees(1)='1' THEN
 IF datemin   IS NULL OR datemin>tabDonnees(4) THEN
 datemin    :=tabDonnees(4);
 END IF;
 -- si rollback on copie les compteur dans la table temporaire
 IF avec_rollback='true' THEN
 merge INTO CAD_COMPTEUR_FOR_ROLL a USING
 (SELECT *
 FROM CAD_COMPTEUR
 WHERE MATRICULE =tabDonnees(2)
 AND DJOUR      >=tabDonnees(4)
 ) b ON (a.id    =numseq AND a.matricule=b.matricule AND a.code_compteur=b.code_compteur AND a.djour=b.djour AND (a.typemj=b.typemj OR (a.typeMj='M' AND b.typeMj='N') OR (b.typeMj='M' AND a.typeMj='N') ))
 WHEN NOT matched THEN
 INSERT
 (
 a.ID,
 a.MATRICULE,
 a.CODE_COMPTEUR,
 a.DJOUR,
 a.TYPEMJ,
 a.DATE_MAJ,
 a.POT1_VALEURJ,
 a.POT1_VALEURH,
 a.POT1_FJ,
 a.POT1_FH,
 a.POT2_VALEURJ,
 a.POT2_VALEURH,
 a.POT2_FJ,
 a.POT2_FH,
 a.POT3_VALEURJ,
 a.POT3_VALEURH ,
 a.POT3_FJ,
 a.POT3_FH,
 a.POT4_VALEURJ,
 a.POT4_VALEURH,
 a.POT4_FJ,
 a.POT4_FH,
 a.POT5_VALEURJ,
 a.POT5_VALEURH,
 a.POT5_FJ,
 a.POT5_FH,
 a.POT6_VALEURJ,
 a.POT6_VALEURH,
 a.POT6_FJ,
 a.POT6_FH,
 a.POT7_VALEURJ,
 a.POT7_VALEURH,
 a.POT7_FJ ,
 a.POT7_FH,
 a.POT8_VALEURJ,
 a.POT8_VALEURH,
 a.POT8_FJ,
 a.POT8_FH,
 a.POT9_VALEURJ,
 a.POT9_VALEURH,
 a.POT9_FJ,
 a.POT9_FH,
 a.POT10_VALEURJ,
 a.POT10_VALEURH,
 a.POT10_FJ,
 a.POT10_FH,
 a.POT11_VALEURJ,
 a.POT11_VALEURH,
 a.POT11_FJ ,
 a.POT11_FH,
 a.POT12_VALEURJ,
 a.POT12_VALEURH,
 a.POT12_FJ,
 a.POT12_FH,
 a.POTV1_VALEURJ,
 a.POTV1_VALEURH,
 a.POTV2_VALEURJ,
 a.POTV2_VALEURH,
 a.POTV3_VALEURJ,
 a.POTV3_VALEURH,
 a.POTV4_VALEURJ,
 a.POTV4_VALEURH,
 a.POTV5_VALEURJ ,
 a.POTV5_VALEURH,
 a.POTV6_VALEURJ,
 a.POTV6_VALEURH
 )
 VALUES
 (
 numseq,
 b.MATRICULE,
 b.CODE_COMPTEUR,
 b.DJOUR,
 b.TYPEMJ,
 b.DATE_MAJ,
 b.POT1_VALEURJ,
 b.POT1_VALEURH,
 b.POT1_FJ,
 b.POT1_FH,
 b.POT2_VALEURJ,
 b.POT2_VALEURH,
 b.POT2_FJ,
 b.POT2_FH,
 b.POT3_VALEURJ,
 b.POT3_VALEURH ,
 b.POT3_FJ,
 b.POT3_FH,
 b.POT4_VALEURJ,
 b.POT4_VALEURH,
 b.POT4_FJ,
 b.POT4_FH,
 b.POT5_VALEURJ,
 b.POT5_VALEURH,
 b.POT5_FJ,
 b.POT5_FH,
 b.POT6_VALEURJ,
 b.POT6_VALEURH,
 b.POT6_FJ,
 b.POT6_FH,
 b.POT7_VALEURJ,
 b.POT7_VALEURH,
 b.POT7_FJ ,
 b.POT7_FH,
 b.POT8_VALEURJ,
 b.POT8_VALEURH,
 b.POT8_FJ,
 b.POT8_FH,
 b.POT9_VALEURJ,
 b.POT9_VALEURH,
 b.POT9_FJ,
 b.POT9_FH,
 b.POT10_VALEURJ,
 b.POT10_VALEURH,
 b.POT10_FJ,
 b.POT10_FH,
 b.POT11_VALEURJ,
 b.POT11_VALEURH,
 b.POT11_FJ ,
 b.POT11_FH,
 b.POT12_VALEURJ,
 b.POT12_VALEURH,
 b.POT12_FJ,
 b.POT12_FH,
 b.POTV1_VALEURJ,
 b.POTV1_VALEURH,
 b.POTV2_VALEURJ,
 b.POTV2_VALEURH,
 b.POTV3_VALEURJ,
 b.POTV3_VALEURH,
 b.POTV4_VALEURJ,
 b.POTV4_VALEURH,
 b.POTV5_VALEURJ ,
 b.POTV5_VALEURH,
 b.POTV6_VALEURJ,
 b.POTV6_VALEURH
 );
 END IF;
 merge INTO CAD_COMPTEUR_MIN_FOR_ROLL a USING
 (SELECT numseq    AS id,
 tabDonnees(2) AS matricule,
 tabDonnees(4) AS dte
 FROM dual
 )
 b ON (a.id=b.id AND a.matricule=b.matricule)
 WHEN matched THEN
 UPDATE SET a.date_min=b.dte WHERE b.dte<a.date_min WHEN NOT matched THEN
 INSERT
 (a.id,a.matricule,a.date_min
 ) VALUES
 (b.id,b.matricule,b.dte
 );
 
 -- passage de tous les M en N
 UPDATE CAD_COMPTEUR
 SET typemj       ='N'
 WHERE typemj     ='M'
 AND code_compteur=tabDonnees(3)
 AND MATRICULE    =tabDonnees(2)
 AND DJOUR       >=tabDonnees(4);
 -- mise du matricule dans les matricules à retraiter
 merge INTO CAD_CALCUL_EN_COURS_MATRIC a USING
 (SELECT tabDonnees(2) AS matricule, numseq AS id FROM dual
 ) b ON (a.id=b.id AND a.matricule=b.matricule )
 WHEN NOT MATCHED THEN
 INSERT
 ( a.ID, a.MATRICULE
 ) VALUES
 ( numseq, b.matricule
 );
 ELSIF tabdonnees(1)='2' THEN
 IF(NOT map_strut_pot.EXISTS(tabdonnees(3)) ) THEN
 DECLARE
 CURSOR tabpot
 IS
 SELECT *
 FROM CAD_PARAM_STRUCT_POT
 WHERE maj_batch  ='O'
 AND code_compteur=tabdonnees(3)
 ORDER BY num_pot;
 ligne_struct CAD_PARAM_STRUCT_POT%ROWTYPE;
 BEGIN
 OPEN tabpot;
 LOOP
 FETCH tabpot INTO ligne_struct;
 EXIT
 WHEN tabpot%NOTFOUND ;
 map_strut_pot(tabdonnees(3))(ligne_struct.num_pot):=ligne_struct.num_pot;
 END LOOP;
 CLOSE tabpot;
 END;
 END IF;
 updatePots :='';
 insertcol  :='';
 insertvalue:='';
 FOR i IN 1.. map_strut_pot(tabdonnees(3)).last
 LOOP
 updatePots :=updatePots|| ' , a.POT'||i||'_VALEURJ='|| tabdonnees(7+(i-1)*4) ||' , a.POT'||i||'_VALEURH='|| tabdonnees(9+(i-1)*4);
 insertcol  :=insertcol||' , a.POT'||i||'_VALEURJ,a.POT'||i||'_VALEURH';
 insertvalue:=insertvalue||' ,'||tabdonnees(7+(i-1)*4)||' , '||tabdonnees(9+(i-1)*4);
 END LOOP;
 requete:='merge into (select * from cad_compteur where typeMJ in (''M'',''N'') and matricule='''||tabdonnees(2)||''' and code_compteur='''||tabdonnees(3)||''' and djour= '''||tabdonnees(4)||''' ) a using (select '''||tabdonnees(2)||''' as matricule, '''||tabdonnees(3)||''' as code_compteur, '''||tabdonnees(4)||''' as DJOUR from dual ) b on ( a.code_compteur=b.code_compteur and a.matricule =b.matricule and a.djour=b.djour  )';
 requete:=requete||' when matched then update set a.typeMJ=''M'' , a.date_maj=sysdate ';
 requete:=requete||updatePots;
 requete:=requete||' when not matched then insert (a.matricule,a.code_compteur,a.djour,a.typemj,a.date_maj '||insertcol||') ' ;
 requete:=requete||' values (b.matricule,b.code_compteur,b.djour,''M'',sysdate '||insertvalue||')';
 EXECUTE_IMMEDIATE_STRING (requete,0);
 END IF;
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  := SQLERRM;
 CAD_ERREUR(numseq ,'IMP'||numligne,numseq||','|| nom_Fichier||','||avec_Rollback||','||tabdonnees(1)||','||tabdonnees(2)||','||tabdonnees(3)||','||tabdonnees(4) ,err_code||'-'||err_msg);
 INSERT
 INTO cad_table_import_err VALUES
 (
 nom_Fichier,
 'Erreur import de la ligne : '
 ||ligneEnCours
 );
 END;
 IF numligne mod 1000 =0 THEN
 COMMIT;
 END IF;
 END LOOP;
 CLOSE tab;
 -- lance calcul
 -- CAD_CALCUL(NULL,numseq, datemin,NULL);
 
 INSERT
 INTO CAD_CALCUL_EN_COURS_IMPORT
 (SELECT * FROM cad_calcul_en_cours_matric WHERE id=numseq
 );
 COMMIT;
 for dte in (select distinct substr(date_min,1,6) as mois from CAD_COMPTEUR_MIN_FOR_ROLL where id=numseq )
 loop
 
 select cad_seq_calcul.nextval into newnumseq from dual;
 INSERT
 INTO CAD_CALCUL_EN_COURS_MATRIC
 (SELECT newnumseq,matricule FROM CAD_COMPTEUR_MIN_FOR_ROLL WHERE id=numseq and substr(date_min,1,6)=dte.mois
 );
 CAD_MAJ_VALEUR_LISTE_RUBJOUR (newnumseq, dte.mois||'01', NULL,'true', 'true');
 COMMIT;
 end loop;
 
 -- CAD_MAJ_VALEUR_LISTE_RUBJOUR (numseq, datemin, NULL,'true', 'true');
 
 /* INSERT
 INTO CAD_CALCUL_EN_COURS_MATRIC
 (SELECT * FROM cad_calcul_en_cours_IMPORT WHERE id=numseq
 );*/
 --  COMMIT;
 DELETE FROM CAD_TABLE_IMPORT;
 DELETE FROM cad_calcul_en_cours_IMPORT WHERE id=numseq;
 COMMIT;
 -- lance calcul
 --  raise_application_error(-20000, 'Problème(s) durant l''import');
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  := SQLERRM;
 CAD_ERREUR(numseq ,'CAD_IMPORT'||': FIN',numseq||','|| nom_Fichier||','||avec_Rollback ,err_code||'-'||err_msg);
 raise;
 END CAD_IMPORT;
 FUNCTION              CAD_MAJ_RUB(
 dtdeb               IN VARCHAR2,
 dtfin               IN VARCHAR2,
 ispreviouscad       IN VARCHAR2,
 forcage             IN VARCHAR2,
 id_tab_mat          IN NUMBER)
 RETURN NUMBER
 IS
 nbmat               NUMBER:=0;
 dfin                VARCHAR2(8);
 dateprec            VARCHAR2(8);
 divide              NUMBER:=300;
 nbrub               NUMBER:=0;
 rubrique            BOOLEAN;
 new_id              NUMBER;
 
 BEGIN
 cad_avancement_info(id_tab_mat, id_tab_mat || ' commencé');
 SELECT COUNT (*) INTO nbmat FROM cad_calcul_en_cours_matric WHERE id = id_tab_mat;
 INSERT INTO cad_calcul_en_cours_cpt(id, code_compteur)
 (SELECT DISTINCT id_tab_mat        AS id,
 code_compteur    AS code_compteur
 FROM cad_compteur                cpt,
 cad_calcul_en_cours_matric  cm
 WHERE cpt.matricule    = cm.matricule
 AND  cm.id            = id_tab_mat
 );
 --COMMIT;
 cad_avancement(id_tab_mat, 'Bascules ' || dtdeb);
 cad_init_bascules(id_tab_mat, NULL , dtdeb, dtfin);
 cad_avancement(id_tab_mat, 'Fin Bascules ' || dtdeb);
 
 IF (dtfin IS NOT NULL) THEN
 SELECT COUNT(*) INTO nbrub
 FROM tge_incidents_paie                                           ip,
 cad_calcul_en_cours_matric                                   cm,
 dic_adm_contrat                                              dac,
 -- MONOP DIT 50818
 dic_adm_contrat_situ                                         s ,
 (SELECT DISTINCT (rub_val_jour) FROM cad_param_lien_rub_cpt) lien
 WHERE cm.id                                 = id_tab_mat
 AND dac.NUMPAC                             = s.NUMPAC
 AND dac.PACMAT                             = s.PACMAT
 AND dac.NUMCNT                             = s.NUMCNT
 AND ip.code_ip                             = lien.rub_val_jour
 AND ip.paiezad                             = s.paiezad
 AND cm.matricule                           = dac.matric
 AND ip.idpacmat                            = dac.idpacmat
 AND ip.date_effet                         >= TO_DATE(dtdeb, 'yyyymmdd')
 AND ip.date_effet                         <= TO_DATE(dtfin, 'yyyymmdd')
 AND ip.date_effet BETWEEN dac.dsdcn AND NVL(dac.dsfcn, TO_DATE('20991231', 'yyyymmdd'));
 ELSE
 SELECT COUNT(*) INTO nbrub
 FROM tge_incidents_paie                                           ip,
 cad_calcul_en_cours_matric                                   cm,
 dic_adm_contrat                                              dac,
 -- MONOP DIT 50818
 dic_adm_contrat_situ                                         s ,
 (SELECT DISTINCT (rub_val_jour) FROM cad_param_lien_rub_cpt) lien
 WHERE cm.id                                 = id_tab_mat
 AND dac.NUMPAC                             = s.NUMPAC
 AND dac.PACMAT                             = s.PACMAT
 AND dac.NUMCNT                             = s.NUMCNT
 AND ip.code_ip                             = lien.rub_val_jour
 AND ip.paiezad                             = s.paiezad
 AND cm.matricule                           = dac.matric
 AND ip.idpacmat                            = dac.idpacmat
 AND ip.date_effet                         >= TO_DATE(dtdeb, 'yyyymmdd')
 AND ip.date_effet BETWEEN dac.dsdcn AND NVL(dac.dsfcn, TO_DATE('20991231', 'yyyymmdd'));
 END IF;
 
 IF nbrub > 0 OR ispreviouscad = 'true' THEN
 DECLARE
 CURSOR cur_rub
 IS
 SELECT
 dac.matric          AS matricule,
 ip.code_ip          AS rub_val_jour,
 ip.jour_heures      AS valeur,
 TO_CHAR(ip.date_effet, 'yyyymmdd')       AS date_jour,
 ip.jour_calendaire  AS val_calendaire,
 ip.jour_ouvre       AS val_ouvre,
 ip.jour_ouvrable    AS val_ouvrable,
 ip.jour_oeuvre      AS val_oeuvre
 FROM tge_incidents_paie                                             ip,
 cad_calcul_en_cours_matric                                     cm,
 dic_adm_contrat                                                 dac,
 -- MONOP DIT 50818
 dic_adm_contrat_situ                                            s  ,
 (SELECT DISTINCT (rub_val_jour) FROM cad_param_lien_rub_cpt)    lien
 WHERE cm.id                                 = id_tab_mat
 AND dac.NUMPAC                             = s.NUMPAC
 AND dac.PACMAT                             = s.PACMAT
 AND dac.NUMCNT                             = s.NUMCNT
 AND cm.matricule                           = dac.matric
 AND ip.code_ip                             = lien.rub_val_jour
 AND ip.paiezad                             = s.paiezad
 AND ip.idpacmat                            = dac.idpacmat
 AND ip.date_effet                         >= TO_DATE(dtdeb, 'yyyymmdd')
 AND ip.date_effet BETWEEN dac.dsdcn AND NVL(dac.dsfcn, TO_DATE('20991231', 'yyyymmdd'))
 ORDER BY cm.matricule, ip.date_effet;
 ligne_rub cur_rub%rowtype;
 BEGIN
 cad_mise_a_0_var(id_tab_mat, dtdeb);
 SELECT cad_seq_calcul.nextval INTO new_id FROM dual;
 rubrique := FALSE;
 
 OPEN cur_rub;
 LOOP
 FETCH cur_rub INTO ligne_rub;
 EXIT WHEN cur_rub%notfound;
 IF dateprec IS NULL OR (ligne_rub.date_jour < dateprec) THEN
 dateprec := dtdeb;
 END IF;
 MERGE INTO cad_calcul_en_cours_matric A USING (SELECT new_id AS new_id,ligne_rub.matricule AS matric FROM dual) b ON (A.ID = b.new_id AND A.matricule = b.matric)
 WHEN NOT MATCHED THEN
 INSERT (A.ID, A.matricule) VALUES (b.new_id, b.matric);
 
 rubrique := TRUE;
 IF ligne_rub.rub_val_jour != '_VIDE_' THEN
 cad_avancement(id_tab_mat, 'Début Valorisation rubrique : ' || ligne_rub.rub_val_jour || ' ,matric :' || ligne_rub.matricule || ' ,date:' || ligne_rub.date_jour);
 IF nbmat = 1 THEN
 cad_maj_valeur_rubjour(id_tab_mat, ligne_rub.matricule, dateprec, ligne_rub.date_jour, NVL(ligne_rub.valeur, 0), NVL(ligne_rub.val_calendaire, 0), NVL(ligne_rub.val_ouvrable, 0), NVL(ligne_rub.val_oeuvre, 0), NVL(ligne_rub.val_ouvre, 0), NVL(ligne_rub.rub_val_jour, 0), forcage);
 ELSE
 BEGIN
 cad_maj_valeur_rubjour(id_tab_mat, ligne_rub.matricule, dateprec, ligne_rub.date_jour, NVL(ligne_rub.valeur, 0), NVL(ligne_rub.val_calendaire, 0), NVL(ligne_rub.val_ouvrable, 0), NVL(ligne_rub.val_oeuvre,0), NVL(ligne_rub.val_ouvre, 0), NVL(ligne_rub.rub_val_jour, 0), forcage);
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg := sqlerrm;
 cad_erreur(id_tab_mat, 'CAD_MAJ_VALEUR_LISTE', ligne_rub.matricule || ',' || ligne_rub.rub_val_jour || ',' || dateprec || ',' || ligne_rub.date_jour, err_code || '-' || err_msg);
 CONTINUE;
 END;
 END IF;
 cad_avancement(id_tab_mat, 'Fin Valorisation rubrique : ' || ligne_rub.rub_val_jour || ' ,matric :' || ligne_rub.matricule || ' ,date:' || ligne_rub.date_jour);
 END IF;
 dateprec := ligne_rub.date_jour;
 END LOOP;
 CLOSE cur_rub;
 
 IF rubrique THEN
 cad_avancement(new_id, 'Bascules ' || dtdeb);
 cad_init_bascules(new_id, NULL, dtdeb, NULL);
 cad_avancement(new_id, 'Fin Bascules ' || dtdeb);
 INSERT INTO cad_calcul_en_cours_cpt(id, code_compteur)
 (SELECT DISTINCT new_id AS id, code_compteur AS code_compteur
 FROM cad_compteur cpt, cad_calcul_en_cours_matric mat
 WHERE cpt.matricule = mat.matricule AND mat.id = new_id
 );
 cad_calcul(NULL, new_id, dtdeb, NULL);
 DELETE FROM cad_calcul_en_cours_rub WHERE id = new_id;
 DELETE FROM cad_calcul_en_cours_cpt WHERE id = new_id;
 DELETE FROM cad_calcul_en_cours_matric WHERE id = new_id;
 END IF;
 
 DELETE FROM cad_calcul_en_cours_rub WHERE id = id_tab_mat;
 DELETE FROM cad_calcul_en_cours_cpt WHERE id = id_tab_mat;
 DELETE FROM cad_calcul_en_cours_matric WHERE id = id_tab_mat;
 
 END;
 END IF;
 cad_avancement_info(id_tab_mat, id_tab_mat || ' terminé');
 IF nbmat > divide THEN
 COMMIT;
 END IF;
 RETURN 0; /* PAS D'ERREUR */
 
 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg := sqlerrm;
 cad_erreur(id_tab_mat, 'CAD_MAJ_RUB', dtdeb || ',' || dtfin || ',' || ispreviouscad || ',' || forcage || ',' || id_tab_mat, err_code || '-' || err_msg);
 RAISE;
 
 END CAD_MAJ_RUB;
 PROCEDURE             CAD_MAJ_VALEUR_LISTE_RUBJOUR(
 idmat               IN NUMBER,
 dtdeb               IN VARCHAR2,
 dtfin               IN VARCHAR2,
 forcage             IN VARCHAR2,
 ispreviouscad       IN VARCHAR2)
 IS
 reqpropagation      VARCHAR2(4000);
 matricprec          VARCHAR2(32);
 nbmat               NUMBER:=0;
 TYPE  typ_tab_id    IS TABLE OF NUMBER;
 tab_id typ_tab_id   :=typ_tab_id();
 new_id              NUMBER;
 nb_newid            NUMBER;
 divide              NUMBER:=300;
 retour              NUMBER;
 cn                  NUMBER;
 BEGIN
 --dbms_profiler.start_profiler;
 BEGIN
 SELECT is_debug INTO valdebug FROM cad_is_debug;
 EXCEPTION
 WHEN OTHERS THEN
 valdebug := 'N';
 END;
 
 -- TAILLE DU TAB_ID A 1/300 IEMES DE LA POPULATION
 SELECT COUNT (*) INTO nbmat FROM cad_calcul_en_cours_matric WHERE id = idmat;
 nb_newid := ROUND(nbmat / divide) + 1;
 tab_id.EXTEND(nb_newid);
 
 -- DECOUPE LA POPULATION PAR TRANCHE DE 1/300 IEMES
 cn := 1;
 WHILE (cn <= nb_newid) --FOR i IN 1..nb_newid
 LOOP
 SELECT cad_seq_calcul.nextval INTO new_id FROM dual;
 tab_id(cn) := new_id;
 INSERT INTO cad_calcul_en_cours_matric
 (SELECT new_id, matricule
 FROM (SELECT matricule, ROWNUM AS rown FROM cad_calcul_en_cours_matric WHERE id = idmat)
 WHERE rown BETWEEN ((cn - 1) * divide) AND cn * divide
 );
 --COMMIT
 cad_avancement_info(new_id, 'Création ID: ' || new_id);
 cn := cn + 1;
 END LOOP;
 
 -- TRAITEMENT POUR CHAQUE TRANCHE
 FOR i IN tab_id.FIRST..tab_id.LAST
 LOOP
 retour := cad_maj_rub(dtdeb, dtfin, ispreviouscad, forcage, tab_id(i));
 END LOOP;
 --dbms_profiler.flush_data;
 --dbms_profiler.stop_profiler;
 DELETE FROM cad_calcul_en_cours_cpt WHERE id = idmat;
 DELETE FROM cad_calcul_en_cours_matric WHERE id = idmat;
 DELETE FROM CAD_COMPTEUR CPT
 WHERE CPT.TYPEMJ in ('B','S')
 AND NOT EXISTS (
    SELECT 1 FROM CAD_REGLES_PREVUES_REALISEES RPR , CAD_PARAM_REGLES_MAJ PRM
    WHERE RPR.CODE_BASCULE = PRM.CODE_BASCULE
		AND CPT.CODE_COMPTEUR in (PRM.COMPTEUR_DEST,PRM.COMPTEUR_ORI)
    AND CPT.DJOUR >= RPR.DATE_THEO_BASCULE
    AND CPT.MATRICULE = RPR.MATRICULE
    AND CPT.TYPEMJ = RPR.TYPE_BASCULE
 )AND CPT.DJOUR >= dtdeb
 AND CPT.MATRICULE = matricule;

 EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg := sqlerrm;
 IF SQLCODE != '-20000' THEN
 DELETE FROM cad_calcul_en_cours_rub WHERE id = idmat;
 DELETE FROM cad_calcul_en_cours_cpt WHERE id = idmat;
 DELETE FROM cad_calcul_en_cours_matric WHERE id = idmat;
 raise_application_error(-20000, 'Problème(s) durant le recalcul des compteurs');
 ELSE
 DELETE FROM cad_calcul_en_cours_rub WHERE id = idmat;
 DELETE FROM cad_calcul_en_cours_cpt WHERE id = idmat;
 DELETE FROM cad_calcul_en_cours_matric WHERE id = idmat;
 RAISE;
 END IF;
 END CAD_MAJ_VALEUR_LISTE_RUBJOUR;
 PROCEDURE CAD_ROLLBACK_IMPORT(
 numseq IN NUMBER)
 AS
 BEGIN
 DELETE
 FROM cad_compteur a
 WHERE matricule IN
 (SELECT CAD_COMPTEUR_MIN_FOR_ROLL.matricule
 FROM CAD_COMPTEUR_MIN_FOR_ROLL
 WHERE id=numseq
 )
 AND djour>=
 (SELECT date_min
 FROM CAD_COMPTEUR_MIN_FOR_ROLL b
 WHERE id       =numseq
 AND a.matricule=b.matricule
 );
 INSERT
 INTO CAD_COMPTEUR
 (SELECT a.MATRICULE,
 a.CODE_COMPTEUR,
 a.DJOUR,
 a.TYPEMJ,
 a.DATE_MAJ,
 a.POT1_VALEURJ,
 a.POT1_VALEURH,
 a.POT1_FJ,
 a.POT1_FH,
 a.POT2_VALEURJ,
 a.POT2_VALEURH,
 a.POT2_FJ,
 a.POT2_FH,
 a.POT3_VALEURJ,
 a.POT3_VALEURH ,
 a.POT3_FJ,
 a.POT3_FH,
 a.POT4_VALEURJ,
 a.POT4_VALEURH,
 a.POT4_FJ,
 a.POT4_FH,
 a.POT5_VALEURJ,
 a.POT5_VALEURH,
 a.POT5_FJ,
 a.POT5_FH,
 a.POT6_VALEURJ,
 a.POT6_VALEURH,
 a.POT6_FJ,
 a.POT6_FH,
 a.POT7_VALEURJ,
 a.POT7_VALEURH,
 a.POT7_FJ ,
 a.POT7_FH,
 a.POT8_VALEURJ,
 a.POT8_VALEURH,
 a.POT8_FJ,
 a.POT8_FH,
 a.POT9_VALEURJ,
 a.POT9_VALEURH,
 a.POT9_FJ,
 a.POT9_FH,
 a.POT10_VALEURJ,
 a.POT10_VALEURH,
 a.POT10_FJ,
 a.POT10_FH,
 a.POT11_VALEURJ,
 a.POT11_VALEURH,
 a.POT11_FJ ,
 a.POT11_FH,
 a.POT12_VALEURJ,
 a.POT12_VALEURH,
 a.POT12_FJ,
 a.POT12_FH,
 a.POTV1_VALEURJ,
 a.POTV1_VALEURH,
 a.POTV2_VALEURJ,
 a.POTV2_VALEURH,
 a.POTV3_VALEURJ,
 a.POTV3_VALEURH,
 a.POTV4_VALEURJ,
 a.POTV4_VALEURH,
 a.POTV5_VALEURJ ,
 a.POTV5_VALEURH,
 a.POTV6_VALEURJ,
 a.POTV6_VALEURH
 FROM cad_compteur_for_roll a
 WHERE id=numseq
 );
 DELETE FROM CAD_COMPTEUR_MIN_FOR_ROLL WHERE id =numseq;
 DELETE FROM cad_compteur_for_roll WHERE id=numseq;
 END CAD_ROLLBACK_IMPORT;
 FUNCTION cad_calcul_date_relative(
 DATE_RELATIVE    IN VARCHAR2,
 DATE_COMPARAISON IN VARCHAR2 )
 RETURN VARCHAR2
 AS
 dte           VARCHAR2(12);
 TYPE tableau IS VARRAY(4) OF VARCHAR2(8);
 tab tableau :=tableau();
 pos        NUMBER;
 indice     NUMBER;
 subs       VARCHAR2(10);
 dteCalc    VARCHAR2(8);
 dtecompare DATE;
 unite      VARCHAR2(1);
 jour       VARCHAR2(2);
 mois       VARCHAR2(3);
 annee      VARCHAR2(4);
 BEGIN
 IF DATE_RELATIVE      IS NOT NULL THEN
 IF date_comparaison IS NULL THEN
 dtecompare        :=sysdate;
 ELSE
 dtecompare:=to_date(date_comparaison,'yyyymmdd');
 END IF;
 dte          :=DATE_RELATIVE;
 IF LENGTH(dte)<8 THEN
 tab.extend;
 tab(1):=dte;
 ELSE
 tab.extend;
 tab(1):=SUBSTR(dte,0,4);
 tab.extend;
 tab(2):=SUBSTR(dte,5);
 tab(2):=SUBSTR( tab(2),0,LENGTH( tab(2))-2);
 tab.extend;
 tab(3):=SUBSTR(dte,LENGTH(dte)-1);
 END IF;
 IF tab.last =3 THEN
 IF tab(3) ='00' THEN
 jour   :=TO_CHAR(dtecompare ,'dd');
 elsif SUBSTR( tab(3),1,1) IN ('L','M','W','J','V','S','D') THEN
 -- on prend le jour minimum possible pour la semaine puis on affinera
 IF SUBSTR( tab(3),2,1)   ='1' THEN
 jour                  :='08';
 elsif SUBSTR( tab(3),2,1)='2' THEN
 jour                  :='15';
 elsif SUBSTR( tab(3),2,1)='3' THEN
 jour                  :='22';
 elsif SUBSTR( tab(3),2,1)='4' THEN
 jour                  :='29';
 END IF;
 ELSE
 jour:=tab(3);
 END IF;
 IF tab(2)                     ='00' THEN
 mois                       :=TO_CHAR(dtecompare ,'mm');
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,-1) ,'mm');
 ELSE
 mois:=TO_CHAR(dtecompare,'mm');
 END IF;
 elsif tab(2) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))-1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 elsif tab(2) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'dd')>=jour THEN
 mois                      :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 ELSE
 mois:=tab(2);
 END IF;
 IF tab(1)                       ='0000' THEN
 annee                        := TO_CHAR(dtecompare ,'yyyy');
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,-12) ,'yyyy');
 ELSE
 annee:= TO_CHAR(dtecompare ,'yyyy');
 END IF;
 elsif tab(1) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 END IF;
 elsif tab(1) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')>=mois||jour THEN
 annee                       := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 END IF;
 ELSE
 annee:=tab(1);
 END IF;
 IF jour='32' THEN
 jour:=TO_CHAR(last_day(to_date(annee||mois||'01','yyyymmdd')) ,'dd');
 END IF;
 IF SUBSTR( tab(3),0,1) IN ('L','M','W','J','V','S','D') THEN
 jour                         :=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),1,1),SUBSTR(tab(3),2,1) ,annee,mois );
 IF tab(2)                     ='00' THEN
 mois                       :=TO_CHAR(dtecompare ,'mm');
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,-1) ,'mm');
 ELSE
 mois:=TO_CHAR(dtecompare,'mm');
 END IF;
 elsif tab(2) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'dd')<jour THEN
 mois                     :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))-1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 elsif tab(2) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'dd')>=jour THEN
 mois                      :=TO_CHAR(add_Months(dtecompare,to_number(tab(2))+1) ,'mm');
 ELSE
 mois:=TO_CHAR(add_Months(dtecompare,to_number(tab(2))) ,'mm');
 END IF;
 ELSE
 mois:=tab(2);
 END IF;
 jour                           :=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),0,1),SUBSTR(tab(3),2,1) ,annee,mois );
 IF tab(1)                       ='0000' THEN
 annee                        := TO_CHAR(dtecompare ,'yyyy');
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,-12) ,'yyyy');
 ELSE
 annee:= TO_CHAR(dtecompare ,'yyyy');
 END IF;
 elsif tab(1) LIKE '+%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')<mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 END IF;
 elsif tab(1) LIKE '-%' THEN
 IF TO_CHAR(dtecompare ,'mmdd')>mois||jour THEN
 annee                      := TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1)))) ,'yyyy');
 ELSE
 annee:= TO_CHAR(add_Months(dtecompare,12*(to_number(tab(1))-1)) ,'yyyy');
 END IF;
 ELSE
 annee:=tab(1);
 END IF;
 jour:=CAD_CALCUL_JOUR_SEMAINE(SUBSTR( tab(3),0,1),SUBSTR(tab(3),2,1) ,annee,mois );
 END IF;
 dteCalc:=annee||mois||jour;
 ELSE
 IF tab(1) LIKE '+%' OR tab(1) LIKE '-%' THEN
 unite     := SUBSTR(tab(1), LENGTH(tab(1)));
 tab(1)    :=REPLACE(tab(1),unite,'');
 IF unite   ='A' THEN
 dteCalc :=TO_CHAR(add_Months(dtecompare,12*to_number(tab(1))) -to_number(SUBSTR(tab(1),1,1)||'1'),'yyyymmdd');
 elsif unite='M' THEN
 dteCalc :=TO_CHAR(add_Months(dtecompare,to_number(tab(1))) -to_number(SUBSTR(tab(1),1,1)||'1'),'yyyymmdd');
 elsif unite='J' THEN
 dteCalc :=TO_CHAR(dtecompare+to_number(tab(1)) ,'yyyymmdd');
 END IF;
 END IF;
 END IF;
 END IF;
 RETURN dteCalc;
 END cad_calcul_date_relative;
 FUNCTION CAD_CALCUL_DATE_RELATIVE_AV(
 DATE_RELATIVE     IN VARCHAR2,
 DATE_COMPARAISON  IN VARCHAR2,
 DATE_VALIDITE_REL IN VARCHAR2 )
 RETURN VARCHAR2
 AS
 ANNEE_RESOLU  VARCHAR2(10);
 dtevalid      DATE;
 var_annee     VARCHAR2(10);
 reste         VARCHAR2(10);
 DATE_VALIDITE VARCHAR2(8);
 BEGIN
 DATE_VALIDITE                     :=CAD_CALCUL_DATE_RELATIVE(DATE_VALIDITE_REL,DATE_COMPARAISON );
 dtevalid                          :=to_date(DATE_VALIDITE,'yyyymmdd');
 IF instr(upper(DATE_RELATIVE),'AV')>0 THEN
 var_annee                       :=SUBSTR(DATE_RELATIVE,3,2);
 reste                           :=SUBSTR(DATE_RELATIVE,5);
 IF var_annee                     ='00' THEN
 ANNEE_RESOLU                  := TO_CHAR(dtevalid ,'yyyy');
 elsif var_annee LIKE '+%' THEN
 ANNEE_RESOLU:= TO_CHAR(add_Months(dtevalid,12*(to_number(var_annee))) ,'yyyy');
 elsif var_annee LIKE '-%' THEN
 ANNEE_RESOLU:= TO_CHAR(add_Months(dtevalid,12*(to_number(var_annee))) ,'yyyy');
 ELSE
 ANNEE_RESOLU:=TO_CHAR(dtevalid ,'yyyy');
 END IF;
 ANNEE_RESOLU:=ANNEE_RESOLU||reste;
 ELSE
 ANNEE_RESOLU:=DATE_RELATIVE;
 END IF;
 RETURN CAD_CALCUL_DATE_RELATIVE(ANNEE_RESOLU,DATE_COMPARAISON );
 END CAD_CALCUL_DATE_RELATIVE_AV;
 FUNCTION CAD_CALCUL_DATE_REL_AV_FIN(
 DATE_ACQ_FIN   IN VARCHAR2,
 DATE_ACQ_DEBUT IN VARCHAR2,
 DATE_COMPARE   IN VARCHAR2,
 DATE_VAL_DEBUT IN VARCHAR2)
 RETURN VARCHAR2
 AS
 BEGIN
 RETURN CAD_CALCUL_DATE_RELATIVE(DATE_ACQ_FIN,CAD_CALCUL_DATE_RELATIVE_AV(DATE_ACQ_DEBUT,DATE_COMPARE,DATE_VAL_DEBUT) );
 END CAD_CALCUL_DATE_REL_AV_FIN;
 FUNCTION CAD_CALCUL_DATE_RELATIVE_FIN(
 DATE_RELATIVE_FIN   IN VARCHAR2,
 DATE_RELATIVE_DEBUT IN VARCHAR2,
 DATE_COMPARE        IN VARCHAR2 )
 RETURN VARCHAR2
 AS
 BEGIN
 RETURN CAD_CALCUL_DATE_RELATIVE(DATE_RELATIVE_FIN,CAD_CALCUL_DATE_RELATIVE(DATE_RELATIVE_DEBUT,DATE_COMPARE) );
 END CAD_CALCUL_DATE_RELATIVE_FIN;
 FUNCTION cad_formate_date_relative(
 DATE_RELATIVE    IN VARCHAR2,
 DATE_COMPARAISON IN VARCHAR2 )
 RETURN VARCHAR2
 AS
 BEGIN
 RETURN CAD_CALCUL_DATE_RELATIVE(DATE_RELATIVE,DATE_COMPARAISON);
 END cad_formate_date_relative;
 FUNCTION CAD_INTERRO_THEME(
 MATRIC       IN VARCHAR2 ,
 p_CODE_THEME IN VARCHAR2 ,
 p_DJOUR      IN VARCHAR2,
 collectif    IN VARCHAR2,
 finPeriode   IN NUMBER DEFAULT NULL)
 RETURN CAD_RESULTAT_THEME
 AS
 CURSOR cur_items
 IS
 SELECT *
 FROM CAD_THEMES_ITEMS
 WHERE (THEME_PERE =p_CODE_THEME
 OR p_CODE_THEME  IS NULL)
 AND ACTIF         ='O'
 ORDER BY THEME_PERE,
 ordre;
 ligne_items CAD_THEMES_ITEMS%ROWTYPE;
 ligne_lib CAD_THEMES_CPT%ROWTYPE;
 ligne_Date CAD_THEMES_CPT%ROWTYPE;
 ligne_calc CAD_THEMES_CPT%ROWTYPE;
 ligne_cpt CAD_COMPTEUR%ROWTYPE;
 liste_cpt VARCHAR(4000);
 requete CLOB;
 reqSelect CLOB;
 TYPE tableau IS VARRAY(50) OF VARCHAR(50);
 tabCpt tableau       :=tableau();
 col tableau          :=tableau();
 tabPotsParCpt tableau:=tableau();
 tabPots tableau      :=tableau();
 posVir   NUMBER;
 indice   NUMBER;
 indice2  NUMBER;
 subs     VARCHAR(50);
 tmp      NUMBER;
 tmpRes   NUMBER;
 elt      VARCHAR(50);
 numLigne NUMBER;
 retour CAD_RESULTAT_THEME:=CAD_RESULTAT_THEME();
 dateinterro     VARCHAR(8);
 unite           VARCHAR(1);
 numDonnee       NUMBER;
 theme_pere_prec VARCHAR(20);
 numpot          NUMBER;
 numpotV         NUMBER;
 dad             VARCHAR(10);
 daf             VARCHAR(10);
 dvd             VARCHAR(10);
 dvf             VARCHAR(10);
 dtcalc          VARCHAR(12);
 dteoucp         VARCHAR(12);
 typeEcran       VARCHAR(1);
 trouve          INT;
 nb_clauseselect INT;
 valdebug        VARCHAR2(1);
 format          VARCHAR(4);
 deb             NUMBER;
 fin             NUMBER;
 total           NUMBER:=0;
 dateRequested   VARCHAR(8);
 BEGIN
 SELECT format_heure INTO format FROM CAD_THEMES WHERE code_theme=p_CODE_THEME;
 BEGIN
 SELECT is_debug INTO valdebug FROM CAD_IS_DEBUG;
 EXCEPTION
 WHEN OTHERS THEN
 valdebug:='N';
 END;
 IF collectif='O' THEN
 typeEcran:='C';
 ELSE
 typeEcran:='I';
 END IF;
 numDonnee:=0;
 OPEN cur_items;
 LOOP
 FETCH cur_items INTO ligne_items;
 EXIT
 WHEN cur_items%NOTFOUND ;
 -- si non actif on passe à la ligne suivante
 --  IF ligne_items.actif='N' THEN CONTINUE; END IF;
 IF theme_pere_prec IS NULL OR theme_pere_prec <>ligne_items.theme_pere THEN
 numDonnee        :=numDonnee+1;
 retour.extend;
 retour(numDonnee)           :=CAD_LIGNE_RESULTAT_THEME(NULL,NULL,NULL,NULL,NULL);
 retour(numDonnee).matricule :=matric;
 retour(numDonnee).CODE_THEME:= ligne_items.theme_pere;
 retour(numDonnee).code_item :=ligne_items.code_item;
 retour(numDonnee).lib_item  :=ligne_items.LIBELLE;
 END IF;
 -- Récupération des dates si il y en a
 DECLARE
 CURSOR cur_items_Date
 IS
 SELECT *
 FROM CAD_THEMES_CPT a
 WHERE code   = ligne_items.theme_pere
 AND ( (type  ='L'
 AND typeecran='I')
 OR (typeecran='C'
 AND (type    ='LC'
 OR ( type    ='L'
 AND NOT EXISTS
 (SELECT NULL
 FROM CAD_THEMES_CPT cpt
 WHERE cpt.code=a.code
 AND cpt.type  ='LC'
 AND cpt.ordre =a.ordre
 ) )) ))
 AND calcul LIKE ('D%')
 ORDER BY ordre;
 BEGIN
 OPEN cur_items_date;
 LOOP
 FETCH cur_items_date INTO ligne_date;
 EXIT
 WHEN cur_items_date%NOTFOUND ;
 BEGIN
 -- calcul date
 SELECT LIB_CPT_POT
 INTO dteoucp
 FROM CAD_THEMES_CPT a
 WHERE code   = ligne_items.code_item
 AND ( (type  ='V'
 AND typeecran='I')
 OR (typeecran='C'
 AND (type    ='VC'
 OR ( type    ='V'
 AND NOT EXISTS
 (SELECT NULL
 FROM CAD_THEMES_CPT cpt
 WHERE cpt.code=a.code
 AND cpt.type  ='VC'
 AND cpt.ordre =a.ordre
 ) )) ))
 AND ordre         =ligne_date.ordre;
 -- on demande à fin de periode
 IF finPeriode IS NOT NULL THEN
 SELECT DATE_FIN_PER
 INTO dateRequested
 FROM CAD_MATRIC_DATEVALID a
 WHERE matricule  =matric
 AND code_compteur=dteoucp
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<= p_DJOUR
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 );
 ELSE
 dateRequested:=p_DJOUR;
 END IF;	
 IF LENGTH(dteoucp)>5 THEN
 dtcalc         :=cad_calcul_date_relative(dteoucp,NULL);
 ELSE
 BEGIN
 IF ligne_date.calcul ='DAD' THEN
 SELECT DATE_DEB_ACQUIS
 INTO dtcalc
 FROM CAD_MATRIC_DATEVALID a
 WHERE matricule  =matric
 AND code_compteur=dteoucp
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<= dateRequested
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 );
 elsif ligne_date.calcul ='DAF' THEN
 SELECT DATE_FIN_ACQUIS
 INTO dtcalc
 FROM CAD_MATRIC_DATEVALID a
 WHERE matricule  =matric
 AND code_compteur=dteoucp
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<= dateRequested
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 );
 elsif ligne_date.calcul ='DVD' THEN
 SELECT DATE_DEB_PER
 INTO dtcalc
 FROM CAD_MATRIC_DATEVALID a
 WHERE matricule  =matric
 AND code_compteur=dteoucp
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<= dateRequested
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 );
 elsif ligne_date.calcul ='DVF' THEN
 SELECT DATE_FIN_PER
 INTO dtcalc
 FROM CAD_MATRIC_DATEVALID a
 WHERE matricule  =matric
 AND code_compteur=dteoucp
 AND a.DATE_EFFET =
 (SELECT MAX(date_effet)
 FROM cad_matric_datevalid b
 WHERE b.date_effet<= dateRequested
 AND a.code_compteur=b.code_compteur
 AND a.matricule    =b.matricule
 );
 END IF;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 IF ligne_date.calcul ='DAD' THEN
 SELECT CAD_CALCUL_DATE_RELATIVE(DATE_DEB_ACQUIS, dateRequested)
 INTO dtcalc
 FROM CAD_PARAM_STRUCT_CPT a
 WHERE code_compteur   =dteoucp;
 elsif ligne_date.calcul ='DAF' THEN
 SELECT CAD_CALCUL_DATE_RELATIVE(DATE_FIN_ACQUIS, dateRequested)
 INTO dtcalc
 FROM CAD_PARAM_STRUCT_CPT a
 WHERE code_compteur   =dteoucp;
 elsif ligne_date.calcul ='DVD' THEN
 SELECT CAD_CALCUL_DATE_RELATIVE(DTDEB_PERIODE, dateRequested)
 INTO dtcalc
 FROM CAD_PARAM_STRUCT_CPT a
 WHERE code_compteur   =dteoucp;
 elsif ligne_date.calcul ='DVF' THEN
 SELECT CAD_CALCUL_DATE_RELATIVE(DTFIN_PERIODE, dateRequested)
 INTO dtcalc
 FROM CAD_PARAM_STRUCT_CPT a
 WHERE code_compteur=dteoucp;
 END IF;
 END;
 END IF;
 IF ligne_date.calcul    ='DAD' THEN
 dad                  :=dtcalc;
 elsif ligne_date.calcul ='DAF' THEN
 daf                  :=dtcalc;
 elsif ligne_date.calcul ='DVD' THEN
 dvd                  :=dtcalc;
 elsif ligne_date.calcul ='DVF' THEN
 dvf                  :=dtcalc;
 END IF;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 NULL;
 END;
 END LOOP;
 CLOSE cur_items_date;
 -- récupération des compteurs à utiliser pour l'item (ordre 0, type V)
 SELECT LIB_CPT_POT
 INTO liste_cpt
 FROM CAD_THEMES_CPT a
 WHERE code =ligne_items.code_item
 AND ordre  =0
 AND type   ='V';
 --  AND ( (type  ='V'
 --  AND typeecran='I')
 -- OR (typeecran='C'
 --  AND (type    ='VC'
 --  OR ( type    ='V'
 -- AND NOT EXISTS
 --   (SELECT NULL
 --   FROM CAD_THEMES_CPT cpt
 --   WHERE cpt.code=a.code
 --   AND cpt.type  ='VC'
 --   AND cpt.ordre =a.ordre
 --   ) )) ));
 indice                 :=0;
 tabcpt                 :=tableau();
 WHILE LENGTH(liste_cpt) >0
 LOOP
 indice      :=indice+1;
 posVir      :=instr(liste_cpt,',');
 IF (posVir   >0) THEN
 subs      :=SUBSTR(liste_cpt,0,posVir);
 liste_cpt :=SUBSTR(liste_cpt,posVir+1);
 subs      :=REPLACE(subs,',','');
 tabcpt.extend;
 tabcpt(indice):=subs;
 ELSE
 tabcpt.extend;
 tabcpt(indice):=liste_cpt;
 liste_cpt     :='';
 END IF;
 END LOOP;
 END;
 DECLARE
 CURSOR cur_lib
 IS
 SELECT *
 FROM CAD_THEMES_CPT a
 WHERE code   =ligne_items.theme_pere
 AND ( (type  ='L'
 AND typeecran='I')
 OR (typeecran='C'
 AND (type    ='LC'
 OR ( type    ='L'
 AND NOT EXISTS
 (SELECT NULL
 FROM CAD_THEMES_CPT cpt
 WHERE cpt.code=a.code
 AND cpt.type  ='LC'
 AND cpt.ordre =a.ordre
 ) )) ))
 ORDER BY ordre;
 BEGIN
 col:=tableau();
 OPEN cur_lib;
 LOOP
 FETCH cur_lib INTO ligne_lib;
 EXIT
 WHEN cur_lib%NOTFOUND ;
 BEGIN
 -- récupération des pots à utiliser pour chaque compteur
 SELECT *
 INTO ligne_calc
 FROM CAD_THEMES_CPT a
 WHERE code   =ligne_items.code_item
 AND ordre    =ligne_lib.ordre
 AND ( (type  ='V'
 AND typeecran='I')
 OR (typeecran='C'
 AND (type    ='VC'
 OR ( type    ='V'
 AND NOT EXISTS
 (SELECT NULL
 FROM CAD_THEMES_CPT cpt
 WHERE cpt.code=a.code
 AND cpt.type  ='VC'
 AND cpt.ordre =a.ordre
 ) )) ));
 requete                               :='';
 reqselect                             :='';
 elt                                   :='';
 IF ligne_lib.CALCUL                    ='R' OR ligne_lib.CALCUL='P' OR ligne_lib.CALCUL='VP' THEN
 deb                                 := DBMS_UTILITY.get_time;
 indice                              :=0;
 tabPotsParCpt                       :=tableau();
 WHILE LENGTH(ligne_calc.LIB_CPT_POT) >0
 LOOP
 indice                   :=indice+1;
 posVir                   :=instr(ligne_calc.LIB_CPT_POT,',');
 IF (posVir                >0) THEN
 subs                   :=SUBSTR(ligne_calc.LIB_CPT_POT,0,posVir);
 ligne_calc.LIB_CPT_POT :=SUBSTR(ligne_calc.LIB_CPT_POT,posVir+1);
 subs                   :=REPLACE(subs,',','');
 tabPotsParCpt.extend;
 tabPotsParCpt(indice) :=subs;
 ELSE
 tabPotsParCpt.extend;
 tabPotsParCpt(indice)  :=ligne_calc.LIB_CPT_POT;
 ligne_calc.LIB_CPT_POT :='';
 END IF;
 END LOOP;
 -- Ecriture des requetes
 nb_clauseselect:=0;
 tmp            :=0;
 FOR i IN 1..indice
 LOOP
 tmpres                        :=0;
 indice2                       :=0;
 tabPots                       :=tableau();
 trouve                        :=0;
 WHILE LENGTH(tabPotsParCpt(i)) >0
 LOOP
 trouve             :=1;
 indice2            :=indice2+1;
 posVir             :=instr(tabPotsParCpt(i),'^');
 IF (posVir          >0) THEN
 subs             :=SUBSTR(tabPotsParCpt(i),0,posVir);
 tabPotsParCpt(i) :=SUBSTR(tabPotsParCpt(i),posVir+1);
 subs             :=REPLACE(subs,'^','');
 tabPots.extend;
 tabPots(indice2) :=subs;
 ELSE
 tabPots.extend;
 tabPots(indice2) :=tabPotsParCpt(i);
 tabPotsParCpt(i) :='';
 END IF;
 END LOOP;
 IF trouve =0 THEN
 CONTINUE;
 END IF;
 IF nb_clauseselect <=1 THEN
 unite            :=cad_unite_cpt(matric, dateRequested,tabcpt(i));
 END IF;
 IF ligne_lib.CALCUL   ='R' THEN
 dateinterro        := dateRequested;
 elsif ligne_lib.CALCUL='P' THEN
 -- récuperer date fin valid
 dateinterro        :=dvf;
 elsif ligne_lib.CALCUL='VP' THEN
 -- récuperer date fin valid
 dateinterro:=dvf;
 END IF;
 IF ligne_lib.CALCUL='R' OR ligne_lib.CALCUL='P' THEN
 BEGIN
 --select *  INTO ligne_cpt from (select * from CAD_COMPTEUR where code_compteur=tabcpt(i) and matricule =matric and djour <=dateinterro order by djour desc,typemj desc) where rownum=1;
 -- select *   INTO ligne_cpt from CAD_COMPTEUR a where code_compteur=tabcpt(i) and matricule =matric and djour||typemj=( select max(b.djour||b.typemj)   from CAD_COMPTEUR b where b.code_compteur=a.code_compteur and b.matricule =a.matricule and b.djour <=dateinterro );
 SELECT MATRICULE,
 CODE_COMPTEUR,
 DJOUR,
 TYPEMJ,
 DATE_MAJ,
 POT1_VALEURJ,
 POT1_VALEURH,
 POT1_FJ,
 POT1_FH,
 POT2_VALEURJ ,
 POT2_VALEURH ,
 POT2_FJ ,
 POT2_FH ,
 POT3_VALEURJ ,
 POT3_VALEURH ,
 POT3_FJ ,
 POT3_FH ,
 POT4_VALEURJ ,
 POT4_VALEURH ,
 POT4_FJ ,
 POT4_FH ,
 POT5_VALEURJ ,
 POT5_VALEURH ,
 POT5_FJ ,
 POT5_FH ,
 POT6_VALEURJ ,
 POT6_VALEURH ,
 POT6_FJ ,
 POT6_FH ,
 POT7_VALEURJ ,
 POT7_VALEURH ,
 POT7_FJ ,
 POT7_FH ,
 POT8_VALEURJ ,
 POT8_VALEURH ,
 POT8_FJ ,
 POT8_FH ,
 POT9_VALEURJ ,
 POT9_VALEURH ,
 POT9_FJ ,
 POT9_FH ,
 POT10_VALEURJ ,
 POT10_VALEURH ,
 POT10_FJ ,
 POT10_FH ,
 POT11_VALEURJ ,
 POT11_VALEURH ,
 POT11_FJ ,
 POT11_FH ,
 POT12_VALEURJ ,
 POT12_VALEURH ,
 POT12_FJ ,
 POT12_FH ,
 POTV1_VALEURJ ,
 POTV1_VALEURH ,
 POTV2_VALEURJ ,
 POTV2_VALEURH ,
 POTV3_VALEURJ ,
 POTV3_VALEURH ,
 POTV4_VALEURJ ,
 POTV4_VALEURH ,
 POTV5_VALEURJ ,
 POTV5_VALEURH ,
 POTV6_VALEURJ ,
 POTV6_VALEURH
 INTO ligne_cpt
 FROM
 (SELECT a.*,
 rank() over(order by djour DESC,typemj DESC) rn
 FROM CAD_COMPTEUR a
 WHERE code_compteur=tabcpt(i)
 AND matricule      =matric
 AND djour         <=dateinterro
 )
 WHERE rn=1;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 CONTINUE;
 WHEN OTHERS THEN
 raise;
 END;
 elsif ligne_lib.CALCUL='VP' THEN
 BEGIN
 SELECT NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 SUM(NVL(POTV1_VALEURj,0)) AS POTV1_VALEURj,
 SUM(NVL(POTV1_VALEURh,0)) AS POTV1_VALEUh,
 SUM(NVL(POTV2_VALEURj,0)) AS POTV2_VALEURj,
 SUM(NVL(POTV2_VALEURh,0)) AS POTV2_VALEURh,
 SUM(NVL(POTV3_VALEURj,0)) AS POTV3_VALEURj,
 SUM(NVL(POTV3_VALEURh,0)) AS POTV3_VALEURh,
 SUM(NVL(POTV4_VALEURj,0)) AS POTV4_VALEURj,
 SUM(NVL(POTV4_VALEURh,0)) AS POTV4_VALEURh,
 SUM(NVL(POTV5_VALEURj,0)) AS POTV5_VALEURj,
 SUM(NVL(POTV5_VALEURh,0)) AS POTV5_VALEURh,
 SUM(NVL(POTV6_VALEURj,0)) AS POTV6_VALEURj,
 SUM(NVL(POTV6_VALEURh,0)) AS POTV6_VALEURh
 INTO ligne_cpt
 FROM
 (SELECT *
 FROM CAD_COMPTEUR
 WHERE code_compteur=tabcpt(i)
 AND matricule      =matric
 AND djour         <=dateinterro
 AND djour          > dateRequested
 );
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 CONTINUE;
 WHEN OTHERS THEN
 raise;
 END;
 END IF;
 FOR j IN 1..indice2
 LOOP
 tmpres            :=0;
 IF ligne_lib.CALCUL='R' OR ligne_lib.CALCUL='P' THEN
 IF tabpots(j)    ='POT1' THEN
 IF (unite      ='H') THEN
 tmpRes      :=NVL(ligne_cpt.POT1_Fh,NVL(ligne_cpt.POT1_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT1_Fj,NVL(ligne_cpt.POT1_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT2' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT2_Fh,NVL(ligne_cpt.POT2_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT2_Fj,NVL(ligne_cpt.POT2_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT3' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT3_Fh,NVL(ligne_cpt.POT3_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT3_Fj,NVL(ligne_cpt.POT3_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT4' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT4_Fh,NVL(ligne_cpt.POT4_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT4_Fj,NVL(ligne_cpt.POT4_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT5' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT5_Fh,NVL(ligne_cpt.POT5_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT5_Fj,NVL(ligne_cpt.POT5_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT6' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT6_Fh,NVL(ligne_cpt.POT6_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT6_Fj,NVL(ligne_cpt.POT6_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT7' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT7_Fh,NVL(ligne_cpt.POT7_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT7_Fj,NVL(ligne_cpt.POT7_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT8' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT8_Fh,NVL(ligne_cpt.POT8_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT8_Fj,NVL(ligne_cpt.POT8_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT9' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT9_Fh,NVL(ligne_cpt.POT9_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT9_Fj,NVL(ligne_cpt.POT9_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT10' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT10_Fh,NVL(ligne_cpt.POT10_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT10_Fj,NVL(ligne_cpt.POT10_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT11' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT11_Fh,NVL(ligne_cpt.POT11_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT11_Fj,NVL(ligne_cpt.POT11_VALEURj,0));
 END IF;
 elsif tabpots(j)='POT12' THEN
 IF (unite     ='H') THEN
 tmpRes     :=NVL(ligne_cpt.POT12_Fh,NVL(ligne_cpt.POT12_VALEURh,0));
 ELSE
 tmpRes:=NVL(ligne_cpt.POT12_Fj,NVL(ligne_cpt.POT12_VALEURj,0));
 END IF;
 END IF;
 elsif ligne_lib.CALCUL='VP' THEN
 numpot             :=REPLACE(tabpots(j),'POT','');
 SELECT numpot_var
 INTO numpotV
 FROM
 (SELECT
 CASE
 WHEN potv1=numpot
 THEN 1
 WHEN potv2=numpot
 THEN 2
 WHEN potv3=numpot
 THEN 3
 WHEN potv4=numpot
 THEN 4
 WHEN potv5=numpot
 THEN 5
 WHEN potv6=numpot
 THEN 6
 END AS numpot_var
 FROM cad_param_calcul
 WHERE code_compteur=tabcpt(i)
 );
 IF numpotV  =1 THEN
 IF (unite ='H') THEN
 tmpRes :=NVL(ligne_cpt.POTV1_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV1_VALEURj,0);
 END IF;
 elsif numpotV=2 THEN
 IF (unite  ='H') THEN
 tmpRes  :=NVL(ligne_cpt.POTV2_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV2_VALEURj,0);
 END IF;
 elsif numpotV=3 THEN
 IF (unite  ='H') THEN
 tmpRes  :=NVL(ligne_cpt.POTV3_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV3_VALEURj,0);
 END IF;
 elsif numpotV=4 THEN
 IF (unite  ='H') THEN
 tmpRes  :=NVL(ligne_cpt.POTV4_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV4_VALEURj,0);
 END IF;
 elsif numpotV=5 THEN
 IF (unite  ='H') THEN
 tmpRes  :=NVL(ligne_cpt.POTV5_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV5_VALEURj,0);
 END IF;
 elsif numpotV=6 THEN
 IF (unite  ='H') THEN
 tmpRes  :=NVL(ligne_cpt.POTV6_VALEURh,0);
 ELSE
 tmpRes:=NVL(ligne_cpt.POTV6_VALEURj,0);
 END IF;
 END IF;
 END IF;
 tmp:=tmp+tmpRes;
 END LOOP;
 END LOOP;
 IF tmp>0 AND tmp<1 THEN
 elt:='0'||tmp;
 elsif tmp>-1 AND tmp<0 THEN
 elt:=tmp;
 if INSTR(elt, '-,') = 1 then
 elt := '-0,' || SUBSTR( elt, 3 );
 end if;
 ELSE
 elt:=tmp;
 END IF;
 fin  := DBMS_UTILITY.get_time;
 total:=total+(fin-deb);
 --DBMS_OUTPUT.put_line('Type R,P,VP '||total);
 --FIXME utiliser la procédure trace_dbms_output()
 elsif ligne_lib.CALCUL='U' THEN
 elt                :=unite;
 elsif ligne_lib.CALCUL='DVD' THEN
 elt                :=dvd;
 elsif ligne_lib.CALCUL='DVF' THEN
 elt                :=dvf;
 elsif ligne_lib.CALCUL='DAD' THEN
 elt                :=dad;
 elsif ligne_lib.CALCUL='DAF' THEN
 elt                :=daf;
 elsif ligne_lib.CALCUL='COL' THEN
 deb                := DBMS_UTILITY.get_time;
 FOR l IN reverse 1..col.count
 LOOP
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT, 'C'||l,'to_number('''||NVL(col(l),0)||''')');
 END LOOP;
 EXECUTE immediate ( 'select '||ligne_calc.LIB_CPT_POT||' from dual') INTO tmp;
 IF tmp>0 AND tmp<1 THEN
 elt:='0'||tmp;
 elsif tmp>-1 AND tmp<0 THEN
 elt:=tmp;
 if INSTR(elt, '-,') = 1 then
 elt := '-0,' || SUBSTR( elt, 3 );
 end if;
 ELSE
 elt:=tmp;
 END IF;
 fin  := DBMS_UTILITY.get_time;
 total:=total+(fin-deb);
 --DBMS_OUTPUT.put_line('Type COL '||total);
 --FIXME utiliser la procédure trace_dbms_output()
 elsif ligne_lib.CALCUL='C' THEN
 deb                := DBMS_UTILITY.get_time;
 FOR i IN 1..indice
 LOOP
 -- récuperer les valeurs des pots pour chaque compteur
 SELECT *
 INTO ligne_cpt
 FROM
 (SELECT *
 FROM CAD_COMPTEUR
 WHERE code_compteur=tabcpt(i)
 AND matricule      =matric
 AND djour         <=dateinterro
 ORDER BY djour DESC,
 typemj DESC
 )
 WHERE rownum=1;
 --EXECUTE immediate requete INTO ligne_cpt;
 -- remplacer les pots
 IF unite                  ='H' THEN
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT12',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT12_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT11',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT11_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT10',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT10_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT9',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT9_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT8',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT8_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT7',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT7_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT6',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT6_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT5',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT5_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT4',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT4_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT3',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT3_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT2',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT2_VALEURH,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT1',NVL(ligne_cpt.POT1_FH,NVL(ligne_cpt.POT1_VALEURH,0)));
 ELSE
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT12',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT12_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT11',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT11_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT10',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT10_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT9',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT9_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT8',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT8_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT7',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT7_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT6',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT6_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT5',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT5_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT4',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT4_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT3',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT3_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT2',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT2_VALEURJ,0)));
 ligne_calc.LIB_CPT_POT :=REPLACE( ligne_calc.LIB_CPT_POT,tabcpt(i)||'.POT1',NVL(ligne_cpt.POT1_FJ,NVL(ligne_cpt.POT1_VALEURJ,0)));
 END IF;
 END LOOP;
 EXECUTE immediate ( 'select '||ligne_calc.LIB_CPT_POT||' from dual') INTO tmp;
 IF tmp>0 AND tmp<1 THEN
 elt:='0'||tmp;
 elsif tmp>-1 AND tmp<0 THEN
 elt:=tmp;
 if INSTR(elt, '-,') = 1 then
 elt := '-0,' || SUBSTR( elt, 3 );
 end if;
 ELSE
 elt:=tmp;
 END IF;
 fin  := DBMS_UTILITY.get_time;
 total:=total+(fin-deb);
 --DBMS_OUTPUT.put_line('Type C'||total);
 --FIXME utiliser la procédure trace_dbms_output()
 END IF;
 deb                        := DBMS_UTILITY.get_time;
 IF ligne_lib.NON_AFFICHAGE IS NOT NULL AND cad_condition_non_aff( dateRequested,ligne_lib.CALCUL,ligne_lib.NON_AFFICHAGE,elt)=1 THEN
 retour.delete(numDonnee);
 EXIT;
 END IF;
 col.extend;
 col(ligne_lib.ordre) :=elt;
 IF (unite             ='H' AND ligne_lib.CALCUL IN ('C','COL','R','P','VP')) THEN
 IF format           ='HHMM' THEN
 -- en HHMM
 elt      :=conversionSecondesHHMM(elt);
 elsif format='HC' THEN
 -- en HHCC
 elt:=conversionSecondesHHCC(elt);
 END IF;
 elsif ligne_lib.CALCUL IN ('C','COL','R','P','VP') AND elt IS NULL THEN
 elt                                                      :='0';
 END IF;
 IF ligne_calc.ordre           =1 THEN
 retour(numDonnee).RESULTAT :=NVL(elt,'');
 ELSE
 retour(numDonnee).RESULTAT :=NVL(retour(numDonnee).RESULTAT,'')||'^'||NVL(elt,'');
 END IF;
 fin  := DBMS_UTILITY.get_time;
 total:=total+(fin-deb);
 --DBMS_OUTPUT.put_line('Ajout donnée'||total);
 --FIXME utiliser la procédure trace_dbms_output()
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 IF ligne_calc.ordre           =1 THEN
 retour(numDonnee).RESULTAT :='';
 ELSE
 retour(numDonnee).RESULTAT :=NVL(retour(numDonnee).RESULTAT,'')||'^'||'';
 END IF;
 col.extend;
 END;
 END LOOP;
 CLOSE cur_lib;
 END;
 END LOOP;
 CLOSE cur_items;
 FOR i in retour.first .. retour.last LOOP
   IF retour(i).RESULTAT LIKE '%^^%' OR retour(i).RESULTAT LIKE '^%' OR retour(i).RESULTAT LIKE '%^' THEN
     retour.delete(i);
   END IF;
 END LOOP;
 RETURN retour;
 END CAD_INTERRO_THEME;
 FUNCTION CAD_INTERRO_THEME_COLL(
 idPop      IN NUMBER ,
 CODE_THEME IN VARCHAR2 ,
 DJOUR      IN VARCHAR2,
 collectif  IN VARCHAR2)
 RETURN CAD_RESULTAT_THEME
 AS
 CURSOR cur_pop
 IS
 SELECT * FROM REQ_POPULATION WHERE num=idPop;
 ligne_pop REQ_POPULATION%ROWTYPE;
 retour CAD_RESULTAT_THEME:=CAD_RESULTAT_THEME();
 tmp CAD_RESULTAT_THEME   :=CAD_RESULTAT_THEME();
 i binary_integer ;
 dernier binary_integer ;
 BEGIN
 OPEN cur_pop;
 LOOP
 FETCH cur_pop INTO ligne_pop;
 EXIT
 WHEN cur_pop%NOTFOUND ;
 tmp     :=CAD_INTERRO_THEME(ligne_pop.matric,code_theme,djour,'O') ;
 i       := tmp.first ;
 WHILE i IS NOT NULL
 LOOP
 dernier:=NVL(retour.last,0);
 retour.extend;
 retour(dernier+1):=tmp(i);
 i                := tmp.next(i) ;
 END LOOP;
 END LOOP;
 CLOSE cur_pop;
 RETURN retour;
 END CAD_INTERRO_THEME_COLL;
 FUNCTION CAD_SOLDE(
 MATRIC   IN VARCHAR2 ,
 DATEJOUR IN VARCHAR2 ,
 RUB      IN VARCHAR2 )
 RETURN NUMBER
 AS
 CURSOR cur_cpt
 IS
 SELECT code_compteur,
 pot_solde,
 pot_variation,
 min_soldej,
 min_soldeh,
 ordre
 FROM CAD_PARAM_LIEN_RUB_CPT
 WHERE RUB_VAL_JOUR =rub
 ORDER BY ordre;
 ligne_cpt cur_cpt%ROWTYPE;
 retour NUMBER:=0;
 req    VARCHAR(1000);
 unite  VARCHAR(1);
 valcpt NUMBER;
 BEGIN
 unite:= cad_unite(matric,datejour,rub);
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO ligne_cpt;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 req    :='select * from (select ';
 IF unite='H' THEN
 req  :=req||'nvl(POT'||ligne_cpt.pot_solde||'_FH,nvl(POT'||ligne_cpt.pot_solde||'_VALEURH,0))';
 ELSE
 req:=req||'nvl(POT'||ligne_cpt.pot_solde||'_FJ,nvl(POT'||ligne_cpt.pot_solde||'_VALEURJ,0))';
 END IF;
 req:=req||' from CAD_COMPTEUR where code_compteur=:cpt and matricule =:matric and djour <=:datejour order by djour desc,typemj desc) where rownum=1';
 BEGIN
 EXECUTE IMMEDIATE req INTO valcpt USING ligne_cpt.code_compteur,
 matric,
 datejour ;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 valcpt:=0;
 END;
 retour:=retour+valcpt;
 END LOOP;
 CLOSE cur_cpt;
 RETURN retour;
 END CAD_SOLDE;
 PROCEDURE CAD_BASCULE_UNIQUE(
 IDMATRIC    IN NUMBER ,
 BASCULE     IN VARCHAR2 ,
 DATEBAS     IN VARCHAR2,
 SUPPRESSION IN VARCHAR2)
 AS
 pos  NUMBER:=0;
 subs VARCHAR2(4000);
 req CLOB;
 requpdate VARCHAR2(4000);
 djourReq  VARCHAR2(1000);
 dteRecalc VARCHAR2(8);
 TYPE Tab_Rowid
 IS
 TABLE OF VARCHAR(100);
 T_Id Tab_Rowid;
 T_IdBasc Tab_Rowid;
 code_basc_prec VARCHAR(20);
 TYPE T_param
 IS
 RECORD
 (
 cpt_dest VARCHAR(20),
 requete CLOB );
 param T_param;
 BEGIN
 SELECT compteur_dest,
 requetes
 INTO param
 FROM CAD_PARAM_REGLES_MAJ
 WHERE code_bascule=bascule;
 DELETE
 FROM CAD_COMPTEUR
 WHERE TYPEMJ     ='I'
 AND CODE_COMPTEUR=param.cpt_dest
 AND DJOUR        =DATEBAS
 AND MATRICULE   IN
 (SELECT matricule FROM CAD_CALCUL_EN_COURS_MATRIC WHERE id=idmatric
 );
 IF SUPPRESSION IS NULL THEN
 INSERT
 INTO CAD_COMPTEUR
 (
 matricule,
 code_compteur,
 djour,
 typemj,
 date_maj
 )
 (SELECT matricule,
 param.cpt_dest,
 datebas,
 'I',
 sysdate
 FROM CAD_CALCUL_EN_COURS_MATRIC
 WHERE id=idmatric
 );
 req :=REPLACE(param.requete,'VALEURJ=','FJ=');
 req :=REPLACE(req,'VALEURH=','FH=');
 DECLARE
 CURSOR cur_cpt
 IS
 SELECT cad_compteur.*,
 cad_compteur.rowid
 FROM cad_compteur, CAD_CALCUL_EN_COURS_MATRIC
 WHERE TYPEMJ     ='I'
 AND CODE_COMPTEUR=param.cpt_dest
 AND DJOUR        =DATEBAS
 AND cad_compteur.MATRICULE =CAD_CALCUL_EN_COURS_MATRIC.matricule
 and   CAD_CALCUL_EN_COURS_MATRIC.id=idmatric;
 lig_cpt cur_cpt%rowtype;
 BEGIN
 OPEN cur_cpt;
 LOOP
 FETCH cur_cpt INTO lig_cpt;
 EXIT
 WHEN cur_cpt%NOTFOUND ;
 -- select max(d.djour)  into djourReq from CAD_COMPTEUR d where d.MATRICULE=lig_cpt.MATRICULE and d.CODE_COMPTEUR=lignebascule.COMPTEUR_ORI AND DJOUR<DATEBAS;
 IF t_id IS NULL THEN
 t_id  :=Tab_Rowid(lig_cpt.rowid);
 ELSE
 t_id.extend();
 t_id(t_id.last):=lig_cpt.rowid;
 END IF;
 END LOOP;
 CLOSE cur_cpt;
 END;
 djourReq           :=' (select max(d.djour)  from CAD_COMPTEUR d where d.MATRICULE=ca.MATRICULE and d.CODE_COMPTEUR=ori.code_compteur AND d.DJOUR<'''||datebas||'''  )  and typemj=(select max(typemj) from CAD_COMPTEUR d where d.code_compteur = ori.code_compteur and d.djour = ori.djour and d.matricule = ori.matricule) ';
 IF t_id            IS NOT NULL THEN
 WHILE LENGTH(req) >0
 LOOP
 IF instr(req,';')>0 THEN
 subs          :=SUBSTR(req,0,instr(req,';'));
 ELSE
 subs:=req;
 END IF;
 req      :=REPLACE(req,subs,'');
 req      :=REPLACE(req,subs,'');
 subs     :=REPLACE(subs,'_DJOUR_',djourReq);
 subs     :=REPLACE(subs,';','');
 requpdate:='update CAD_COMPTEUR ca set '||subs||' where rowid=:1' ;
 FORALL i IN T_Id.first..T_Id.last
 EXECUTE immediate requpdate USING t_id(i);
 END LOOP;
 END IF;
 END IF;
 SELECT MIN(dte)
 INTO dteRecalc
 FROM
 (SELECT MAX(d.djour) AS dte,
 d.matricule
 FROM CAD_COMPTEUR d,cad_calcul_en_cours_matric
 WHERE d.MATRICULE = cad_calcul_en_cours_matric.matricule and cad_calcul_en_cours_matric.id=IDMATRIC
 AND d.CODE_COMPTEUR=param.cpt_dest
 AND d.DJOUR
 ||d.typemj<DATEBAS
 ||'I'
 GROUP BY d.matricule
 );
 CAD_MAJ_VALEUR_LISTE_RUBJOUR( IDMATRIC , dteRecalc , NULL , 'true' , 'true' );
 /*EXCEPTION
 WHEN OTHERS THEN
 err_code := SQLCODE;
 err_msg  :=SQLERRM;
 CAD_ERREUR(IDMATRIC ,'CAD_BASCULE_UNIQUE', IDMATRIC||','|| BASCULE ||','|| DATEBAS  ,err_code||'-'||err_msg);
 raise;*/
 END CAD_BASCULE_UNIQUE;
 END CAD;
##
CALC_HP
=SQL=
create or replace PACKAGE CALC_HP IS

p_date_deb DATE;
p_date_fin DATE;
horaireRemu VARCHAR(255);--horaire remu.	
horairePres VARCHAR(255); -- tmp horaire pres. 
dateDebTranchSitu DATE;   --tmp loop cycle dans situation
dateFinTranchSitu DATE;   --tmp loop cycle dans situation
dateEnCours DATE;         --date en cours pour calcul LOOP decomposerArrCycleDcySituationEnTrancheAndCreateHP
numJourCanevas NUMBER(5,0);--tmp for LOOP decomposerArrCycleDcySituationEnTrancheAndCreateHP
nbreHeures NUMBER(5,2);    --tmp for LOOP decomposerArrCycleDcySituationEnTrancheAndCreateHP
jourSemaine VARCHAR2(15);
 isRetro NUMBER;

TYPE map_horaire_par_jour IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
arrHoraireParJour map_horaire_par_jour;

/*****************/
TYPE TgeRefHprType IS RECORD (
    NUMPAC	VARCHAR2(6 BYTE),
    CODE_HOR_PRES	NUMBER(3,0),
    DATE_DEBUT	DATE,
    DATE_FIN	DATE,
    HRS_LUNDI	NUMBER(4,2),
    HRS_MARDI	NUMBER(4,2),
    HRS_MERCREDI	NUMBER(4,2),
    HRS_JEUDI	NUMBER(4,2),
    HRS_VENDREDI	NUMBER(4,2),
    HRS_SAMEDI	NUMBER(4,2),
    HRS_DIMANCHE	NUMBER(4,2)
);
--TYPE map_hpr IS TABLE OF TgeRefHprType INDEX BY VARCHAR2(30);
cur_TgeRefhpr TgeRefHprType;
--l_map_hpr map_hpr;
TYPE type_List_arr_2 IS VARRAY(999) OF TgeRefHprType;
lst_2 type_List_arr_2;
arrCycleHprSituation type_List_arr_2;


TYPE TgeRefDcyCy1Cy2Type IS RECORD (
	NUMPAC						VARCHAR2(6 BYTE),
	CODE_CLASSE_HORAIRE_OTT 	NUMBER(3,0),
	DATE_DEBUT 					DATE,
	DATE_FIN 					DATE,
	CODE_CYCLE_OTT 				NUMBER(3,0),
	CODE_CANEVAS_CYCLE_OTT 		NUMBER(3,0),
	NOMBRE_JOURS_CYCLE			NUMBER(3,0),
	NUM_JOUR_ENTREE_CANEVAS		NUMBER(3,0),
	NOMBRE_HEURE_1 				NUMBER(5,2),
	NOMBRE_HEURE_2				NUMBER(5,2),
	NOMBRE_HEURE_3				NUMBER(5,2),
	NOMBRE_HEURE_4				NUMBER(5,2),
	NOMBRE_HEURE_5				NUMBER(5,2),
	NOMBRE_HEURE_6				NUMBER(5,2),
	NOMBRE_HEURE_7				NUMBER(5,2),
	NOMBRE_HEURE_8				NUMBER(5,2),
	NOMBRE_HEURE_9				NUMBER(5,2),
	NOMBRE_HEURE_10				NUMBER(5,2),
	NOMBRE_HEURE_11				NUMBER(5,2),
	NOMBRE_HEURE_12				NUMBER(5,2),
	NOMBRE_HEURE_13				NUMBER(5,2),
	NOMBRE_HEURE_14				NUMBER(5,2),
	NOMBRE_HEURE_15				NUMBER(5,2),
	NOMBRE_HEURE_16				NUMBER(5,2), 
	NOMBRE_HEURE_17				NUMBER(5,2),
	NOMBRE_HEURE_18				NUMBER(5,2),
	NOMBRE_HEURE_19				NUMBER(5,2),
	NOMBRE_HEURE_20				NUMBER(5,2),
	NOMBRE_HEURE_21				NUMBER(5,2)
	) ;
  /* FOR HASHMAP AND RECORD */
--TYPE map_varchar IS TABLE OF TgeRefDcyCy1Cy2Type INDEX BY VARCHAR2(30);
cur_TgeRefDcy TgeRefDcyCy1Cy2Type;
--l_map map_varchar;
TYPE type_List_arr IS VARRAY(999) OF TgeRefDcyCy1Cy2Type;
lst_1 type_List_arr;
arrCycleSituation type_List_arr;
  /***************/
  
  TYPE TGE_REF_MAPDOType IS RECORD (
    NUMPAC	VARCHAR2(6),
    ELEMENT	VARCHAR2(4),
    OCCURENCE	VARCHAR2(2),
    DONNEEGXP	VARCHAR2(50),
    TABLEGXP	VARCHAR2(24),
    DONNFILTRE	VARCHAR2(50),
    OPERFILTRE	VARCHAR2(2),
    VALFILTRE	VARCHAR2(15),
    TRTPARTICULIER	VARCHAR2(4000),
    ENVOI_SYSTEMATIQUE	VARCHAR2(1),
    FORCABLE_ECRAN_GENERE	VARCHAR2(1)
	) ;
cur_TgeRefmapdo TGE_REF_MAPDOType;
TYPE type_List_arr_3 IS VARRAY(999) OF TGE_REF_MAPDOType;
lst_3 type_List_arr_3;


--TYPE dachtype IS RECORD();
 TYPE DACH_Type IS RECORD (PAIEZAD VARCHAR2(8),
    MATRIC VARCHAR2(32),
    NUMPAC VARCHAR2(6),
    PACMAT VARCHAR2(8),
    NUMCNT  NUMBER(9,0),
    DATE_EFF  DATE,
    DATE_FIN  DATE,
    ZA819  NUMBER(3,0),
    ZA820  NUMBER(3,0),
    ZA996  VARCHAR2(1),
    DEBUT_PER_GENERATION_HP DATE,
    FIN_PER_GENERATION_HP  DATE);
 cur_dachtype DACH_Type;
cur_periodetype VARCHAR2(10);
 
 TYPE type_List_arr_4 IS VARRAY(999) OF DACH_Type;
 lst_4 type_List_arr_4;
 

  
 sql_1 CLOB;
 sql_2 CLOB;
 sql_3 CLOB;
 sql_4 CLOB;

 sql_periode_hp CLOB ;
 
 
 
 cpt number:=1;
 
 TYPE SituationType IS RECORD (
    numpac	VARCHAR2(30),
    pacmat	VARCHAR2(30),
    paieZad	VARCHAR2(30),
    numcnt	NUMBER(13,0),
    code_classe_horaire_ott	NUMBER(13,0),
    code_cycle_ott	NUMBER(13,0),
    dateDeb	DATE,
    dateFin	DATE,
    isGtaT1	boolean,
    HRS_SAMEDI	NUMBER(4,2),
    HRS_DIMANCHE	NUMBER(4,2)
);
--l_map_hpr map_hpr;
TYPE SituationType_arr_2 IS VARRAY(99) OF SituationType;
lst_Situation SituationType_arr_2;
 
 /**
  * récupérer valeur de l'objet TgeRefDcyCy1Cy2 selon chaine de caractére (nom colonne)
  */
  FUNCTION calculateNomJourCanevas( ligneTgeRefHprType IN TgeRefHprType, dateEnCour IN DATE  ) RETURN VARCHAR;
  
  /**
  * retourne le numero de jour canevas 
  */
 FUNCTION calculateNumJourCanevas( ligneDcyCy1Cy2 IN TgeRefDcyCy1Cy2Type, local_dateEnCours IN DATE  ) RETURN NUMBER;
    
  /**
  * récupérer valeur de l'objet TgeRefDcyCy1Cy2 selon chaine de caractére (nom colonne)
  */
  FUNCTION getValOfCycle( val IN VARCHAR2, obj IN TgeRefDcyCy1Cy2Type) RETURN NUMBER;
  
   FUNCTION getHprHoursNbre( val IN NUMBER, obj IN TgeRefHprType  )  RETURN NUMBER;
  
  
  /*
  * get value from DACH object selon clé
  */
 FUNCTION getValOfDACH( val IN VARCHAR2, obj IN DACH_Type  )  RETURN VARCHAR2;
  
  /*
  *   insertion d'un incident paie hors absence (a la fin de du traitement)
  */
PROCEDURE insertIncidentPaieHorsAbs( nbrHeur IN NUMBER,dateActu IN DATE, p_unIncident IN SituationType,  p_login IN VARCHAR2, v_periode_limiteRetro IN VARCHAR2);
  
PROCEDURE principal( p_numpac IN VARCHAR2
 , p_pacmat IN VARCHAR2
 , p_paiezad IN VARCHAR2
 , p_numcnt IN NUMBER
 , p_date_eff IN VARCHAR2 
 , p_date_sortie_sit_bo IN VARCHAR2
 , p_login IN VARCHAR2
 , p_isDeleting IN NUMBER
  ); 
 
 
END CALC_HP;

##
CALC_HP
=SQL=
create or replace PACKAGE BODY CALC_HP AS

 /**
  * récupérer valeur de l'objet TgeRefDcyCy1Cy2 selon chaine de caractére (nom colonne)
  */
  FUNCTION calculateNomJourCanevas( ligneTgeRefHprType IN TgeRefHprType, dateEnCour IN DATE  )
  RETURN VARCHAR
  IS
  numJr NUMBER := 0;
  BEGIN
  select to_char(dateEnCour,'D') INTO numJr from dual;
  CASE numJr
    WHEN 1 THEN  RETURN 'Lundi';
    WHEN 2 THEN  RETURN 'Mardi';
    WHEN 3 THEN  RETURN 'Mercredi';
    WHEN 4 THEN  RETURN 'Jeudi';
    WHEN 5 THEN  RETURN 'Vendredi';
    WHEN 6 THEN  RETURN 'Samedi';
    WHEN 7 THEN  RETURN 'Dimanche';
    ELSE RETURN 'Erreur numéro jour';
  END CASE;
  
  
  END calculateNomJourCanevas;
  
  /**
  * retourne le numero de jour canevas 
  */
 FUNCTION calculateNumJourCanevas( ligneDcyCy1Cy2 IN TgeRefDcyCy1Cy2Type, local_dateEnCours IN DATE  )
  RETURN NUMBER
  IS
  local_numJourCanevas NUMBER;
  res1 NUMBER;
  res2 NUMBER;
  
  tmp NUMBER;
  tmp2 NUMBER;
  BEGIN
    IF((ligneDcyCy1Cy2.Date_debut-local_dateEnCours+ligneDcyCy1Cy2.Num_jour_entree_canevas)< ligneDcyCy1Cy2.Nombre_jours_cycle) THEN
      res1:=(ligneDcyCy1Cy2.date_debut - local_dateEnCours) / ligneDcyCy1Cy2.Nombre_jours_cycle;
      res2:=ABS((ligneDcyCy1Cy2.date_debut - local_dateEnCours)) + 1 - (TRUNC(ABS(res1)) * ligneDcyCy1Cy2.Nombre_jours_cycle); 
      
      tmp2:=TRUNC(ABS(res1));
      
     tmp:= ABS((ligneDcyCy1Cy2.date_debut - local_dateEnCours));
      
      
      IF( (res2-1) > ligneDcyCy1Cy2.Nombre_jours_cycle - ligneDcyCy1Cy2.Num_jour_entree_canevas ) THEN
        local_numJourCanevas := res2- (ligneDcyCy1Cy2.Nombre_jours_cycle - ligneDcyCy1Cy2.Num_jour_entree_canevas);
       ELSE
        local_numJourCanevas := res2 + ligneDcyCy1Cy2.Num_jour_entree_canevas-1;
      END IF;
    ELSE
        local_numJourCanevas :=ligneDcyCy1Cy2.Num_jour_entree_canevas + ABS(ligneDcyCy1Cy2.date_debut - local_dateEnCours); --
    END IF;
    
    RETURN local_numJourCanevas;
  END calculateNumJourCanevas;
    
  /**
  * récupérer valeur de l'objet TgeRefDcyCy1Cy2 selon chaine de caractére (nom colonne)
  */
  FUNCTION getValOfCycle( val IN VARCHAR2, obj IN TgeRefDcyCy1Cy2Type  )
  RETURN NUMBER
  IS
  BEGIN
      IF val='NOMBRE_HEURE_1' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_1); END IF;
      IF val='NOMBRE_HEURE_2' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_2); END IF;
      IF val='NOMBRE_HEURE_3' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_3); END IF;
      IF val='NOMBRE_HEURE_4' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_4); END IF;
      IF val='NOMBRE_HEURE_5' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_5); END IF;
      IF val='NOMBRE_HEURE_6' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_6); END IF;
      IF val='NOMBRE_HEURE_7' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_7); END IF;
      IF val='NOMBRE_HEURE_8' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_8); END IF;
      IF val='NOMBRE_HEURE_9' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_9); END IF;
      IF val='NOMBRE_HEURE_10' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_10); END IF;
      IF val='NOMBRE_HEURE_11' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_11); END IF;
      IF val='NOMBRE_HEURE_12' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_12); END IF;
      IF val='NOMBRE_HEURE_13' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_13); END IF;
      IF val='NOMBRE_HEURE_14' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_14); END IF;
      IF val='NOMBRE_HEURE_15' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_15); END IF;
      IF val='NOMBRE_HEURE_16' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_16); END IF;
      IF val='NOMBRE_HEURE_17' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_17); END IF;
      IF val='NOMBRE_HEURE_18' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_18); END IF;
      IF val='NOMBRE_HEURE_19' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_19); END IF;
      IF val='NOMBRE_HEURE_20' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_20); END IF;
      IF val='NOMBRE_HEURE_21' THEN RETURN TO_NUMBER(obj.NOMBRE_HEURE_21); END IF;
      RETURN NULL;
  END getValOfCycle;
  
   FUNCTION getHprHoursNbre( val IN NUMBER, obj IN TgeRefHprType  )
  RETURN NUMBER
  IS
  BEGIN
      IF val='Lundi' THEN RETURN TO_NUMBER(obj.HRS_LUNDI); END IF;
      IF val='Mardi' THEN RETURN TO_NUMBER(obj.HRS_MARDI); END IF;
      IF val='Mercredi' THEN RETURN TO_NUMBER(obj.HRS_MERCREDI); END IF;
      IF val='Jeudi' THEN RETURN TO_NUMBER(obj.HRS_JEUDI); END IF;
      IF val='Vendredi' THEN RETURN TO_NUMBER(obj.HRS_VENDREDI); END IF;
      IF val='Samedi' THEN RETURN TO_NUMBER(obj.HRS_SAMEDI); END IF;
      IF val='Dimanche' THEN RETURN TO_NUMBER(obj.HRS_DIMANCHE); END IF;
      RETURN NULL;
  END getHprHoursNbre;
  
  
  /*
  * get value from DACH object selon clé
  */
 FUNCTION getValOfDACH( val IN VARCHAR2, obj IN DACH_Type  )
  RETURN VARCHAR2
  IS
  BEGIN
    IF val='ZA996' THEN RETURN TO_CHAR(obj.ZA996); END IF;
    IF val='ZA819' THEN RETURN TO_CHAR(obj.ZA819); END IF;
    IF val='ZA820' THEN RETURN TO_CHAR(obj.ZA820); END IF;
    return '';
  END getValOfDACH;
  
  /*
  *   insertion d'un incident paie hors absence (a la fin de du traitement)
  */
PROCEDURE insertIncidentPaieHorsAbs( nbrHeur IN NUMBER,dateActu IN DATE, p_unIncident IN SituationType, p_login IN VARCHAR2,v_periode_limiteRetro VARCHAR2 )
  IS
  seq NUMBER:='';
 cur_5 SYS_REFCURSOR;
 v_periode_retro VARCHAR2(10) ;
  
 BEGIN
 --	En rétro, CALC_HP calcule les HP à partir du mois de la date d'effet en entrée et sur tous les mois suivants jusqu’à la période en cours.
 IF isRetro='1'  THEN

 sql_periode_hp := ' SELECT MOIS_PAIE 
 FROM TGE_PERIODE_RECUEIL_PAIEZAD
 WHERE numpac = ''' || p_unIncident.numPac || '''
 AND paiezad  = '''|| p_unIncident.paieZad ||'''
AND '''|| dateActu ||''' BETWEEN DEBUT_PER_GENERATION_HP AND FIN_PER_GENERATION_HP
AND MOIS_PAIE>=' || v_periode_limiteRetro ;
 
 cpt:=1;
 OPEN cur_5 FOR sql_periode_hp;
 LOOP
 FETCH cur_5 INTO cur_periodetype;
 EXIT WHEN cur_5%NOTFOUND;
 
 v_periode_retro := cur_periodetype;
  select SEQ_TGE_INCIDENTS_PAIE.NEXTVAL into seq from dual;
  
  INSERT INTO TGE_INCIDENTS_PAIE
	 (ID, NUMPAC, PAIEZAD, PERIODE, TYPE_TRAITEMENT, DATE_EFFET, TYPE_IP, CODE_IP
			, CODE_IMPUTATION, HEURES, ORIGINE, LOGIN_CREATE, DATE_CREATE, ROLE_CREATE, ORIGINE_CREATE
			, LOGIN_MAJ, DATE_MAJ, ROLE_MAJ, ORIGINE_MAJ, CLE_IMPORT, CLE_ABSENCE, IDPACMAT, ENVOYE, JOUR_OUVRABLE
			,JOUR_OUVRE , JOUR_OEUVRE, JOUR_CALENDAIRE, JOUR_HEURES )
			 values (
			  seq --ID
			  , p_unIncident.numPac --NUMPAC
			  , p_unIncident.paieZad --PAIEZAD
			  , TO_DATE(v_periode_retro || 01, 'yyyyMMdd') --PERIODE
			  , (select CODETYPTRT  from (select CODETYPTRT from TGE_REF_TYPETRT where (NUMPAC=p_unIncident.numPac OR NUMPAC='*') and CODETYPTRT='TT' order by NUMPAC desc) where rownum = 1 ) --TYPE_TRAITEMENT
			  ,  dateActu --DATE_EFFET
			  , 'T' --TYPE_IP
			  , 'HP' --CODE_IP
			  , '' -- p_unIncident.code_imputation;
			  , nbrHeur --HEURES

			  , 'T' --ORIGINE
			  , p_login --LOGIN_CREATE
			  , sysdate --DATE_CREATE
			  , 'ADM' -- info non trouver :'( !!ROLE_CREATE DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
			  , 'TRG_DIC_ADM_CONTRAT_HISTO' --ORIGINE_CREATE DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
			  , p_login --LOGIN_MAJ
			  , sysdate --Date MAJ
			  , 'ADM' -- ROLE_MAJ
			  , 'TRG_DIC_ADM_CONTRAT_HISTO' --ORIGINE_MAJ DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
			  , null --CLE_IMPORT

				,  null --CLE_ABSENCE
			  ,  p_unIncident.numpac||p_unIncident.pacmat --IDPACMAT
			  ,  '' --ENVOYE
			
			  ,  null -- p_unIncident.jour_ouvrable
			  ,  null -- p_unIncident.jour_ouvre
			  ,  null --p_unIncident.jour_oeuvre
			  ,  null --p_unIncident.jour_calendaire
			  ,  null --p_unIncident.jour_heures
			  );
	cpt:=cpt+1;
 END LOOP;
 ELSE 
 select SEQ_TGE_INCIDENTS_PAIE.NEXTVAL into seq from dual;
 
 INSERT INTO TGE_INCIDENTS_PAIE
 (ID, NUMPAC, PAIEZAD, PERIODE, TYPE_TRAITEMENT, DATE_EFFET, TYPE_IP, CODE_IP
 , CODE_IMPUTATION, HEURES, ORIGINE, LOGIN_CREATE, DATE_CREATE, ROLE_CREATE, ORIGINE_CREATE
 , LOGIN_MAJ, DATE_MAJ, ROLE_MAJ, ORIGINE_MAJ, CLE_IMPORT, CLE_ABSENCE, IDPACMAT, ENVOYE, JOUR_OUVRABLE
 ,JOUR_OUVRE , JOUR_OEUVRE, JOUR_CALENDAIRE, JOUR_HEURES )
 values (
 seq --ID
 , p_unIncident.numPac --NUMPAC
 , p_unIncident.paieZad --PAIEZAD 
 , TO_DATE((select periodeEnCours from TGE_REF_PAC where numpac=p_unIncident.numPac) , 'YYYYMM') --PERIODE
 , (select CODETYPTRT  from (select CODETYPTRT from TGE_REF_TYPETRT where (NUMPAC=p_unIncident.numPac OR NUMPAC='*') and CODETYPTRT='TT' order by NUMPAC desc) where rownum = 1 ) --TYPE_TRAITEMENT
 ,  dateActu --DATE_EFFET
 , 'T' --TYPE_IP
 , 'HP' --CODE_IP
 , '' -- p_unIncident.code_imputation;
 , nbrHeur --HEURES
 , 'T' --ORIGINE
 , p_login --LOGIN_CREATE
 , sysdate --DATE_CREATE
 , 'ADM' -- info non trouver :'( !!ROLE_CREATE DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
 , 'TRG_DIC_ADM_CONTRAT_HISTO' --ORIGINE_CREATE DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
 , p_login --LOGIN_MAJ
 , sysdate --Date MAJ
 , 'ADM' -- ROLE_MAJ
 , 'TRG_DIC_ADM_CONTRAT_HISTO' --ORIGINE_MAJ DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER -------
 , null --CLE_IMPORT
 
 ,  null --CLE_ABSENCE
 ,  p_unIncident.numpac||p_unIncident.pacmat --IDPACMAT
 ,  '' --ENVOYE
 
 ,  null -- p_unIncident.jour_ouvrable
 ,  null -- p_unIncident.jour_ouvre
 ,  null --p_unIncident.jour_oeuvre
 ,  null --p_unIncident.jour_calendaire
 ,  null --p_unIncident.jour_heures
 );
 END IF ;
  END;
  
  
  
   PROCEDURE principal( p_numpac IN VARCHAR2
 , p_pacmat IN VARCHAR2
 , p_paiezad IN VARCHAR2
 , p_numcnt IN NUMBER
 , p_date_eff IN VARCHAR2 
 , p_date_sortie_sit_bo IN VARCHAR2
 , p_login IN VARCHAR2
 , p_isDeleting IN NUMBER
)
  IS
    cur_1 SYS_REFCURSOR; 
    cur_2 SYS_REFCURSOR; 
    cur_3 SYS_REFCURSOR; 
    cur_4 SYS_REFCURSOR; 
    debut_calcul_hp_DB DATE;
    v_period_en_cour varchar2(10);
    v_deb_retro varchar2(10);
    v_fin_per_gen_hp varchar2(10);
    m_embauche varchar2(6);
 	d_limiteMaj DATE;
 	d_dsdcn DATE;
 	v_count number;
    err_msg  VARCHAR(1000);
 	err_code VARCHAR(200);
    p_id NUMBER; 
    numJourCanevas NUMBER;
    dateEnCours DATE;
    dateFinTranchSitu DATE;
    dateDebTranchSitu DATE;
    v_periode_limiteRetro VARCHAR(6);
  BEGIN
 
 SELECT GAP_TRT_SEQ_ID.nextval INTO p_id FROM DUAL;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Begin)','Début de recalcul des HP pour la situation ( numpac:  '||p_numpac ||', pacmat: '|| p_pacmat ||', numcnt: '||p_numcnt|| ', paiezad: '|| p_paiezad ||', date_eff : '||p_date_eff||')');
	  isRetro:= 0 ;
      p_date_deb := TO_DATE(p_date_eff,'DD/MM/YYYY');
 	  p_date_fin := TO_DATE(p_date_sortie_sit_bo,'DD/MM/YYYY');
	  select count(*) into v_count from tge_periode_recueil_paiezad where NUMPAC=p_numpac and PAIEZAD=p_paiezad ;
  	  if  v_count<1 THEN 
 			FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (End)','Fin de CALC HP. La table TGE_PERIODE_RECUEIL_PAIEZAD n''est pas alimenté pour le paiezad '||p_paiezad);
 	    RETURN;
 	  END IF ; 

    /**** IS RETRO ? IS FUTUR *****/
FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Recup Periode)','Récupération de la période en cours, début retro et fin génération HP à partir de TGE_REF_PAC pour le numpac : '||p_numpac);
	 select pac.PERIODEENCOURS,pac.DEB_RETRO,tprp.fin_per_generation_hp INTO v_period_en_cour,v_deb_retro,v_fin_per_gen_hp
	 from tge_ref_pac pac
	 LEFT join tge_periode_recueil_paiezad tprp
	 ON (pac.PERIODEENCOURS=tprp.MOIS_PAIE and pac.NUMPAC = tprp.NUMPAC  and tprp.PAIEZAD=p_paiezad )
	 where pac.NUMPAC=p_numpac  ;
	 IF  ((v_fin_per_gen_hp is null )   and  (p_date_sortie_sit_bo= '31/12/2099'  )) THEN
	 	FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (End)','Fin de CALC HP. La date de fin de recalcul est 20991231'); 
	 RETURN;
	 END IF;

--IF DACH FUTUR ALORS pas calcul HP
    IF ( v_fin_per_gen_hp is not null and p_date_deb>v_fin_per_gen_hp)THEN
		FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (End)','Fin de CALC HP. La date d''effet de la situation modifiée '||p_date_eff||' est dans le future, donc pas de recalcul des HP pour le paiezad '|| p_paiezad); RETURN;
      RETURN; 
    END IF;

/**** IS retro ***/
IF v_deb_retro IS NOT NULL AND v_period_en_cour > v_deb_retro THEN

BEGIN
	isRetro:=1 ;
 	FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Recup mois d''embauche)','Récupération du mois d''embauche pour le numpac : '||p_numpac ||'  paiezad '||p_paiezad );
	SELECT MIN(MOIS_PAIE) INTO m_embauche FROM TGE_PERIODE_RECUEIL_PAIEZAD WHERE NUMPAC =p_numpac AND paiezad  =p_paiezad  ;
	
	SELECT Greatest (m_embauche ,pac.deb_histo_retro,TO_CHAR(ADD_MONTHS(TO_DATE(pac.periodeencours,'YYYYMM'), - pac.nb_mois_retro),'YYYYMM'),NVL( S.PREMIERE_PAIE, '190101'))
	INTO v_periode_limiteRetro FROM TGE_REF_PAC pac INNER JOIN SECUPACMAT S ON S.NUMPAC=pac.NUMPAC AND S.PACMAT = p_pacmat AND S.NUMPAC = p_numpac ;
	
	FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Recup date d''embauche)','' );
	BEGIN
	 	SELECT DSDCN INTO d_dsdcn  FROM DIC_ADM_CONTRAT WHERE NUMPAC  =p_numpac and PACMAT = p_pacmat and NUMCNT = p_numcnt; 
	 EXCEPTION
	 WHEN OTHERS THEN
	 d_dsdcn:=  to_date ('31122099', 'ddmmyyyy');
	END; 
	FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Recup date limite retro)','Récupération de la date limite retro le numpac : '||p_numpac ||'  paiezad '||p_paiezad );
	 BEGIN 
	
	 	SELECT DEBUT_PERIODE_RECUEIL INTO d_limiteMaj FROM TGE_PERIODE_RECUEIL_PAIEZAD WHERE MOIS_PAIE=
		 (SELECT Greatest (m_embauche ,pac.deb_histo_retro,TO_CHAR(ADD_MONTHS(TO_DATE(pac.periodeencours,'YYYYMM'), - pac.nb_mois_retro),'YYYYMM'),NVL( S.PREMIERE_PAIE, '190101'))
		 FROM TGE_REF_PAC pac
 		INNER JOIN SECUPACMAT S ON S.NUMPAC=pac.NUMPAC AND S.PACMAT = p_pacmat AND S.NUMPAC = p_numpac 
		 )
		 AND NUMPAC  =p_numpac
		 AND PAIEZAD =p_paiezad;
	 EXCEPTION
	 WHEN others THEN
	  	d_limiteMaj := nvl (d_dsdcn,  to_date ('31122099', 'ddmmyyyy')); 
	 END;
	 IF (d_limiteMaj IS NULL)  THEN  
	 	d_limiteMaj := nvl (d_dsdcn,  to_date ('31122099', 'ddmmyyyy')); 
	 END IF;  
	 FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Recup date deb genHP)','Récupération de la date de début de génération des HP en mode retro pour le numpac : '||p_numpac ||'  paiezad '||p_paiezad );
	 SELECT
	 	debut_per_generation_hp  INTO debut_calcul_hp_DB
	 	FROM
	 tge_periode_recueil_paiezad tprp, tge_ref_pac p
	 WHERE
		 tprp.numpac = p_numpac
	 AND tprp.paiezad = p_paiezad
	 AND P.numpac = p_numpac
	 AND tprp.mois_paie = nvl (--mois_paie_hp
	 ( SELECT  MIN(tprp.mois_paie) FROM
	 tge_periode_recueil_paiezad tprp, tge_ref_pac pac
	 WHERE
	 tprp.numpac = p_numpac -- NEW.numpac
	 AND  tprp.numpac = pac.numpac
	 AND tprp.paiezad = p_paiezad -- NEW.paiezad
	 AND tprp.fin_periode_paie >=p_date_deb-- NEW.date_sortie_sit_bo
	 AND tprp.mois_paie >= greatest(pac.deb_histo_retro,TO_CHAR(ADD_MONTHS(TO_DATE(pac.periodeencours,'YYYYMM'), - pac.nb_mois_retro),'YYYYMM'))
	
	 ), p.periodeencours);
  EXCEPTION
 WHEN others THEN
 	debut_calcul_hp_DB:=null;
 END;

/**** fin retro ****/
ELSE
/*** NOT RETRO ***/
BEGIN
        select debut_per_generation_hp  INTO debut_calcul_hp_DB 
            from tge_periode_recueil_paiezad 
            where numpac=p_numpac
              and PAIEZAD=p_paiezad
              and MOIS_PAIE=(select PERIODEENCOURS from tge_ref_pac where NUMPAC=p_numpac );
EXCEPTION
 WHEN others THEN
 	debut_calcul_hp_DB:=null;
 END;
END IF; -- END test is RETRO    


 p_date_deb:=GREATEST(NVL(debut_calcul_hp_DB,p_date_deb),NVL(d_limiteMaj,debut_calcul_hp_DB) );

p_date_fin:=NVL(v_fin_per_gen_hp,p_date_fin);

    
   sql_1:='SELECT * 
            FROM
              ( SELECT dcy.numpac            AS numpac, dcy.code_classe_horaire_ott AS code_classe_horaire_ott, dcy.date_debut              AS date_debut,
                dcy.date_fin                AS date_fin, dcy.code_cycle_ott          AS code_cycle_ott,
                cy1.code_canevas_cycle_ott  AS code_canevas_cycle_ott, cy1.nombre_jours_cycle      AS nombre_jours_cycle,
                cy1.num_jour_entree_canevas AS num_jour_entree_canevas,    cy2.num_jour_dans_cycle     AS num_jour_dans_cycle, cy2.nombre_heure_1          AS nombre_heure
                
              FROM tge_ref_dcy dcy,  tge_ref_cy1 cy1,  tge_ref_cy2 cy2
              WHERE  dcy.numpac              IN ('''|| p_numpac /*SUBSTR(:NEW.IDPACMAT,0,6)*/ ||''')
              AND  cy1.numpac                 = dcy.numpac  AND cy2.numpac                 = cy1.numpac
              AND dcy.code_cycle_ott         = cy1.code_cycle_ott  AND cy1.code_canevas_cycle_ott = cy2.code_canevas_cycle_ott
              ORDER BY dcy.code_cycle_ott, dcy.code_classe_horaire_ott, cy1.code_canevas_cycle_ott, cy1.num_jour_entree_canevas
              ) pivot 	( MAX(nombre_heure) FOR num_jour_dans_cycle IN ( 	''1'' AS "NOMBRE_HEURE_1", ''2'' AS "NOMBRE_HEURE_2", ''3'' AS "NOMBRE_HEURE_3",
                                            ''4'' AS "NOMBRE_HEURE_4", ''5'' AS "NOMBRE_HEURE_5", ''6'' AS "NOMBRE_HEURE_6", ''7'' AS "NOMBRE_HEURE_7",
                                            ''8'' AS "NOMBRE_HEURE_8", ''9'' AS "NOMBRE_HEURE_9", ''10'' AS "NOMBRE_HEURE_10", ''11'' AS "NOMBRE_HEURE_11",
                                            ''12'' AS "NOMBRE_HEURE_12", ''13'' AS "NOMBRE_HEURE_13", ''14'' AS "NOMBRE_HEURE_14", ''15'' AS "NOMBRE_HEURE_15",
                                            ''16'' AS "NOMBRE_HEURE_16", ''17'' AS "NOMBRE_HEURE_17", ''18'' AS "NOMBRE_HEURE_18", ''19'' AS "NOMBRE_HEURE_19",
                                            ''20'' AS "NOMBRE_HEURE_20", ''21'' AS "NOMBRE_HEURE_21")
                    ) ORDER BY numpac, code_classe_horaire_ott, date_debut';
        
        
sql_2:='select numpac, code_hor_pres, date_debut, date_fin, hrs_lundi, hrs_mardi, hrs_mercredi, hrs_jeudi, hrs_vendredi, hrs_samedi, hrs_dimanche 
		  	 FROM   tge_ref_hpr 
		  	 WHERE  numpac               		IN ('''|| p_numpac ||''')
          ORDER BY numpac, code_hor_pres, date_debut';


/* A819,A820,A996 valeur alimenter manuellement dans Java*/
sql_3:='select M.NUMPAC,M.ELEMENT,M.OCCURENCE,M.DONNEEGXP,M.TABLEGXP,M.DONNFILTRE,M.OPERFILTRE,M.VALFILTRE,M.TRTPARTICULIER,M.ENVOI_SYSTEMATIQUE,M.FORCABLE_ECRAN_GENERE 
          from TGE_REF_MAPDO M  
          where ( ELEMENT IN (''A819'',''A820'',''A996'') ) 
          and  (((SELECT COUNT(1) FROM TGE_REF_MAPDO WHERE NUMPAC= '''||p_numpac||''' AND  ELEMENT = M.ELEMENT ) > 0 AND  M.NUMPAC='''||p_numpac||''')
              OR ((SELECT COUNT(1) FROM TGE_REF_MAPDO WHERE NUMPAC='''||p_numpac||''' AND ELEMENT = M.ELEMENT) = 0 AND M.NUMPAC=''*'' ))';

/* les colonne FIN_PER_GENERATION_HP et DEBUT_PER_GENERATION_HP sont null pour les alimenter manuellement lors d'itération*/
 IF ( p_isDeleting=1) THEN 
 	sql_4:='select PAIEZAD,MATRIC,NUMPAC,PACMAT,NUMCNT,TO_DATE('''||p_date_eff ||''',''DD/MM/YYYY''),DATE_FIN,ZA819,ZA820,ZA996,
              null as DEBUT_PER_GENERATION_HP, 
              null as FIN_PER_GENERATION_HP
            from DIC_ADM_CONTRAT_HISTO where 
                NUMPAC = '''|| p_numpac || ''''
             || ' AND PACMAT ='''|| p_pacmat || ''''
             || ' AND numcnt ='''|| p_numcnt||'''' 
             || ' AND paiezad ='''|| p_paiezad||''''             
 			 || ' AND    TO_DATE('''||p_date_eff ||''',''DD/MM/YYYY'')-1 BETWEEN DATE_EFF AND DATE_FIN
               
                ORDER BY matric asc, date_eff asc' ;
 ELSE 
	sql_4:='select PAIEZAD,MATRIC,NUMPAC,PACMAT,NUMCNT,DATE_EFF,DATE_FIN,ZA819,ZA820,ZA996,
              null as DEBUT_PER_GENERATION_HP, 
              null as FIN_PER_GENERATION_HP
            from DIC_ADM_CONTRAT_HISTO where 
                NUMPAC = '''|| p_numpac || ''''
             || ' AND PACMAT ='''|| p_pacmat || ''''
             || ' AND numcnt ='''|| p_numcnt||'''' 
             || ' AND paiezad ='''|| p_paiezad||''''             
             || ' AND date_eff =   TO_DATE('''||p_date_eff ||''',''DD/MM/YYYY'')
               
                ORDER BY matric asc, date_eff asc' ;
 END IF; 
FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Chargement des cycles)','' );

/*****************************************************************************/
/******************** loadCyclesGroupByPacAndClasseHorOtt ********************/
/*****************************************************************************/
cpt:=1; lst_1:=type_List_arr();
  OPEN cur_1 FOR sql_1;
  LOOP
     FETCH cur_1 INTO cur_TgeRefDcy; EXIT WHEN cur_1%NOTFOUND;
      lst_1.extend;
      lst_1(cpt) :=cur_TgeRefDcy;
      cpt:=cpt+1;
  END LOOP;

FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Chargement des horaires)','' );

/*****************************************************************/
/******************** loadCyclesHprGroupByPac ********************/
/*****************************************************************/
cpt:=1; lst_2:=type_List_arr_2();
  OPEN cur_2 FOR sql_2;
  LOOP
     FETCH cur_2 INTO cur_TgeRefhpr; EXIT WHEN cur_2%NOTFOUND;
    lst_2.extend;
    lst_2(cpt) :=cur_TgeRefhpr;
    cpt:=cpt+1;
  END LOOP;


/*****************************************************************/
/******************** getPopulationHistoContrat ********************/
/******************** chargerInfoElementMapDo ********************/
/*****************************************************************/
cpt:=1; lst_3:=type_List_arr_3();
  OPEN cur_3 FOR sql_3;
  LOOP
     FETCH cur_3 INTO cur_TgeRefmapdo; EXIT WHEN cur_3%NOTFOUND;
    lst_3.extend;
    lst_3(cpt) :=cur_TgeRefmapdo;
    cpt:=cpt+1;
  END LOOP;
FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Chargement info contractuelle)','Chargement de toute la situation y compris horaire de présence, horaire de rémunération et type GTA ' );
/******************** chargerHistoContrat ********************/

cpt:=1; lst_4:=type_List_arr_4();
  OPEN cur_4 FOR sql_4;
  LOOP
     FETCH cur_4 INTO cur_dachtype; 
     EXIT WHEN cur_4%NOTFOUND;
    lst_4.extend;
    lst_4(cpt) :=cur_dachtype;
    lst_4(cpt).FIN_PER_GENERATION_HP := p_date_fin; 
    lst_4(cpt).DEBUT_PER_GENERATION_HP := p_date_deb; 
    cpt:=cpt+1;
  END LOOP;
  

 FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Suppression  HP )','Suppression des anciens HP entre  '||p_date_deb ||' et '||p_date_fin );
  IF lst_4.COUNT >0 THEN
    delete from TGE_INCIDENTS_PAIE 
                  WHERE 
                  NUMPAC = p_numpac
                  AND PAIEZAD = p_PAIEZAD
                  AND TYPE_IP = 'T'
                  AND CODE_IP = 'HP'
                  AND DATE_EFFET  between p_date_deb AND p_date_fin;  -- sortie du boucle pour executer une seul fois
  END IF;
  
  lst_Situation:=SituationType_arr_2();
  arrCycleSituation:=type_List_arr();
  arrCycleSituation.extend;
    
    
  FOR k IN 1..lst_4.COUNT LOOP --K LOOP DACH
          lst_Situation.extend;
          
          /****** ajusterPeriodeSituation ******/
              lst_4(k).DATE_EFF:=p_date_deb; --lst_4(cpt).DEBUT_PER_GENERATION_HP;
   
          /***** build Situation *****/
          lst_Situation(k).numpac:=lst_4(k).NUMPAC;
          lst_Situation(k).Pacmat:=lst_4(k).Pacmat;
          lst_Situation(k).PaieZad:=lst_4(k).PaieZad;
          lst_Situation(k).DateDeb:=lst_4(k).DATE_EFF;
          lst_Situation(k).DateFin:=lst_4(k).FIN_PER_GENERATION_HP;
          
          --GET Donner specifier selon parametrage MAPDO
          --LOOP MAPDO
          FOR J IN 1..lst_3.COUNT LOOP --J LOOP
          
            --A996 / TYPE_GTA
            IF(lst_3(J).ELEMENT='A996' AND lst_3(J).NUMPAC=lst_4(k).NUMPAC) THEN
              lst_Situation(k).isGtaT1:=CASE WHEN getValOfDACH(lst_3(J).DONNEEGXP,lst_4(k))='Z' THEN TRUE ELSE FALSE END;
            END IF; 
        
            -- Horaire Remu Presence
            --ZA819 / HORAIRE_REMUNERATION
            IF(lst_3(J).ELEMENT='A819') THEN
                    HoraireRemu := getValOfDACH(lst_3(J).DONNEEGXP,lst_4(k));
                    
                    
            END IF;
            --ZA820 / HORAIRE_PRESENCE
            IF(lst_3(J).ELEMENT='A820') THEN
                    HorairePres := getValOfDACH(lst_3(J).DONNEEGXP,lst_4(k));
                    
		           
            END IF;
             --horairePres/horaireRemu =>Code_classe_horaire_ott
            IF(lst_3.count=J) THEN 
              IF(horairePres IS NOT NULL) THEN
                lst_Situation(k).Code_classe_horaire_ott:=TO_NUMBER(horairePres);
              ELSE
              IF(horaireRemu IS NOT NULL) THEN
                lst_Situation(k).Code_classe_horaire_ott:=TO_NUMBER(horaireRemu);
              END IF;
              END IF;
            END IF;          
            
          END LOOP; --FIN J MAPDO LOOP 
          
    cpt:=1;     
    
     FOR M IN 1..lst_1.COUNT LOOP
       IF( lst_1(M).CODE_CLASSE_HORAIRE_OTT=lst_Situation(k).Code_classe_horaire_ott)THEN
          arrCycleSituation(cpt):=lst_1(M);
          cpt:=cpt+1;
       END IF;     
     END LOOP;
     
      cpt:=1; 
     arrCycleHprSituation:=type_List_arr_2();
     arrCycleHprSituation.extend;
     FOR M IN 1..lst_2.COUNT LOOP
       IF( lst_2(M).Code_hor_pres=lst_Situation(k).Code_classe_horaire_ott)THEN
          arrCycleHprSituation(cpt):=lst_2(M);
          cpt:=cpt+1;
       END IF;     
     END LOOP;



     END LOOP; --END K LOOP DACH
     
     
  --decomposerArrCycle_DCY_SituationEnTrancheAndCreateHP
  FOR k IN 1..lst_Situation.COUNT LOOP   
     
     IF(arrCycleSituation.COUNT>0) THEN
     FOR W IN 1..arrCycleSituation.COUNT LOOP
     /* La date de début du premier cycle d'une situation doit être égale à la date de début de la situation La date de
         fin du dernier cycle d'une situation doit être égale à la  date de fin de la situation*/
        IF(lst_Situation(k).datedeb <= arrCycleSituation(W).Date_fin AND lst_Situation(k).datefin >= arrCycleSituation(W).Date_debut) THEN
          dateDebTranchSitu:=null; dateFinTranchSitu:=null;
          
          --La date d'effet du cycle est antérieure à la date de début de la situation, On se met sur la date début de la situation
            dateDebTranchSitu:=lst_Situation(k).datedeb;
          
          --La date de fin d'effet du cycle est postérieur à la date de fin de la situation, On se met sur la date de fin de la situation
            dateFinTranchSitu:=lst_Situation(k).datefin;
          
          dateEnCours:=dateDebTranchSitu;
		  FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Début insertion HP)',' ' );
		  
		  --LOOP INSERT TGE_INCIDENTS_PAIE
          WHILE (dateEnCours <= dateFinTranchSitu) LOOP
             numJourCanevas:=calculateNumJourCanevas( arrCycleSituation(W), dateEnCours );
             nbreHeures:=getValOfCycle('NOMBRE_HEURE_'||numJourCanevas,arrCycleSituation(W));
             arrHoraireParJour(TO_CHAR(dateEnCours,'dd/mm/yyyy')):=nbreHeures;
             -- Insertion des HP
             insertIncidentPaieHorsAbs( nbreHeures ,dateEnCours, lst_Situation(k),p_login ,v_periode_limiteRetro );
             dateEnCours:=dateEnCours+1;
          END LOOP; --LOOP WHILE   
          
          FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (Fin insertion HP)',' ' );
          
        END IF; --FIN decomposerArrCycleDcySituationEnTrancheAndCreateHP
         
  /*******************************************************/
  
    --decomposerArrCycle_Hpr_SituationEnTrancheAndCreateHP
 
   IF(arrCycleSituation.count=0) THEN
    FOR W IN 1..arrCycleHprSituation.COUNT LOOP  
      /* La date de début du premier cycle d'une situation doit être égale à la date de début de la situation La date de
         fin du dernier cycle d'une situation doit être égale à la  date de fin de la situation*/
        IF(lst_Situation(k).datedeb <= arrCycleHprSituation(W).Date_fin AND lst_Situation(k).datefin >= arrCycleHprSituation(W).Date_debut) THEN
          dateDebTranchSitu:=null; dateFinTranchSitu:=null;
          
          --La date d'effet du cycle est antérieure à la date de début de la situation, On se met sur la date début de la situation
          IF(arrCycleHprSituation(W).Date_debut <= lst_Situation(k).datedeb) THEN
            dateDebTranchSitu:=lst_Situation(k).datedeb;
           ELSE
            dateDebTranchSitu:=arrCycleHprSituation(W).Date_debut;
          END IF;
          
          --La date de fin d'effet du cycle est postérieur à la date de fin de la situation, On se met sur la date de fin de la situation
          IF(arrCycleHprSituation(W).Date_fin >= lst_Situation(k).datefin) THEN
            dateFinTranchSitu:=lst_Situation(k).datefin;
           ELSE
            dateFinTranchSitu:=arrCycleHprSituation(W).Date_fin;
          END IF;
          
          dateEnCours:=dateDebTranchSitu;
          
          --LOOP INSERT TGE_INCIDENTS_PAIE 
          WHILE (dateEnCours <= dateFinTranchSitu) LOOP
             jourSemaine:=calculateNomJourCanevas( arrCycleHprSituation(W), dateEnCours );
             nbreHeures:=getHprHoursNbre(numJourCanevas,arrCycleHprSituation(W));
             arrHoraireParJour(TO_CHAR(dateEnCours,'dd/mm/yyyy')):=nbreHeures;
             -- Insertion des HP
             insertIncidentPaieHorsAbs( nbreHeures ,dateEnCours, lst_Situation(k), p_login ,v_periode_limiteRetro );
             dateEnCours:=dateEnCours+1;
          END LOOP; --LOOP WHILE TGE_INCIDENTS_PAIE
 
        END IF; -- END IF INTO THE LOOP
    END LOOP; --FIN decomposerArrCycleHprSituationEnTrancheAndCreateHP
  END IF; --END IF arrCycleSituation vide
  END LOOP; --END LOOP parcour situation
  END IF;
  END LOOP;  --END LOOP Situation génerer
    

 FSED.FSED_AVANCEMENT_PLSQL(p_id,'CALC_HP (End)','Fin de recalcul des HP pour la situation ( numpac:  '||p_numpac ||', pacmat: '|| p_pacmat ||', numcnt: '||p_numcnt|| ', paiezad: '|| p_paiezad ||',date_eff : '||p_date_eff||')');
 
	EXCEPTION
 	WHEN others THEN
  	err_code := SQLCODE;
 	err_msg  := SQLERRM;
 	FSED.FSED_ERREUR( p_id , 'Calc_HP (Erreur) ' , 'Erreur est survenue lors du recalcul des HP pour la situation  ( numpac:  '||p_numpac ||', pacmat: '|| p_pacmat ||', numcnt: '||p_numcnt|| ', paiezad: '|| p_paiezad ||',date_eff : '||p_date_eff||') ' , err_code||'-'||err_msg );


 END;

END CALC_HP;
##
TAG_CHARSET=@€éèç
##
FSED
=SQL=
CREATE OR REPLACE PACKAGE FSED 
AS
 FUNCTION getTypeTable(
 p_table IN VARCHAR2)
 RETURN VARCHAR2;
 FUNCTION getClauseSelect(
 p_numpac IN VARCHAR2,
 p_nom_table_ou_alias IN VARCHAR2,
 p_donneegxp IN VARCHAR2,
 p_donnfiltre IN VARCHAR2,
 p_operfiltre IN VARCHAR2,
 p_valfiltre IN VARCHAR2,
 p_trtparticulier IN VARCHAR2,
 p_envoi_systematique IN VARCHAR2,
 p_data_type IN VARCHAR2,
 p_type_zadig IN VARCHAR2,
 p_masque IN VARCHAR2,
 p_occ IN VARCHAR2,
 p_avec_balises_photo IN BOOLEAN)
 RETURN VARCHAR2;
 PROCEDURE FSED_ERREUR(
 p_id      IN NUMBER,
 p_nomproc IN VARCHAR2,
 p_idDate  IN VARCHAR2,
 p_erreur  IN CLOB );
 PROCEDURE preparation_FSED_unit(
 p_nomTable    IN VARCHAR2,
 p_alias       IN VARCHAR2,
 p_TABLETYPE   IN VARCHAR2,
 p_id_trt      IN NUMBER,
 p_numpac      IN VARCHAR2,
 p_periode     IN VARCHAR2,
 p_ALLERRETOUR IN VARCHAR2,
 p_nb_mois_paie_init IN NUMBER);
 PROCEDURE preparation_FSED(
 p_id_trt  IN NUMBER,
 p_numpac  IN VARCHAR2,
 p_periode IN VARCHAR2);
 PROCEDURE retour_Fsed(
 p_id IN NUMBER );
 PROCEDURE insertCart80(
 p_id    IN NUMBER,
 p_newId IN NUMBER);
 PROCEDURE insertCart30(
 p_id    IN NUMBER,
 p_newId IN NUMBER,
 p_table IN VARCHAR2);
 PROCEDURE sous_insertCart80(
 p_id    IN NUMBER,
 p_newId IN NUMBER) ;
 PROCEDURE sous_insertCart30(
 p_id    IN NUMBER,
 p_newId IN NUMBER,
 p_table IN VARCHAR2) ;
 PROCEDURE maj_CAD30(
 p_id IN NUMBER) ;
 PROCEDURE getPeriodeRecueil(
 p_numpac  IN TGE_REF_PAC.numpac%type,
 p_paiezad IN TGE_IMPORT_FSED_30.paiezad%type,
 p_dateDeb IN OUT DATE,
 p_dateFin IN OUT DATE);
 PROCEDURE tmp_histo_fsed_30(
 p_id  IN NUMBER ,
 p_numpac  IN TGE_REF_MAPDO.NUMPAC%TYPE,
 p_moi IN VARCHAR2);
 procedure FSED_AVANCEMENT_PLSQL(
 p_id             IN NUMBER,
 p_typeAction     IN VARCHAR2,
 p_detailAction   IN CLOB );
 PROCEDURE FSED_AVANCEMENT(
    id  IN NUMBER,
    txt IN VARCHAR2);
 PROCEDURE insert_gap_trt(
 p_id          IN NUMBER ,
 p_numpac      IN TGE_REF_PAC.numpac%type,
 p_periode     IN TGE_REF_PAC.PERIODEENCOURS%TYPE,
 p_type_retour IN VARCHAR2);
 PROCEDURE insert_gap_trt_suivi(
 p_id               IN NUMBER ,
 p_statut           IN TGE_REF_PAC.numpac%type,
 p_code_retour_zpp  IN TGE_REF_PAC.PERIODEENCOURS%TYPE,
 p_login            IN VARCHAR2,
 p_type_retour     IN VARCHAR2);
 PROCEDURE getPeriodeRecueilEvol(
 p_id      IN NUMBER,
 p_numpac  IN TGE_REF_PAC.numpac%type,
 p_periodeEnCours IN TGE_REF_PAC.periodeencours%type,
 p_paiezad IN TGE_IMPORT_FSED_30.paiezad%type,
 p_dateDeb IN OUT DATE,
 p_dateFin IN OUT DATE);
 END FSED;
##
FSED
=SQL=
create or replace PACKAGE body FSED AS
  /********************************************************************************
  Version     : V5.05.00
  *********************************************************************************/
  err_msg  VARCHAR(1000);
  err_code VARCHAR(200);
type pour_comp
IS
  record
  (
    CLE     VARCHAR2(1000),
    numpac  VARCHAR2(6),
    pacmat  VARCHAR2(8),
    paiezad VARCHAR2(8),
    dteffet DATE,
    dtfin   DATE,
    rank    NUMBER,
    C1      VARCHAR2(1000),
    C2      VARCHAR2(1000),
    C3      VARCHAR2(1000),
    C4      VARCHAR2(1000),
    C5      VARCHAR2(1000),
    C6      VARCHAR2(1000),
    C7      VARCHAR2(1000),
    C8      VARCHAR2(1000),
    C9      VARCHAR2(1000),
    C10     VARCHAR2(1000),
    C11     VARCHAR2(1000),
    C12     VARCHAR2(1000),
    C13     VARCHAR2(1000),
    C14     VARCHAR2(1000),
    C15     VARCHAR2(1000),
    C16     VARCHAR2(1000),
    C17     VARCHAR2(1000),
    C18     VARCHAR2(1000),
    C19     VARCHAR2(1000),
    C20     VARCHAR2(1000),
    C21     VARCHAR2(1000),
    C22     VARCHAR2(1000),
    C23     VARCHAR2(1000),
    C24     VARCHAR2(1000),
    C25     VARCHAR2(1000),
    C26     VARCHAR2(1000),
    C27     VARCHAR2(1000),
    C28     VARCHAR2(1000),
    C29     VARCHAR2(1000),
    C30     VARCHAR2(1000) );
TYPE DATE_A275_h
IS
  RECORD
  (
    numpac        VARCHAR2(6),
    IDPACMAT      VARCHAR2(14),
    donnee_A275_h DATE );
TYPE TAB_DATE_A275_H
IS
  TABLE OF DATE_A275_h INDEX BY binary_integer ;
TYPE DATE_w580_h
IS
  RECORD
  (
    numpac        VARCHAR2(6),
    IDPACMAT      VARCHAR2(14),
    donnee_W580_h VARCHAR2(8) );
TYPE TAB_DATE_w580_H
IS
  TABLE OF DATE_w580_h INDEX BY binary_integer ;
TYPE DATE_WL52_h
IS
  RECORD
  (
    numpac        VARCHAR2(6),
    IDPACMAT      VARCHAR2(14),
    donnee_WL52_h VARCHAR2(8) );
TYPE TAB_DATE_WL52_H
IS
  TABLE OF DATE_WL52_h INDEX BY binary_integer ;
TYPE TAB_pour_comp
IS
  TABLE OF pour_comp INDEX BY binary_integer ;
type pour_lib
IS
  record
  (
    LIB         VARCHAR2(1000),
    TYPE_DONNEE VARCHAR2(1),
    OCC         VARCHAR2(2) );
TYPE TAB_pour_lib
IS
  TABLE OF pour_lib INDEX BY binary_integer ;
type pour_retour
IS
  record
  (
    ID_TRT      NUMBER,
    NUMPAC      VARCHAR2(6),
    CLE         VARCHAR2(1000),
    pacmat      VARCHAR2(8),
    ELEM        VARCHAR2(1000),
    OCC         VARCHAR2(2),
    VALEUR      VARCHAR2(1000),
    CODEOP      VARCHAR2(1),
    TYPE_DONNEE VARCHAR2(1),
    DTEFFET     DATE,
    paiezad     VARCHAR2(8));
TYPE TAB_pour_retour
IS
  TABLE OF pour_retour INDEX BY binary_integer ;
type pour_cle
IS
  record
  (
    column_name VARCHAR2(255),
    data_type   VARCHAR2(255));
TYPE TAB_cle
IS
  TABLE OF pour_cle INDEX BY binary_integer ;
  CURSOR cur_lig (p_id TGE_IMPORT_FSED.id_trt%TYPE)
  IS
    SELECT *
    FROM TGE_IMPORT_FSED
    WHERE id_trt             =p_id
    AND SUBSTR(donnees,7,2) IN ('00','11','15','17','99')
    ORDER BY num_lig;
TYPE t_TGE_REF_VRREP
IS
  TABLE OF TGE_REF_VRREP%rowtype;
TYPE t_TGE_REF_VRDES
IS
  TABLE OF TGE_REF_VRDES%rowtype;
TYPE t_TGE_REF_VRVAL
IS
  TABLE OF TGE_REF_VRVAL%rowtype;
TYPE t_TGE_REF_RUBRIQUE
IS
  TABLE OF TGE_REF_RUBRIQUE%rowtype;
TYPE t_TGE_REF_LIBRUB_COTIS
IS
  TABLE OF TGE_REF_LIBRUB_COTIS%rowtype;
TYPE t_TGE_REF_RUBRIQUE_CONTEXTE
IS
  TABLE OF TGE_REF_RUBRIQUE_CONTEXTE%rowtype;
TYPE t_TGE_REF_DICOZ
IS
  TABLE OF TGE_REF_DICOZ%rowtype;
TYPE t_TGE_IMPORT_FSED
IS
  TABLE OF TGE_IMPORT_FSED%rowtype;
TYPE t_CODE_TABLE
IS
  TABLE OF VARCHAR2(5) INDEX BY VARCHAR2(15) ;
TYPE t_numLig_00
IS
  TABLE OF NUMBER INDEX BY binary_integer ;
TYPE t_numLig_99
IS
  TABLE OF NUMBER INDEX BY binary_integer ;
  lig t_TGE_IMPORT_FSED;
  tab_11R t_TGE_REF_VRREP;
  elt_tab_11R TGE_REF_VRREP%rowtype;
  tab_11D t_TGE_REF_VRDES;
  elt_tab_11D TGE_REF_VRDES%rowtype;
  tab_11D1 t_TGE_REF_VRDES;
  elt_tab_11D1 TGE_REF_VRDES%rowtype;
  tab_11V t_TGE_REF_VRVAL;
  elt_tab_11V TGE_REF_VRVAL%rowtype;
  tab_15 t_TGE_REF_RUBRIQUE;
  tab_15_lib t_TGE_REF_LIBRUB_COTIS;
  elt_tab_15 TGE_REF_RUBRIQUE%rowtype;
  elt_tab_15_lib TGE_REF_LIBRUB_COTIS%rowtype;
  tab_17CR t_TGE_REF_RUBRIQUE_CONTEXTE;
  elt_tab_17CR TGE_REF_RUBRIQUE_CONTEXTE%rowtype;
  tab_17DMF t_TGE_REF_DICOZ;
  elt_tab_17DMF TGE_REF_DICOZ%rowtype;
  w_Error_code    NUMBER(2)    :=0 ;
  w_Error_msg     VARCHAR2(255):= '';
  v_cmpt_numLigne NUMBER       := 0;
  code_table_liste t_CODE_TABLE;
  valdebug VARCHAR2(1);
  tab_numLigne00 t_numLig_00;
  tab_numligne99 t_numLig_99;
  DicoPret          VARCHAR2(30);
  soldePret         VARCHAR2(30);
  MontantPret       VARCHAR2(30);
  DicoOpposition    VARCHAR2(30);
  soldeOpposition   VARCHAR2(30);
  MontantOpposition VARCHAR2(30);
  coldteffet        VARCHAR2(30);
  coldatecle        VARCHAR2(30);
 MatEcrit          VARCHAR2(20);
  oldvaleur         VARCHAR2(1000);
  MatARenvoyer      VARCHAR2(20);
  mMoins1           DATE;
  CURSOR cur_numlig00 (p_id TGE_IMPORT_FSED.id_trt%TYPE)
  IS
    SELECT num_lig
    FROM TGE_IMPORT_FSED
    WHERE id_trt            =p_id
    AND SUBSTR(donnees,7,2) ='00'
    ORDER BY num_lig;
  CURSOR cur_numlig99 (p_id TGE_IMPORT_FSED.id_trt%TYPE)
  IS
    SELECT num_lig
    FROM TGE_IMPORT_FSED
    WHERE id_trt            =p_id
    AND SUBSTR(donnees,7,2) ='99'
    ORDER BY num_lig;
PROCEDURE FSED_AVANCEMENT(
    id  IN NUMBER,
    txt IN VARCHAR2)
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
  line   VARCHAR(32672);
  status INT;
BEGIN
  IF valdebug IS NULL THEN
    SELECT is_debug INTO valdebug FROM TGE_FSED_IS_DEBUG;
  END IF;
  IF valdebug='O' THEN
    INSERT INTO TGE_FSED_AVANCEMENT_proc VALUES
      (id,systimestamp,txt
      );
    COMMIT;
  END IF;
END FSED_AVANCEMENT;
PROCEDURE FSED_ERREUR
  (
    p_id      IN NUMBER,
    p_nomproc IN VARCHAR2,
    p_idDate  IN VARCHAR2,
    p_erreur  IN CLOB
  )
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
  line   VARCHAR(32672);
  status INT;
BEGIN
  INSERT
  INTO TGE_FSED_ERREUR
    (
      ID,
      PROC,
      PARAM,
      MESSAGE,
      date_err
    )
    VALUES
    (
      p_id ,
      p_nomproc,
      p_idDate ,
      p_erreur,
      sysdate
    );
  COMMIT;
END FSED_ERREUR;
PROCEDURE FSED_AVANCEMENT_PLSQL(
    p_id           IN NUMBER,
    p_typeAction   IN VARCHAR2,
    p_detailAction IN CLOB)
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
  line   VARCHAR(32672);
  status INT;
BEGIN
  INSERT
  INTO TGE_AVANCEMENT_PLSQL
    (
      NUM,
      TYPE_ACTION,
      DATE_ACTION,
      DETAIL_ACTION
    )
    VALUES
    (
      p_id ,
      p_typeAction,
      SYSTIMESTAMP,
      p_detailAction
    );
  COMMIT;
END FSED_AVANCEMENT_PLSQL;
PROCEDURE remplissage_ligne
  (
    tabRetour   IN OUT nocopy TAB_pour_retour,
    tab         IN pour_comp,
    tablib      IN pour_lib,
    p_id_trt    IN NUMBER,
    p_numretour IN OUT NUMBER,
    p_numcol    IN NUMBER,
    p_code_op   IN VARCHAR2,
    p_TABLETYPE IN VARCHAR2
  )
AS
  VALEUR_TO_SEND VARCHAR2
  (
    1000
  )
  ;
BEGIN
  IF p_numcol      =0 THEN
    VALEUR_TO_SEND:=tab.C1;
  elsif p_numcol   =1 THEN
    VALEUR_TO_SEND:=tab.C2;
  elsif p_numcol   =2 THEN
    VALEUR_TO_SEND:=tab.C3;
  elsif p_numcol   =3 THEN
    VALEUR_TO_SEND:=tab.C4;
  elsif p_numcol   =4 THEN
    VALEUR_TO_SEND:=tab.C5;
  elsif p_numcol   =5 THEN
    VALEUR_TO_SEND:=tab.C6;
  elsif p_numcol   =6 THEN
    VALEUR_TO_SEND:=tab.C7;
  elsif p_numcol   =7 THEN
    VALEUR_TO_SEND:=tab.C8;
  elsif p_numcol   =8 THEN
    VALEUR_TO_SEND:=tab.C9;
  elsif p_numcol   =9 THEN
    VALEUR_TO_SEND:=tab.C10;
  elsif p_numcol   =10 THEN
    VALEUR_TO_SEND:=tab.C11;
  elsif p_numcol   =11 THEN
    VALEUR_TO_SEND:=tab.C12;
  elsif p_numcol   =12 THEN
    VALEUR_TO_SEND:=tab.C13;
  elsif p_numcol   =13 THEN
    VALEUR_TO_SEND:=tab.C14;
  elsif p_numcol   =14 THEN
    VALEUR_TO_SEND:=tab.C15;
  elsif p_numcol   =15 THEN
    VALEUR_TO_SEND:=tab.C16;
  elsif p_numcol   =16 THEN
    VALEUR_TO_SEND:=tab.C17;
  elsif p_numcol   =17 THEN
    VALEUR_TO_SEND:=tab.C18;
  elsif p_numcol   =18 THEN
    VALEUR_TO_SEND:=tab.C19;
  elsif p_numcol   =19 THEN
    VALEUR_TO_SEND:=tab.C20;
  elsif p_numcol   =20 THEN
    VALEUR_TO_SEND:=tab.C21;
  elsif p_numcol   =21 THEN
    VALEUR_TO_SEND:=tab.C22;
  elsif p_numcol   =22 THEN
    VALEUR_TO_SEND:=tab.C23;
  elsif p_numcol   =23 THEN
    VALEUR_TO_SEND:=tab.C24;
  elsif p_numcol   =24 THEN
    VALEUR_TO_SEND:=tab.C25;
  elsif p_numcol   =25 THEN
    VALEUR_TO_SEND:=tab.C26;
  elsif p_numcol   =26 THEN
    VALEUR_TO_SEND:=tab.C27;
  elsif p_numcol   =27 THEN
    VALEUR_TO_SEND:=tab.C28;
  elsif p_numcol   =28 THEN
    VALEUR_TO_SEND:=tab.C29;
  elsif p_numcol   =29 THEN
    VALEUR_TO_SEND:=tab.C30;
  END IF;
  --préparer envoi si NULL ou autre que valeur "ne pas envoyer"
  IF VALEUR_TO_SEND IS NULL OR VALEUR_TO_SEND <>'_NOTSEND_' THEN
    IF p_code_op     ='S' THEN
      --les suppressions sont des envois à blanc
      VALEUR_TO_SEND:=NULL;
    END IF;
    --éliminer les doublons même matricule déjà écrit et même valeur
    IF MatEcrit=tab.pacmat||'#'||tab.paiezad AND oldvaleur=NVL(VALEUR_TO_SEND,'@NULL@') THEN
      RETURN;
    END IF;
    --on a détecté au moins une différence
    MatARenvoyer:=tab.pacmat||'#'||tab.paiezad;
    --éliminer le passé et pour les historiques les doublons déjà écrits
    IF NVL(tab.DTFIN,to_date('31.12.2099','dd.mm.yyyy'))            >= mMoins1
      AND ( coldteffet <> 'a.DATE_EFF' 
      OR MatARenvoyer<>MatEcrit OR oldvaleur<>NVL(VALEUR_TO_SEND,'@NULL@') )
    THEN
      tabRetour(p_numretour).VALEUR                                 :=VALEUR_TO_SEND;
      tabRetour(p_numretour).DTEFFET                                :=tab.DTEFFET;
      tabRetour(p_numretour).CLE                                    :=tab.CLE;
      tabRetour(p_numretour).pacmat                                 :=tab.pacmat;
      tabRetour(p_numretour).paiezad                                :=tab.paiezad;
      tabRetour(p_numretour).ELEM                                   :=tablib.LIB;
      tabRetour(p_numretour).CODEOP                                 :=p_code_op;
      tabRetour(p_numretour).TYPE_DONNEE                            :=tablib.TYPE_DONNEE;
    IF coldteffet = 'a.DATE_EFF' THEN
    --au moins 1 histo écrit, forcer l'écriture des prochaines dates d'effet.
    MatEcrit:=MatARenvoyer;
    --mémoriser la valeur de cette colonne historique
    oldvaleur:=NVL(VALEUR_TO_SEND,'@NULL@');
    END IF;
      IF LENGTH(TRIM(TRANSLATE(tablib.OCC, ' +-.0123456789', ' '))) IS NULL THEN
        --occurrence numérique indiquée dans MAPDO
        tabRetour(p_numretour).OCC :=tablib.OCC;
      ELSE
        IF tablib.OCC     ='**' OR tablib.OCC='*F' OR tablib.OCC='*I' THEN
          IF p_TABLETYPE <>'OCCURS' THEN
            --occurrences spéciales, ce ne sont pas des occurrences Zadig donc on vide
            tabRetour(p_numretour).OCC :=NULL;
          ELSE
            --pour le type OCCURS valoriser OCC avec le rang par exemple 3ème enfant OCC=3
            tabRetour(p_numretour).OCC:=tab.RANK;
          END IF;
        ELSE
          --occurrence bizarre dans MAPDO (ni numérique, ni ** ni *F ni *I)
          tabRetour(p_numretour).OCC :=tablib.OCC;
        END IF;
      END IF;
      --incrémenter le n° de ligne pour anticiper la ligne suivante
      p_numretour:=p_numretour+1;
    END IF;
  END IF;
END remplissage_ligne;
------------------------------------
 FUNCTION GET_NB_MOIS_PAIE_INIT
 RETURN NUMBER
 IS
 p_nb_mois_paie_init SYS_VARSYS.VALVAR%type ;
 BEGIN
 BEGIN
 select TO_NUMBER(NVL(VALVAR,'0')) into p_nb_mois_paie_init from SYS_VARSYS where MODULE = 'GAP' and CODVAR = 'NB_MOIS_PAIE_INIT';
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 p_nb_mois_paie_init :=1;
 END ;
p_nb_mois_paie_init := p_nb_mois_paie_init-1;
RETURN p_nb_mois_paie_init;
 END GET_NB_MOIS_PAIE_INIT ;
------------------------------------
FUNCTION difference_col
  (
    tab1     IN pour_comp,
    tab2     IN pour_comp,
    p_numcol IN NUMBER
  )
  RETURN INTEGER
IS
BEGIN
  IF p_numcol=0 AND NVL(tab1.c1,'@NULL@') <>NVL(tab2.c1,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=1 AND NVL(tab1.c2,'@NULL@') <>NVL(tab2.c2,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=2 AND NVL(tab1.c3,'@NULL@') <>NVL(tab2.c3,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=3 AND NVL(tab1.c4,'@NULL@') <>NVL(tab2.c4,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=4 AND NVL(tab1.c5,'@NULL@') <>NVL(tab2.c5,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=5 AND NVL(tab1.c6,'@NULL@') <>NVL(tab2.c6,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=6 AND NVL(tab1.c7,'@NULL@') <>NVL(tab2.c7,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=7 AND NVL(tab1.c8,'@NULL@') <>NVL(tab2.c8,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=8 AND NVL(tab1.c9,'@NULL@') <>NVL(tab2.c9,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=9 AND NVL(tab1.c10,'@NULL@') <>NVL(tab2.c10,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=10 AND NVL(tab1.c11,'@NULL@') <>NVL(tab2.c11,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=11 AND NVL(tab1.c12,'@NULL@') <>NVL(tab2.c12,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=12 AND NVL(tab1.c13,'@NULL@') <>NVL(tab2.c13,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=13 AND NVL(tab1.c14,'@NULL@') <>NVL(tab2.c14,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=14 AND NVL(tab1.c15,'@NULL@') <>NVL(tab2.c15,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=15 AND NVL(tab1.c16,'@NULL@') <>NVL(tab2.c16,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=16 AND NVL(tab1.c17,'@NULL@') <>NVL(tab2.c17,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=17 AND NVL(tab1.c18,'@NULL@') <>NVL(tab2.c18,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=18 AND NVL(tab1.c19,'@NULL@') <>NVL(tab2.c19,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=19 AND NVL(tab1.c20,'@NULL@') <>NVL(tab2.c20,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=20 AND NVL(tab1.c21,'@NULL@') <>NVL(tab2.c21,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=21 AND NVL(tab1.c22,'@NULL@') <>NVL(tab2.c22,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=22 AND NVL(tab1.c23,'@NULL@') <>NVL(tab2.c23,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=23 AND NVL(tab1.c24,'@NULL@') <>NVL(tab2.c24,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=24 AND NVL(tab1.c25,'@NULL@') <>NVL(tab2.c25,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=25 AND NVL(tab1.c26,'@NULL@') <>NVL(tab2.c26,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=26 AND NVL(tab1.c27,'@NULL@') <>NVL(tab2.c27,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=27 AND NVL(tab1.c28,'@NULL@') <>NVL(tab2.c28,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=28 AND NVL(tab1.c29,'@NULL@') <>NVL(tab2.c29,'@NULL@') THEN
    RETURN 1;
  elsif p_numcol=29 AND NVL(tab1.c30,'@NULL@') <>NVL(tab2.c30,'@NULL@') THEN
    RETURN 1;
  ELSE
    RETURN 0;
  END IF;
END difference_col;
FUNCTION getTypeTable
  (
    p_table IN VARCHAR2
  )
  RETURN VARCHAR2
IS
  v_typeTable VARCHAR2(1);
BEGIN
IF p_table ='DIC_ADM_CONTRAT_SITU' THEN 
    v_typeTable :='z';
ELSE

  BEGIN
    SELECT typetable
    INTO v_typeTable
    FROM
      (SELECT 'p' AS typetable
      FROM user_cons_columns
      WHERE table_name =p_table
        --faux PACMAT, c'est un PAIEZAD
      AND p_table         <> 'DIC_ADM_CONTRAT_HISTO'
      AND constraint_name IN
        (SELECT user_constraints.constraint_name
        FROM user_constraints
        WHERE user_cons_columns.table_name =user_constraints.table_name
        AND CONSTRAINT_TYPE                ='P'
        )
      AND column_name='PACMAT'
      UNION
      SELECT 'z' AS typetable
      FROM user_cons_columns
      WHERE (table_name =p_table
        --PAIEZAD imposé
      OR p_table           = 'DIC_ADM_CONTRAT_HISTO')
      AND constraint_name IN
        (SELECT user_constraints.constraint_name
        FROM user_constraints
        WHERE user_cons_columns.table_name =user_constraints.table_name
        AND CONSTRAINT_TYPE                ='P'
        )
      AND column_name= 'PAIEZAD'
      UNION
      SELECT 'm' AS typetable
      FROM user_cons_columns
      WHERE table_name     =p_table
      AND constraint_name IN
        (SELECT user_constraints.constraint_name
        FROM user_constraints
        WHERE user_cons_columns.table_name =user_constraints.table_name
        AND CONSTRAINT_TYPE                ='P'
        )
      AND column_name= 'MATRIC'
      );
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  END;
END IF;
  RETURN v_typeTable;
END getTypeTable;
PROCEDURE effaceMatricToutTable(
    p_numpac IN VARCHAR2,
    p_pacmat IN VARCHAR2 )
AS
  CURSOR cur_tables
  IS
    SELECT DISTINCT TABLEPHY
    FROM tge_ref_mapta
    WHERE numpac     = p_numpac
    AND ALLERRETOUR IN ('A','2')
    AND TABLEPHY    <>'DIC_ADM_CONTRAT'
  UNION
  SELECT DISTINCT TABLEPHY
  FROM tge_ref_mapta
  WHERE numpac        = '*'
  AND ALLERRETOUR    IN ('A','2')
  AND TABLEPHY       <>'DIC_ADM_CONTRAT'
  AND TABLEPARAM NOT IN
    (SELECT TABLEPARAM
    FROM tge_ref_mapta
    WHERE numpac     = p_numpac
    AND ALLERRETOUR IN ('A','2')
    AND TABLEPHY    <>'DIC_ADM_CONTRAT'
    );
  lig_tables cur_tables%rowtype;
BEGIN
  OPEN cur_tables;
  LOOP
    FETCH cur_tables INTO lig_tables;
    EXIT
  WHEN cur_tables%NOTFOUND ;
    EXECUTE immediate 'DELETE FROM PHOTO_'||lig_tables.TABLEPHY||' where numpac=:2 and pacmat=:1' USING p_numpac,
    p_pacmat;
  END LOOP;
  CLOSE cur_tables;
END effaceMatricToutTable;
PROCEDURE getSoldMontant(
    p_numpac IN VARCHAR2 ,
    p_id_trt IN NUMBER,
    DicoPret OUT VARCHAR2 ,
    soldePret OUT VARCHAR2 ,
    MontantPret OUT VARCHAR2 ,
    DicoOpposition OUT VARCHAR2 ,
    soldeOpposition OUT VARCHAR2 ,
    MontantOpposition OUT VARCHAR2 )
AS
BEGIN
  SELECT MontantPret_DONNEE,
    SoldePret_DONNEE,
    DicoPret_DONNEE,
    MontantOpposition_DONNEE,
    SoldeOpposition_DONNEE,
    DicoOpposition_DONNEE
  INTO MontantPret,
    soldePret,
    DicoPret,
    MontantOpposition,
    soldeOpposition,
    DicoOpposition
  FROM
    (
    --ce SELECT fournit la liste element/donneegxp des éléments personnalisés
    SELECT DISTINCT a.element,
      a.DONNEEGXP
    FROM tge_ref_mapdo a,
      (
      --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac     =p_numpac
      AND ALLERRETOUR IN ('A','2','I')
      UNION ALL
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac        ='*'
      AND ALLERRETOUR    IN ('A','2','I')
      AND tableparam NOT IN
        (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
        )
      ) t ,
      user_tables b
    WHERE a.numpac   =p_numpac
    AND t.tableparam =a.TABLEGXP
    AND b.table_name =a.TABLEGXP
    AND a.element   IN ('B712','B714','B832','B834')
    UNION ALL
    --ce SELECT fournit la liste element/donneegxp des éléments Pac "*"
    SELECT DISTINCT a.element,
      a.DONNEEGXP
    FROM tge_ref_mapdo a,
      (
      --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac     =p_numpac
      AND ALLERRETOUR IN ('A','2','I')
      UNION ALL
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac        ='*'
      AND ALLERRETOUR    IN ('A','2','I')
      AND tableparam NOT IN
        (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
        )
      ) t ,
      user_tables b
    WHERE a.numpac     ='*'
    AND t.tableparam   =a.TABLEGXP
    AND b.table_name   =a.TABLEGXP
    AND a.element     IN ('B712','B714','B832','B834')
    AND a.element NOT IN
      (SELECT element
      FROM tge_ref_mapdo a,
        (
        --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
        SELECT *
        FROM tge_ref_mapta
        WHERE numpac     =p_numpac
        AND ALLERRETOUR IN ('A','2','I')
        UNION ALL
        SELECT *
        FROM tge_ref_mapta
        WHERE numpac        ='*'
        AND ALLERRETOUR    IN ('A','2','I')
        AND tableparam NOT IN
          (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
          )
        ) t ,
        user_tables b
      WHERE a.numpac   =p_numpac
      AND t.tableparam =a.TABLEGXP
      AND b.table_name =a.TABLEGXP
      )
    UNION ALL
    --ce SELECT fournit la liste 'DICO'||element/tableparam des dictionnaires des éléments personnalisés
    SELECT DISTINCT 'DICO'
      ||a.element,
      a.TABLEGXP AS DONNEEGXP
    FROM tge_ref_mapdo a,
      (
      --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac     =p_numpac
      AND ALLERRETOUR IN ('A','2','I')
      UNION ALL
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac        ='*'
      AND ALLERRETOUR    IN ('A','2','I')
      AND tableparam NOT IN
        (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
        )
      ) t , 
      user_tables b
    WHERE a.numpac   =p_numpac
    AND t.tableparam =a.TABLEGXP
    AND b.table_name =a.TABLEGXP
    AND a.element   IN ('B712','B714','B832','B834')
    UNION ALL
    --ce SELECT fournit la liste 'DICO'||element/tableparam des dictionnaires des éléments Pac "*"
    SELECT DISTINCT 'DICO'
      ||a.element,
      a.TABLEGXP AS DONNEEGXP
    FROM tge_ref_mapdo a,
      (
      --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac     =p_numpac
      AND ALLERRETOUR IN ('A','2','I')
      UNION ALL
      SELECT *
      FROM tge_ref_mapta
      WHERE numpac        ='*'
      AND ALLERRETOUR    IN ('A','2','I')
      AND tableparam NOT IN
        (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
        )
      ) t ,
      user_tables b
    WHERE a.numpac     ='*'
    AND t.tableparam   =a.TABLEGXP
    AND b.table_name   =a.TABLEGXP
    AND a.element     IN ('B712','B714','B832','B834')
    AND a.element NOT IN
      (SELECT element
      FROM tge_ref_mapdo a,
        (
        --liste résolue "t" des tables MAPTA en Aller pour éviter les tables en Retour
        SELECT *
        FROM tge_ref_mapta
        WHERE numpac     =p_numpac
        AND ALLERRETOUR IN ('A','2','I')
        UNION ALL
        SELECT *
        FROM tge_ref_mapta
        WHERE numpac        ='*'
        AND ALLERRETOUR    IN ('A','2','I')
        AND tableparam NOT IN
          (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
          )
        ) t ,
        user_tables b
      WHERE a.numpac   =p_numpac
      AND t.tableparam =a.TABLEGXP
      AND b.table_name =a.TABLEGXP
      )
    ) --fin de la liste des éléments et des dictionnaires empilés dans la même colonne
    --la fonction PIVOT transforme la liste element/donneegxp en distribution horizontale. Les lignes DICOB714 et DICOB834 sont abandonnées, on suppose que c'est le même dico.
    pivot (MAX(DONNEEGXP) AS DONNEE FOR element IN ('B712' AS MontantPret, 'B714' AS SoldePret, 'B832' AS MontantOpposition, 'B834' AS SoldeOpposition, 'DICOB712' AS DicoPret, 'DICOB832' AS DicoOpposition));
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id_trt , 'getSoldMontant ' ,p_id_trt||','||p_numpac , err_code||'-'||err_msg );
  raise;
END getSoldMontant;
PROCEDURE insert_gap_trt
(
    p_id          IN NUMBER ,
    p_numpac      IN TGE_REF_PAC.numpac%type,
    p_periode     IN TGE_REF_PAC.PERIODEENCOURS%TYPE,
    p_type_retour IN VARCHAR2 
)
IS
  PRAGMA AUTONOMOUS_TRANSACTION;
  status      INT;
  v_dtdebMois VARCHAR2(8);
  v_finMois   VARCHAR2(8);
  v_periode TGE_REF_PAC.PERIODEENCOURS%TYPE;
  v_req CLOB;
BEGIN
  --get date debut et fin du mois
  FSED_AVANCEMENT(p_id,'insert_gap_trt Debut p_id='||p_id||';p_numpac='||p_numpac||';p_periode='||NVL(p_periode,v_periode)||';p_type_retour='||p_type_retour);
  SELECT periodeencours INTO v_periode FROM tge_ref_pac WHERE numpac =p_numpac;
  BEGIN
    SELECT DATE_DEBUT_MOIS,
      DATE_FIN_MOIS
    INTO v_dtdebMois,
      v_finMois
    FROM TGE_REF_PER
    WHERE numpac       = p_numpac
    AND periodeencours = NVL(p_periode,v_periode);
  EXCEPTION
  WHEN NO_data_Found THEN
    v_dtdebMois := v_periode ||'01';
    select to_char(last_day(to_date(to_char(v_periode),'yyyymm')),'YYYYMMDD') into v_finMois   from dual;
  WHEN OTHERS THEN
    v_dtdebMois :=null;
    v_finMois :=null;
  END;
  --La création dans GAP_TRT est donc conditionnée : on regarde s’il existe déjà dans GAP_TRT
  --une ligne pour N° d’échange, date de paie et Numpac (infos de la carte 00).
  v_req := 'MERGE into GAP_TRT USING (SELECT 1 FROM dual) ON ( ID_TRT= :p_id )';--AND NUMPAC = :p_numpac AND NUMERO_ECHANGE =''0000'' AND PERIODE_PAIE = :p_periode
  v_req := v_req ||' WHEN NOT MATCHED THEN INSERT (ID_TRT,NUMPAC,PERIODE_PAIE,NUMERO_ECHANGE,MODELE,NATURE,DATE_DEBUT_PAIE,DATE_FIN_PAIE,WORKFLOW_ID,DATE_PREVUE_TRT,DATE_PLANIF_TRT,DATE_DEBUT_TRT,INFO) ';
  v_req := v_req ||' values (:p_id,:p_numpac,:p_periode,''0000'',''ALP'',:v_dtdebMois,:v_dtdebMois,:v_finMois,''TGEPAY'||p_numpac||'PACGXP'||NVL(p_periode,v_periode)||'0000'',sysdate,sysdate,sysdate,:p_type_retour)' ;
  EXECUTE IMMEDIATE v_req USING p_id,
  p_id,
  p_numpac,
  NVL(p_periode,v_periode),
  p_type_retour,
  v_dtdebMois,
  v_finMois,
  p_type_retour;
  COMMIT;
  FSED_AVANCEMENT(p_id,'insert_gap_trt Fin v_req='||v_req);
END insert_gap_trt;
PROCEDURE insert_gap_trt_suivi(
    p_id              IN NUMBER ,
    p_statut          IN TGE_REF_PAC.numpac%type,
    p_code_retour_zpp IN TGE_REF_PAC.PERIODEENCOURS%TYPE,
    p_login           IN VARCHAR2,
    p_type_retour     IN VARCHAR2)
IS
  PRAGMA AUTONOMOUS_TRANSACTION;
  status INT;
  v_req  VARCHAR2(3000);
BEGIN
  IF p_type_retour IN ('RR','RC','RN','CL') THEN
    FSED_AVANCEMENT(p_id,'insert_gap_trt_suivi Debut p_id='||p_id||';p_statut='||p_statut||';p_code_retour_zpp='||p_code_retour_zpp||';p_login='||p_login);
    v_req := 'INSERT INTO gap_trt_suivi(ID_TRT,DATE_EVT,STATUT,CODE_RETOUR_ZPP,LOGIN) VALUES (:p_id,SYSTIMESTAMP,:p_statut ,:p_code_retour_zpp,:p_login)';
    FSED_AVANCEMENT(p_id,'insert_gap_trt_suivi ='||p_id||';p_statut='||p_statut||';p_code_retour_zpp='||p_code_retour_zpp||';p_login='||p_login||';v_req='||v_req);
    EXECUTE IMMEDIATE v_req USING p_id,
    p_statut,
    p_code_retour_zpp,
    p_login;
    COMMIT;
    FSED_AVANCEMENT(p_id,'insert_gap_trt_suivi Fin');
  END IF;
END insert_gap_trt_suivi;
/**********************************************************************
  Funct : preparation_FSED_unit 
  DESC  : 
***********************************************************************/
PROCEDURE preparation_FSED_unit(
    p_nomTable  IN VARCHAR2,
    p_alias     IN VARCHAR2,
    p_TABLETYPE IN VARCHAR2,
    p_id_trt    IN NUMBER,
    p_numpac    IN VARCHAR2,
    p_periode   IN VARCHAR2,
    p_ALLERRETOUR IN VARCHAR2,
     p_nb_mois_paie_init IN number)
AS
  --curseur sur MAPDO
  CURSOR cur_mapdo IS
    SELECT a.*,
      b.*,
      c.type AS typeZADIG,
      c.longueur,
      c.MASQUE
    FROM
      (SELECT *
      FROM tge_ref_mapdo
      WHERE numpac     =p_numpac
      AND (tablegxp    =p_alias
      AND element NOT IN ('A301','A302','A962')
        --Pour ces 3 éléments on impose un alias spécial, ils seront traités indépendamment.
      OR p_alias   ='VUE-A301-A302-A962'
      AND element IN ('A301','A302','A962'))
    UNION ALL
    SELECT *
    FROM tge_ref_mapdo
    WHERE numpac     ='*'
    AND (tablegxp    =p_alias
    AND element NOT IN ('A301','A302','A962')
      --Pour ces 3 éléments on impose un alias spécial, ils seront traités indépendamment.
    OR p_alias       ='VUE-A301-A302-A962'
    AND element     IN ('A301','A302','A962'))
    AND element NOT IN
      (SELECT element
      FROM tge_ref_mapdo
      WHERE numpac=p_numpac
      )
      ) a,
      (SELECT column_name,
        data_type
      FROM user_tab_columns
      WHERE table_name = p_nomTable
      ) b,
      (SELECT *
      FROM TGE_REF_DICOZ
      WHERE numpac=p_numpac
      ) C
    WHERE donneegxp  = column_name
    AND c.element    =a.element
    AND (donnfiltre IS NULL
    OR donnfiltre   IN
      (SELECT c.column_name
      FROM user_tab_columns c
      WHERE c.table_name = p_nomTable
      ))
    AND occurence NOT LIKE '%!%'
    ORDER BY a.element,a.occurence;

    lig_mapdo      cur_mapdo%rowtype;
    requete        CLOB;
    requetePhoto   CLOB;
    requeteTDIF    CLOB;
    clselect       CLOB;
    numcol         NUMBER:=0;
    i              NUMBER:=1;
    j              NUMBER:=1;
    numretour      NUMBER:=1;
    tab1           TAB_pour_comp;
    tab2           TAB_pour_comp;
    tabLib         TAB_pour_lib;
    tabRetour      TAB_pour_retour;
    tabNotRetour   TAB_pour_retour;
    donnee         VARCHAR(1000);
    tabCles        TAB_cle;
    cles           VARCHAR2(1000);
    v_typeTable    VARCHAR2(1);
    clwhere        VARCHAR(3000);
    clfrom         VARCHAR(3000);
    clwhereDate    VARCHAR(500);
    clwherePrOp    VARCHAR(500);
    coldtfin       VARCHAR(255);
    histoARenvoyer BOOLEAN:=false;
    hasDtfin       NUMBER;
    hasDtfinSit    NUMBER;
    reqLength      NUMBER;
    photoLength    NUMBER;
    curclemati     VARCHAR2(20);
    curclematj     VARCHAR2(20);
    preclemati     VARCHAR2(20);
    preclematj     VARCHAR2(20);
    tab1cle        VARCHAR2(1000);
    tab2cle        VARCHAR2(1000);
    w_where_dic    CLOB;
    w_where_dic1   CLOB;
    w_arg1         CLOB;
    w_arg2         CLOB;
    isDICOJointure Number;
    w_mpe          varchar2(1);
  BEGIN
    --vérifier le type principal de la table m=MATRIC p=PACMAT z=PAIEZAD
    v_typeTable:=getTypeTable(p_nomTable);
    --lire le type de MPE (N=rien,M=MPE,C=CSCP)
    select mpe into w_mpe from tge_ref_pac where numpac=p_numpac ;
    --préparation des champs relatifs à la clé et à la date d'effet
    SELECT a.column_name,
      b.data_type bulk collect
    INTO tabCles
    FROM user_cons_columns a,
      USER_TAB_COLUMNS b
    WHERE a.table_name   =p_nomTable
    AND a.table_name     =b.table_name
    AND a.column_name    =b.column_name
    AND constraint_name IN
      (SELECT c.constraint_name
      FROM user_constraints c
      WHERE c.table_name =a.table_name
      AND CONSTRAINT_TYPE='P'
      );
    --colonne dteffet du résultat qui se déverse dans DIF_FSED et participe aux jointures D_A_C et D_A_C_H
 if w_mpe='C' THEN
 coldteffet:='d.DSDSC';
 ELSE
 coldteffet:='d.DSDCN';
END IF;
    --coldatecle (colonne date dans la clé) sert à fabriquer le filtre qui élimine le futur
    coldatecle:='';
    --colonne dtfin du résultat qui participe aux jointures D_A_C et D_A_C_H
    coldtfin :='to_date(''20991231'',''yyyymmdd'') as dtfin ';
    --début du champ "cle" selon le type du dico
    IF v_typeTable   ='m' THEN
      cles          :='b.pacmat||''#''||d.paiezad';
    ELSIF v_typeTable='p' THEN
      cles          :='a.pacmat||''#''||d.paiezad';
    ELSE
      cles :='NVL(a.pacmat,a.paiezad)||''#''||a.paiezad';
    END IF;
    --reste du champ "cle"
    FOR i IN tabCles.first..tabCles.last
    LOOP
      IF tabCles(i).column_name NOT IN ('NUMPAC','MATRIC','PACMAT','PAIEZAD','NUMCNT') THEN
        cles                   :=cles||'||''#''||';
        IF tabCles(i).data_type ='DATE' THEN
          --une date dans la clé servira à filtrer le futur
          coldatecle               :=tabCles(i).column_name;
          cles                     :=cles||'to_char(a.'||coldatecle||',''yyyymmdd'')';
          IF tabCles(i).column_name = 'DATE_EFF' THEN
            coldteffet             :='a.DATE_EFF';
          END IF;
        ELSE
          cles :=cles||'a.'||tabCles(i).column_name;
        END IF;
      END IF;
    END LOOP;
    --champ "cle" cas particulier de D_A_C
    IF p_nomTable ='DIC_ADM_CONTRAT' THEN
      coldatecle :='DSDCN';
     if w_mpe='C' THEN
     coldteffet :='d.DSDSC';
      ELSE
      coldteffet :='a.DSDCN';
    END IF;
      cles       :=cles||'||''#''||to_char(a.DSDCN,''yyyymmdd'')';
    END IF;
    --champ "cle" cas particulier de D_A_C_S
    IF p_nomTable ='DIC_ADM_CONTRAT_SITU' THEN
      coldatecle :='DSDSC';
      coldteffet :='a.DSDSC';
      cles       :=cles||'||''#''||to_char(a.DSDSC,''yyyymmdd'')';
    END IF;
    --préparation du filtre sur la date d'effet et la date de fin si elles existent
    SELECT COUNT(*)
    INTO   hasDtfinSit
    FROM   user_tab_columns
    WHERE  table_name =p_nomTable
    AND     column_name  ='DATE_SORTIE_SIT_BO';
     --préparation du filtre sur la date d'effet et la date de fin si elles existent
    SELECT COUNT(*)
    INTO   hasDtfin
    FROM   user_tab_columns
    WHERE  table_name =p_nomTable
    AND    column_name  ='DATE_FIN';
    clwhereDate     :='';
    --si on a une date dans la clé on élimine le futur avec (date de naissance d'enfant, d'adhésion mutuelle, d'effet HISTO...)
    IF coldatecle IS NOT NULL THEN
      clwhereDate :=' and nvl(a.'||coldatecle||',to_date(''19000101'',''yyyymmdd''))<=last_day(to_date('''||p_periode||''',''yyyymm''))';
      IF p_TABLETYPE='H2' AND p_nomTable ='DIC_PERIODES_RECUEIL_HIS' THEN
      clwhereDate :=clwhereDate||' and to_char(a.'||coldatecle||',''yyyymm'')='''||p_periode||'''';
      END IF;
      IF  p_TABLETYPE='DERNIERE' THEN
         clwhereDate :=clwhereDate||' and nvl(a.'||coldatecle||',to_date(''19000101'',''yyyymmdd''))<=d.date_sortie_sit_bo';
      END IF;      
      IF p_alias   ='VUE-A301-A302-A962' THEN
        --cas particulier pour lire D_A_C_H jusqu'au 1er jour de M+1 donc on ajoute 1 jour à la limite
        clwhereDate :=clwhereDate||'+1';
      END IF;
    END IF;
    --si on a une date de fin dans la table on elle alimente la colonne dtfin pour exclure les vieux historiques inutiles (finis avant 1er jour de M-1)
    IF hasDtfinSit >0 THEN
      --date fin spéciale calculée par la GAP une seule fois à 2099 par MATRIC
      coldtfin     :='a.DATE_SORTIE_SIT_BO as dtfin';
    ELSIF p_nomtable in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_SITU') THEN
      --pour D_A_C et D_A_C_S on va chercher DATE_SORTIE_SIT_BO sur D_A_C_H
      coldtfin    :='d.DATE_SORTIE_SIT_BO as dtfin';
    ELSIF hasDtfin >0 THEN
      --date fin d'HISTO classique
      coldtfin :='a.DATE_FIN as dtfin';
    END IF;
    --préparation du filtre sur prêt et opposition car solde=0 filtre, mais montant=0 force l'envoi.
    IF p_alias     =DicoPret THEN
      clwherePrOp := ' and (NVL(a.'||soldePret ||',0) !=0 or NVL(a.'||MontantPret ||',0) =0) ';
    ELSIF p_alias  =DicoOpposition THEN
      clwherePrOp := ' and (NVL(a.'||soldeOpposition||',0) !=0 or NVL(a.'||MontantOpposition||',0) =0) ';
    ELSE
      clwherePrOp:='';
    END IF;
    --création des requêtes sur DICO et table PHOTO
    OPEN cur_mapdo;
    LOOP
      FETCH cur_mapdo INTO lig_mapdo;
      IF (numcol =0 OR numcol >=30) THEN
        FSED_AVANCEMENT(p_id_trt,'Creation requetes '||p_nomTable);
        clselect :='select ';
        tablib.delete;
        IF v_typeTable    ='m' THEN
        	IF coldatecle is not null THEN
        		clselect       :=clselect||cles||' as CLE,b.numpac,b.pacmat,d.paiezad,greatest(a.'||coldatecle||','||coldteffet||') as dteffet,'||coldtfin;
        	ELSE
          		clselect       :=clselect||cles||' as CLE,b.numpac,b.pacmat,d.paiezad,'||coldteffet||' as dteffet,'||coldtfin;
          	END IF;
        ELSIF v_typeTable ='p' THEN
          clselect       :=clselect||cles||' as CLE,a.numpac,a.pacmat,d.paiezad,'||coldteffet||' as dteffet,'||coldtfin;
        ELSE
          --les dicos 'z' (PAIEZAD) peuvent avoir une colonne PACMAT mal remplie
          clselect :=clselect||cles||' as CLE,a.numpac,NVL(a.pacmat,a.paiezad) as pacmat,a.paiezad,'||coldteffet||' as dteffet,'||coldtfin;
        END IF;
        IF p_TABLETYPE     ='PREMIERE' OR p_TABLETYPE='DERNIERE' OR p_TABLETYPE='OCCURS' THEN
          IF v_typetable   ='m' THEN
            clselect      :=clselect||','||' row_number() over (partition by d.paiezad order by '||cles;
          ELSIF v_typetable='p' THEN
            clselect      :=clselect||','||' row_number() over (partition by a.paiezad order by '||cles;
          ELSE
            clselect :=clselect||','||' row_number() over (partition by a.paiezad order by '||cles;
          END IF;
          IF p_TABLETYPE='DERNIERE' THEN
            clselect   :=clselect||' desc';
          END IF;
          clselect :=clselect||') as rank ';
        ELSE
          clselect :=clselect||',null as rank ';
        END IF;
        numcol :=0;
      END IF;
      IF cur_mapdo%NOTFOUND THEN
        numcol:=numcol+1;
        FOR k        IN numcol..30
        LOOP
          clselect :=clselect||','''' as C'||k ;
        END LOOP;
      ELSE
        tablib(numcol).LIB                        :=lig_mapdo.ELEMENT;
        IF lig_mapdo.TRTPARTICULIER               IS NULL THEN
          IF lig_mapdo.data_type                   ='DATE' THEN
            tablib(numcol).TYPE_DONNEE            :='D';
          elsif instr(lig_mapdo.data_type,'NUMBER')>0 THEN
            tablib(numcol).TYPE_DONNEE            :='N';
          ELSE
            tablib(numcol).TYPE_DONNEE:='A';
          END IF;
        ELSE
          -- Transcription du format dans TGE_REF_DICOZ
          IF lig_mapdo.typeZADIG       ='P' THEN
            tablib(numcol).TYPE_DONNEE:='N';
          ELSIF lig_mapdo.typeZADIG    ='N' AND lig_mapdo.MASQUE IN (1,2,3,4,5,6,7)THEN
            tablib(numcol).TYPE_DONNEE:='D';
          ELSIF lig_mapdo.typeZADIG    ='N' AND lig_mapdo.MASQUE NOT IN (1,2,3,4,5,6,7)THEN
            tablib(numcol).TYPE_DONNEE:='N';
          ELSIF lig_mapdo.typeZADIG    ='A' THEN
            tablib(numcol).TYPE_DONNEE:='A';
          ELSE
            tablib(numcol).TYPE_DONNEE:=lig_mapdo.typeZADIG;
          END IF;
        END IF;
        tablib(numcol).OCC                :=lig_mapdo.OCCURENCE;
        clselect                          :=clselect||',';
        donnee :=getClauseSelect(p_numpac,
                                 'a',
                                 lig_mapdo.DONNEEGXP,
                                 lig_mapdo.DONNFILTRE,
                                 lig_mapdo.OPERFILTRE,
                                 lig_mapdo.VALFILTRE,
                                 lig_mapdo.TRTPARTICULIER,
                                 lig_mapdo.ENVOI_SYSTEMATIQUE,
                                 lig_mapdo.data_type,
                                 lig_mapdo.typeZADIG,
                                 lig_mapdo.MASQUE,
                                 tablib(numcol).OCC,
                                 TRUE);
        numcol :=numcol+1;
        clselect :=clselect||donnee||' as C'||numcol;
        FSED_AVANCEMENT(p_id_trt,'numcol='||TO_CHAR(numcol)||' mapdo='||lig_mapdo.NUMPAC||'/'||lig_mapdo.ELEMENT||'/'||lig_mapdo.OCCURENCE||'/'||lig_mapdo.DONNEEGXP||'/'||lig_mapdo.TABLEGXP||'/'||lig_mapdo.DONNFILTRE||'/'||lig_mapdo.OPERFILTRE||'/'||lig_mapdo.VALFILTRE||'/'||lig_mapdo.TRTPARTICULIER||'/'||lig_mapdo.ENVOI_SYSTEMATIQUE||'/'||lig_mapdo.FORCABLE_ECRAN_GENERE||' data_type='||lig_mapdo.data_type||' zadig='||lig_mapdo.typeZadig||'/'||TO_CHAR(lig_mapdo.longueur)||'/'||lig_mapdo.masque);
      END IF;
      --toutes les 30 colonnes on lance les requêtes et on effectue les comparaisons
      IF (numcol =30 OR cur_mapdo%NOTFOUND) THEN
        --clause from commune avec ses jointures
        if w_mpe='C' THEN 
        clfrom       :='(SELECT * FROM ( WITH TABLE_DATES_EFF (PACMAT, PAIEZAD, DATE_EFF) AS ( SELECT DACH2.PACMAT, DACH2.PAIEZAD , MAX(DATE_EFF) ';
        ELSE
        clfrom       :='(SELECT * FROM ( WITH TABLE_DATES_EFF (PACMAT, NUMCNT, DATE_EFF) AS ( SELECT DISTINCT DACH2.PACMAT, DACH2.NUMCNT , MAX(DATE_EFF) OVER (PARTITION BY L.NUMPAC, L.PACMAT, DACH2.NUMCNT) ';
        END IF;
        clfrom       :=clfrom||'FROM GAP_TRT_LISTE_MAT L, DIC_ADM_CONTRAT_HISTO DACH2 ';
        clfrom       :=clfrom||'WHERE L.ID_TRT = '||p_id_trt||' AND L.NUMPAC = '''||p_numpac||''' AND DACH2.NUMPAC = '''||p_numpac||''' ';
        if w_mpe='C' THEN 
        clfrom       :=clfrom||'AND DACH2.PACMAT = L.PACMAT AND DACH2.DATE_EFF <=LAST_DAY(TO_DATE('''||p_periode||''',''yyyymm'')) AND DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE('''||p_periode||''',''yyyymm'')),-'||p_nb_mois_paie_init||') GROUP BY DACH2.NUMPAC, DACH2.PACMAT, DACH2.PAIEZAD ) ';
        ELSE
        clfrom       :=clfrom||'AND DACH2.PACMAT = L.PACMAT AND DACH2.DATE_EFF <=LAST_DAY(TO_DATE('''||p_periode||''',''yyyymm'')) AND DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE('''||p_periode||''',''yyyymm'')),-'||p_nb_mois_paie_init||') ) ';
        END IF;
        if w_mpe='C' THEN
        clfrom       :=clfrom||'SELECT DACS.NUMPAC, DACS.MATRIC, DACS.PACMAT, MAX(DACS.CODE_CHRONO) CODE_CHRONO, DACS.PAIEZAD, MIN(DACS.DSDSC) DSDSC,MIN(C.DSDCN) DSDCN , MAX(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO ';
        ELSE
        clfrom       :=clfrom||'SELECT DACS.NUMPAC, DACS.MATRIC, DACS.PACMAT, MAX(DACS.CODE_CHRONO) CODE_CHRONO, DACS.PAIEZAD, MIN(C.DSDCN) DSDCN, MAX(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO ';
        END IF;
        clfrom       :=clfrom||'FROM TABLE_DATES_EFF T, DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH ';
        clfrom       :=clfrom||'WHERE C.NUMPAC = '''||p_numpac||''' AND DACS.NUMPAC = '''||p_numpac||''' AND DACH.NUMPAC = '''||p_numpac||''' ';
        if w_mpe='C' THEN
        clfrom       :=clfrom||'AND C.PACMAT = T.PACMAT AND DACH.PACMAT = T.PACMAT AND DACH.PAIEZAD = T.PAIEZAD AND DACH.DATE_EFF = T.DATE_EFF AND C.NUMCNT = DACS.NUMCNT AND DACS.PACMAT = T.PACMAT AND DACS.PAIEZAD = T.PAIEZAD AND DACS.PAIEZAD = DACH.PAIEZAD ';
        ELSE
        clfrom       :=clfrom||'AND C.PACMAT = T.PACMAT AND C.NUMCNT = T.NUMCNT AND DACH.PACMAT = T.PACMAT AND DACH.NUMCNT = T.NUMCNT AND DACH.DATE_EFF = T.DATE_EFF AND DACS.PACMAT = T.PACMAT AND DACS.NUMCNT = T.NUMCNT AND DACS.PAIEZAD = DACH.PAIEZAD ';
        END IF;
        if w_mpe='C' and p_nomTable ='DIC_ADM_CONTRAT' THEN
         --jointure forcée entre DAC et DACS pour les situations contractuelles
          clfrom       :=clfrom||'AND C.DSDCN <=LAST_DAY(TO_DATE('''||p_periode||''',''yyyymm'')) AND NVL(dach.DRPAI2, ''B'') <> ''B'' AND C.NATCOL IN (''SAL'',''STA'') GROUP BY DACS.NUMPAC, DACS.MATRIC, DACS.PACMAT, DACS.PAIEZAD )) d WHERE d.dsdsc between a.dsdcn AND nvl(a.dsfcn,to_date(''20991231'',''yyyymmdd'')) AND ';
        ELSE
			--SEUNA2-17301 Cas des dictionnaires historisés.
			IF coldteffet='a.DATE_EFF' THEN
			   clfrom       :=clfrom||'AND C.DSDCN <=LAST_DAY(TO_DATE('''||p_periode||''',''yyyymm'')) AND NVL(dach.DRPAI2, ''B'') <> ''B'' AND C.NATCOL IN (''SAL'',''STA'') GROUP BY DACS.NUMPAC, DACS.MATRIC, DACS.PACMAT, DACS.PAIEZAD )) d WHERE  a.DATE_EFF < d.date_sortie_sit_bo and 1=1 and nvl(a.DATE_FIN,to_date(''20991231'',''yyyymmdd'')) >= d.dsdcn  and ';    
			ELSE
			   clfrom       :=clfrom||'AND C.DSDCN <=LAST_DAY(TO_DATE('''||p_periode||''',''yyyymm'')) AND NVL(dach.DRPAI2, ''B'') <> ''B'' AND C.NATCOL IN (''SAL'',''STA'') GROUP BY DACS.NUMPAC, DACS.MATRIC, DACS.PACMAT, DACS.PAIEZAD )) d WHERE  '||coldteffet||' between d.dsdcn and d.date_sortie_sit_bo AND ';
			END IF;          
        END IF;
        IF v_typeTable='m' THEN
          --dictionnaire à base de MATRIC (conjoint, enfants, perso...)
          clwhere       :='a.matric=d.matric '||clwhereDate;
          requete       :=REPLACE(REPLACE(REPLACE(clselect,'b.','d.'),'@###',''),'###@','')||' from '||p_nomTable||' a, '||clfrom||clwhere||' order by cle';          
          if w_mpe='C' THEN 
          requetePhoto  :=REGEXP_REPLACE(REPLACE(clselect,'b.','a.'),'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(REPLACE(REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C'),'DIC_ADM_CONTRAT_SITU DACS','PHOTO_DIC_ADM_CONTRAT_SITU DACS'),'DIC_ADM_CONTRAT_HISTO DACH','PHOTO_DIC_ADM_CONTRAT_HISTO DACH')||'a.numpac='''||p_numpac||''' and a.pacmat=d.pacmat and '||clwhere||' order by cle';
          else
          requetePhoto  :=REGEXP_REPLACE(REPLACE(clselect,'b.','a.'),'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C')||'a.numpac='''||p_numpac||''' and a.pacmat=d.pacmat and '||clwhere||' order by cle';                   
          end if;

        ELSIF v_typeTable='p' THEN
          --dictionnaire à base de PACMAT (D_A_C, Oppositions à partir de la 5.03...)
          clwhere      :='a.numpac='''||p_numpac||''' and a.pacmat=d.pacmat '||clwhereDate||clwherePrOp;
          requete      :=REPLACE(REPLACE(clselect,'@###',''),'###@','')||' from '||p_nomTable||' a, '||clfrom||clwhere||' order by cle';
          if w_mpe='C' THEN 
          requetePhoto :=REGEXP_REPLACE(clselect,'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(REPLACE(REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C'),'DIC_ADM_CONTRAT_SITU DACS','PHOTO_DIC_ADM_CONTRAT_SITU DACS'),'DIC_ADM_CONTRAT_HISTO DACH','PHOTO_DIC_ADM_CONTRAT_HISTO DACH')||'d.numpac='''||p_numpac||''' and '||clwhere||' order by cle';
          else
          requetePhoto :=REGEXP_REPLACE(clselect,'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C')||'d.numpac='''||p_numpac||''' and '||clwhere||' order by cle';
          end if;
        ELSE
          --dictionnaire à base de PAIEZAD (D_A_C_H, imputations permanentes par exemple)
          clwhere      :='a.numpac='''||p_numpac||''' and a.pacmat=d.pacmat and a.paiezad=d.paiezad '||clwhereDate||clwherePrOp;
          requete      :=REPLACE(REPLACE(clselect,'@###',''),'###@','')||' from '||p_nomTable||' a, '||clfrom||clwhere||' order by cle';
          if w_mpe='C' THEN 
          requetePhoto :=REGEXP_REPLACE(clselect,'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(REPLACE(REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C'),'DIC_ADM_CONTRAT_SITU DACS','PHOTO_DIC_ADM_CONTRAT_SITU DACS'),'DIC_ADM_CONTRAT_HISTO DACH','PHOTO_DIC_ADM_CONTRAT_HISTO DACH')||'d.numpac='''||p_numpac||''' and '||clwhere||' order by cle';          
          else
          requetePhoto :=REGEXP_REPLACE(clselect,'(@###)[^###@]+(###@)','''_TO_SEND_''')||' from PHOTO_'||p_nomTable||' a, '||REPLACE(clfrom,' DIC_ADM_CONTRAT C',' PHOTO_DIC_ADM_CONTRAT C')||'d.numpac='''||p_numpac||''' and '||clwhere||' order by cle';
          end if;
        END IF;
        requetePhoto :=REPLACE (requetePhoto,'to_char(''_TO_SEND_'',''yyyymmddHH24MISS'')','to_char(''_TO_SEND_'')');
        --recup clause where
        select instr(requete,'$DICOUPHOTO_JOINTURE') into isDICOJointure from dual;
        IF isDICOJointure != 0 THEN
        w_where_dic1 :=  REGEXP_SUBSTR(requete,'\(.*\)');
        w_where_dic:= REPLACE(REGEXP_SUBSTR(requete,'\$DICOUPHOTO_JOINTURE[^\)]*'),'$DICOUPHOTO_JOINTURE(','');
        --recup arg 1:
        w_arg1 := substr(w_where_dic,1,instr(w_where_dic,',',-1)-1);
        --recup arg 2 :
        w_arg2 := substr(w_where_dic,instr(w_where_dic,',',-1)+1,length(w_where_dic)-instr(w_where_dic,',',-1));
        requete :=REPLACE (REPLACE (requete,w_where_dic1,w_arg1),'$DICOUPHOTO_JOINTURE','');
        requetePhoto :=REPLACE (REPLACE (requetePhoto,w_where_dic1,w_arg2),'$DICOUPHOTO_JOINTURE','');
        END IF;
        requete :=REPLACE (requete,'$DICOUPHOTO',p_nomTable);
        requetePhoto :=REPLACE (requetePhoto, '$DICOUPHOTO','PHOTO_'||p_nomTable);
        
        IF tablib.exists(0) THEN
          IF p_TABLETYPE ='PREMIERE' OR p_TABLETYPE='DERNIERE' THEN
            requete     :='select * from ('||requete||') where rank=1';
            requetePhoto:='select * from ('||requetePhoto||') where rank=1';
          END IF;
          tab1.delete;
          tab2.delete;
          EXECUTE immediate 'select length(:req) from dual' INTO reqLength USING requete ;
          EXECUTE immediate 'select length(:req) from dual' INTO photoLength USING requetePhoto ;
          FSED_AVANCEMENT(p_id_trt,'Execution requete '||p_alias);
          FSED_AVANCEMENT(p_id_trt,SUBSTR(requete,1,4000));
          IF reqLength IS NOT NULL AND reqLength>4000 THEN
            FSED_AVANCEMENT(p_id_trt,SUBSTR(requete,4001,4000));
            IF reqLength IS NOT NULL AND reqLength>8000 THEN
              FSED_AVANCEMENT(p_id_trt,SUBSTR(requete,8001,4000));
            END IF;
          END IF;
          EXECUTE immediate requete bulk collect INTO tab1 ;
          FSED_AVANCEMENT(p_id_trt,'Fin execution requete DICO');

          IF p_ALLERRETOUR != 'I' THEN
            FSED_AVANCEMENT(p_id_trt,'Execution requetePhoto '||p_alias);
            FSED_AVANCEMENT(p_id_trt,SUBSTR(requetePhoto,1,4000));
            IF photoLength IS NOT NULL AND photoLength>4000 THEN
              FSED_AVANCEMENT(p_id_trt,SUBSTR(requetePhoto,4001,4000));
              IF photoLength IS NOT NULL AND photoLength>8000 THEN
                FSED_AVANCEMENT(p_id_trt,SUBSTR(requetePhoto,8001,4000));
              END IF;
            END IF;
            EXECUTE immediate requetePhoto bulk collect INTO tab2;
            FSED_AVANCEMENT(p_id_trt,'Fin execution requete PHOTO ');
          END IF;
          FSED_AVANCEMENT(p_id_trt,'Debut traitement des differences lignes DICO='||TO_CHAR(NVL(tab1.last,0))||' lignes PHOTO='||TO_CHAR(NVL(tab2.last,0)));
          numretour:=1;
          tabRetour.delete;
          --Boucle principale sur la colonne de 0 à 29 indicée par numcol
          FOR numcol IN tablib.first..tablib.last
          LOOP
            --Pour chaque nouvelle colonne on initialise le dernier matricule, les matricules en cours, et les indices.
            i            :=1;
            j            :=1;
            MatARenvoyer :=' ';
            MatEcrit     :=' ';
            oldvaleur    :=' ';
            curclemati   :=' ';
            curclematj   :=' ';
            preclemati   :='#';
            preclematj   :='#';
            tab1cle      :=' ';
            tab2cle      :=' ';
            --Appareillage "tab1" (DIC_xxx) et "tab2" (PHOTO_DIC_xxx) triés selon leurs clés
            WHILE i <= tab1.last OR j <= tab2.last
            LOOP
              IF i        <= tab1.last THEN
                --constitution de la clé "matricule courant" partie GAP

                curclemati:=tab1(i).pacmat||'#'||tab1(i).paiezad;
                IF p_TABLETYPE IN ('OCCURS','PREMIERE','DERNIERE') THEN
                  --clé de comparaison = couple pacmat-paiezad + rang de l'OCCURS (vaut 1 sur PREMIERE et DERNIERE)
                  tab1cle :=curclemati||TO_CHAR(NVL(tab1(i).rank,0),'000');
                ELSE
                  --clé de comparaison = celle de DIF_FSED donc celle de la ligne Oracle
                  tab1cle :=tab1(i).cle;
                END IF;
              ELSE
                curclemati :=' ';
                --clé de comparaison = high_value pour faciliter les comparaisons
                tab1cle :=chr(255);
              END IF;
              IF j        <= tab2.last THEN
                --constitution de la clé "matricule" courant partie PHOTO

                curclematj:=tab2(j).pacmat||'#'||tab2(j).paiezad;
                IF p_TABLETYPE IN ('OCCURS','PREMIERE','DERNIERE') THEN
                  --clé de comparaison = couple pacmat-paiezad + rang de l'OCCURS (vaut 1 sur PREMIERE et DERNIERE)
                  tab2cle :=curclematj||TO_CHAR(NVL(tab2(j).rank,0),'000');
                ELSE
                  --clé de comparaison = celle de DIF_FSED donc celle de la ligne Oracle
                  tab2cle :=tab2(j).cle;
                END IF;
              ELSE
                curclematj :=' ';
                --clé de comparaison = high_value pour faciliter les comparaisons
                tab2cle :=chr(255);
              END IF;
              --Tables avec historiques comme D_A_C_H : la clé contient des dates d'effet donc il faut adapter l'appareillage
              IF coldteffet='a.DATE_EFF' THEN
                IF i <= tab1.last AND curclemati=MatARenvoyer THEN
                  --matricule déjà détecté en différence histo, on envoie tous les historiques. Les doublons sont éliminés automatiquement.
                  remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'M', p_TABLETYPE);
                  --avancer dans tab1
                  i :=i+1;
                  preclemati:=curclemati;
                Elsif j <= tab2.last AND curclematj=MatARenvoyer THEN
                  --avancer dans tab2 pour épuiser les histos photo déjà détectés en différence
                  j :=j+1;
                  preclematj:=curclematj;
                Elsif tab1cle < tab2cle and preclemati<>curclemati THEN
                  --ligne gap ajoutée car clé gap plus petite que clé photo et c'était le 1er histo du matricule : création
                  remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'C', p_TABLETYPE);
                  --avancer dans tab1
                  i :=i+1;
                  preclemati:=curclemati;
                Elsif tab1cle < tab2cle AND preclemati=curclemati THEN
                  --ligne gap ajoutée car clé gap plus petite que clé photo et il existe un histo gap précédent sur le même matricule : il faut comparer les valeurs du précédent.
                  IF difference_col( tab1(i) , tab1(i-1) , numcol )=1 THEN
                    --modification constatée entre histo gap précédent (j) et histo gap courant (i)
                    remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'C', p_TABLETYPE);
                  END IF;
                  --avancer dans tab1
                  i :=i+1;
                  preclemati:=curclemati;
                Elsif tab1cle > tab2cle AND preclemati<>curclematj THEN
                  --ligne gap supprimée et c'était le 1er histo du matricule : il faut forcer les valeurs à blanc sur cette date perdue.
                  remplissage_ligne(tabRetour, tab2(j), tablib(numcol), p_id_trt, numretour, numcol, 'S', p_TABLETYPE);
                  --avancer dans tab2
                  j :=j+1;
                  preclematj:=curclematj;
                Elsif tab1cle > tab2cle AND preclemati=curclematj THEN
                  --ligne gap supprimée et il existe un histo gap précédent sur le même matricule : il faut comparer les valeurs du précédent avec la photo.
                  i :=i-1;
                  IF difference_col( tab1(i) , tab2(j) , numcol )=1 THEN
                    --modification constatée entre histo gap précédent et histo photo courant (date d'effet=photo)
                    tab1(i).DTEFFET :=tab2(j).DTEFFET ;
                    remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'M', p_TABLETYPE);
                  END IF;
                  --avancer dans tab1 et tab2 car on a "comparé" ces 2 lignes
                  i :=i+1;
                  preclemati:=curclemati;
                  j :=j+1;
                  preclematj:=curclematj;
                ELSE
                  --comparaison car à ce stade il y a forcément égalité tab1cle=tab2cle (pacmat + paiezad + date d'effet)
                  IF difference_col( tab1(i) , tab2(j) , numcol )=1 THEN
                    --modification constatée
                    remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'M', p_TABLETYPE);
                  END IF;
                  --avancer dans tab1 et tab2
                  i :=i+1;
                  preclemati:=curclemati;
                  j :=j+1;
                  preclematj:=curclematj;
                END IF;
              ELSE
                --Tables sans historiques comme DIC_ENFANTS ou DIC_ADM_PERSO
                IF tab1cle < tab2cle THEN
                  --ligne ajoutée car j épuisé ou clé i plus petite que clé j (ce qui marche aussi pour des historiques créés après photo)
                  remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'C', p_TABLETYPE);
                  --avancer dans tab1
                  i    :=i+1;
                  preclemati:=curclemati;
                Elsif tab1cle > tab2cle THEN
                  --ligne supprimée car i épuisé ou clé i plus grande que clé j
                  remplissage_ligne(tabRetour, tab2(j), tablib(numcol), p_id_trt, numretour, numcol, 'S', p_TABLETYPE);
                  --avancer dans tab2
                  j :=j+1;
                  preclematj:=curclematj;
                ELSE
                  --comparaison car à ce stade il y a forcément égalité de clé tab1(i).cle=tab2(j).cle -ou- OCCURS du couple pacmat-paiezad
                  IF difference_col( tab1(i) , tab2(j) , numcol )=1 THEN
                    --modification constatée
                    remplissage_ligne(tabRetour, tab1(i), tablib(numcol), p_id_trt, numretour, numcol, 'M', p_TABLETYPE);
                  END IF;
                  --avancer dans tab1 et tab2
                  i :=i+1;
                  preclemati:=curclemati;
                  j :=j+1;
                  preclematj:=curclematj;
                END IF;
              END IF;
            END LOOP;
          END LOOP;
          FSED_AVANCEMENT(p_id_trt,'Fin traitement des differences');
          IF NVL(tabRetour.first,0)=0 THEN
            FSED_AVANCEMENT(p_id_trt,'Pas de differences');
          ELSE
            FSED_AVANCEMENT(p_id_trt,'Insertion des differences numeros '||TO_CHAR(NVL(tabRetour.first,0))||' a '||TO_CHAR(NVL(tabRetour.last,0)));
            FORALL i IN tabRetour.first..tabRetour.last
            INSERT
            INTO DIF_FSED_TEMPORARY
              (
                id_trt,
                numpac,
                CLE,
                pacmat,
                ELEM,
                OCC,
                VALEUR,
                CODEOP,
                TYPE_DONNEE ,
                DTEFFET,
                paiezad
              )
              VALUES
              (
                p_id_trt,
                p_numpac,
                tabRetour(i).CLE,
                tabRetour(i).pacmat,
                tabRetour(i).ELEM,
                NVL(lpad(tabRetour(i).OCC,3,'0'),'  '),
                tabRetour(i).VALEUR,
                tabRetour(i).CODEOP,
                tabRetour(i).TYPE_DONNEE,
                tabRetour(i).DTEFFET,
                tabRetour(i).paiezad
              );
            requeteTDIF:='INSERT INTO DIF_FSED (ID_TRT,NUMPAC,CLE,PACMAT,PAIEZAD,ELEM,OCC,VALEUR,CODEOP,TYPE_DONNEE,DTEFFET) (select ID_TRT,NUMPAC,CLE,PACMAT,PAIEZAD,ELEM,OCC,VALEUR,CODEOP,TYPE_DONNEE,DTEFFET from DIF_FSED_TEMPORARY)';
            FSED_AVANCEMENT(p_id_trt,'Injection des differences dans DIF_FSED : '||requeteTDIF);
             EXECUTE_IMMEDIATE_STRING  (requeteTDIF,0);
            requeteTDIF:='TRUNCATE TABLE DIF_FSED_TEMPORARY';
            FSED_AVANCEMENT(p_id_trt,'Vidage de DIF_FSED_TEMPORARY : '||requeteTDIF);
             EXECUTE_IMMEDIATE_STRING  (requeteTDIF,0);
          END IF;
        END IF;
      END IF;
      EXIT
    WHEN cur_mapdo%NOTFOUND ;
    END LOOP;
    CLOSE cur_mapdo;
  EXCEPTION
  WHEN OTHERS THEN
    err_code := SQLCODE;
    err_msg  := SQLERRM;
    FSED_ERREUR( p_id_trt , 'preparation_FSED_unit' , p_nomTable||','||p_alias||','||p_TABLETYPE||','||p_id_trt||','||p_numpac||','||p_nb_mois_paie_init , err_code||'-'||err_msg );
    raise;
  END preparation_FSED_unit;
/*********************************************************
Proc : preparation_FSED
Fctn :
**********************************************************/
PROCEDURE preparation_FSED
  (
    p_id_trt  IN NUMBER,
    p_numpac  IN VARCHAR2,
    p_periode IN VARCHAR2
  )
IS
  CURSOR cur_tables
  IS
    SELECT *
    FROM
      (SELECT *
      FROM tge_ref_mapta
      WHERE numpac =p_numpac
        --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
        --Ajout du type 'I'
      AND ALLERRETOUR IN ('A','2','I')
    UNION ALL
    SELECT p_numpac,
      '***',
      'VUE-A301-A302-A962',
      FICHIER,
      TABLEPHY,
      ALLERRETOUR,
      TABLETYPE,
      MOISZERO,
      NBMOISCONS,
      SENSIBLERHID,
      RESERVE
    FROM tge_ref_mapta
    WHERE numpac  ='*'
    AND tableparam='DIC_ADM_CONTRAT_HISTO'
    UNION ALL
    SELECT *
    FROM tge_ref_mapta
    WHERE numpac ='*'
      --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
      --Ajout du type 'I'
    AND ALLERRETOUR      IN ('A','2','I')
    AND (tableparam) NOT IN
      (SELECT tableparam FROM tge_ref_mapta WHERE numpac=p_numpac
      )
      )
    ORDER BY tableparam;
    lig cur_tables%rowtype;
    nbPurgePhoto NUMBER:=0;
    v_flag       NUMBER;
    p_nb_mois_paie_init number;
    pReq  CLOB;
    w_PERIODEENCOURS TGE_REF_PAC.PERIODEENCOURS%TYPE;
    w_DEB_RETRO      TGE_REF_PAC.DEB_RETRO%TYPE;
    w_DEB_HISTO_RETRO TGE_REF_PAC.DEB_HISTO_RETRO%TYPE;
    w_MIN_RETRO       TGE_REF_PAC.DEB_RETRO%TYPE;
  BEGIN
    --Purge de la table des erreurs en cas de relance manuelle du "call"
   p_nb_mois_paie_init:= GET_NB_MOIS_PAIE_INIT();
   SELECT PERIODEENCOURS ,DEB_RETRO,DEB_HISTO_RETRO,
   greatest(DEB_HISTO_RETRO,TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS,'yyyymm'),-1*NB_MOIS_RETRO),'yyyymm'))
   INTO   w_PERIODEENCOURS ,w_DEB_RETRO,w_DEB_HISTO_RETRO,w_MIN_RETRO
   FROM TGE_REF_PAC 
   WHERE NUMPAC =p_numpac;
    DELETE
    FROM TGE_FSED_ERREUR
    WHERE id=p_id_trt;
    --Purge de la table d'avancement activée si TGE_FSED_IS_DEBUG.IS_DEBUG='O'
    DELETE
    FROM TGE_FSED_AVANCEMENT_PROC
    WHERE id=p_id_trt;
    COMMIT;
    pReq := 'select ADD_MONTHS(to_date('||p_periode||',''yyyymm''),-'||p_nb_mois_paie_init||') from dual';
    EXECUTE IMMEDIATE pReq INTO  mMoins1;
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED *** START *** pac='||p_numpac||' periode='||p_periode||' intervalle de validite='||TO_CHAR(mMoins1,'yyyymmdd')||'-'||TO_CHAR(last_day(to_date(p_periode,'yyyymm')),'yyyymmdd'));
    --Purge des photos si photo absente de DIC_ADM_CONTRAT
    FOR tabPurgePhoto IN
    (SELECT DISTINCT pacmat
    FROM GAP_TRT_LISTE_MAT
    WHERE id_trt    =p_id_trt
    AND pacmat NOT IN
      (SELECT pacmat FROM PHOTO_DIC_ADM_CONTRAT WHERE numpac=p_numpac
      )
    ORDER BY pacmat
    )
    LOOP
      FSED_AVANCEMENT(p_id_trt,'Efface Photo toutes tables pacmat='||tabPurgePhoto.pacmat);
      effaceMatricToutTable(p_numpac,tabPurgePhoto.pacmat);
      nbPurgePhoto:=nbPurgePhoto+1;
    END LOOP;
    IF nbPurgePhoto=0 THEN
      FSED_AVANCEMENT(p_id_trt,'Tous les Pacmat du traitement sont presents dans PHOTO_DIC_ADM_CONTRAT');
    ELSE
      FSED_AVANCEMENT(p_id_trt,'Nb pacmat absents de PHOTO_DIC_ADM_CONTRAT (effaceMatricToutTable) ='||TO_CHAR(nbPurgePhoto));
    END IF;
    getSoldMontant(p_numpac,p_id_trt,DicoPret,soldePret,MontantPret,DicoOpposition,soldeOpposition,MontantOpposition);
    FSED_AVANCEMENT(p_id_trt,'Donnees filtres prets oppositions : soldePret='||DicoPret||'.'||soldePret||' MontantPret='||DicoPret||'.'||MontantPret|| ' soldeOpposition='||DicoOpposition||'.'||soldeOpposition||' MontantOpposition='||DicoOpposition||'.'||MontantOpposition);
    OPEN cur_tables;
    LOOP
      FETCH cur_tables INTO lig;
      EXIT
    WHEN cur_tables%NOTFOUND ;
      FSED_AVANCEMENT(p_id_trt,'preparation_FSED --- Debut Traitement alias '||lig.tableparam||' (table '||lig.tablephy||')');
      preparation_FSED_unit(lig.tablephy,lig.tableparam,lig.TABLETYPE,p_id_trt,p_numpac,p_periode,lig.ALLERRETOUR ,p_nb_mois_paie_init);
      FSED_AVANCEMENT(p_id_trt,'preparation_FSED --- Fin Traitement alias '||lig.tableparam||' (table '||lig.tablephy||')');
    END LOOP;
    CLOSE cur_tables;
    SELECT COUNT(*) INTO v_flag FROM GAP_TRT_LISTE_MAT where ID_TRT = p_id_trt;
    --Partie Rétro 
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED ---Début Rétro id_trt= '||p_id_trt);
    IF w_DEB_RETRO is not null AND to_date(w_PERIODEENCOURS,'YYYYMM')>=to_date(w_DEB_RETRO,'YYYYMM') THEN
     BEGIN
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED --- remplissage DIF_FSED_MODIF_RETRO id_trt= '||p_id_trt);
     pReq := 'Alter TABLE DIF_FSED_MODIF_RETRO add partition ID_'||p_id_trt||' values ('||p_id_trt||')';
     EXECUTE_IMMEDIATE_STRING( pReq,0);
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED--remplissage DIF_FSED_MODIF_RETRO--partition cree: ID_'||p_id_trt||', pReq '||pReq);
    EXCEPTION
    WHEN OTHERS THEN
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED--remplissage DIF_FSED_MODIF_RETRO-- Erreur partition ID_'||p_id_trt);
    END ;
    
    --Insertion dans DIF_FSED_MODIF_RETRO
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion DIF_FSED_MODIF_RETRO--: ID_'||p_id_trt);
    pReq := 'INSERT INTO DIF_FSED_MODIF_RETRO SELECT * FROM dif_fsed f WHERE numpac ='''||p_numpac||''' AND f.id_trt ='||p_id_trt;
 	pReq := pReq ||' AND DTEFFET  <to_date('''||w_PERIODEENCOURS||'''||''01'',''YYYYMMDD'') ';
 	pReq := pReq ||' AND  f.elem in (select ELEMENT from tge_ref_dicoz where  numpac='''||p_numpac||''' AND nvl(CALCUL_RETRO,0)=1 )';
 	pReq := pReq ||' UNION  SELECT * FROM dif_fsed f WHERE numpac ='''||p_numpac||''' AND f.id_trt ='||p_id_trt;
 	pReq := pReq ||' AND DTEFFET  <to_date('''||w_PERIODEENCOURS||'''||''01'',''YYYYMMDD'') '; 
 	pReq := pReq ||' AND  exists (select 1 from dif_fsed t where t.numpac ='''||p_numpac||''' and t.id_trt ='''||p_id_trt||''' AND t.codeop=''C'' and t.ELEM =''A001'' and f.numpac = t.numpac AND f.id_trt = t.id_trt and f.paiezad=t.paiezad and f.pacmat=t.pacmat ) ';
 	FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début remplissage DIF_FSED_MODIF_RETRO--: ID_'||p_id_trt||', pReq '||pReq);
    EXECUTE_IMMEDIATE_STRING( pReq,0);
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- FIN insertion DIF_FSED_MODIF_RETRO-- CALCUL DE STATISTIQUES: ID_'||p_id_trt);
	DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'DIF_FSED_MODIF_RETRO',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4, partname => 'ID_'||p_id_trt||'');    
    --Insertion dans GAP_TRT_MOIS_RETRO
    pReq := ' insert into GAP_TRT_MOIS_RETRO (id_trt,numpac,pacmat,PERIODE_RETRO)';
    pReq := pReq ||' WITH grm AS (SELECT pacmat,periode_retro FROM gap_retro_matric    g WHERE numpac = '''||p_numpac||''' AND EXISTS (SELECT 1 FROM gap_trt_liste_mat gtlm WHERE gtlm.id_trt = '||p_id_trt||' AND gtlm.numpac = g.numpac AND gtlm.pacmat = g.pacmat))';
    pReq := pReq ||'     ,gsr AS (SELECT pacmat,periode_retro FROM gap_selection_retro g WHERE numpac = '''||p_numpac||''' AND EXISTS (SELECT 1 FROM gap_trt_liste_mat gtlm WHERE gtlm.id_trt = '||p_id_trt||' AND gtlm.numpac = g.numpac AND gtlm.pacmat = g.pacmat))';
    --                 min_periode_retro : plus vieille rétro par matricule
    pReq := pReq ||' ,min_periode_retro (pacmat,min_periode) AS (';
    pReq := pReq ||' SELECT pacmat,MIN(periode_retro) FROM';
    pReq := pReq ||' (          SELECT pacmat,periode_retro FROM grm';
    pReq := pReq ||'  UNION ALL SELECT pacmat,periode_retro FROM gsr ) GROUP BY pacmat) ';
    --                 histo_retro : historique des mois où on a fait de la rétro *et* sur quels mois
    pReq := pReq ||' ,histo_retro AS (SELECT DISTINCT pacmat,periode,to_char(dteffet,''yyyymm'') as periode_retro FROM dif_fsed_histo h WHERE numpac = '''||p_numpac||''' AND EXISTS (SELECT 1 FROM gap_trt_liste_mat gtlm WHERE gtlm.id_trt = '||p_id_trt||' AND gtlm.numpac = h.numpac AND gtlm.pacmat = h.pacmat) ';
    pReq := pReq ||'       AND periode>='''||w_MIN_RETRO||''' AND to_char(dteffet,''yyyymm'')<periode';
    pReq := pReq ||'       AND  h.elem in (select ELEMENT from tge_ref_dicoz where  numpac='''||p_numpac||''' AND nvl(CALCUL_RETRO,0)=1) )';
    --                 liste_mois_retro_pacmat : liste exhaustive des mois rétro par matricule (mois rétro paie en cours + mois rétro dans l'historique)
    pReq := pReq ||' ,liste_mois_retro_pacmat (pacmat,periode_retro) AS ( ';
    pReq := pReq ||'       SELECT pacmat,periode_retro      FROM grm';
    pReq := pReq ||' UNION ALL SELECT pacmat,periode_retro      FROM gsr';
    pReq := pReq ||' UNION ALL SELECT DISTINCT pacmat,periode_retro FROM histo_retro hr WHERE EXISTS (select 1 from min_periode_retro mpr WHERE hr.pacmat=mpr.pacmat and hr.periode_retro>=mpr.min_periode)';
    pReq := pReq ||' UNION ALL SELECT DISTINCT pacmat,periode       FROM histo_retro hr WHERE EXISTS (select 1 from min_periode_retro mpr WHERE hr.pacmat=mpr.pacmat and hr.periode      >=mpr.min_periode))';
    --                SELECT principal
    pReq := pReq ||' SELECT DISTINCT '||p_id_trt||','''||p_numpac||''',pacmat,periode_retro FROM liste_mois_retro_pacmat';
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion GAP_TRT_MOIS_RETRO: ID_'||p_id_trt||', pReq '||pReq);   
    EXECUTE_IMMEDIATE_STRING( pReq,0);
    DBMS_STATS.GATHER_TABLE_STATS(OWNNAME => SYS_CONTEXT('USERENV', 'SESSION_SCHEMA'), TABNAME => 'GAP_TRT_MOIS_RETRO', METHOD_OPT => 'FOR ALL COLUMNS SIZE 254', ESTIMATE_PERCENT => 100, CASCADE => TRUE, DEGREE => 4);
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Fin insertion GAP_TRT_MOIS_RETRO: ID_'||p_id_trt);
    BEGIN
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED --- remplissage DIF_FSED_PARTIERETRO id_trt= '||p_id_trt);
     pReq := 'Alter TABLE DIF_FSED_PARTIERETRO add partition ID_'||p_id_trt||' values ('||p_id_trt||')';
     EXECUTE_IMMEDIATE_STRING( pReq,0);
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED--remplissage DIF_FSED_PARTIERETRO--partition cree: ID_'||p_id_trt);
    EXCEPTION
    WHEN OTHERS THEN
     FSED_AVANCEMENT(p_id_trt,'preparation_FSED--remplissage DIF_FSED_PARTIERETRO--partition ID_'||p_id_trt||' existe déja');
    END ;
    --Insertion dans DIF_FSED_PARTIERETRO
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion LISTE_MOIS_RETRO: ID_'||p_id_trt);   
    pReq := ' INSERT INTO LISTE_MOIS_RETRO (id_trt,numpac,pacmat,periode_retro) select id_trt,numpac,pacmat,periode_retro from (';
	--WITH1 liste des vrais mois rétro
	pReq := pReq ||' WITH liste_mois_retro_pacmat (id_trt,numpac,pacmat,periode_retro) AS ( ';
	pReq := pReq ||'       SELECT '''||p_id_trt||''',numpac,pacmat,periode_retro FROM gap_trt_mois_retro WHERE numpac = '''||p_numpac||''' AND id_trt = '''||p_id_trt||''') ';
	pReq := pReq ||' select id_trt,numpac,pacmat,periode_retro from liste_mois_retro_pacmat)';
	FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- requete LISTE_MOIS_RETRO: ID_'||p_id_trt||', pReq '||pReq);
	EXECUTE_IMMEDIATE_STRING( pReq,0);
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion TRANCHES_MOIS_RETRO: ID_'||p_id_trt);   
    pReq := ' INSERT INTO TRANCHES_MOIS_RETRO (id_trt,numpac,pacmat,periode_retro,prec_periode_retro) select id_trt,numpac,pacmat,periode_retro,prec_periode_retro from (';
	--WITH1 liste des vrais mois rétro
	pReq := pReq ||' WITH tranches_mois_retro_pacmat (id_trt,numpac,pacmat,periode_retro,prec_periode_retro) AS ( ';
	pReq := pReq ||' SELECT '''||p_id_trt||''',lmr.numpac,lmr.pacmat,lmr.periode_retro,NVL((SELECT to_char(add_months(to_date(MAX(lmr2.periode_retro),''yyyymm''),1),''yyyymm'') FROM liste_mois_retro lmr2 WHERE lmr2.numpac = lmr.numpac and lmr2.pacmat=lmr.pacmat AND lmr2.periode_retro<lmr.periode_retro),'''||w_MIN_RETRO||''') FROM liste_mois_retro lmr where lmr.id_trt = '''||p_id_trt||''')';
	pReq := pReq ||' select id_trt,numpac,pacmat,periode_retro,prec_periode_retro from tranches_mois_retro_pacmat)';
	FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- requete TRANCHES_MOIS_RETRO: ID_'||p_id_trt||', pReq '||pReq);
	EXECUTE_IMMEDIATE_STRING( pReq,0);
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion DIF_FSED_PARTIERETRO: ID_'||p_id_trt);   
    pReq := ' INSERT INTO DIF_FSED_PARTIERETRO ';
	--WITH1 liste des vrais mois rétro
	pReq := pReq ||' WITH liste_envoi_systematique(elem) AS( ';
	pReq := pReq ||' SELECT ELEMENT FROM TGE_REF_MAPDO WHERE ''*''= decode (numpac,'''||p_numpac||''',''*'',numpac) AND NVL(ENVOI_SYSTEMATIQUE,''N'')=''O'' )';
	--SELECT1 DIF_FSED_MODIF_RETRO
	pReq := pReq ||' SELECT '''||p_id_trt||''', tmr.periode_retro AS periode, m.numpac, m.cle, m.pacmat, m.paiezad, m.elem, m.occ, m.valeur, m.codeop, m.type_donnee, m.dteffet ';
	pReq := pReq ||' FROM dif_fsed_modif_retro m, tranches_mois_retro tmr ';
	pReq := pReq ||' WHERE m.id_trt = '''||p_id_trt||''' and m.id_trt = tmr.id_trt AND m.numpac = tmr.numpac and m.pacmat = tmr.pacmat ';
	pReq := pReq ||' AND  ( ' ;
	pReq := pReq ||' greatest(TO_CHAR(m.dteffet,''yyyymm''),'''||w_MIN_RETRO||''') BETWEEN tmr.prec_periode_retro AND tmr.periode_retro ';
	pReq := pReq ||' OR  substr(m.elem,0,1)>''W'' OR Exists (select * from liste_envoi_systematique les  where m.elem=les.elem ) ';
	pReq := pReq ||' ) ' ;
	--SELECT2 DIF_FSED_HISTO sauf les lignes déjà présentes dans DIF_FSED_MODIF_RETRO
	pReq := pReq ||' UNION ALL SELECT '''||p_id_trt||''', h.periode, h.numpac, h.cle, h.pacmat, h.paiezad, h.elem, h.occ, h.valeur, h.codeop, h.type_donnee, h.dteffet ';
	pReq := pReq ||' FROM dif_fsed_histo h, liste_mois_retro lmr ';
	pReq := pReq ||' WHERE h.numpac = '''||p_numpac||''' AND lmr.id_trt = '''||p_id_trt||''' AND h.numpac = lmr.numpac and h.pacmat=lmr.pacmat AND periode>='''||w_MIN_RETRO||''' AND h.periode=lmr.periode_retro  ';
	pReq := pReq ||' AND  substr(h.elem,0,1)<''W'' AND NOT Exists (select * from liste_envoi_systematique les  where h.elem=les.elem ) ';
	pReq := pReq ||' AND NOT EXISTS  (SELECT 1 FROM dif_fsed_modif_retro m, tranches_mois_retro tmr ';
	pReq := pReq ||' WHERE m.id_trt = '''||p_id_trt||''' AND m.id_trt = tmr.id_trt AND m.numpac = tmr.numpac and m.pacmat = tmr.pacmat AND greatest(TO_CHAR(m.dteffet,''yyyymm''),'''||w_MIN_RETRO||''') BETWEEN tmr.prec_periode_retro AND tmr.periode_retro ';
	pReq := pReq ||'   AND greatest(TO_CHAR(m.dteffet,''yyyymm''),'''||w_MIN_RETRO||''') <= h.periode';
	pReq := pReq ||'   AND m.numpac = h.numpac and m.pacmat = h.pacmat AND m.paiezad = h.paiezad AND m.elem = h.elem AND m.occ = h.occ )';
	FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Début insertion DIF_FSED_PARTIERETRO: ID_'||p_id_trt||', pReq '||pReq);
	EXECUTE_IMMEDIATE_STRING( pReq,0);
	FSED_AVANCEMENT(p_id_trt,'preparation_FSED-- Fin insertion DIF_FSED_PARTIERETRO: ID_'||p_id_trt);
	FSED_AVANCEMENT(p_id_trt,'preparation_FSED ---Fin Rétro id_trt= '||p_id_trt);
	END IF;
    IF v_flag > 1000 THEN
        DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'DIF_FSED',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
    END IF;
    FSED_AVANCEMENT(p_id_trt,'preparation_FSED *** END *** pac='||p_numpac||' periode='||p_periode);
  EXCEPTION
  WHEN OTHERS THEN
    err_code := SQLCODE;
    err_msg  := SQLERRM;
    FSED_ERREUR( p_id_trt , 'preparation_FSED' , p_id_trt||','||p_numpac , err_code||'-'||err_msg );
    raise;
  END preparation_FSED;
/***********************************************************************
  Funct : getTableCode
  DESC : recuperer le code table
*************************************************************************/
FUNCTION getTableCode(
    plig TGE_IMPORT_FSED%rowtype)
  RETURN VARCHAR
IS
  v_code_table VARCHAR2(5);
  CURSOR C_VRTA
  IS
    SELECT * FROM TGE_REF_VRTA;
  lig_vrta TGE_REF_VRTA%rowtype;
BEGIN
  IF code_table_liste.count=0 THEN
    OPEN C_VRTA ;
    LOOP
      FETCH C_VRTA INTO lig_vrta ;
      EXIT
    WHEN C_VRTA%NOTFOUND;
      IF lig_vrta.tablevr11                                       IS NOT NULL THEN
        code_table_liste(lig_vrta.numpac||'#'||lig_vrta.TABLEVR11):= lig_vrta.TABLEZADIG;
      END IF;
    END LOOP;
    CLOSE C_VRTA;
  END IF;
  IF code_table_liste.exists(SUBSTR(plig.donnees,1,6)||'#'||trim(SUBSTR(plig.donnees,10,3)) ) THEN
    RETURN code_table_liste(SUBSTR(plig.donnees,1,6)||'#'||trim(SUBSTR(plig.donnees,10,3)) );
  elsif code_table_liste.exists('*#'||trim(SUBSTR(plig.donnees,10,3)) ) THEN
    RETURN code_table_liste('*#'||trim(SUBSTR(plig.donnees,10,3)) );
  ELSE
    RETURN trim(SUBSTR(plig.donnees,10,3));
  END IF;
END getTableCode;
/********************************************************************
Funct : getTypeColonne
DESC  : recuperer le type de colonne
**********************************************************************/
FUNCTION getTypeColonne(
    p_table   IN VARCHAR2,
    p_colonne IN VARCHAR2)
  RETURN VARCHAR2
IS
  v_typecolonne user_tab_columns.data_type%type;
BEGIN
  BEGIN
    SELECT DISTINCT data_type
    INTO v_typecolonne
    FROM user_tab_columns cln
    WHERE cln.table_name = p_table
    AND cln.column_name  = p_colonne;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN (NULL);
  END ;
  IF v_typecolonne ='NUMBER' THEN
    RETURN('N');
  ELSIF v_typecolonne ='DATE' THEN
    RETURN('D');
  ELSIF v_typecolonne ='VARCHAR2' THEN
    RETURN('V');
  END IF;
END getTypeColonne;
/***********************************************************************
PROC : setCart11 
DESC : Cart 11
*************************************************************************/
PROCEDURE setCart11(
    p_id IN NUMBER,
    lig TGE_IMPORT_FSED%rowtype,
    pNumPac TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
    pCodeTable TGE_REF_VRTA.TABLEZADIG%TYPE,
    pCodeTableOld TGE_REF_VRTA.TABLEZADIG%TYPE)
IS
  type_carte   VARCHAR2(3) := '';
  v_code_table VARCHAR2(5);
  v_num_ligne  VARCHAR2(4);
  v_code_seq   VARCHAR2(1);
  v_nom_champ  VARCHAR2(4);
  v_existVRREP number :=0 ;
BEGIN
  type_carte                         := trim(SUBSTR(lig.donnees,18,2));
  IF type_carte                       ='R' THEN
    elt_tab_11R.NUMERO_DE_PAC        :=pNumPac;
    elt_tab_11R.CODE_TABLE           :=pCodeTable;
    elt_tab_11R.FONCTIONNALITE       :=trim(SUBSTR(lig.donnees,20,2));
    elt_tab_11R.NOM_DE_LA_TABLE      :=trim(SUBSTR(lig.donnees,22,35));
    elt_tab_11R.CLASSE_PROTECTION    :=trim(SUBSTR(lig.donnees,57,3));
    elt_tab_11R.CODE_MAJ_CAL         :=trim(SUBSTR(lig.donnees,60,1));
    elt_tab_11R.TABLE_USAGE_MULTIPLE :=trim(SUBSTR(lig.donnees,61,1));
    elt_tab_11R.NOM_TABLEASSOCIE     :=trim(SUBSTR(lig.donnees,62,3));
    elt_tab_11R.VALEURS_MENSUELLES   :=trim(SUBSTR(lig.donnees,66,1));
    elt_tab_11R.CODE_TOPAGE          :=trim(SUBSTR(lig.donnees,67,1));
    elt_tab_11R.REPERCUSSION_TVP     :=trim(SUBSTR(lig.donnees,68,1));
    elt_tab_11R.PGM_COHE_LIGNE       :=trim(SUBSTR(lig.donnees,69,8));
    elt_tab_11R.DATE_DERNIERE_MAJ    :=trim(SUBSTR(lig.donnees,77,8));
    elt_tab_11R.HEURE_DERNIERE_MAJ   :=trim(SUBSTR(lig.donnees,85,4));
    elt_tab_11R.TRAIT_PARTICULIER    :=trim(SUBSTR(lig.donnees,89,1));
    elt_tab_11R.CODE_DESTINATION_1   :=trim(SUBSTR(lig.donnees,90,1));
    elt_tab_11R.CODE_DESTINATION_2   :=trim(SUBSTR(lig.donnees,91,1));
    elt_tab_11R.CODE_DESTINATION_3   :=trim(SUBSTR(lig.donnees,92,1));
    elt_tab_11R.CODE_DESTINATION_4   :=trim(SUBSTR(lig.donnees,93,1));
    elt_tab_11R.CODE_DESTINATION_5   :=trim(SUBSTR(lig.donnees,94,1));
    elt_tab_11R.PGM_COHE_TABLE       :=trim(SUBSTR(lig.donnees,95,8));
    elt_tab_11R.TEMOIN_VR_BASE       :=trim(SUBSTR(lig.donnees,103,1));
    elt_tab_11R.TEMOIN_SITE_MULTIPLE :=trim(SUBSTR(lig.donnees,104,1));
    elt_tab_11R.CODE_GESTIONNAIRE    :=trim(SUBSTR(lig.donnees,105,1));
    elt_tab_11R.CODE_EDI             :=trim(SUBSTR(lig.donnees,106,1));
    elt_tab_11R.NB_LIG_MINI          :=trim(SUBSTR(lig.donnees,111,4));
    elt_tab_11R.NB_LIG_MAXI          :=trim(SUBSTR(lig.donnees,115,4));
    elt_tab_11R.NB_LIG_TOTALES       :=trim(SUBSTR(lig.donnees,119,4));
    elt_tab_11R.NB_LIG_ACTIVES       :=trim(SUBSTR(lig.donnees,123,4));
    IF tab_11R                       IS NULL THEN
      tab_11R                        := t_TGE_REF_VRREP();
    END IF;
    select count(*) into v_existVRREP from TGE_REF_VRREP where TGE_REF_VRREP.NUMERO_DE_PAC=elt_tab_11R.NUMERO_DE_PAC and TGE_REF_VRREP.CODE_TABLE=elt_tab_11R.CODE_TABLE;
	if(v_existVRREP=0) then
	tab_11R.extend;
	tab_11R(tab_11R.last)            :=elt_tab_11R;
	end if ;
  elsif type_carte                    ='D' THEN
    v_nom_champ                      := trim (SUBSTR(lig.donnees,20,4));
    elt_tab_11D.NUMERO_DE_PAC        := pNumPac;
    elt_tab_11D.CODE_TABLE           := pCodeTable;
    elt_tab_11D.NOM_DU_CHAMP         := v_nom_champ;
    elt_tab_11D.ELEMENT_DE_RECHERCHE := trim (SUBSTR(lig.donnees,24,4));
    elt_tab_11D.VALEUR_ASSOCIEE      := trim (SUBSTR(lig.donnees,28,3));
    elt_tab_11D.CODE_MAJ             := trim (SUBSTR(lig.donnees,31,1));
    elt_tab_11D.NB_OCCURRENCES       := trim (SUBSTR(lig.donnees,32,2));
    elt_tab_11D.NATURE               := trim (SUBSTR(lig.donnees,34,1));
    elt_tab_11D.NB_ENTIERS           := trim (SUBSTR(lig.donnees,35,2));
    elt_tab_11D.NB_DECIMALES         := trim (SUBSTR(lig.donnees,37,2));
    elt_tab_11D.LONGUEUR             := trim (SUBSTR(lig.donnees,39,2));
    elt_tab_11D.CODE_CONTROLE_FORMAT := trim (SUBSTR(lig.donnees,41,2));
    elt_tab_11D.CLASSE_PROTECTION    := trim (SUBSTR(lig.donnees,43,2));
    elt_tab_11D.TYPE_MANIPULATION    := trim (SUBSTR(lig.donnees,45,1));
    elt_tab_11D.CODE_DESCRIPTEUR     := trim (SUBSTR(lig.donnees,46,1));
    elt_tab_11D.CODE_OUVERTURE       := trim (SUBSTR(lig.donnees,47,1));
    elt_tab_11D.BL_ZERO_SIGNIFICATIF := trim (SUBSTR(lig.donnees,48,1));
    elt_tab_11D.CODE_OBLIGATION      := trim (SUBSTR(lig.donnees,49,1));
    elt_tab_11D.CODE_VALIDATION      := trim (SUBSTR(lig.donnees,50,1));
    elt_tab_11D.VAL_POS_COLON_DEBUT  := trim (SUBSTR(lig.donnees,51,2));
    elt_tab_11D.VAL_POS_COLON_FIN    := trim (SUBSTR(lig.donnees,53,2));
    elt_tab_11D.VAL_POS_VALEUR       := trim (SUBSTR(lig.donnees,55,35));
    elt_tab_11D.CNTL_TAB_REFER_TABLE := trim (SUBSTR(lig.donnees,90,5));
    elt_tab_11D.CNTL_TAB_COLON_DEBUT := trim (SUBSTR(lig.donnees,95,2));
    elt_tab_11D.CNTL_TAB_COLON_FIN   := trim (SUBSTR(lig.donnees,97,2));
    elt_tab_11D.CODE_GRAVITE         := trim (SUBSTR(lig.donnees,99,1));
    elt_tab_11D.LIBELLE              := trim (SUBSTR(lig.donnees,100,35));
    elt_tab_11D.MORCEAU_1_NOM_TABLE  := trim (SUBSTR(lig.donnees,135,3));
    elt_tab_11D.MORCEAU_1_COL_DEB    := trim (SUBSTR(lig.donnees,138,3));
    elt_tab_11D.MORCEAU_1_COL_FIN    := trim (SUBSTR(lig.donnees,141,3));
    elt_tab_11D.MORCEAU_2_NOM_TABLE  := trim (SUBSTR(lig.donnees,144,3));
    elt_tab_11D.MORCEAU_2_COL_DEB    := trim (SUBSTR(lig.donnees,147,3));
    elt_tab_11D.MORCEAU_2_COL_FIN    := trim (SUBSTR(lig.donnees,150,3));
    elt_tab_11D.MORCEAU_3_NOM_TABLE  := trim (SUBSTR(lig.donnees,153,3));
    elt_tab_11D.MORCEAU_3_COL_DEB    := trim (SUBSTR(lig.donnees,156,3));
    elt_tab_11D.MORCEAU_3_COL_FIN    := trim (SUBSTR(lig.donnees,159,3));
    elt_tab_11D.MORCEAU_4_NOM_TABLE  := trim (SUBSTR(lig.donnees,162,3));
    elt_tab_11D.MORCEAU_4_COL_DEB    := trim (SUBSTR(lig.donnees,165,3));
    elt_tab_11D.MORCEAU_4_COL_FIN    := trim (SUBSTR(lig.donnees,168,3));
    elt_tab_11D.S_P_CONTROLE         := trim (SUBSTR(lig.donnees,171,8));
    elt_tab_11D.INVISIBLE            := trim (SUBSTR(lig.donnees,179,1));
    IF tab_11D                       IS NULL THEN
      tab_11D                        := t_TGE_REF_VRDES();
    END IF;
    tab_11D.extend;
    tab_11D(tab_11D.last)            := elt_tab_11D;
  elsif type_carte                    ='D1' THEN
    elt_tab_11D1.NUMERO_DE_PAC       := pNumPac;
    elt_tab_11D1.CODE_TABLE          := pCodeTable;
    elt_tab_11D1.NOM_DU_CHAMP        := trim (SUBSTR(lig.donnees,20,4));
    elt_tab_11D1.MORCEAU_5_NOM_TABLE := trim (SUBSTR(lig.donnees,24,3));
    elt_tab_11D1.MORCEAU_5_COL_DEB   := trim (SUBSTR(lig.donnees,27,3));
    elt_tab_11D1.MORCEAU_5_COL_FIN   := trim (SUBSTR(lig.donnees,30,3));
    elt_tab_11D1.MORCEAU_6_NOM_TABLE := trim (SUBSTR(lig.donnees,33,3));
    elt_tab_11D1.MORCEAU_6_COL_DEB   := trim (SUBSTR(lig.donnees,36,3));
    elt_tab_11D1.MORCEAU_6_COL_FIN   := trim (SUBSTR(lig.donnees,39,3));
    elt_tab_11D1.MORCEAU_7_NOM_TABLE := trim (SUBSTR(lig.donnees,42,3));
    elt_tab_11D1.MORCEAU_7_COL_DEB   := trim (SUBSTR(lig.donnees,45,3));
    elt_tab_11D1.MORCEAU_7_COL_FIN   := trim (SUBSTR(lig.donnees,48,3));
    elt_tab_11D1.MORCEAU_8_NOM_TABLE := trim (SUBSTR(lig.donnees,51,3));
    elt_tab_11D1.MORCEAU_8_COL_DEB   := trim (SUBSTR(lig.donnees,54,3));
    elt_tab_11D1.MORCEAU_8_COL_FIN   := trim (SUBSTR(lig.donnees,57,3));
    elt_tab_11D1.MORCEAU_9_NOM_TABLE := trim (SUBSTR(lig.donnees,60,3));
    elt_tab_11D1.MORCEAU_9_COL_DEB   := trim (SUBSTR(lig.donnees,63,3));
    elt_tab_11D1.MORCEAU_9_COL_FIN   := trim (SUBSTR(lig.donnees,66,3));
    IF tab_11D1                      IS NULL THEN
      tab_11D1                       := t_TGE_REF_VRDES();
    END IF;
    tab_11D1.extend;
    tab_11D1(tab_11D1.last)   :=elt_tab_11D1;
  elsif type_carte             ='V' THEN
    elt_tab_11V.NUMERO_DE_PAC :=pNumPac;
    elt_tab_11V.CODE_TABLE    :=pCodeTable;
    v_num_ligne               := trim (SUBSTR(lig.donnees,19,4));
    v_code_seq                := trim (SUBSTR(lig.donnees,24,1));
    IF v_code_seq             IS NULL THEN
      v_code_seq              :='1';
    END IF;
    IF pCodeTableOld  != pCodeTable THEN
      v_cmpt_numLigne := 0;
    END IF;
    IF v_num_ligne      IS NULL THEN
      IF v_code_seq      ='1' THEN
        v_cmpt_numLigne := v_cmpt_numLigne+100;
      END IF;
      elt_tab_11V.NUMERO_DE_LIGNE:= TO_CHAR(v_cmpt_numLigne,'FM09999999') ||v_code_seq;
    ELSE
      elt_tab_11V.NUMERO_DE_LIGNE:= TO_CHAR((to_number(v_num_ligne)*100),'FM09999999') ||v_code_seq;
    END IF;
    elt_tab_11V.ENREGISTREMENT := SUBSTR(lig.donnees,29,86);
    elt_tab_11V.LONGUEUR_INFO  := trim (SUBSTR(lig.donnees,26,3));
    IF tab_11V                 IS NULL THEN
      tab_11V                  := t_TGE_REF_VRVAL();
    END IF;
    tab_11V.extend;
    tab_11V(tab_11V.last):=elt_tab_11V;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'setCart11' , lig.num_lig||','||pNumPac||','||pCodeTable , err_code||'-'||err_msg );
  raise;
  raise_application_error(-20000, 'FSED cart 11  '|| sqlerrm);
END setCart11;
/**************************************************
Fonc : getLibResolu 
DESC : Calcul du libelle resolu
**************************************************/
FUNCTION getLibResolu(pNumPac       IN TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
                      pCodeCaisse   IN TGE_REF_CAISSE.CODECAISSE%TYPE,
                      pLibRUB       IN TGE_REF_RUBRIQUE.LIBRUB%TYPE) RETURN VARCHAR2 IS 
                      
w_libcaisse        TGE_REF_CAISSE.LIBCAISSE%TYPE;
w_nombre_occ       NUMBER;
w_libResolu        TGE_REF_LIBRUB_COTIS.LIB_RESOLU%TYPE;
w_first_pos        NUMBER;
w_length_seq       NUMBER :=1;
w_reste            TGE_REF_RUBRIQUE.LIBRUB%TYPE;
j                  NUMBER ; 
w_seq              TGE_REF_RUBRIQUE.LIBRUB%TYPE;
wLibRUB            TGE_REF_RUBRIQUE.LIBRUB%TYPE;
BEGIN
  BEGIN 
  SELECT LIBCAISSE
  INTO   w_libcaisse
  FROM   TGE_REF_CAISSE
  WHERE  numpac= pNumPac
  AND    codecaisse = pCodeCaisse;
  EXCEPTION 
    WHEN OTHERS THEN 
     w_libcaisse := null;
  END ;
  wLibRUB := REPLACE(pLibRUB,'£','#');
  select ( (LENGTH(wLibRUB) - LENGTH(REPLACE(wLibRUB,'#',NULL)) ) / NVL(LENGTH('#'),1) ) INTO w_nombre_occ from dual;
  
  IF w_nombre_occ =1 THEN
    select substr(replace(wLibRUB,'#',w_libcaisse),0,40) INTO w_libResolu from dual;
  ELSE

    select instr (wLibRUB ,'#') into w_first_pos from dual;
    for i IN w_first_pos..length(wLibRUB) Loop 
      if substr(wLibRUB,i+1,1)='#' THEN 
        w_length_seq:= w_length_seq+1;
      else         
         exit;
      END IF;
    END LOOP;
    if w_length_seq =1 THEN 
     select substr(replace(wLibRUB,'#',w_libcaisse),0,40) INTO w_libResolu from dual;
    else
      for k in 0..w_length_seq-1 loop
        w_seq := w_seq ||'#';
      end loop;
      select replace(wLibRUB,w_seq,substr(w_libcaisse,0,w_length_seq)) INTO w_libResolu from dual;
      w_seq := null;
    end if;
  END IF;
  return w_libResolu;
END getLibResolu ;
      
/**************************************************************************
PROC : setCart15 
DESC : cart 15
***************************************************************************/
PROCEDURE setCart15(
    p_id    IN NUMBER,
    lig     IN TGE_IMPORT_FSED%rowtype,
    pNumPac IN TGE_REF_VRREP.NUMERO_DE_PAC%TYPE)
IS
w_codegroup tge_ref_caisse.codegroup%type;

CURSOR REF_CAISSE(p_caisseref IN TGE_REF_CAISSE.caisseref%type,pNumPac IN TGE_REF_VRREP.NUMERO_DE_PAC%TYPE) is 
  SELECT CODECAISSE
  FROM   TGE_REF_CAISSE
  WHERE  NUMPAC    = pNumPac
  AND    caisseref = p_caisseref ;

BEGIN
  elt_tab_15.NUMPAC              := pNumPac;
  elt_tab_15.CODERUB             := trim(SUBSTR(lig.donnees,10,4));
  elt_tab_15.NOSEQU              := trim(SUBSTR(lig.donnees,24,1));
  elt_tab_15.TYPERUB             := trim(SUBSTR(lig.donnees,29,1));
  elt_tab_15.SENSRUB             := trim(SUBSTR(lig.donnees,30,1));
  elt_tab_15.CODEUNITE           := trim(SUBSTR(lig.donnees,31,1));
  elt_tab_15.LIBRUB              := trim(SUBSTR(lig.donnees,32,40));
  elt_tab_15.CODEFICHE           := trim(SUBSTR(lig.donnees,72,1));
  elt_tab_15.FLAGDVDR            := trim(SUBSTR(lig.donnees,73,1));
  elt_tab_15.LIBLAN1             := trim(SUBSTR(lig.donnees,74,20));
  elt_tab_15.LIBLAN2             := trim(SUBSTR(lig.donnees,94,20));
  elt_tab_15.LIBLAN3             := trim(SUBSTR(lig.donnees,114,20));
  elt_tab_15.NATURERUB           := trim(SUBSTR(lig.donnees,134,1));
  elt_tab_15.ORDREXEC            := trim(SUBSTR(lig.donnees,135,4));
  elt_tab_15.CODETAUX            := trim(SUBSTR(lig.donnees,139,3));
  elt_tab_15.CODEACCDEREMISE     := trim(SUBSTR(lig.donnees,142,3));
  elt_tab_15.QUALIFNOMBRE        := trim(SUBSTR(lig.donnees,145,1));
  elt_tab_15.QUALIFTAUX          := trim(SUBSTR(lig.donnees,146,1));
  elt_tab_15.QUALIFMONTANT       := trim(SUBSTR(lig.donnees,147,1));
  elt_tab_15.FLAGMONTANT         := trim(SUBSTR(lig.donnees,148,1));
  elt_tab_15.FLAGNB              := trim(SUBSTR(lig.donnees,149,1));
  elt_tab_15.FLAGTAUX            := trim(SUBSTR(lig.donnees,150,1));
  elt_tab_15.FLAGPCTG            := trim(SUBSTR(lig.donnees,151,1));
  elt_tab_15.FLAGIMP             := trim(SUBSTR(lig.donnees,152,1));
  elt_tab_15.POSITIONCURSEUR     := trim(SUBSTR(lig.donnees,153,1));
  elt_tab_15.CODECAISSE          := trim(SUBSTR(lig.donnees,154,3));
  elt_tab_15.CODEVENTILCOMPTABLE := trim(SUBSTR(lig.donnees,157,4));
  elt_tab_15.TYPTRAIT            := trim(SUBSTR(lig.donnees,171,10));
  elt_tab_15.FLAGARRET           := trim(SUBSTR(lig.donnees,161,1));
  elt_tab_15.FLAGRATTACH         := trim(SUBSTR(lig.donnees,162,1));
  elt_tab_15.OPTION_RETRO        := trim(SUBSTR(lig.donnees,163,1));
  elt_tab_15.CSCP        		 := trim(SUBSTR(lig.donnees,164,1));
   IF LENGTH(lig.donnees)>240 THEN
 elt_tab_15.TEXTE_EXPLICATIF    := trim(SUBSTR(lig.donnees,241,400));
 ELSE elt_tab_15.TEXTE_EXPLICATIF  := '' ;
 END IF ;

  BEGIN
     SELECT CODEGROUP
     INTO   w_codegroup
     FROM   TGE_REF_CAISSE
     WHERE  NUMPAC     = pNumPac
     AND    CODECAISSE = elt_tab_15.CODECAISSE ;
  EXCEPTION
    WHEN OTHERS THEN
      w_codegroup :=NULL;
  END ;
  
  IF tab_15_lib  IS NULL THEN
     tab_15_lib := t_TGE_REF_LIBRUB_COTIS();
  END IF;
  
  IF elt_tab_15.CODECAISSE  is null THEN 
    elt_tab_15_lib.NUMPAC     := pNumPac;
    elt_tab_15_lib.CODERUB    := nvl(elt_tab_15.CODERUB,'*');
    elt_tab_15_lib.LIB_RESOLU := elt_tab_15.LIBRUB;
    elt_tab_15_lib.CODECAISSE := '*';
    elt_tab_15_lib.CAISSEREF  := '*';
    
    tab_15_lib.extend;
    tab_15_lib(tab_15_lib.last):=elt_tab_15_lib;
  ELSE
    IF elt_tab_15.LIBRUB not like '%#%'  and elt_tab_15.LIBRUB not like '%£%' THEN  
        elt_tab_15_lib.NUMPAC     := pNumPac;
        elt_tab_15_lib.CODERUB    := nvl(elt_tab_15.CODERUB,'*');
        elt_tab_15_lib.LIB_RESOLU := elt_tab_15.LIBRUB;      
        IF w_codegroup ='R' THEN 
          FOR i IN REF_CAISSE (elt_tab_15.CODECAISSE,pNumPac) LOOP
          elt_tab_15_lib.CAISSEREF  :=elt_tab_15.CODECAISSE;
          elt_tab_15_lib.CODECAISSE :=nvl(i.CODECAISSE,'*');
          tab_15_lib.extend;
          tab_15_lib(tab_15_lib.last):=elt_tab_15_lib;
          END LOOP;
        ELSE
          elt_tab_15_lib.CODECAISSE :=nvl(elt_tab_15.CODECAISSE,'*');
          elt_tab_15_lib.CAISSEREF  :='*';
          tab_15_lib.extend;
          tab_15_lib(tab_15_lib.last):=elt_tab_15_lib;
        END IF;
        
    ELSE
     FOR i IN REF_CAISSE (elt_tab_15.CODECAISSE,pNumPac) LOOP
        elt_tab_15_lib.NUMPAC     := pNumPac;
        elt_tab_15_lib.CODERUB    := nvl(elt_tab_15.CODERUB,'*');            
        elt_tab_15_lib.CODECAISSE := nvl(i.CODECAISSE,'*');
        elt_tab_15_lib.LIB_RESOLU := getLibResolu(pNumPac,elt_tab_15_lib.CODECAISSE,elt_tab_15.LIBRUB); 
        IF w_codegroup ='R' THEN 
          elt_tab_15_lib.CAISSEREF  := elt_tab_15.CODECAISSE;
         ELSE
           elt_tab_15_lib.CAISSEREF  := '*';
         END IF;        
         tab_15_lib.extend;
         tab_15_lib(tab_15_lib.last):=elt_tab_15_lib;
      END LOOP;
    
    END IF ;
  END IF;     
  
  IF tab_15                      IS NULL THEN
    tab_15                       := t_TGE_REF_RUBRIQUE();
  END IF;
  tab_15.extend;
  tab_15(tab_15.last):=elt_tab_15;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'setCart15' , lig.num_lig||','||pNumPac , err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED cart 15  '|| sqlerrm);
END setCart15;
/*******************************************************************
PROC : setCart17
DESC :  cart 17
*******************************************************************/
PROCEDURE setCart17(
    p_id IN NUMBER,
    lig TGE_IMPORT_FSED%rowtype,
    pNumPac TGE_REF_VRREP.NUMERO_DE_PAC%TYPE)
IS
  type_carte VARCHAR(3) := '';
BEGIN
  type_carte                   := trim(SUBSTR(lig.donnees,10,2));
  IF type_carte                 ='CR' THEN
    elt_tab_17CR.NUMPAC        := pNumPac;
    elt_tab_17CR.CODERUB       := trim(SUBSTR(lig.donnees,13,4));
    elt_tab_17CR.NOSEQU        := trim(SUBSTR(lig.donnees,18,3));
    elt_tab_17CR.CONTEXTE      := trim(SUBSTR(lig.donnees,22,50));
    elt_tab_17CR.CONTEXTESUITE := trim(SUBSTR(lig.donnees,72,30));
    IF tab_17CR                IS NULL THEN
      tab_17CR                 := t_TGE_REF_RUBRIQUE_CONTEXTE();
    END IF;
    tab_17CR.extend;
    tab_17CR(tab_17CR.last)         :=elt_tab_17CR;
  elsif type_carte                   ='DM' THEN
    IF trim(SUBSTR(lig.donnees,13,1))='F' THEN
      elt_tab_17DMF.NUMPAC          := pNumPac;
      elt_tab_17DMF.ELEMENT         := trim(SUBSTR(lig.donnees,15,4));
      elt_tab_17DMF.CODEMODIF       := trim(SUBSTR(lig.donnees,134,1));
      elt_tab_17DMF.LIBELLE         := trim(SUBSTR(lig.donnees,22,35));
      elt_tab_17DMF.TYPE            := trim(SUBSTR(lig.donnees,58,1));
      elt_tab_17DMF.LONGUEUR        := to_number(trim(SUBSTR(lig.donnees,60,2)));
      elt_tab_17DMF.NBDECI          := to_number(trim(SUBSTR(lig.donnees,62,1)));
      elt_tab_17DMF.MASQUE          := to_number(trim(SUBSTR(lig.donnees,64,2)));
      elt_tab_17DMF.STATUT          := trim(SUBSTR(lig.donnees,67,1));
      elt_tab_17DMF.GROUPE          := trim(SUBSTR(lig.donnees,69,3));
      elt_tab_17DMF.OCC1            := to_number(trim(SUBSTR(lig.donnees,73,3)));
      elt_tab_17DMF.OCC2            := to_number(trim(SUBSTR(lig.donnees,77,3)));
      elt_tab_17DMF.IND1            := trim(SUBSTR(lig.donnees,81,5));
      elt_tab_17DMF.IND2            := trim(SUBSTR(lig.donnees,86,4));
      elt_tab_17DMF.TEMOINS         := trim(SUBSTR(lig.donnees,91,42));
      elt_tab_17DMF.CALCUL_RETRO    := trim(SUBSTR(lig.donnees,136,1));
      elt_tab_17DMF.CSCP    		:= trim(SUBSTR(lig.donnees,137,1));
      IF tab_17DMF                  IS NULL THEN
        tab_17DMF                   := t_TGE_REF_DICOZ();
      END IF;
      tab_17DMF.extend;
      tab_17DMF(tab_17DMF.last) :=elt_tab_17DMF;
    END IF;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'setCart17' , lig.num_lig||','||pNumPac , err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED cart 17  '|| sqlerrm);
END setCart17;
/***********************************************************************
PROC : getNumLigne
DESC : recuperer le code table
*************************************************************************/
PROCEDURE getNumLigne(
    p_id IN NUMBER)
IS
BEGIN
  OPEN cur_numlig00(p_id) ;
  LOOP
    FETCH cur_numlig00 BULK COLLECT INTO tab_numLigne00 ;
    EXIT
  WHEN cur_numlig00%NOTFOUND;
  END LOOP;
  CLOSE cur_numlig00;
  OPEN cur_numlig99(p_id) ;
  LOOP
    FETCH cur_numlig99 BULK COLLECT INTO tab_numLigne99 ;
    EXIT
  WHEN cur_numlig99%NOTFOUND;
  END LOOP;
  CLOSE cur_numlig99;
END getNumLigne;
/***********************************************************************
FUNCT : GET_H2_COLONNE
DESC : recuperer la colonne clé de type DATE pour les tables de type H2
*************************************************************************/
FUNCTION GET_H2_COLONNE(
    p_table_name IN VARCHAR2)
  RETURN VARCHAR2
IS
  w_column_name user_cons_columns.column_name%TYPE;
BEGIN
  BEGIN
    SELECT column_name
    INTO w_column_name
    FROM user_cons_columns
    WHERE table_name     =p_table_name
    AND constraint_name IN
      (SELECT user_constraints.constraint_name
      FROM user_constraints
      WHERE user_cons_columns.table_name =user_constraints.table_name
      AND CONSTRAINT_TYPE                ='P'
      )
    AND column_name IN
      (SELECT tab.column_name
      FROM user_tab_columns tab
      WHERE tab.table_name =p_table_name
      AND tab.data_type    ='DATE'
      );
    RETURN(w_column_name);
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN(NULL);
  END;
END GET_H2_COLONNE;
/***********************************************************************
FUNCT : GET_M3_COLONNE
DESC : recuperer la colonne clé
*************************************************************************/
FUNCTION GET_M3_COLONNE(
    p_table_name IN VARCHAR2)
  RETURN VARCHAR2
IS
  w_column_name user_cons_columns.column_name%TYPE;
BEGIN
  BEGIN
    SELECT column_name
    INTO w_column_name
    FROM user_cons_columns
    WHERE table_name     =p_table_name
    AND constraint_name IN
      (SELECT user_constraints.constraint_name
      FROM user_constraints
      WHERE user_cons_columns.table_name =user_constraints.table_name
      AND CONSTRAINT_TYPE                ='P'
      )
    AND column_name IN
      (SELECT tab.column_name
      FROM user_tab_columns tab
      WHERE tab.table_name     =p_table_name
      AND tab.data_type!       ='DATE'
      AND tab.column_name NOT IN ('NUMPAC','PAIEZAD','PACMAT')
      );
    RETURN(w_column_name);
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN(NULL);
  END;
END GET_M3_COLONNE;
/***********************************************************************
FUNCT : GET_MONTH_00 
DESC : retourne le  mois de paie indiqué dans le FSED carte 00
*************************************************************************/
FUNCTION GET_PERIODE_00(
    p_id       IN NUMBER ,
    p_numligne IN NUMBER )
  RETURN NUMBER
IS
  w_moi_eff NUMBER ;
BEGIN
  SELECT SUBSTR(donnees,70,6)
  INTO w_moi_eff
  FROM TGE_IMPORT_FSED
  WHERE id_trt =p_id
  AND NUM_LIG  =p_numligne;
  RETURN (w_moi_eff);
END GET_PERIODE_00 ;
/***********************************************************************
FUNCT : IS_VALID_COLUMN 
DESC : retourne 1 si c'est une colonne de la table
*************************************************************************/
FUNCTION IS_VALID_COLUMN(
    p_TABLE_NAME VARCHAR2 ,
    p_colonne IN VARCHAR2 )
  RETURN NUMBER
IS
  flag NUMBER ;
BEGIN
  SELECT COUNT(*)
  INTO flag
  FROM user_tab_columns
  WHERE table_name =p_TABLE_NAME
  AND column_name  =p_colonne;
  RETURN (flag);
END IS_VALID_COLUMN ;
/***********************************************************************
FUNCT : GET_NUMPAC 
DESC : retourne le  numpac carte 00
*************************************************************************/
FUNCTION GET_NUMPAC(
    p_id       IN NUMBER ,
    p_numligne IN NUMBER )
  RETURN VARCHAR2
IS
  w_numpac VARCHAR2(7) ;
BEGIN
  SELECT SUBSTR(donnees,1,6)
  INTO w_numpac
  FROM TGE_IMPORT_FSED
  WHERE id_trt =p_id
  AND NUM_LIG  =p_numligne;
  RETURN (w_numpac);
END GET_NUMPAC ;
/****************************************************************
FUNCT : GET_Statement 
DESC : retourne sql statment avec le type de colonne
*****************************************************************/
    FUNCTION GET_Statement(
    p_type_colonne IN VARCHAR2 ,
    p_type_DICOZ   IN VARCHAR2 ,
    p_colonne      IN VARCHAR2 ,
    p_alias        IN VARCHAR2 )
  RETURN VARCHAR2
IS
  v_alias VARCHAR2(100):=' ';
BEGIN
  IF p_alias IS NOT NULL THEN
    v_alias  :=p_alias||'.';
  END IF;
  IF p_type_colonne ='N' AND p_type_DICOZ ='N' THEN
    RETURN('TO_NUMBER(replace('||v_alias||p_colonne||',''.'','',''))');
  ELSIF p_type_DICOZ ='D1' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''YYYYMMDD''),1,TO_date('||v_alias||p_colonne||',''YYYYMMDD''),null)');--yyyyMMdd
  ELSIF p_type_DICOZ ='D2' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''MMYYYY''),1,TO_date('||v_alias||p_colonne||',''MMYYYY''),decode(is_date('||v_alias||p_colonne||',''YYYYMM''),1,TO_date('||v_alias||p_colonne||',''YYYYMM''),null))');--MMyyyy/YYYYMM
   ELSIF p_type_DICOZ ='D3' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''YYYYMM''),1,TO_date('||v_alias||p_colonne||',''YYYYMM''),null)');--yyyyMM
   ELSIF p_type_DICOZ ='D4' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''DD''),1,TO_date('||v_alias||p_colonne||',''DD''),null)');--dd
   ELSIF p_type_DICOZ ='D5' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''MM''),1,TO_date('||v_alias||p_colonne||',''MM''),null)');--MM 
   ELSIF p_type_DICOZ ='D6' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''YYYYMMDD''),1,TO_date('||v_alias||p_colonne||',''YYYYMMDD''),null)');--yyyy
   ELSIF p_type_DICOZ ='D7' AND p_type_colonne='D' THEN
    RETURN('decode(is_date('||v_alias||p_colonne||',''YYYYMMDD''),1,TO_date('||v_alias||p_colonne||',''YYYYMMDD''),null)');
  ELSIF p_type_DICOZ ='V' THEN
    RETURN('TO_CHAR('||v_alias||p_colonne||')');
  ELSE
    RETURN(v_alias||p_colonne);
  END IF;
END GET_STATEMENT ;
/****************************************************************
FUNCT : GET_Statement 
DESC : 
*****************************************************************/
FUNCTION GET_Statement(
    p_type_colonne IN VARCHAR2 ,
    p_type_DICOZ   IN VARCHAR2,
    p_colonne      IN VARCHAR2 )
  RETURN VARCHAR2
IS
BEGIN
  RETURN GET_Statement (p_type_colonne,p_type_DICOZ , p_colonne , 'i');
END GET_STATEMENT ;
/****************************************************************
FUNCT : GET_TYPE_RETOUR 
DESC  : retourne type de retour
*****************************************************************/
FUNCTION GET_TYPE_RETOUR(
    p_id       IN NUMBER ,
    p_numligne IN NUMBER)
  RETURN VARCHAR2
IS
  w_type_retour VARCHAR2(2);
BEGIN
  SELECT SUBSTR(DONNEES,68,2)
  INTO w_type_retour
  FROM TGE_IMPORT_FSED
  WHERE id_trt      =p_id
  AND NUM_LIG       =p_numligne;
  IF w_type_retour IS NULL OR w_type_retour='  ' OR w_type_retour='RT' THEN
    w_type_retour  :='RN';
  END IF;
  RETURN (w_type_retour);
END GET_TYPE_RETOUR ;
/*****************************************************
PROC : purge_carte80
DESC :
*****************************************************/
PROCEDURE purge_carte80(
    p_id    IN NUMBER,
    p_mois  IN VARCHAR2,
    p_lig00 IN NUMBER ,
    p_lig99 IN NUMBER )
IS
BEGIN
  DELETE
  FROM DIC_TGE_RESPAIE_RUBRIQUE
  WHERE (numpac,paiezad,TO_CHAR(to_date(periodepaie),'YYYYMM')) IN
    (SELECT numpac ,
      paiezad ,
      PERIODEPAIE
    FROM TGE_IMPORT_FSED_80
    WHERE id_trt =p_id
    AND numligne BETWEEN p_lig00 AND p_lig99
    GROUP BY(numpac,paiezad,PERIODEPAIE)
    HAVING COUNT(*)>0
    ) ;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'purge_carte80' , NULL, err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED purge_carte80  '|| sqlerrm);
END purge_carte80;
/******************************************************************
PROC : insertCart80 
********************************************************************/
PROCEDURE sous_insertCart80(
    p_id    IN NUMBER,
    p_newId IN NUMBER)
IS
  req          VARCHAR2(32767);
  v_start      NUMBER;
  v_stop       NUMBER;
  v_flag_cart  NUMBER;
  w_moi_retour NUMBER;
  w_numpac TGE_REF_MAPDO.NUMPAC%TYPE;
  jobno         NUMBER;
  w_type_retour VARCHAR2(2);
BEGIN
  v_start := DBMS_UTILITY.GET_TIME;
  getNumLigne(p_id);
  IF tab_numLigne00 IS NOT NULL AND tab_numLigne99 IS NOT NULL THEN
    FOR i IN tab_numLigne00.first..tab_numLigne00.last
    LOOP
      IF i            <=tab_numLigne99.count AND tab_numLigne99(i) IS NOT NULL THEN
        w_moi_retour  := GET_PERIODE_00(p_id,tab_numLigne00(i));
        w_numpac      := GET_NUMPAC(p_id,tab_numLigne00(i));
        w_type_retour := GET_TYPE_RETOUR(p_id,tab_numLigne00(i));
        insert_gap_trt(p_id,w_numpac,w_moi_retour,w_type_retour);
        insert_gap_trt_suivi(p_id,'DEBUT',NULL,'BATCH',w_type_retour);
        purge_carte80(p_id,w_moi_retour,tab_numLigne00(i),tab_numLigne99(i));
        -- la periodepaie est forcé au premier jour du moi
        req := 'INSERT INTO DIC_TGE_RESPAIE_RUBRIQUE (NUMPAC,PAIEZAD,PACMAT,CLASSE,CAISSE_RUB,CLEIMP,CODERES,CODERUB,IMPUTATION,MONTANT,NOMBRE,ORDRE,PERIODEPAIE,SENS,TAUX,TYPE,DATE_DEB_ARRET,PERIODE_RATTACH_DEB,PERIODE_RATTACH_FIN,PERIODE_AFFECTATION,MATRIC) ';
        req := req ||' SELECT DISTINCT i.numpac,i.paiezad,i.pacmat ,i.classe,i.attribut ,';--DIT  50818
        req := req ||' (dense_rank() over(partition by i.NUMPAC, i.PAIEZAD, i.CODERUB, i.CODERES order by i.NUMLIGNE)-1 )as CLEIMP';
        req := req ||' ,i.coderes,i.coderub,i.imputation, case when  i.sens =''-''  then ((i.montant)*(-1)) else i.montant end as montant ,';
        req         := req ||' i.nombre,to_number(r.ORDREXEC),TO_DATE('||w_moi_retour||'01,''YYYYMMDD''),';
        req         := req ||' i.sens,i.taux,';
        req         := req ||' i.type,to_date(i.DATE_DEB_ARRET,''yyyymmdd''),to_date(i.PERIODE_RATTACH_DEB,''yyyymmdd''),to_date(i.PERIODE_RATTACH_FIN,''yyyymmdd''),to_date(replace(i.PERIODE_AFFECTATION,''000000'',null),''yyyymm''),i.MATRICULE FROM TGE_IMPORT_FSED_80 i,TGE_REF_RUBRIQUE r  WHERE id_trt= :id_trt ';
        req         := req ||' AND r.coderub= i.coderub AND r.numpac = i.numpac ';
        req         := req ||' AND ( ';
        req         := req ||' (numligne >=' ||tab_numLigne00(i)||' AND numligne <= '||tab_numLigne99(i)||') ';
        req         := req ||' ) ';
        v_flag_cart := 1;
      ELSE
        v_flag_cart := 0;
      END IF;
      IF req IS NOT NULL THEN
        insert_gap_trt(p_id,w_numpac,w_moi_retour,w_type_retour);
        EXECUTE IMMEDIATE req USING p_id;
      ELSIF req IS NULL OR v_flag_cart = 0 THEN
        FSED_ERREUR( p_id , 'sous_insertCart80' , NULL, err_code||'-'||err_msg );
      END IF;
    END LOOP;
  ELSE
    req := NULL;
  END IF;
  merge INTO
  (SELECT * FROM GAP_TRT_LISTE_MAT WHERE id_trt=p_id
  ) a USING
  (SELECT DISTINCT numpac,
    NVL(pacmat,paiezad) AS pacmat
  FROM TGE_import_fsed_80
  WHERE id_trt     =p_id
  ) b ON (a.numpac =b.numpac AND a.pacmat=b.pacmat)
WHEN NOT matched THEN
  INSERT
    (a.id_trt,a.numpac,a.pacmat
    ) VALUES
    (p_id,b.numpac,b.pacmat
    );
  tab_numLigne00.delete;
  tab_numLigne99.delete;
  v_stop := DBMS_UTILITY.GET_TIME;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := err_msg||' '||SQLERRM;
  --DBMS_OUTPUT.PUT_LINE(req);
  --FIXME utiliser la procédure trace_dbms_output()
  FSED_ERREUR( p_id , 'insertCart80' , p_id || ',' || p_newId, err_code||'-'||err_msg||'- Requete : '||req);
  raise_application_error(-20000, 'FSED insertCart80  '|| sqlerrm);
END sous_insertCart80;
/******************************************************************
PROC : insertCart30 (p_id IN NUMBER)
DESC :
********************************************************************/
PROCEDURE insertCart80
  (
    p_id    IN NUMBER,
    p_newId IN NUMBER
  )
IS
  PRAGMA AUTONOMOUS_TRANSACTION;
  jobno    NUMBER;
  finished NUMBER;
BEGIN
  finished:=1;
  dbms_job.submit(jobno, 'sous_insertCart80('||p_id||','||p_newid||')',sysdate, NULL);
END insertCart80;
/*******************************************************************
PROC : tmp_histo_fsed_30
Fonc :
********************************************************************/
PROCEDURE tmp_histo_fsed_30(
    p_id     IN NUMBER ,
    p_numpac IN TGE_REF_MAPDO.NUMPAC%TYPE,
    p_moi    IN VARCHAR2
  )
IS
  CURSOR tmp_30
  IS
    SELECT DISTINCT do.DONNEEGXP ,
      ( SELECT DISTINCT data_type
      FROM user_tab_columns cln
      WHERE cln.table_name = do.TABLEGXP
      AND cln.column_name  = do.DONNEEGXP
      ) AS typeelt,
    dicoz.longueur
  FROM
    (SELECT * FROM TGE_REF_MAPDO WHERE numpac=p_numpac
    UNION ALL
    SELECT *
    FROM TGE_REF_MAPDO
    WHERE numpac     ='*'
    AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=p_numpac
      )
    ) DO ,tge_import_fsed_30 imp,tge_ref_dicoz dicoz
  WHERE do.TABLEGXP    ='DIC_ADM_CONTRAT_HISTO'
  AND imp.code_element =do.element
  AND imp.tablegxp     =do.tablegxp
  AND imp.donneegxp    =do.donneegxp
  AND id_trt           =p_id
  AND imp.numpac       = p_numpac
  AND imp.TABLEGXP     =do.tablegxp
  AND imp.code_element =do.element
  AND dicoz.element    = do.element
  AND dicoz.numpac     = imp.numpac ;
  stmtClause CLOB ;
  cmp NUMBER :=0;
BEGIN
  stmtClause := 'insert into TGE_FSED_30_TEMPORARY (id_trt,numpac,pacmat,paiezad,TOUPDATE)  (SELECT ';
  stmtClause :=stmtClause||'/*+  BATCH_TABLE_ACCESS_BY_ROWID(@"SEL$291F8F59" "DACH2"@"SEL$3") LEADING(@"SEL$B29E968D" "VW_SQ_1"@"SEL$E9784550" "T"@"SEL$2" "A"@"SEL$2") INDEX(@"SEL$B29E968D" "A"@"SEL$2" ("DIC_ADM_CONTRAT_HISTO"."NUMPAC" "DIC_ADM_CONTRAT_HISTO"."PAIEZAD" "DIC_ADM_CONTRAT_HISTO"."DATE_EFF")) BATCH_TABLE_ACCESS_BY_ROWID(@"SEL$B29E968D" "T"@"SEL$2") NO_ACCESS(@"SEL$B29E968D" "VW_SQ_1"@"SEL$E9784550") BATCH_TABLE_ACCESS_BY_ROWID(@"SEL$5" "F"@"SEL$5") USE_HASH(@"SEL$4FDF941B" "HISTO"@"SEL$1") LEADING(@"SEL$4FDF941B" "COMPTEUR"@"SEL$4" "HISTO"@"SEL$1") NO_ACCESS(@"SEL$4FDF941B" "HISTO"@"SEL$1") NO_ACCESS(@"SEL$4FDF941B" "COMPTEUR"@"SEL$4") UNNEST(@"SEL$3") */ ';
  stmtClause :=stmtClause||p_id||','''||p_numpac||''',compteur.pacmat,compteur.paiezad,decode(nvl(cmp,-1),cmp1,''N'',''O'') as TOUPDATE FROM ';
  stmtClause :=stmtClause||' (SELECT t.pacmat,t.paiezad,count(*) as cmp  FROM tge_import_fsed_30 t , dic_adm_contrat_histo a  where t.numpac ='''||p_numpac||''' and t.id_trt='||p_id||' and t.tablegxp=''DIC_ADM_CONTRAT_HISTO''';
  stmtClause :=stmtClause||' and a.paiezad = t.paiezad and a.pacmat =t.pacmat ';
  stmtClause :=stmtClause||' and a.numpac='''||p_numpac||''' and a.date_eff= ';
  stmtClause :=stmtClause||'(select max(dach2.date_eff) from dic_adm_contrat_histo dach2 where dach2.date_eff<=TO_DATE('''||p_moi||'01'',''YYYYMMDD'') and dach2.paiezad = t.paiezad ';
  stmtClause :=stmtClause||' AND dach2.pacmat= t.pacmat and dach2.numpac='''||p_numpac||''')';
  stmtClause :=stmtClause|| ' AND (';
  FOR c IN tmp_30
  LOOP
    IF cmp!=0 THEN
      stmtClause :=stmtClause||' OR ';
    END IF;
    cmp                      := cmp+1;
    IF c.typeelt              ='DATE' THEN
      stmtClause             :=stmtClause||' ( NVL(to_char(a.'||c.donneegxp;
      IF c.longueur   =6 THEN
        stmtClause           :=stmtClause||',''YYYYMM''';
      elsif c.longueur=8 THEN
        stmtClause           :=stmtClause||',''YYYYMMDD''';
      elsif c.longueur=4 THEN
        stmtClause           :=stmtClause||',''YYYY''';
      elsif c.longueur=2 THEN
        stmtClause           :=stmtClause||',''MM''';
      END IF;
      stmtClause   :=stmtClause||'),''NULL'')=NVL(to_char(replace(replace(t.valeur,'' '','''')';
      IF c.longueur   =6 THEN
        stmtClause           :=stmtClause||',''000000'',null';
      elsif c.longueur=8 THEN
        stmtClause           :=stmtClause||',''00000000'',null';
      elsif c.longueur=4 THEN
        stmtClause           :=stmtClause||',''0000'',null';
      elsif c.longueur=2 THEN
        stmtClause           :=stmtClause||',''00'',null';
      END IF;
      stmtClause   :=stmtClause||')),''NULL'') ';
      stmtClause   :=stmtClause||' AND t.donneegxp ='''||c.donneegxp||''')' ;
    elsif c.typeelt ='VARCHAR2' THEN
      stmtClause   :=stmtClause||'( NVL(a.'||c.donneegxp||',''NULL'')=NVL(to_char(t.valeur),''NULL'') AND t.donneegxp ='''||c.donneegxp||''')' ;
    ELSE
      stmtClause :=stmtClause||' ( NVL(a.'||c.donneegxp||',0)=nvl(is_number(t.valeur),0) AND t.donneegxp ='''||c.donneegxp||''')' ;
    END IF;
  END LOOP;
  stmtClause :=stmtClause|| ' )group by t.pacmat,t.paiezad)HISTO right join (select f.pacmat,f.paiezad,count(*)as cmp1 from tge_import_fsed_30 f WHERE f.numpac='''||p_numpac||''' AND f.id_trt  ='||p_id||' AND f.tablegxp=''DIC_ADM_CONTRAT_HISTO'' group by f.pacmat,f.paiezad) Compteur ';
  stmtClause :=stmtClause||' ON  histo.pacmat =compteur.pacmat and histo.paiezad =compteur.paiezad ) ';
  FSED_AVANCEMENT(p_id,'tmp_histo_fsed_30 stmtClause= '||substr(stmtClause,0,3800) );
  --dbms_output.put_line('test '||stmtClause);
  --FIXME utiliser la procédure trace_dbms_output()
   EXECUTE_IMMEDIATE_STRING  (stmtClause,0);
END tmp_histo_fsed_30;
/*******************************************************************
PROC : sous_insertCart30
Fonc : traitement des tables M1,M7,M3ANNEE,M3MOIS,MULTIPLE,OCCC
UNIQUE,H2 et AVPERS.
********************************************************************/
PROCEDURE sous_insertCart30(
    p_id    IN NUMBER,
    p_newId IN NUMBER,
    p_table IN VARCHAR2 )
IS
  req               CLOB;
  reqChrono         VARCHAR2(500);
  reqRc             CLOB;
  w_date_RC         DATE;
  w_date_indic      DATE;
  w_date_COMP       DATE;
  reqPropag         CLOB;
  reqTrace          CLOB;
  reqW580           CLOB;
  reqWL52           CLOB;
  reqUdpateDate     CLOB;
  ssreq             CLOB;
  v_start           NUMBER;
  v_stop            NUMBER;
  w_table           TGE_REF_MAPDO.TABLEGXP%TYPE;
  w_table_param     TGE_REF_MAPDO.TABLEGXP%TYPE;
  w_type_colonne    VARCHAR2(1);
  w_cle             VARCHAR2(12);
  w_type            VARCHAR2(1);
  w_colonne_30      VARCHAR2(12);
  coldtfin          VARCHAR2(50);
  v_flag_cart       NUMBER;
  w_date_eff        user_cons_columns.column_name%TYPE;
  w_code_caisse     user_cons_columns.column_name%TYPE;
  w_ann_social      VARCHAR2(100);
  w_table_soc       VARCHAR2(100);
  w_type_retour     VARCHAR2(2);
  w_moi_retour      NUMBER;
  w_numpac          TGE_REF_MAPDO.NUMPAC%TYPE;
  w_trace           VARCHAR2(50);
  tabW580_h         TAB_DATE_w580_H;
  tabWL52_h         TAB_DATE_WL52_H;
  objTable          TGE_REF_MAPTA%rowtype;
  w_00              NUMBER;
  w_99              NUMBER;
  w_elem            VARCHAR2(4);
  w_occ             VARCHAR2(2);
  
  CURSOR cur_element ( p_numpac IN VARCHAR2)
  IS
    SELECT DISTINCT do.DONNEEGXP ,
      (SELECT DISTINCT data_type
       FROM   user_tab_columns cln
       WHERE  cln.table_name = do.TABLEGXP
       AND    cln.column_name  = do.DONNEEGXP
      ) AS typeelt,
     ( select case 
       when type='N' and masque=1 THEN 'D1'  
       when type='N' and masque=2 THEN 'D2' 
       when type='N' and masque=3 THEN 'D3' 
       when type='N' and masque=4 THEN 'D4' 
       when type='N' and masque=5 THEN 'D5' 
       when type='N' and masque=6 THEN 'D6' 
       when type='N' and masque=7 THEN 'D7' 
       when type='P'  OR (type ='N' AND MASQUE NOT IN (1,2,3,4,5,6,7))THEN 'N' 
       WHEN type ='A' THEN 'V'
       ELSE type 
       end as typeDICOZ
      from tge_ref_dicoz d where numpac=p_numpac and element=do.element )as typeDICOZ
      
   FROM
    (SELECT * FROM TGE_REF_MAPDO WHERE numpac=p_numpac
     UNION ALL
     SELECT *
     FROM TGE_REF_MAPDO
     WHERE numpac     ='*'
     AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=p_numpac)
    ) DO 
  WHERE do.TABLEGXP=p_table
  AND EXISTS
    (SELECT code_element,
            tablegxp,
            donneegxp
    FROM  tge_import_fsed_30 imp
    WHERE id_trt       = p_id
    AND   imp.numpac   = p_numpac
    AND   imp.TABLEGXP = do.tablegxp
    AND   imp.code_element = do.element
    ) ;

  CURSOR cur_element_histo ( p_numpac IN VARCHAR2)
  IS
    SELECT DISTINCT do.DONNEEGXP ,
      ( SELECT DISTINCT data_type
        FROM user_tab_columns cln
        WHERE cln.table_name = do.TABLEGXP
        AND cln.column_name  = do.DONNEEGXP
      ) AS typeelt
    FROM
     (SELECT * FROM TGE_REF_MAPDO WHERE numpac=p_numpac
      UNION ALL
      SELECT *
      FROM TGE_REF_MAPDO
      WHERE numpac     ='*'
      AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=p_numpac)
    ) DO
  WHERE do.TABLEGXP=p_table
  AND EXISTS
    (SELECT code_element,
      tablegxp,
      donneegxp
    FROM tge_import_fsed_30 imp
    WHERE id_trt        =p_id
    AND imp.numpac      = p_numpac
    AND imp.TABLEGXP    =do.tablegxp
    AND imp.code_element=do.element
    ) ;

  CURSOR cur_SECUPACMAT ( p_numpac IN VARCHAR2)
  IS
    SELECT DISTINCT do.DONNEEGXP ,
      ( SELECT DISTINCT data_type
      FROM user_tab_columns cln
      WHERE cln.table_name = 'SECUPACMAT'
      AND cln.column_name  = do.DONNEEGXP
      ) AS typeelt,
      ( select case 
       when type='N' and masque=1 THEN 'D1'  
       when type='N' and masque=2 THEN 'D2' 
       when type='N' and masque=3 THEN 'D3' 
       when type='N' and masque=4 THEN 'D4' 
       when type='N' and masque=5 THEN 'D5' 
       when type='N' and masque=6 THEN 'D6' 
       when type='N' and masque=7 THEN 'D7' 
       when type='P'  OR (type ='N' AND MASQUE NOT IN (1,2,3,4,5,6,7))THEN 'N' 
       WHEN type ='A' THEN 'V'
       ELSE type 
       end as typeDICOZ
      from tge_ref_dicoz d where numpac=p_numpac and element=do.element )as typeDICOZ
  FROM
    (SELECT * FROM TGE_REF_MAPDO WHERE numpac=p_numpac
    UNION ALL
    SELECT *
    FROM TGE_REF_MAPDO
    WHERE numpac     ='*'
    AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=p_numpac
      )
    ) DO,
    user_tab_columns u
  WHERE do.TABLEGXP ='DIC_ADM_CONTRAT'
  AND u.column_name = do.DONNEEGXP
  AND u.table_name  = 'SECUPACMAT'
  AND EXISTS
    (SELECT code_element,
      tablegxp,
      donneegxp
    FROM tge_import_fsed_30 imp
    WHERE id_trt        =p_id
    AND imp.numpac      =p_numpac
    AND imp.TABLEGXP    =do.tablegxp
    AND imp.code_element=do.element
    ) ;
  clinsertcols       CLOB;
  clinsertsel        CLOB;
  clinsertvalues     CLOB;
  clmerge            CLOB;
  nbmapta            NUMBER;
  hasDtfin           NUMBER;
  clssreqPivotMerge  CLOB;
  clupdateMerge      CLOB;
  clinsertDonMerge   CLOB;
  clinsertValMerge   CLOB;
  clssreqPivotSec    CLOB;
  clupdSecu          CLOB;
  clinsertDonSecu    CLOB;
  clinsertValSecu    CLOB;
TYPE t_colonne IS  TABLE OF user_tab_columns.column_name%type;
  tab_colonne         t_colonne;
  donneesUpdatePropag CLOB;
  donneesSelectPropag CLOB;
BEGIN
  FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début p_id='||p_id||';p_newId='||p_newId||';p_table='||p_table);
  v_start := DBMS_UTILITY.GET_TIME;
  getNumLigne(p_id);
  --gestion du trigger des DACH : insertion dans la table temporaire BYPASS_TRG_DACH_ON_SESSION
  INSERT INTO BYPASS_TRG_DACH_ON_SESSION(date_event,MESSAGE)VALUES(sysdate,'Retour de paie Carte 30');
  COMMIT;
  FOR i IN tab_numLigne00.first..tab_numLigne00.last
  LOOP
    IF i <=tab_numLigne99.count AND tab_numLigne99(i)IS NOT NULL THEN
      w_numpac := GET_NUMPAC(p_id,tab_numLigne00(i));
      w_type_retour := GET_TYPE_RETOUR(p_id,tab_numLigne00(i));
      IF p_table IN ('DIC_TGE_PRETS','DIC_TGE_OPPOSITIONS') THEN
        reqChrono := ' AND ( (pacmat,NVL(code_chrono,''0'') ) IN (select pacmat,nvl(max(imp.code_chrono),''0'')  from tge_import_FSED_30 imp WHERE  imp.id_trt='||p_id||' AND imp.numpac='''||w_numpac||''' AND imp.tablegxp = '''||p_table||''' and imp.CODE_ELEMENT=tge_import_FSED_30.CODE_ELEMENT AND NVL(imp.indicatif,''XyZ'')=NVL(tge_import_FSED_30.indicatif,''XyZ'') AND imp.pacmat =tge_import_FSED_30.pacmat   group by imp.pacmat))';
      ELSE
        reqChrono := '';
      END IF;
      IF w_type_retour IN ('RN','RC','RT') THEN
        w_moi_retour := GET_PERIODE_00(p_id,tab_numLigne00(i));
        IF p_table    ='DIC_ADM_CONTRAT_HISTO' THEN
          FSED_AVANCEMENT(p_id,'tmp_histo_fsed_30 Début p_id='||p_id ||';w_numpac='||w_numpac||';w_moi_retour='||w_moi_retour );
          DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'GAP_TRT_LISTE_MAT',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
              DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'TGE_IMPORT_FSED',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
              DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'TGE_IMPORT_FSED_30',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
          tmp_histo_fsed_30(p_id,w_numpac,w_moi_retour);
          COMMIT;
          DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'TGE_FSED_30_TEMPORARY',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
          FSED_AVANCEMENT(p_id,'tmp_histo_fsed_30 Fin ');
        END IF;
        SELECT COUNT(*)
        INTO nbmapta
        FROM
          (SELECT * FROM TGE_REF_MAPTA WHERE numpac=w_numpac
          UNION ALL
          SELECT *
          FROM TGE_REF_MAPTA
          WHERE numpac        ='*'
          AND TABLEPARAM NOT IN
            (SELECT TABLEPARAM FROM TGE_REF_MAPTA WHERE numpac=w_numpac
            )
          ) TA
        WHERE ta.tableparam=p_table
        AND ALLERRETOUR   IN ('2','R')
        AND TABLETYPE     IS NOT NULL
        AND TABLEPHY      IS NOT NULL ;
        IF (nbmapta        > 0) THEN
          SELECT DISTINCT numpac,
            NULL AS rownumber ,
            tableparam,
            NULL AS fichier,
            tablephy,
            allerretour,
            tabletype,
            moiszero,
            nbmoiscons,
            sensiblerhid,
            reserve
          INTO objtable
          FROM
            (SELECT * FROM TGE_REF_MAPTA WHERE numpac=w_numpac
            UNION ALL
            SELECT *
            FROM TGE_REF_MAPTA
            WHERE numpac        ='*'
            AND TABLEPARAM NOT IN
              (SELECT TABLEPARAM FROM TGE_REF_MAPTA WHERE numpac=w_numpac
              )
            ) TA
          WHERE ta.tableparam=p_table
          AND ALLERRETOUR   IN ('2','R')
          AND TABLETYPE     IS NOT NULL
          AND TABLEPHY      IS NOT NULL;
          IF objtable.TABLETYPE ='M3ANNEE' THEN
            reqW580 := 'SELECT numpac,paiezad, valeur FROM TGE_IMPORT_FSED_30 AN WHERE  ID_TRT = :1 and AN.numpac  = :2 AND code_element =''W580'' ';
            EXECUTE IMMEDIATE reqW580 bulk collect INTO tabW580_h USING p_id,
            w_numpac;
          END IF;
          IF objtable.TABLETYPE ='M1' THEN
            reqWL52 := 'SELECT numpac,paiezad, valeur FROM TGE_IMPORT_FSED_30 AN WHERE  ID_TRT = :1 and AN.numpac  = :2 AND code_element =''WL52'' ';
            EXECUTE IMMEDIATE reqWL52 bulk collect INTO tabWL52_h USING p_id,
            w_numpac;
          END IF;
          w_table       := objtable.TABLEPHY;
          w_table_param := objtable.TABLEPARAM;
          w_type        := getTypeTable(w_table);
          FOR trig IN
          (SELECT object_name
          FROM user_objects
          WHERE lower(object_type)='trigger'
          AND lower(object_name) LIKE '%'
            ||lower(w_table)
            ||'%'
          AND (lower(object_name) LIKE 'horo%' )
          )
          LOOP
             EXECUTE_IMMEDIATE_STRING  ('ALTER TRIGGER ' || trig.object_name ||' disable ',0);
          END LOOP;
          w_date_eff := GET_H2_COLONNE(w_table);
          --RSI : En cas de RN, si 1 ligne existe dans la même année sociale, il faut la détruire. La date de paie AAAAMM01 sera insérée
          IF w_type_retour = 'RN' THEN
          --DEBUT M3ANNEE
            IF objtable.TABLETYPE ='M3ANNEE' THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RN '||objtable.TABLETYPE );
              IF tabW580_h.exists(1) THEN
                req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  ';
                req := req ||' EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and numpac  = :numpac  and TGE_IMPORT_FSED_30.paiezad=T.paiezad';
                req := req ||' AND TGE_IMPORT_FSED_30.CODE_ELEMENT =''W580'' AND SUBSTR('''||w_moi_retour||''',5,2)>=TGE_IMPORT_FSED_30.valeur ';
                req := req ||' AND '||w_date_eff||' between TO_DATE(';
                req := req ||' SUBSTR('''||w_moi_retour||''',1,4)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
                req := req ||' AND TO_DATE(';
                req := req ||' SUBSTR('''||w_moi_retour||''',1,4)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364 )';
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id,
                w_numpac;
                req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  ';
                req := req ||' EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and numpac  = :numpac and TGE_IMPORT_FSED_30.paiezad=T.paiezad  ';
                req := req ||' AND TGE_IMPORT_FSED_30.CODE_ELEMENT =''W580'' AND SUBSTR('''||w_moi_retour||''',5,2)<TGE_IMPORT_FSED_30.valeur ';
                req := req ||' AND '||w_date_eff||' between TO_DATE(';
                req := req ||' (SUBSTR('''||w_moi_retour||''',1,4)-1)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
                req := req ||' AND TO_DATE(';
                req := req ||' (SUBSTR('''||w_moi_retour||''',1,4)-1)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364 )';
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id,
                w_numpac;
              ELSE
                IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
                  req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
                  req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
                  req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
                  req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
                  req                      := req ||' AND TO_DATE(';
                  req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
                  req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')+364';
                ELSE
                  req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
                  req := req ||' AND '||w_date_eff||' between TO_DATE(';
                  req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||''';
                  req := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
                  req := req ||' AND TO_DATE(';
                  req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
                  req := req ||objtable.MOISZERO||'||''01'''||',''YYYYMMDD'')+364';
                END IF ;
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id;
                req:='';
              END IF;
            END IF;
          --FIN M3ANNEE 
          --DEBUT M1
          IF objtable.TABLETYPE ='M1' THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RN '||objtable.TABLETYPE );
              IF tabWL52_h.exists(1) THEN
                req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  ';
                req := req ||' EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and numpac  = :numpac  and TGE_IMPORT_FSED_30.paiezad=T.paiezad';
                req := req ||' AND TGE_IMPORT_FSED_30.CODE_ELEMENT =''WL52'' AND SUBSTR('''||w_moi_retour||''',5,2)>=TGE_IMPORT_FSED_30.valeur ';
                req := req ||' AND '||w_date_eff||' between TO_DATE(';
                req := req ||' SUBSTR('''||w_moi_retour||''',1,4)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
                req := req ||' AND TO_DATE(';
                req := req ||' SUBSTR('''||w_moi_retour||''',1,4)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364 )';
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id,
                w_numpac;
                req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  ';
                req := req ||' EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and numpac  = :numpac and TGE_IMPORT_FSED_30.paiezad=T.paiezad  ';
                req := req ||' AND TGE_IMPORT_FSED_30.CODE_ELEMENT =''WL52'' AND SUBSTR('''||w_moi_retour||''',5,2)<TGE_IMPORT_FSED_30.valeur ';
                req := req ||' AND '||w_date_eff||' between TO_DATE(';
                req := req ||' (SUBSTR('''||w_moi_retour||''',1,4)-1)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
                req := req ||' AND TO_DATE(';
                req := req ||' (SUBSTR('''||w_moi_retour||''',1,4)-1)||';
                req := req ||' NVL(TGE_IMPORT_FSED_30.valeur,'''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364 )';
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id,
                w_numpac;
              ELSE
                IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
                  req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
                  req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
                  req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
                  req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
                  req                      := req ||' AND TO_DATE(';
                  req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
                  req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')+364';
                ELSE
                  req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
                  req := req ||' AND '||w_date_eff||' between TO_DATE(';
                  req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||''';
                  req := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
                  req := req ||' AND TO_DATE(';
                  req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
                  req := req ||objtable.MOISZERO||'||''01'''||',''YYYYMMDD'')+364';
                END IF ;
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';w_numpac'||w_numpac||';req='||req );
                EXECUTE IMMEDIATE req USING p_id;
                req:='';
              END IF;
            END IF;
          --FIN M1
            --RSI : En cas de RN, si 1 ligne existe dans la même année statistique, il faut la détruire. La date de paie AAAAMM01 sera insérée.
            IF objtable.TABLETYPE ='M9' THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RN TABLETYPE M9');
              IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
                req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) AND '||w_date_eff||' between TO_DATE(SUBSTR('||w_moi_retour||',1,4)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'') and (TO_DATE(SUBSTR('||w_moi_retour||',1,4)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'')+364)';
              ELSE
                req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) AND '||w_date_eff||' between TO_DATE((SUBSTR('||w_moi_retour||',1,4)-1)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'') and (TO_DATE((SUBSTR('||w_moi_retour||',1,4)-1)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'')+364)';
              END IF;
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete req p_id='||p_id||';req='||req);
              EXECUTE IMMEDIATE req USING p_id;
              req:='';
            END IF;
          END IF;
          IF objtable.TABLETYPE ='AVPERS' THEN
            w_code_caisse      :='';
          ELSE
            w_code_caisse := GET_M3_COLONNE(w_table);
          END IF;
          IF w_type    ='m' THEN
            w_cle     := 'MATRIC';
          ELSIF w_type ='p' THEN
            w_cle     := 'PACMAT';
          ELSIF w_type ='z' THEN
            w_cle     := 'PAIEZAD';
          END IF;
          IF w_cle        = 'MATRIC' THEN
            w_colonne_30 := 'MATRICULE';
          ELSE
            w_colonne_30 := w_cle;
          END IF;
          IF objtable.TABLETYPE <> 'AVPERS' OR w_table ='DIC_ADM_CONTRAT' THEN
            FOR C IN cur_element(w_numpac)
            LOOP
              req                  :='';
              reqUdpateDate        :='';
              reqPropag            :='';
              w_type_colonne       := SUBSTR(c.typeelt,0,1);
              w_trace              := C.DONNEEGXP;
              IF clssreqPivotMerge IS NOT NULL THEN
                clssreqPivotMerge  :=clssreqPivotMerge||',';
              END IF;
              clssreqPivotMerge:=clssreqPivotMerge||' '''||C.DONNEEGXP||'''  as '||C.DONNEEGXP ;
              IF clupdateMerge IS NOT NULL THEN
                clupdateMerge  :=clupdateMerge||',';
              END IF;
              clupdateMerge       :=clupdateMerge||'T.'||C.DONNEEGXP||'='||GET_Statement (w_type_colonne,C.typeDICOZ ,C.DONNEEGXP) ;
              IF clinsertDonMerge IS NOT NULL THEN
                clinsertDonMerge  :=clinsertDonMerge||',';
              END IF;
              clinsertDonMerge    :=clinsertDonMerge||C.DONNEEGXP ;
              IF clinsertValMerge IS NOT NULL THEN
                clinsertValMerge  :=clinsertValMerge||',';
              END IF;
              clinsertValMerge:=clinsertValMerge||GET_Statement (w_type_colonne,C.typeDICOZ ,C.DONNEEGXP) ;
            END LOOP;
          END IF;
          -- TABLE Unique
          IF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='UNIQUE' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  UNIQUE ');
            req             := 'MERGE INTO '||w_table ||' T USING ';
            req             := req ||' (select tge.* from (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp  ,valeur  FROM TGE_IMPORT_FSED_30 TGE  where ID_TRT= ' ;
            req             := req ||':id AND tablegxp='''||w_table ||''' ';
            req             := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND  numpac='''||w_numpac||'''   ';
            IF w_type_retour ='RC' AND IS_VALID_COLUMN (w_table,'PACMAT') >0 THEN
              req           := req || ' AND PAIEZAD in (select PAIEZAD from dic_adm_contrat_situ a where numpac = tge.numpac and pacmat not in ';
              req           := req || ' (SELECT PACMAT FROM GAP_TRT_LISTE_MAT_HISTO G WHERE G.NUMPAC=a.NUMPAC AND G.PERIODE_PAIE = '''||w_moi_retour||''' AND TO_CHAR(G.DATE_COMP,''YYYYMM'')<= '''||w_moi_retour||'''))';
            END IF ;
            req                      := req|| reqChrono;
            req                      := req ||') pivot ( max(valeur) for donneegxp in ( '||clssreqPivotMerge;
            req                      := req ||')) )tge)  i';
            req                      := req ||' on ( T.numpac=i.numpac and T.'||w_colonne_30||'=i.'||w_cle;
            req                      := req ||') ';
            IF w_type_retour          ='RN' THEN
              req                    := req ||' when MATCHED THEN ';
              req                    := req ||' UPDATE  set '||clupdateMerge;
              req                  := req ||',DATE_DERNIERE_MODIF=sysdate ';
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',type_writer=''N'' ';
              END IF;
              req                      := req ||' when NOT MATCHED THEN INSERT (numpac,pacmat,MATRIC,DATE_CREATION,'||w_cle||',';
              IF w_cle                  ='PAIEZAD' THEN
                req                    := req || clinsertDonMerge;
                IF objtable.ALLERRETOUR ='2' THEN
                  req                  := req ||',type_writer';
                END IF;
                req := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD, ';
              ELSE
                req                    := req ||clinsertDonMerge;
                IF objtable.ALLERRETOUR ='2' THEN
                  req                  := req ||',type_writer';
                END IF;
                req := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.'||w_colonne_30||',';
              END IF;
              req                    := req || clinsertValMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',''N''';
              END IF;
              req := req ||')';
              --
            END IF;
            IF w_type_retour          ='RC' THEN
              req                    := req ||' when MATCHED THEN UPDATE  set '||clupdateMerge;
              req                  := req ||',DATE_DERNIERE_MODIF=sysdate ';
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',type_writer=''N''';
              END IF;
              req                      := req ||' when NOT MATCHED THEN INSERT (numpac,pacmat,MATRIC,DATE_CREATION,'||w_cle||',';
              IF w_cle                  ='PAIEZAD' THEN
                req                    := req || clinsertDonMerge;
                IF objtable.ALLERRETOUR ='2' THEN
                  req                  := req ||',type_writer';
                END IF;
                req := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD, ';
              ELSE
                req                    := req ||clinsertDonMerge;
                IF objtable.ALLERRETOUR ='2' THEN
                  req                  := req ||',type_writer';
                END IF;
                req := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.'||w_colonne_30||',';
              END IF;
              req                    := req || clinsertValMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',''N''';
              END IF;
              req := req ||')';
            END IF;
            
            --TABLE H2
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE = 'H2' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  H2 ');
            req                    := 'MERGE INTO '||w_table ||' T USING ';
            req                    := req ||' (select  TGE.*,';
            req                    := req ||'TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
            req                    := req ||'as '||w_date_eff||', ';
            req                    := req ||' numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
            req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp  ,valeur from tge_import_FSED_30  WHERE  ID_TRT= ' ;
            req                    := req ||':id AND tablegxp='''||w_table ||''' ';
            req                    := req ||' AND ( numligne >=:ligne0 AND numligne <= :ligne99) and numpac='''||w_numpac||'''  ';
            req                    := req || reqChrono;
            req                    := req ||') pivot ( max(valeur) for donneegxp in (';
            req                    := req || clssreqPivotMerge;
            req                    := req ||')) )tge  ) i';
            req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad AND T.'||w_date_eff||'=i.'||w_date_eff||') ';
            req                    := req ||' when NOT MATCHED THEN INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||clinsertDonMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',type_writer';
            END IF;
            req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||', ';
            req                    := req || clinsertValMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',''N''';
            END IF;
            req                    := req ||')';
            req                    := req ||' when MATCHED THEN ';
            req                    := req ||' UPDATE  set '||clupdateMerge;
            req                  := req ||',DATE_DERNIERE_MODIF=sysdate ';
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',type_writer=''N''';
            END IF;
            -- Si il y a une colonne dtFin, on met à jour la date
            SELECT COUNT(*)
            INTO hasDtfin
            FROM user_tab_columns
            WHERE table_name =w_table
            AND column_name  ='DTFIN';
            IF hasDtfin      >0 THEN
              -- table H2  forcer le DTFIN au dernier jour du mois
              reqUdpateDate   :=' update  '||w_table || ' a  set DTFIN= last_day('||w_date_eff||') ' ;
              reqUdpateDate   :=reqUdpateDate|| ' where  exists(select * FROM TGE_IMPORT_FSED_30 TGE  WHERE  ID_TRT= ' ;
              reqUdpateDate   := reqUdpateDate ||':id  AND tablegxp='''||w_table ||''' ';
              reqUdpateDate   := reqUdpateDate ||' AND ( numligne >=:ligne0 AND numligne <= :ligne99) ';
              IF w_colonne_30  = 'PACMAT' THEN
                reqUdpateDate := reqUdpateDate ||' and TGE.numpac=a.numpac and nvl(TGE.PACMAT,TGE.PAIEZAD) =a.'||w_colonne_30||'   ';
              ELSE
                reqUdpateDate := reqUdpateDate ||' and TGE.numpac=a.numpac and TGE.PAIEZAD =a.'||w_colonne_30||'   ';
              END IF;
              reqUdpateDate := reqUdpateDate ||') ';
            END IF;
            --TABLE AVPERS
          ELSIF objtable.TABLETYPE = 'AVPERS' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  AVPERS ');
            --calcul de la date fin
            IF w_table ='DIC_ADM_CONTRAT' THEN
              coldtfin:='DSFCN';
            ELSE
              coldtfin:='DATE_FIN';
            END IF;
            SELECT column_name BULK COLLECT
            INTO tab_colonne
            FROM user_tab_columns
            WHERE table_name = w_table
            AND column_name NOT LIKE '%IDPACMAT%'
            ORDER BY column_id;
            -- eliminer les doublons du merge des AVPERS
            IF w_table='DIC_ADM_CONTRAT_HISTO' THEN
              FOR K IN cur_element_histo(w_numpac)
              LOOP
                clinsertcols   :='';
                clinsertsel    :='';
                clinsertvalues :='';
                FOR indx IN tab_colonne.first .. tab_colonne.last
                LOOP
                  IF tab_colonne(indx) =w_date_eff THEN
                    IF clinsertsel    IS NULL THEN
                      clinsertsel     :='TO_DATE('''||w_moi_retour||'01'',''YYYYMMDD'') as '||w_date_eff;
                      clinsertcols    :=tab_colonne(indx);
                      clinsertvalues  :='I.'||tab_colonne(indx);
                    ELSE
                      clinsertsel    :=clinsertsel||',TO_DATE('''||w_moi_retour||'01'',''YYYYMMDD'') as '||w_date_eff;
                      clinsertcols   :=clinsertcols||','||tab_colonne(indx);
                      clinsertvalues :=clinsertvalues||','||'I.'||tab_colonne(indx);
                    END IF;
                  elsif objtable.ALLERRETOUR ='2' AND tab_colonne(indx)='TYPE_WRITER' THEN
                    IF clinsertsel          IS NULL THEN
                      clinsertsel           :='''N'' as type_writer';
                      clinsertcols          :=tab_colonne(indx);
                      clinsertvalues        :='''N''';
                    ELSE
                      clinsertsel    :=clinsertsel||',a.'||tab_colonne(indx);
                      clinsertcols   :=clinsertcols||','||tab_colonne(indx);
                      clinsertvalues :=clinsertvalues||',''N''';
                    END IF;
                  ELSE
                    IF clinsertsel   IS NULL THEN
                      clinsertsel    :='a.'||tab_colonne(indx);
                      clinsertcols   :=tab_colonne(indx);
                      clinsertvalues :='I.'||tab_colonne(indx);
                    ELSE
                      clinsertsel    :=clinsertsel||',a.'||tab_colonne(indx);
                      clinsertcols   :=clinsertcols||','||tab_colonne(indx);
                      clinsertvalues :=clinsertvalues||','||'I.'||tab_colonne(indx);
                    END IF;
                  END IF;
                END LOOP;
                -- construction de la requête de propagation
                --si la colonne des AVPERS est une date
                IF NVL(k.typeelt,'XyZ') ='DATE' THEN
                  donneesUpdatePropag  := donneesUpdatePropag || 'a.' || K.DONNEEGXP || '= decode (instr(tge.' || K.DONNEEGXP || ',''-''),0,TO_DATE(tge.' || K.DONNEEGXP || ',''YYYYMMDD''),TO_DATE(tge.' || K.DONNEEGXP || ',''yy-mm-dd'')) ,';
                ELSE
                  donneesUpdatePropag := donneesUpdatePropag || 'a.' || K.DONNEEGXP || '= tge.' || K.DONNEEGXP || ' ,';
                END IF;

                donneesSelectPropag := donneesSelectPropag || K.DONNEEGXP || ' ,';
                clssreqPivotMerge   := clssreqPivotMerge || '''' || K.DONNEEGXP || ''' AS '|| K.DONNEEGXP || ' ,';
              END LOOP;
            END IF ;
            IF w_table       ='DIC_ADM_CONTRAT_HISTO' THEN
              req           := 'INSERT INTO '||w_table ||'('||clinsertcols||') ';
              req           := req || ' WITH Cont AS(SELECT  MAX(DATE_EFF) AS mydate,numpac as numpac ,pacmat as pacmat FROM    DIC_ADM_CONTRAT_HISTO WHERE '||w_date_eff||' <TO_DATE('||w_moi_retour||'01,''YYYYMMDD'')  GROUP BY numpac,pacmat)';
              req           := req || ' SELECT /*+ LEADING(@"SEL$C19C7BAF" "TGE"@"SEL$3" "A"@"SEL$2" "TGE_FSED_30_TEMPORARY"@"SEL$6" "CONT"@"SEL$2" "D"@"SEL$5")*/'||clinsertsel||' FROM '||w_table ||'  a , cont WHERE EXISTS(SELECT 1 FROM TGE_IMPORT_FSED_30 TGE WHERE ';
              req           := req || ' ID_TRT = ' ;
              req           := req ||':id AND ( numligne >=:ligne00 AND numligne <= :ligne99) ';
              IF w_colonne_30= 'PACMAT' THEN
                req         := req ||' and TGE.numpac=a.numpac and nvl(TGE.PACMAT,TGE.PAIEZAD) =a.'||w_colonne_30||'  AND TGE.tablegxp    = ''DIC_ADM_CONTRAT_HISTO'')      ';
              ELSE
                req := req ||' and TGE.numpac=a.numpac and TGE.PAIEZAD =a.'||w_colonne_30||'  AND TGE.tablegxp    = ''DIC_ADM_CONTRAT_HISTO'')       ';
              END IF;
              req := req ||' AND A.DATE_EFF =Cont.mydate AND A.NUMPAC =Cont.NUMPAC AND A.PACMAT =Cont.PACMAT';
              --Ajout du contrôle sur la date de fin de contrat pour ne pas générer de nouvelles dates d'effets si celle ci est supérieur à la date de fin .
              req := req ||' AND TO_DATE('''||w_moi_retour||'01'',''YYYYMMDD'') < ( select NVL(DSFCN,to_date(''20991231'',''YYYYMMDD'')) from DIC_ADM_CONTRAT where NUMPAC=a.numpac and  PACMAT=a.PACMAT and  NUMCNT=a.NUMCNT )';
              req := req ||' and not exists (select 1 from  '||w_table || ' d where d.numpac=a.numpac and d.'||w_colonne_30||' =a.'||w_colonne_30||' and d.'||w_date_eff||'=TO_DATE('||w_moi_retour||'01,''YYYYMMDD'') ) ';
              req := req ||' and exists (select 1 from  TGE_FSED_30_TEMPORARY where id_trt ='||p_id||' AND numpac = a.numpac and '||w_colonne_30||' =a.'||w_colonne_30||' and TOUPDATE=''O'' ) ';
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Insert DACH='||substr(req,0,3800) );
              EXECUTE IMMEDIATE req USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i);
              IF donneesUpdatePropag IS NOT NULL THEN
                donneesUpdatePropag  := SUBSTR(donneesUpdatePropag, 0, LENGTH(donneesUpdatePropag) - 1); -- enlever la virgule de trop à la fin
              END IF;
              IF donneesSelectPropag IS NOT NULL THEN
                donneesSelectPropag  := SUBSTR(donneesSelectPropag, 0, LENGTH(donneesSelectPropag) - 1); -- enlever la virgule de trop à la fin
              END IF;
              IF clssreqPivotMerge IS NOT NULL THEN
                clssreqPivotMerge  := SUBSTR(clssreqPivotMerge, 0, LENGTH(clssreqPivotMerge) - 1); -- enlever la virgule de trop à la fin
              END IF;
            END IF;
            IF w_table        ='DIC_ADM_CONTRAT_HISTO' THEN
              reqPropag      := 'merge  into ' || w_table || ' a using (SELECT  * from (SELECT * FROM (SELECT id_trt, numpac, paiezad, pacmat, donneegxp, valeur';
              reqPropag      := reqPropag || ' FROM TGE_IMPORT_FSED_30 TGE WHERE ID_TRT =';
              reqPropag      := reqPropag || ' :id AND tablegxp = ''' || w_table ||'''';
              reqPropag      := reqPropag || ' AND (numligne >= :ligne0 AND numligne <= :ligne99)  AND (numpac,pacmat,paiezad) in (select numpac, pacmat, paiezad from TGE_FSED_30_TEMPORARY where id_trt='''||p_id||''' and toupdate=''O'')';
              reqPropag      := reqPropag || reqChrono;
              reqPropag      := reqPropag || ') PIVOT(MAX(valeur) FOR DONNEEGXP IN (' || clssreqPivotMerge || ')) ) ) tge  on (';
              reqPropag      := reqPropag || '  TGE.numpac = a.numpac';
              IF w_colonne_30 = 'PACMAT' THEN
                reqPropag    := reqPropag || ' AND NVL(TGE.PACMAT, TGE.PAIEZAD) = a.' || w_colonne_30;
              ELSE
                reqPropag := reqPropag || ' AND TGE.PAIEZAD = a.' || w_colonne_30 ;
              END IF;
              reqPropag              := reqPropag || ' and ' || w_date_eff || ' >= TO_DATE(''' || w_moi_retour || '01'',''YYYYMMDD'') and  ' || w_date_eff || '< ADD_MONTHS(TO_DATE(''' || w_moi_retour || '01'',''YYYYMMDD''), 1) ) when matched then update set ';
              IF objtable.ALLERRETOUR = '2' THEN
                reqPropag            := reqPropag || ' a.type_writer = ''N'', ';
              END IF;
              reqPropag := reqPropag ||''|| donneesUpdatePropag ;
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Merge DACH='||substr(reqPropag,0,3800) );
              -- lancer la requete de propagation avec pivot
              EXECUTE IMMEDIATE reqPropag USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i);

            END IF;
            IF w_table                ='DIC_ADM_CONTRAT' AND clssreqPivotMerge IS NOT NULL THEN
              req                    := 'MERGE INTO '||w_table ||' T USING ';
              req                    := req ||'(select TGE.*';
              req                    := req ||',numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
              req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat, donneegxp,indicatif,valeur from tge_import_FSED_30  where ID_TRT= ' ;
              req                    := req ||':id  AND tablegxp='''||w_table ||''' ';
              req                    := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||'''  ';
              req                    := req || reqChrono;
              req                    := req ||' ) pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
              req                    := req ||')) )tge)  i';
              req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad and (';
              req                    := req||'(T.DSDCN<= TO_DATE('''||w_moi_retour||''', ''YYYYMM'')  and T.DSFCN is not null and T.DSFCN between TO_DATE('''||w_moi_retour||''', ''YYYYMM'') and last_day(to_date('''||w_moi_retour||''',''YYYYMM'')))';
              req                    := req||' OR(T.DSDCN between TO_DATE('''||w_moi_retour||''', ''YYYYMM'') and last_day(to_date('''||w_moi_retour||''',''YYYYMM''))AND NVL(T.DSFCN,to_date(''20991231'',''YYYYMMDD''))>= last_day(to_date('''||w_moi_retour||''',''YYYYMM'')))';
              req                    := req||' OR (T.DSDCN <=last_day(to_date('''||w_moi_retour||''',''YYYYMM''))AND  T.DSFCN IS  NULL)';
              req                    := req||') ';
              req                    := req ||') ';
              req                    := req ||' when MATCHED THEN UPDATE  set ' ;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||'type_writer=''N'', ';
              END IF;
              req := req ||clupdateMerge;
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 DAC='||substr(req,0,3800) );
              EXECUTE IMMEDIATE req USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i);
              --Mise à jour de la donnée dans secupacmat
              FOR C IN cur_secupacmat(w_numpac)
              LOOP
                req                :='';
                w_type_colonne     := SUBSTR(c.typeelt,0,1);
                IF clssreqPivotSec IS NOT NULL THEN
                  clssreqPivotSec  :=clssreqPivotSec||',';
                END IF;
                clssreqPivotSec:=clssreqPivotSec||' '''||C.DONNEEGXP||'''  as '||C.DONNEEGXP ;
                IF clupdSecu   IS NOT NULL THEN
                  clupdSecu    :=clupdSecu||',';
                END IF;
                clupdSecu          :=clupdSecu||'T.'||C.DONNEEGXP||'='||GET_Statement (w_type_colonne,C.typeDICOZ ,C.DONNEEGXP) ;
                IF clinsertDonSecu IS NOT NULL THEN
                  clinsertDonSecu  :=clinsertDonSecu||',';
                END IF;
                clinsertDonSecu    :=clinsertDonSecu||C.DONNEEGXP ;
                IF clinsertValSecu IS NOT NULL THEN
                  clinsertValSecu  :=clinsertValSecu||',';
                END IF;
                clinsertValSecu:=clinsertValSecu||GET_Statement (w_type_colonne,C.typeDICOZ ,C.DONNEEGXP) ;
              END LOOP;
              IF clssreqPivotSec IS NOT NULL THEN
                req              := 'MERGE INTO SECUPACMAT T USING ';
                req              := req ||'(select TGE.*';
                req              := req ||',numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
                req              := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat, donneegxp,indicatif  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
                req              := req ||':id  AND tablegxp='''||w_table ||''' ';
                req              := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||'''  ';
                req              := req || reqChrono;
                req              := req ||' ) pivot(max(valeur) for donneegxp in ('||clssreqPivotSec;
                req              := req ||')) )tge)  i';
                req              := req ||' on ( T.numpac=i.numpac and T.pacmat =i.pacmat and (';
                req              := req||'(to_date(T.DSDCN,''YYYYMMDD'')<= TO_DATE('''||w_moi_retour||''', ''YYYYMM'')  and T.DSFCN is not null and TO_DATE(T.DSFCN,''YYYYMMDD'') between TO_DATE('''||w_moi_retour||''', ''YYYYMM'') and last_day(to_date('''||w_moi_retour||''',''YYYYMM'')))';
                req              := req||' OR(to_date(T.DSDCN,''YYYYMMDD'') between TO_DATE('''||w_moi_retour||''', ''YYYYMM'') and last_day(to_date('''||w_moi_retour||''',''YYYYMM''))AND NVL(TO_DATE(T.DSFCN,''YYYYMMDD''),to_date(''20991231'',''YYYYMMDD''))>= last_day(to_date('''||w_moi_retour||''',''YYYYMM'')))';
                req              := req||' OR (to_date(T.DSDCN,''YYYYMMDD'') <=last_day(to_date('''||w_moi_retour||''',''YYYYMM''))AND  T.DSFCN IS  NULL)';
                req              := req||') ';
                req              := req ||') ';
                req              := req ||' when MATCHED THEN UPDATE  set ' ;
                req              := req ||clupdSecu;
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 SECUPACMAT='|| substr(req,0,3600));
                EXECUTE IMMEDIATE req USING p_id,
                tab_numLigne00(i),
                tab_numLigne99(i);
              END IF;
            END IF;
            -- lancer la requete trace
            reqTrace := REPLACE('INSERT INTO SYS_TRC_MODIF 
SELECT DISTINCT ''RETOUR_PAIE'', 
CURRENT_TIMESTAMP, 
3, 
''Retour de paie type AVPERS'', 
''numpac='' || tge.numpac || ''&' || w_colonne_30 || '='' || nvl(tge.' || w_colonne_30 || ',tge.paiezad) || ''&PERIODEPAIE='' || TO_DATE(''' || w_moi_retour || '01'', ''YYYYMMDD'') || ''&ELEMENT='' || tge.code_element || ''&VALEUR='' || tge.valeur, 
''Retour de paie'', 
''M'', 
null, 
null, 
null, 
null ,
tge.numpac,
tge.pacmat,
tge.PAIEZAD,
tge.MATRICULE,
tge.DATE_EFFET 
FROM TGE_IMPORT_FSED_30 TGE 

WHERE ID_TRT = :id AND tablegxp='''||w_table ||'''  AND ( numligne >=:ligne0 AND numligne <= :ligne99) and TGE.numpac=a.numpac', 'a.', 'TGE.' );
            FSED_AVANCEMENT(p_id,' SYS_TRC_MODIF= '|| substr(reqTrace,0,3600));
            EXECUTE IMMEDIATE reqTrace USING p_id,
            tab_numLigne00(i),
            tab_numLigne99(i);
            reqTrace :=null;
            -- Table M7
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='M7' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  M7 ');
           req                    := 'MERGE INTO ' || w_table ||' t USING ' ||
              '(SELECT * FROM ' || 
              '(SELECT ID_TRT, ' || 
              'NUMPAC, ' || 
              'PAIEZAD, ' || 
              'PACMAT, ' || 
              'MATRICULE, ' || 
              'DONNEEGXP, ' || 
              'VALEUR, ' || 
              'TO_DATE(SUBSTR(INDICATIF, 1, 6) || ''01'', ''YYYYMMDD'') AS ' || w_date_eff || ', ' || 
              'NUMPAC || NVL(PACMAT, PAIEZAD) AS IDPACMAT ' || 
              'FROM TGE_IMPORT_FSED_30 ' || 
              'WHERE ID_TRT = :id  AND TABLEGXP = ''' || w_table ||''' AND (NUMLIGNE >= :ligne0 AND NUMLIGNE <= :ligne99) AND NUMPAC = ''' || w_numpac || '''' || 
              ') PIVOT(MAX(VALEUR) FOR DONNEEGXP IN (' || clssreqPivotMerge || '))' || 
              ') i ' || 
              'ON (t.NUMPAC = i.NUMPAC AND t.PAIEZAD = i.PAIEZAD AND t.' || w_date_eff || ' = i.' || w_date_eff || ') ' || 
              'WHEN MATCHED THEN ';
            req                    := req || 'UPDATE SET ' ;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'', ';
            END IF;
            req                    := req ||clupdateMerge;
            req                    := req ||',DATE_DERNIERE_MODIF=sysdate ';
            req                    := req ||' when NOT MATCHED THEN ';
            req                    := req ||' INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||clinsertDonMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',type_writer';
            END IF;
            req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||', ';
            req                    := req || clinsertValMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',''N''';
            END IF;
            req := req ||' )';
            ---TABLE M1
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='M1' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  M1 ');
            IF w_type_retour ='RC' THEN
              reqRc         := 'select min ('||w_date_eff||') from '||w_table ||' WHERE numpac =:numpac and paiezad in (select distinct paiezad from TGE_IMPORT_FSED_30 where id_trt = :id )';
              EXECUTE immediate reqRC INTO w_date_RC USING w_numpac,
              p_id;
            END IF ;
            req                    := 'MERGE INTO '||w_table ||' T USING ';
            req                    := req ||'(select tge.*, ';
            req                    := req ||'TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
            req                    := req ||'as '||w_date_eff||', ';
            req                    := req ||'numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
            req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
            req                    := req ||':id  AND tablegxp='''||w_table ||''' ';
            req                    := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||''' ';
            req                    := req || reqChrono;
            req                    := req ||') pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
            req                    := req ||')) )tge)  i';
            req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad AND T.'||w_date_eff||'=i.'||w_date_eff||') ';
            req                    := req ||' when MATCHED THEN ' ;
            req                    := req ||' UPDATE  set ' ;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'', ';
            END IF;
            req                      := req ||clupdateMerge;
            req                      := req ||',DATE_DERNIERE_MODIF=sysdate ';
            IF w_type_retour          ='RN' OR (w_type_retour ='RC' AND (w_date_RC < TO_DATE(w_moi_retour||'01','YYYYMMDD'))OR w_date_RC is null) THEN
              req                    := req ||' when NOT MATCHED THEN ' ;
              req                    := req ||' INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||clinsertDonMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',type_writer';
              END IF;
              req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||', ';
              req                    := req ||clinsertValMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',''N''';
              END IF;
              req := req ||')';
            END IF ;
            ---TABLE M9
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='M9' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  M9 ');
            IF w_type_retour ='RC' THEN
              reqRc         := 'select min ('||w_date_eff||') from '||w_table ||' WHERE numpac =:numpac and paiezad in (select distinct paiezad from TGE_IMPORT_FSED_30 where id_trt = :id )';
              EXECUTE immediate reqRC INTO w_date_RC USING w_numpac,
              p_id;
            END IF;
            req                    := 'MERGE INTO '||w_table ||' T USING ';
            req                    := req ||'(select tge.*';
            req                    := req ||', TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
            req                    := req ||'as '||w_date_eff;
            req                    := req ||', numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
            req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp  ,valeur from tge_import_FSED_30 where ID_TRT= ' ;
            req                    := req ||':id  AND tablegxp='''||w_table ||''' ';
            req                    := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||''' ';
            req                    := req || reqChrono;
            req                    := req ||') pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
            req                    := req ||')) )tge)  i';
            req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad AND T.'||w_date_eff||'=i.'||w_date_eff||') ';
            req                    := req ||' when MATCHED THEN ' ;
            req                    := req ||' UPDATE  set ' ;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'', ';
            END IF;
            req                      := req ||clupdateMerge;
            req                      := req ||',DATE_DERNIERE_MODIF=sysdate ';
            IF w_type_retour          ='RN' OR (w_type_retour ='RC' AND ( w_date_RC < TO_DATE(w_moi_retour||'01','YYYYMMDD'))OR w_date_RC IS NULL) THEN
              req                    := req ||' when NOT MATCHED THEN ' ;
              req                    := req ||' INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||clinsertDonMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',type_writer';
              END IF;
              req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||', ';
              req                    := req || clinsertValMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',''N''';
              END IF;
              req := req ||')';
            END IF;
            ---Table M3ANNEE
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='M3ANNEE' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  M3ANNEE ');
            IF w_type_retour ='RC' THEN
              reqRc         := 'select min ('||w_date_eff||') from '||w_table ||' WHERE numpac =:numpac and paiezad in (select distinct paiezad from TGE_IMPORT_FSED_30 where id_trt = :id )';
              EXECUTE immediate reqRC INTO w_date_RC USING w_numpac,
              p_id;
            END IF;
            req                    := 'MERGE INTO '||w_table ||' T USING ';
            req                    := req ||'(select tge.*, ';
            req                    := req ||'TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
            req                    := req ||'as '||w_date_eff||', ';
            req                    := req ||'NVL(substr(indicatif,1,3),0) as '||w_code_caisse||',';
            req                    := req ||'numpac||nvl(tge.pacmat,'||w_colonne_30||')as idPACMAT';
            req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp, indicatif  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
            req                    := req ||':id  AND tablegxp='''||w_table ||''' ';
            req                    := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||''' ';
            req                    := req || reqChrono;
            req                    := req ||') pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
            req                    := req ||')) )tge)  i';
            req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad AND T.'||w_code_caisse||'=i.'||w_code_caisse||' AND i.'||w_date_eff||'= T.'||w_date_eff||') ';
            req                    := req ||' when MATCHED THEN ' ;
            req                    := req ||' UPDATE  set ' ;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'', ';
            END IF;
            req                      := req ||clupdateMerge;
            req                      := req ||',DATE_DERNIERE_MODIF=sysdate ';
            IF w_type_retour          ='RN' OR (w_type_retour ='RC' AND (w_date_RC < TO_DATE(w_moi_retour||'01','YYYYMMDD'))OR w_date_RC is null ) THEN
              req                    := req ||' when NOT MATCHED THEN ' ;
              req                    := req ||' INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||w_code_caisse||','||clinsertDonMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',type_writer';
              END IF;
              req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||',i.'||w_code_caisse||', ';
              req                    := req || clinsertValMerge;
              IF objtable.ALLERRETOUR ='2' THEN
                req                  := req ||',''N''';
              END IF;
              req := req ||')';
            END IF;
            ---Table M3MOIS
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE ='M3MOIS' THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  M3MOIS ');
            req                    := 'MERGE INTO '||w_table ||' T USING ';
            req                    := req ||'(select tge.*,';
            req                    := req ||'TO_DATE(replace ('||w_moi_retour||',SUBSTR('||w_moi_retour||',5,2),substr(indicatif,1,2))'||'||''01'''||',''YYYYMMDD'')';
            req                    := req ||'as '||w_date_eff;
            req                    := req ||',substr(indicatif,4,3) as '||w_code_caisse||',';
            req                    := req ||'numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
            req                    := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp,indicatif  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
            req                    := req ||':id  AND tablegxp='''||w_table ||''' ';
            req                    := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||''' ';
            req                    := req || reqChrono;
            req                    := req ||' ) pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
            req                    := req ||')) )tge )  i';
            req                    := req ||' on ( T.numpac=i.numpac and T.paiezad =i.paiezad AND T.'||w_code_caisse||'=i.'||w_code_caisse||' AND i.'||w_date_eff||'= T.'||w_date_eff||') ';
            req                    := req ||' when MATCHED THEN ' ;
            req                    := req ||' UPDATE  set ';
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'',';
            END IF;
            req                    := req ||clupdateMerge;
            req                    := req ||',DATE_DERNIERE_MODIF=sysdate ';
            req                    := req ||' when NOT MATCHED THEN ' ;
            req                    := req ||' INSERT (numpac,pacmat,MATRIC,DATE_CREATION,paiezad,'||w_date_eff||','||w_code_caisse||','||clinsertDonMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',type_writer';
            END IF;
            req                    := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,i.PAIEZAD,i.'||w_DATE_EFF||',i.'||w_code_caisse||', ';
            req                    := req || clinsertValMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',''N''';
            END IF;
            req := req ||')';
            ---Tables MULTIPLE et OCCURS
          ELSIF clssreqPivotMerge IS NOT NULL AND objtable.TABLETYPE IN ('MULTIPLE','OCCURS') THEN
            FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Début  '||objtable.TABLETYPE);
            req              := 'MERGE INTO '||w_table ||' T USING ';
            req              := req ||'(select TGE.*';
            IF w_code_caisse IS NOT NULL THEN
              req            := req ||',substr(indicatif,1,3) as '||w_code_caisse;
            END IF ;
            req := req ||',numpac||nvl(tge.pacmat,'||w_colonne_30||') as idPACMAT';
            IF p_table IN ('DIC_TGE_PRETS','DIC_TGE_OPPOSITIONS') THEN 
            req := req ||' FROM (select * from (select id_trt,numpac,pacmat,MATRICULE, donneegxp,indicatif  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
            ELSE
            req := req ||' FROM (select * from (select id_trt,numpac, paiezad,pacmat,MATRICULE, donneegxp,indicatif  ,valeur from tge_import_FSED_30  where ID_TRT= ' ;
            END IF;
            req := req ||':id  AND tablegxp='''||w_table ||''' ';
            req := req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99) AND numpac='''||w_numpac||'''  ';
            req := req || reqChrono;
            req := req ||' ) pivot(max(valeur) for donneegxp in ('||clssreqPivotMerge;
            req := req ||')) )tge)  i';
            req := req ||' on ( T.numpac=i.numpac ';
            IF w_table NOT IN ('DIC_TGE_PRETS','DIC_TGE_OPPOSITIONS') THEN
              req := req ||' and T.paiezad =i.paiezad ';
            ELSE
              req := req ||' and T.pacmat =i.pacmat ';
            END IF;
            req             := req ||'  and i.'||w_code_caisse||'=t.'||w_code_caisse;
            IF w_type_retour ='RC' THEN
              req           := req ||' AND T.PACMAT NOT IN (SELECT PACMAT FROM GAP_TRT_LISTE_MAT_HISTO G WHERE G.NUMPAC=T.NUMPAC AND G.PERIODE_PAIE = '''||w_moi_retour||''' AND SUBSTR(TO_CHAR(G.DATE_RESP,''YYYYMMDD''),5,2)<= '||SUBSTR(w_moi_retour,5,2)||')';
            END IF;
            req                    := req ||') ';
            req                    := req ||' when MATCHED THEN UPDATE  set ' ;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||'type_writer=''N'', ';
            END IF;
            req := req ||clupdateMerge;
            req := req ||',DATE_DERNIERE_MODIF=sysdate ';
            req := req ||' when NOT MATCHED THEN INSERT (numpac,pacmat,MATRIC,DATE_CREATION,';
            IF w_table NOT IN ('DIC_TGE_PRETS','DIC_TGE_OPPOSITIONS') THEN
              req := req ||' PAIEZAD,';
            END IF;
            IF w_code_caisse IS NOT NULL THEN
              req            := req ||w_code_caisse||',';
            END IF ;
            req                    := req ||clinsertDonMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',type_writer';
            END IF;
            req := req ||') VALUES (i.numpac,i.pacmat,i.MATRICULE,sysdate,';
            IF w_table NOT IN ('DIC_TGE_PRETS','DIC_TGE_OPPOSITIONS') THEN
              req := req ||'  i.PAIEZAD,';
            END IF;
            IF w_code_caisse IS NOT NULL THEN
              req            := req ||'i.'||w_code_caisse||',';
            END IF ;
            req                    := req || clinsertValMerge;
            IF objtable.ALLERRETOUR ='2' THEN
              req                  := req ||',''N''';
            END IF;
            req := req ||')';
          END IF;
          IF req IS NOT NULL THEN
            w_00 :=tab_numLigne00(i);
            w_99 :=tab_numLigne99(i);
            IF objtable.TABLETYPE IN('H2','M7') THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';Ligne00='||tab_numLigne00(i)||';Ligne99='||tab_numLigne99(i)||'='|| substr(req,0,3600));
              EXECUTE IMMEDIATE req USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i);
              IF reqUdpateDate IS NOT NULL THEN
                FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';Ligne00='||tab_numLigne00(i)||';Ligne99='||tab_numLigne99(i)||'='|| substr(reqUdpateDate,0,3600));
                EXECUTE IMMEDIATE reqUdpateDate USING p_id,
                tab_numLigne00(i),
                tab_numLigne99(i);
              END IF;
            elsiF objtable.TABLETYPE IN('M1','M3ANNEE') THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';Ligne00='||tab_numLigne00(i)||';Ligne99='||tab_numLigne99(i)||'='|| substr(req,0,3600));
              EXECUTE IMMEDIATE req USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i);
            ELSiF objtable.TABLETYPE <> 'AVPERS' THEN
              FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 p_id='||p_id||';Ligne00='||tab_numLigne00(i)||';Ligne99='||tab_numLigne99(i)||'='|| substr(req,0,3600));
              EXECUTE IMMEDIATE req USING p_id,
              tab_numLigne00(i),
              tab_numLigne99(i) ;
            END IF;
            IF w_table = 'DIC_TGE_RESPAIE_UNIQUE' THEN
              R_PRESENT_FICHIER_PAIE( w_numpac , null );
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
    IF objtable.TABLETYPE ='AVPERS' AND w_table ='DIC_ADM_CONTRAT_HISTO' THEN
      -- insertion dans SECUPACMAT_TMP_CONTRAT
      INSERT
      INTO SECUPACMAT_TMP_CONTRAT
        (
          numpac,
          pacmat
        )
      SELECT DISTINCT numpac,
        NVL(pacmat,paiezad)
      FROM TGE_IMPORT_FSED_30
      WHERE ID_TRT=p_id
      AND numligne BETWEEN tab_numLigne00(i) AND tab_numLigne99(i)
      AND tablegxp=w_table ;
      -- lancement de la procédure ALIM_IDX_CH_RETOUR_PAIE
      ALIM_IDX_CH_RETOUR_PAIE();
      --suppression des matricules de la table SECUPACMAT_TMP_CONTRAT
       EXECUTE_IMMEDIATE_STRING ( 'truncate table SECUPACMAT_TMP_CONTRAT',0);
    END IF;
  END LOOP;
  FOR trig IN
  (SELECT object_name
  FROM user_objects
  WHERE lower(object_type)='trigger'
  AND lower(object_name) LIKE '%'
    ||lower(w_table)
    ||'%'
  AND (lower(object_name) LIKE 'horo%' )
  )
  LOOP
     EXECUTE_IMMEDIATE_STRING  ('ALTER TRIGGER ' || trig.object_name ||' enable ',0);
  END LOOP;
  --Mise à jour des indicateurs de production pour la période traité dans le retour de paie te pour chaque salarié traité.
  req             := 'update GAP_TRT_LISTE_MAT_HISTO ';
  IF w_type_retour ='RN' THEN
    w_date_indic  := to_date(sysdate);
    req           := req ||'set DATE_RESP = :date_effet ';
  END IF;
  IF w_type_retour ='RC' THEN
    SELECT MAX(date_COMP)
    INTO w_date_comp
    FROM GAP_TRT_LISTE_MAT_HISTO
    WHERE numpac     = w_numpac
    AND periode_paie = w_moi_retour
    AND pacmat      IN
      (SELECT DISTINCT pacmat
      --DIT 50818 
      FROM DIC_ADM_CONTRAT_SITU
      WHERE numpac = w_numpac
      AND paiezad IN
        (SELECT DISTINCT paiezad FROM TGE_IMPORT_FSED_30 WHERE id_trt = p_id
        )
      );
    IF w_date_comp  <to_date(sysdate) THEN
      w_date_indic := w_date_comp;
    ELSE
      w_date_indic := to_date(sysdate);
    END IF;
    req:= req ||'set DATE_COMP = :date_effet ';
  END IF ;
  req:= req || ' where NUMPAC = :numpac  and   PERIODE_PAIE = :periode ';
  req:= req || ' and pacmat in (select distinct pacmat from DIC_ADM_CONTRAT_SITU where numpac = : numpac and paiezad in (select distinct paiezad from TGE_IMPORT_FSED_30 where id_trt = :trt) )';
  EXECUTE IMMEDIATE req USING w_date_indic,
  w_numpac,
  w_moi_retour,
  w_numpac,
  p_id;
  --RSI : En cas de RC, il faut regarder si elle est plus vieille que le mois du retour complémentaire.
  IF w_type_retour ='RC' THEN
  --DEBUT M3ANNEE
    IF objtable.TABLETYPE ='M3ANNEE' THEN
      IF tabW580_h.exists(1) THEN
        FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC '||objtable.TABLETYPE );
        FOR i IN tabW580_h.first..tabW580_h.last
        LOOP
          IF SUBSTR(w_moi_retour,5,2)>=tabW580_h(i).donnee_W580_h THEN
            req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
            req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
            req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||';
            req                      := req ||' NVL('''||tabW580_h(i).donnee_W580_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
            req                      := req ||' AND TO_DATE(';
            req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||';
            req                      := req ||' NVL('''||tabW580_h(i).donnee_W580_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364';
            req                      := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
          ELSE
            req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad) ';
            req := req ||' AND '||w_date_eff||' between TO_DATE(';
            req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
            req := req ||' NVL('''||tabW580_h(i).donnee_W580_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
            req := req ||' AND TO_DATE(';
            req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
            req := req ||' NVL('''||tabW580_h(i).donnee_W580_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364';
            req := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
          END IF;
          FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC req='||substr(req,0,3700));
          EXECUTE IMMEDIATE req USING p_id;
        END LOOP;
      ELSE
        IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
          req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
          req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
          req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
          req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
          req                      := req ||' AND TO_DATE(';
          req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
          req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')+364';
          req                      := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
        ELSE
          req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
          req := req ||' AND '||w_date_eff||' between TO_DATE(';
          req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||''';
          req := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
          req := req ||' AND TO_DATE(';
          req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
          req := req ||objtable.MOISZERO||'||''01'''||',''YYYYMMDD'')+364';
          req := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
        END IF ;
        FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC req='||substr(req,0,3700));
        EXECUTE IMMEDIATE req USING p_id;
        req:='';
      END IF;
    END IF;
  -- Fin M3ANNEE
  --DEBUT M1
  IF objtable.TABLETYPE = 'M1' THEN
      IF tabWL52_h.exists(1) THEN
        FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC '||objtable.TABLETYPE );
        FOR i IN tabWL52_h.first..tabWL52_h.last
        LOOP
          IF SUBSTR(w_moi_retour,5,2)>=tabWL52_h(i).donnee_WL52_h THEN
            req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
            req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
            req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||';
            req                      := req ||' NVL('''||tabWL52_h(i).donnee_WL52_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
            req                      := req ||' AND TO_DATE(';
            req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||';
            req                      := req ||' NVL('''||tabWL52_h(i).donnee_WL52_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364';
            req                      := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
          ELSE
            req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad) ';
            req := req ||' AND '||w_date_eff||' between TO_DATE(';
            req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
            req := req ||' NVL('''||tabWL52_h(i).donnee_WL52_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')';
            req := req ||' AND TO_DATE(';
            req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
            req := req ||' NVL('''||tabWL52_h(i).donnee_WL52_h||''','''||objtable.MOISZERO||''')'||'||''01'''||',''YYYYMMDD'')+364';
            req := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
          END IF;
          FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC req='||substr(req,0,3700));
          EXECUTE IMMEDIATE req USING p_id;
        END LOOP;
      ELSE
        IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
          req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
          req                      := req ||' AND '||w_date_eff||' between TO_DATE(';
          req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
          req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
          req                      := req ||' AND TO_DATE(';
          req                      := req ||' SUBSTR('||w_moi_retour||',1,4)||''';
          req                      := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')+364';
          req                      := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
        ELSE
          req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) ';
          req := req ||' AND '||w_date_eff||' between TO_DATE(';
          req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||''';
          req := req ||objtable.MOISZERO||'''||''01'''||',''YYYYMMDD'')';
          req := req ||' AND TO_DATE(';
          req := req ||' (SUBSTR('||w_moi_retour||',1,4)-1)||';
          req := req ||objtable.MOISZERO||'||''01'''||',''YYYYMMDD'')+364';
          req := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
        END IF ;
        FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC req='||substr(req,0,3700));
        EXECUTE IMMEDIATE req USING p_id;
        req:='';
      END IF;
    END IF;
  --FIN M1
  
    IF objtable.TABLETYPE ='M9' THEN
      FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC M9');
      IF SUBSTR(w_moi_retour,5,2)>=objtable.MOISZERO THEN
        req                      := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) AND '||w_date_eff||' between TO_DATE(SUBSTR('||w_moi_retour||',1,4)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'') and (TO_DATE(SUBSTR('||w_moi_retour||',1,4)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'')+364) ';
      ELSE
        req := ' delete from  '||w_table ||' T where numpac ='''||w_numpac||''' AND  EXISTS (select 1 from TGE_IMPORT_FSED_30 where id_trt = :id and TGE_IMPORT_FSED_30.paiezad=T.paiezad ) AND '||w_date_eff||' between TO_DATE((SUBSTR('||w_moi_retour||',1,4)-1)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'') and (TO_DATE((SUBSTR('||w_moi_retour||',1,4)-1)||'''||objtable.MOISZERO||'''||''01'',''YYYYMMDD'')+364)';
      END IF;
      req := req ||' AND '||w_date_eff||' < TO_DATE('||w_moi_retour||'||''01'''||',''YYYYMMDD'')';
      FSED_AVANCEMENT(p_id,'FSED.sous_insertCart30 Delete RC req='||substr(req,0,3700));
      EXECUTE IMMEDIATE req USING p_id;
      req:='';
    END IF;
  END IF;
  v_stop := DBMS_UTILITY.GET_TIME;
  tab_numLigne00.delete;
  tab_numLigne99.delete;
  IF p_table ='DIC_ADM_CONTRAT_HISTO' THEN
    COMMIT;
    FSED_AVANCEMENT(p_id,'MAJ_DATE_FIN_CONTRAT_HISTO ');
    MAJ_DATE_FIN_CONTRAT_HISTO();
    COMMIT;
    FSED_AVANCEMENT(p_id,'R_DATE_FIN_BO_CONTRAT_HISTO');
    R_DATE_FIN_BO_CONTRAT_HISTO();
    FSED_AVANCEMENT(p_id,'R_DATE_SORTIE_SIT_BO_CNT_HISTO');
    R_DATE_SORTIE_SIT_BO_CNT_HISTO();
    FSED_AVANCEMENT(p_id,'Fin R_DATE_SORTIE_SIT_BO_CNT_HISTO');
  END IF;
  COMMIT;
  --gestion du trigger des DACH : suppression de la table temporaire BYPASS_TRG_DACH_ON_SESSION
  DELETE FROM BYPASS_TRG_DACH_ON_SESSION;
   EXECUTE_IMMEDIATE_STRING ('truncate table TGE_FSED_30_TEMPORARY',0);
EXCEPTION
WHEN OTHERS THEN
  --gestion du trigger des DACH : suppression de la table temporaire BYPASS_TRG_DACH_ON_SESSION
  DELETE FROM BYPASS_TRG_DACH_ON_SESSION;
   EXECUTE_IMMEDIATE_STRING ('truncate table TGE_FSED_30_TEMPORARY',0);
  err_code := SQLCODE;
  err_msg  := err_msg||' '||SQLERRM;
 IF reqTrace is not null then
    FSED_ERREUR(p_id , 'Trace SYS_TRC_MODIF ',p_id || ',' || p_newId || ',' || p_table, err_code || '-' || err_msg||' requete :'||req );
 END IF;
  FSED_ERREUR(p_id , 'insertCart30 '||p_table||' ' || w_elem, p_id || ',' || p_newId || ',' || p_table, err_code || '-' || err_msg||' requete :'||req );
  raise_application_error(-20000, 'FSED insertCart30  '|| sqlerrm||' w_00 :'||w_00||'w_99 :'||w_99||'elem :'||w_elem||'occur'||w_occ);
END sous_insertCart30;
/********************************************************************
PROC : insertCart30(p_id    IN NUMBER,
p_newId IN NUMBER,
p_table IN VARCHAR2 )
DESC : Procedure de lancement de retour de paie pour les cartes 30
*********************************************************************/
PROCEDURE insertCart30(
    p_id    IN NUMBER ,
    p_newId IN NUMBER ,
    p_table IN VARCHAR2) parallel_enable
IS
  jobno NUMBER;
BEGIN
  dbms_job.submit(jobno, 'sous_insertCart30('||p_id||','||p_newid||','||p_table||');',sysdate, NULL);
END insertCart30;
/*****************************************************************************
PROC : getPeriodeReceuil(p_numpac  in     TGE_REF_PAC.numpac%type,
p_paiezad in     TGE_IMPORT_FSED_30.paiezad%type,
p_dateDeb in out DATE,
p_dateFin in out DATE)
DESC : retourne la date debut et fin de la periode de recueil
TEST : getPeriodeReceuil('TLSE01','0001492')-->(2010-01-01,2014-02-02)
*******************************************************************************/
PROCEDURE getPeriodeRecueil(
    p_numpac  IN TGE_REF_PAC.numpac%type,
    p_paiezad IN TGE_IMPORT_FSED_30.paiezad%type,
    p_dateDeb IN OUT DATE,
    p_dateFin IN OUT DATE)
IS
  w_dsdcn DIC_ADM_CONTRAT.dsdcn%TYPE;
  w_dsfcn DIC_ADM_CONTRAT.dsfcn%TYPE;
  w_dr DATE;
  w_fr DATE;
  w_periodeEnCours tge_ref_pac.periodeencours%TYPE;
  w_doneegxpFin TGE_REF_MAPDO.donneegxp%type;
  w_doneegxpDeb TGE_REF_MAPDO.donneegxp%type;
  w_req CLOB;
  w_pacmat DIC_ADM_CONTRAT_SITU.pacmat%type;--DIT 50818 
BEGIN
  SELECT pacmat
  INTO w_pacmat
  FROM DIC_ADM_CONTRAT_SITU --DIT 50818 
  WHERE numpac =p_numpac
  AND paiezad  = p_paiezad
  AND rownum   =1 ;
  BEGIN
    SELECT POP.DSDCN,
      POP.DSFCN,
      CASE
        WHEN R.DATE_DEBUT_1 IS NOT NULL
        THEN R.DATE_DEBUT_1
        ELSE L.DEBUT_PERIODE
      END AS DT_RECUEIL_DEB,
      CASE
        WHEN R.DATE_FIN_1 IS NOT NULL
        THEN R.DATE_FIN_1
        ELSE L.FIN_PERIODE
      END AS DT_RECUEIL_FIN,
      POP.PERIODEENCOURS
    INTO w_dsdcn,
      w_dsfcn,
      p_dateDeb,
      p_dateFin,
      w_periodeEnCours
    FROM
      (SELECT C.NUMPAC,
        S.paiezad,--DIT 50818 
        c.pacmat,
        P.PERIODEENCOURS,
        C.DSDCN AS DSDCN,
        C.DSFCN AS DSFCN
      FROM DIC_ADM_CONTRAT C,
        DIC_ADM_CONTRAT_SITU S,--DIT 50818 
        TGE_REF_PAC P
      WHERE C.NUMPAC = P.NUMPAC
      AND C.NUMPAC   = S.NUMPAC
      AND C.PACMAT   = S.PACMAT
      AND C.NUMCNT   = S.NUMCNT
      AND C.NUMPAC   = p_numpac
      AND S.PAIEZAD  = p_paiezad--DIT 50818 
      ) POP ,
      SECUPACMAT S ,
      DIC_TGE_PERIODES_RECUEIL R ,
      TGE_REF_LTP L
    WHERE POP.NUMPAC       = S.NUMPAC
    AND POP.PACMAT         = S.PACMAT
    AND POP.NUMPAC         = L.NUMPAC
    AND POP.PERIODEENCOURS = L.MOIS_PAIE
    AND POP.PAIEZAD        = R.PAIEZAD(+)
    AND POP.NUMPAC         = R.NUMPAC(+)
    AND rownum             = 1 ;
  EXCEPTION
  WHEN OTHERS THEN
    err_msg := SQLERRM;
  END;
  SELECT m.donneegxp
  INTO w_doneegxpDeb
  FROM TGE_REF_MAPDO M
  WHERE ( ELEMENT = 'A275' )
  AND ( ( (SELECT COUNT(*)
    FROM TGE_REF_MAPDO
    WHERE NUMPAC=p_numpac
    AND ELEMENT = M.ELEMENT) > 0
  AND M.NUMPAC  = 'TLSE01' )
  OR ( (SELECT COUNT(*)
    FROM TGE_REF_MAPDO
    WHERE NUMPAC=p_numpac
    AND ELEMENT = M.ELEMENT) = 0
  AND M.NUMPAC  ='*' ) );
  SELECT m.donneegxp
  INTO w_doneegxpFin
  FROM TGE_REF_MAPDO M
  WHERE ( ELEMENT = 'A309' )
  AND ( ( (SELECT COUNT(*)
    FROM TGE_REF_MAPDO
    WHERE NUMPAC=p_numpac
    AND ELEMENT = M.ELEMENT) > 0
  AND M.NUMPAC  = 'TLSE01' )
  OR ( (SELECT COUNT(*)
    FROM TGE_REF_MAPDO
    WHERE NUMPAC    =p_numpac
    AND ELEMENT     = M.ELEMENT) = 0
  AND M.NUMPAC      ='*' ) );
  IF w_doneegxpDeb IS NOT NULL AND w_doneegxpFin IS NOT NULL THEN
    w_req          := 'select distinct '||w_doneegxpDeb||','||w_doneegxpFin ||' from DIC_ADM_CONTRAT_HISTO where numpac = :numpac and pacmat= :pacmat and DATE_EFF <= :dateeff ';
    EXECUTE immediate w_req INTO w_dr,
    w_fr USING p_numpac,
    w_pacmat,
    last_day(to_date(w_periodeencours,'YYYYMM'));
  END IF;
  IF p_dateDeb >w_dr AND w_dr <p_dateFin THEN
    p_dateDeb := w_dr ;
  END IF ;
  IF w_fr      > to_date(w_periodeencours,'YYYYMM') AND w_fr < last_day(to_date(w_periodeencours,'YYYYMM')) THEN
    p_dateFin := w_fr;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_msg := SQLERRM;
END getPeriodeRecueil;
/*************************************************************************************************************************************
PROC :  maj_CAD30   (p_id IN NUMBER)
DESC :  Procedure de mise à jour des compteurs aprés retour de paie
TEST :  cad_compteur          : code_compteur in ('CPO','CRTT') and matricule in ('0001494','0001492','0001498','0001576','0001510')
TGE_REF_MAPDO         : TRTPARTICULIER like 'CAD=%' and ELEMENT IN ('I001','I002','I005','J003','T301','T303')
DIC_ADM_CONTRAT       : matric in ('0001494','0001492','0001498','0001576','0001510') and NUMPAC ='TLSE01'
DIC_ADM_CONTRAT_HISTO : pacmat in ('00001492','00001494','00001498','00001510','00001576') and numpac ='TLSE01'
TGE_IMPORT_FSED_30    : code_element in ('I001','I002','I005','T301','T303','J003') and id_trt =2576
CAD.CAD_unite_cpt('0001510','20130101','CPO') -->'U'
CAD.CAD_unite_cpt('0001498','20130101','CPO') -->NULL
CAD.CAD_unite_cpt('0001576','20130101','CPO') -->NULL
CAD.CAD_unite_cpt('0001498','20130101','CRTT')-->'U'
CAD.CAD_unite_cpt('0001492','20130101','CRTT')-->'U'
CAD.CAD_unite_cpt('0001494','20130101','CRTT')-->'U'
CAD.CAD_unite_cpt('0001510','20130101','CRTT')-->'U'
***************************************************************************************************************************************/
PROCEDURE maj_CAD30(
    p_id IN NUMBER)
IS
  CURSOR cur_element ( pnumpac IN VARCHAR2)
  IS
    SELECT DISTINCT DO.ELEMENT,
      do.TRTPARTICULIER ,
      imp.paiezad,
      imp.pacmat
    FROM
      (SELECT *
      FROM TGE_REF_MAPDO
      WHERE numpac= pnumpac
      AND TRTPARTICULIER LIKE 'CAD=%'
    UNION ALL
    SELECT *
    FROM TGE_REF_MAPDO
    WHERE numpac     ='*'
    AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=pnumpac
      )
    AND TRTPARTICULIER LIKE 'CAD=%'
      ) DO ,
      tge_import_fsed_30 imp
    WHERE id_trt        = p_id
    AND imp.code_element= do.element
    ORDER BY DO.ELEMENT;
    w_cad CAD_COMPTEUR.CODE_COMPTEUR%TYPE;
    w_pot CAD_COMPTEUR.POT1_FJ%TYPE;
    w_cad_temp  VARCHAR2(11);
    w_pot_temp  VARCHAR2(11);
    w_type_date VARCHAR2(11);
    w_req_maj CLOB;
    w_req CLOB;
    w_seq      NUMBER;
    w_unit     VARCHAR2(1);
    w_cadCount NUMBER := 1;
    w_numpac TGE_REF_PAC.NUMPAC%TYPE;
    w_periode    DATE;
    w_dateDed    DATE;
    w_dateFin    DATE;
    w_moi_retour NUMBER;
    w_matric     DIC_ADM_CONTRAT_SITU.matric%type;--DIT 50818 
    w_dateCalcul  DATE;
    w_matricCount NUMBER :=1;
    obj_cad CAD_DATEVALID;
    tab_DATEVALID TAB_CAD_DATEVALID;
    w_datevalidCount NUMBER :=1;
    w_num number;
    w_num2 number;
    W_IS_T1_LIKE_DECIDIUM SYS_VARSYS.VALVAR%TYPE;
    w_DSDSC DIC_ADM_CONTRAT_SITU.DSDSC%TYPE;
  TYPE t_cad
IS
  TABLE OF VARCHAR2(5) INDEX BY VARCHAR2(2) ;
TYPE t_matric
IS
  TABLE OF VARCHAR2(32) INDEX BY VARCHAR2(2) ;
  tab_cad TAB_SMALLVARCHAR;
  tab_matric TAB_SMALLVARCHAR; 
BEGIN
  FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 début');
  ---Sélection des éléments liés à des compteurs
  --T1 LIKE DECIDECIDIUM 
  BEGIN 
  SELECT upper(NVL(VALVAR,'FALSE'))
  INTO W_IS_T1_LIKE_DECIDIUM
  FROM SYS_VARSYS 
  WHERE codvar='IS_T1_LIKE_DECIDIUM'
  AND MODULE='GTA';
  Exception 
   WHEN OTHERS THEN 
   W_IS_T1_LIKE_DECIDIUM :='FALSE';
    FSED_AVANCEMENT(p_id,'Warning : la varsys IS_T1_LIKE_DECIDIUM n existe pas ');
  END;
  getNumLigne(p_id);
  FOR i IN tab_numLigne00.first..tab_numLigne00.last
  LOOP
    IF i            <=tab_numLigne99.count AND tab_numLigne99(i) IS NOT NULL THEN
      w_numpac      := GET_NUMPAC(p_id,tab_numLigne00(i));
      w_moi_retour  := GET_PERIODE_00(p_id,tab_numLigne00(i));
      tab_DATEVALID := TAB_CAD_DATEVALID();
      tab_cad       := TAB_SMALLVARCHAR();
      tab_matric    := TAB_SMALLVARCHAR();
      FOR C IN cur_element(w_numpac)
      LOOP
        FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 loop '||C.TRTPARTICULIER||'  '||'paiezad'||C.paiezad);
        w_cad_temp  := SUBSTR(C.TRTPARTICULIER,1,instr(C.TRTPARTICULIER,',')-1);
        w_cad       := SUBSTR(w_cad_temp,instr(w_cad_temp,'=')              +1,LENGTH(w_cad_temp));
        w_pot_temp  := SUBSTR(C.TRTPARTICULIER,instr(C.TRTPARTICULIER,',')  +1,LENGTH(C.TRTPARTICULIER));
        w_pot       := NVL(SUBSTR(w_pot_temp,1,instr(w_pot_temp,'F')        -2),NVL(SUBSTR(w_pot_temp,1,instr(w_pot_temp,'D')-2),w_pot_temp));
        w_type_date := NVL(SUBSTR(w_pot_temp,LENGTH(w_pot_temp)             -1,instr(w_pot_temp,'F')),SUBSTR(w_pot_temp,LENGTH(w_pot_temp)-1,instr(w_pot_temp,'D')));
        --T1 LIKE DECIDECIDIUM 
        IF W_IS_T1_LIKE_DECIDIUM ='FALSE' THEN 
        --getPeriodeRecueil(w_numpac,C.paiezad,w_dateDed,w_dateFin);
        FSED_AVANCEMENT(p_id,'Avant :getPeriodeRecueil:paiezad '||C.paiezad||' '||'w_dateDed'||w_dateDed||' '||'w_dateFin'||w_dateFin);
        getPeriodeRecueilEvol(p_id,w_numpac,w_moi_retour,C.paiezad,w_dateDed,w_dateFin);
        FSED_AVANCEMENT(p_id,'Apres :getPeriodeRecueil:paiezad '||C.paiezad||' '||'w_dateDed'||w_dateDed||' '||'w_dateFin'||w_dateFin);
        END IF; 
        IF w_type_date   ='FP' THEN
          w_periode     := LAST_DAY(TO_DATE(w_moi_retour,'YYYYMM'));
        elsif w_type_date='DP' THEN
          w_periode     := TO_DATE(w_moi_retour,'YYYYMM');
        elsif w_type_date='DR' AND W_IS_T1_LIKE_DECIDIUM ='FALSE' THEN
          w_periode     := w_dateDed;
        elsif w_type_date='FR' AND W_IS_T1_LIKE_DECIDIUM ='FALSE' THEN
          w_periode     := w_dateFin ;
        END IF;

        -- on mémorise que ce matricule/compteur a déjà été effacé, il ne faut pas le reeffacer sous peine de perre les compteurs déjà positionnés
        w_req := 'insert into CAD_RETP_MATRIC_CPT_DELETED values (nvl((SELECT DISTINCT MATRIC FROM DIC_ADM_CONTRAT WHERE PAIEZAD = :paiezad AND NUMPAC = :numpac),''INCONNU''),:w_cad)';
        EXECUTE immediate w_req USING C.paiezad,
        w_numpac,
        w_cad;
        commit;
        IF w_cad IS NOT NULL THEN
          tab_cad.extend;
          tab_cad(w_cadCount):= w_cad;
          w_cadCount         := w_cadCount + 1;
        END IF;
        BEGIN
          SELECT DISTINCT matric,DSDSC
          INTO w_matric,w_DSDSC
          FROM DIC_ADM_CONTRAT_SITU
          WHERE numpac =w_numpac
          AND paiezad  =C.paiezad ;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          w_matric := NULL;
        WHEN OTHERS THEN
          err_msg := SQLERRM;
        END;
        IF w_matric IS NOT NULL THEN
          tab_matric.extend;
          tab_matric(w_matricCount) := w_matric;
          w_matricCount             := w_matricCount+1;
          FSED_AVANCEMENT(p_id,'FSED.maj_CAD30: CAD.CAD_UNITE_CPT');
          w_unit     := CAD.CAD_UNITE_CPT(w_matric,TO_CHAR(to_date(w_moi_retour,'YYYYMM'),'YYYYMMDD'),w_cad);
          IF w_unit  IS NOT NULL THEN
            w_req    := 'MERGE INTO CAD_COMPTEUR CA USING ';
            w_req    := w_req ||'(SELECT * from (select  (select distinct c.matric from dic_ADM_CONTRAt c,DIC_ADm_CONTRAT_HISTO h where c.numpac=h.numpac and  c.numpac =:numpac AND c.paiezad =TGE.paiezad and h.ZA996 =''Z'' and c.pacmat =h.pacmat   )';
            w_req    := w_req ||' as MATRICULE ,to_char(to_date('''||w_periode||'''),''YYYYMMDD'') as DJOUR ,';
            w_req    := w_req ||' is_number(TGE.VALEUR) AS ';
            IF w_unit = 'H' THEN
              w_req  := w_req ||' pot'||w_pot||'_FH';
            ELSE
              w_req := w_req ||' pot'||w_pot||'_FJ';
            END IF ;
            w_req   := w_req ||' FROM TGE_IMPORT_FSED_30 TGE  where ID_TRT= :id and code_element= :elt and numpac = :numpac and tge.paiezad = :paiezad';
            w_req   := w_req ||' AND (numligne >=:ligne0 AND numligne <= :ligne99)) where MATRICULE is not null)i ';
            w_req   := w_req ||' ON (CA.MATRICULE =i.MATRICULE AND CA.DJOUR =i.DJOUR AND CA.TYPEMJ =''I'' AND CA.CODE_COMPTEUR = :cad )';
            w_req   := w_req ||' when MATCHED THEN ' ;
            w_req   := w_req ||' UPDATE  set ';
            IF w_unit= 'H' THEN
              w_req := w_req ||' pot'||w_pot||'_FH =(i.pot'||w_pot||'_FH)*3600 ';
            ELSE
              w_req := w_req ||' pot'||w_pot||'_FJ =(i.pot'||w_pot||'_FJ)';
            END IF ;
            w_req   := w_req ||' when NOT MATCHED THEN ' ;
            w_req   := w_req ||' INSERT (MATRICULE, CODE_COMPTEUR, DJOUR,DATE_MAJ, TYPEMJ,';
            IF w_unit= 'H' THEN
              w_req := w_req ||' pot'||w_pot||'_FH)';
            ELSE
              w_req := w_req ||' pot'||w_pot||'_FJ)';
            END IF;
            w_req   := w_req ||'VALUES (i.MATRICULE,'''||w_cad||''',i.DJOUR,sysdate,''I'', ';
            IF w_unit= 'H' THEN
              w_req := w_req ||'(i.pot'||w_pot||'_FH)*3600 )';
            ELSE
              w_req := w_req ||'i.pot'||w_pot||'_FJ)';
            END IF;
            FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Merge : w_cad='||w_cad||' c.paiezad='||c.paiezad ||' C.ELEMENT='||C.ELEMENT||'tab_numLigne00(i)='||tab_numLigne00(i)||'tab_numLigne99(i)='||tab_numLigne99(i)||'substr('||w_req||',0,3600)' );
            EXECUTE IMMEDIATE w_req USING w_numpac,
            p_id,
            C.ELEMENT,
            w_numpac,
            c.paiezad,
            tab_numLigne00(i),
            tab_numLigne99(i),
            w_cad;
          END IF;
        END IF;
        --  creation de l'objet + insertion dans le tableau TAB_CAD_DATEVALID
        FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 insertion dans le tableau TAB_CAD_DATEVALID  paiezad '||c.paiezad||'  '||'dateDeb'||w_dateDed||' w_unit '||w_unit);
        --T1 LIKE DECIDECIDIUM 
        IF W_IS_T1_LIKE_DECIDIUM ='TRUE' THEN 
        w_dateDed := w_periode ;
        END IF;
        IF w_matric IS NOT NULL AND w_dateDed IS NOT NULL AND w_unit IS NOT NULL AND w_cad IS NOT NULL THEN
          Obj_CAD   := NEW CAD_DATEVALID( w_cad, c.element, c.paiezad,w_matric,w_dateDed,w_DSDSC,w_unit);
          tab_DATEVALID.extend;
          tab_DATEVALID(w_datevalidCount):= Obj_CAD ;
          w_datevalidCount               := w_datevalidCount +1;
        END IF;
      END LOOP;
    END IF;
  END LOOP;
  COMMIT;
  FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Insertion des matricules dans CAD_CALCUL_EN_COURS_MATRIC ');
  --- Insertion des matricules dans CAD_CALCUL_EN_COURS_MATRIC avec un nouvel ID :CAD_SEQ_CALCUL.NEXTVAL
  w_seq := CAD_SEQ_CALCUL.NEXTVAL;
  INSERT INTO CAD_CALCUL_EN_COURS_MATRIC
    (ID,MATRICULE
    )
  SELECT DISTINCT w_seq ,
    CAD.MATRIC
  FROM
    (SELECT DISTINCT ta.Matricule AS matric FROM TABLE (tab_DATEVALID) ta
    )CAD ;
  --- Lancement du calcul
  --- si au moin 1 cad par element
  IF w_cadCount >1 THEN
    IF W_IS_T1_LIKE_DECIDIUM ='FALSE' THEN 
    SELECT MIN(i.Periode_Recueil) INTO w_dateCalcul FROM TABLE(tab_DATEVALID) i;
    IF w_dateCalcul >TO_DATE(w_moi_retour,'YYYYMM') THEN
      w_dateCalcul := add_months(TO_DATE(w_moi_retour,'YYYYMM'),-1);
    END IF;
    ELSE 
      w_dateCalcul := add_months(TO_DATE(w_moi_retour,'YYYYMM'),-1);
    END IF; 
    BEGIN
      FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 avant CAD.CAD_MAJ_VALEUR_LISTE_RUBJOUR w_seq='||w_seq||' w_dateCalcul='||w_dateCalcul);
      CAD.CAD_MAJ_VALEUR_LISTE_RUBJOUR(w_seq,TO_CHAR(w_dateCalcul,'YYYYMMDD'),NULL,'true','true');
      FSED_AVANCEMENT(p_id,'FSED.maj_CAD30  après  CAD.CAD_MAJ_VALEUR_LISTE_RUBJOUR');
    EXCEPTION
    WHEN OTHERS THEN
      err_code := SQLCODE;
      err_msg  := SQLERRM;
      FSED_AVANCEMENT(p_id,'FSED.maj_CAD30:ERR:CAD.CAD_MAJ_VALEUR_LISTE_RUBJOUR '||err_code||' '||err_msg);
    END;
  END IF;
  COMMIT;
  --la suppression du passé pour les matricules concernés par le retour
  IF tab_matric.count>=1 AND tab_cad.count>=1 THEN
    w_req:='truncate table TGE_MAJ_30_MATRIC_TEMPORARY';
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Vidage 1 de TGE_MAJ_30_MATRIC_TEMPORARY : '||w_req);
     EXECUTE_IMMEDIATE_STRING  (w_req,0);
    w_req:='truncate table TGE_MAJ_30_CPT_TEMPORARY';
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Vidage 1 de TGE_MAJ_30_CPT_TEMPORARY : '||w_req);
     EXECUTE_IMMEDIATE_STRING ( w_req,0);
    -- insert into temporary table TGE_MAJ_30_MATRIC_TEMPORARY et TGE_MAJ_30_CPT_TEMPORARY 
    FORALL i IN tab_matric.first..tab_matric.last
    INSERT INTO TGE_MAJ_30_MATRIC_TEMPORARY (matricule) values(tab_matric(i));
    FORALL i IN tab_cad.first..tab_cad.last
    INSERT INTO TGE_MAJ_30_CPT_TEMPORARY (CODE_COMPTEUR) values(tab_cad(i));
    select count(*) into w_num from TGE_MAJ_30_MATRIC_TEMPORARY;
    select count(*) into w_num2 from TGE_MAJ_30_cpt_TEMPORARY;
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 insertion temporary nb_matric='||w_num||' nb_cpt= '||w_num2);
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 suppression du passé');
    w_req :=
    'UPDATE CAD_COMPTEUR set pot1_FJ = null , pot1_FH = null ,pot2_FJ = null , pot2_FH = null ,pot3_FJ = null , pot3_FH = null ,pot4_FJ = null , pot4_FH = null, 
pot5_FJ = null , pot5_FH = null ,pot6_FJ = null , pot6_FH = null ,pot7_FJ = null , pot7_FH = null ,pot8_FJ = null , pot8_FH = null, 
pot9_FJ = null , pot9_FH = null ,pot10_FJ = null , pot10_FH = null ,pot11_FJ = null , pot11_FH = null ,pot12_FJ = null , pot12_FH = null , 
POT1_VALEURJ  = null ,POT1_VALEURH  = null ,POT2_VALEURJ  = null ,POT2_VALEURH  = null ,POT3_VALEURJ  = null ,POT3_VALEURH  = null , 
POT4_VALEURJ  = null ,POT4_VALEURH  = null ,POT5_VALEURJ  = null ,POT5_VALEURH  = null ,POT6_VALEURJ  = null ,POT6_VALEURH  = null , 
POT7_VALEURJ  = null ,POT7_VALEURH  = null ,POT8_VALEURJ  = null ,POT8_VALEURH  = null ,POT9_VALEURJ  = null ,POT9_VALEURH  = null , 
POT10_VALEURJ = null ,POT10_VALEURH = null ,POT11_VALEURJ = null ,POT11_VALEURH = null ,POT12_VALEURJ = null ,POT12_VALEURH = null , 
POTV1_VALEURJ = null ,POTV1_VALEURH = null ,POTV2_VALEURJ = null ,POTV2_VALEURH = null ,POTV3_VALEURJ = null ,POTV3_VALEURH = null , 
POTV4_VALEURJ = null ,POTV4_VALEURH = null ,POTV5_VALEURJ = null ,POTV5_VALEURH = null ,POTV6_VALEURJ = null ,POTV6_VALEURH = null '
    ;
    w_req := w_req ||'  where MATRICULE in (select matricule from TGE_MAJ_30_MATRIC_TEMPORARY)';
    w_req := w_req ||' and CODE_COMPTEUR in (select CODE_COMPTEUR from TGE_MAJ_30_CPT_TEMPORARY)';
    w_req := w_req ||' and typeMJ =''I'' and to_date(DJOUR,''YYYYMMDD'') < :periode';
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 req supression :periode='||w_dateCalcul||'w_req : '||w_req);
    EXECUTE immediate w_req USING to_date(w_dateCalcul);
    w_req:='truncate table TGE_MAJ_30_MATRIC_TEMPORARY';
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Vidage 2 de TGE_MAJ_30_MATRIC_TEMPORARY : '||w_req);
     EXECUTE_IMMEDIATE_STRING  (w_req,0);
    w_req:='truncate table TGE_MAJ_30_CPT_TEMPORARY';
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 Vidage 2 de TGE_MAJ_30_CPT_TEMPORARY : '||w_req);
     EXECUTE_IMMEDIATE_STRING  (w_req,0);
  END IF;
  --Mettre à jour CAD_MATRIC_DATE_VALID :update la date de début de validité avec la date de début de recueil de la période suivante:
  IF tab_DATEVALID.count>=1 THEN
   IF W_IS_T1_LIKE_DECIDIUM ='FALSE' THEN 
  FSED_AVANCEMENT(p_id,'FSED.maj_CAD30  loop tab_DATEVALID');
    FOR i IN tab_DATEVALID.first..tab_DATEVALID.last
    LOOP
      UPDATE CAD_MATRIC_DATEVALID a
      SET a.DATE_DEB_PER                   = TO_CHAR(ADD_MONTHS( to_date(tab_DATEVALID(i).Periode_Recueil),1),'YYYYMMDD')
      WHERE a.Matricule                    = tab_DATEVALID(i).Matricule
      AND a.code_compteur                  = tab_DATEVALID(i).Code_Compteur
      AND to_date(a.DATE_EFFET,'YYYYMMDD') =
        (SELECT MAX(to_date(b.date_effet,'YYYYMMDD'))
        FROM cad_matric_datevalid b
        WHERE to_date(b.date_effet,'YYYYMMDD')<= to_date(ADD_MONTHS( to_date(tab_DATEVALID(i).Periode_Recueil),1))
        AND a.code_compteur                    =b.code_compteur
        AND a.matricule                        =b.matricule
        );
    END LOOP;
    ELSE 
    FSED_AVANCEMENT(p_id,'FSED.maj_CAD30  MERGE CAD_MATRIC_DATEVALID');
    merge INTO
    (SELECT MATRICULE,CODE_COMPTEUR,DATE_EFFET,UNITE_TENUE,DATE_DEB_PER,DATE_FIN_PER ,
    DATE_FIN_ACQUIS,DATE_DEB_ACQUIS,MAJ_CONTRAT,VISUHOUJ FROM CAD_MATRIC_DATEVALID ) a
    USING
    (SELECT distinct i.Matricule , i.Code_Compteur,
    to_char(i.DATE_DEBUT,'YYYYMMDD') as DATE_DEB , i.unite FROM TABLE(tab_DATEVALID) i ) b
    ON (a.Matricule =b.Matricule AND a.Code_Compteur=b.Code_Compteur and a.DATE_EFFET=to_char(w_periode,'YYYYMMDD'))
    WHEN NOT matched THEN
    INSERT
    (a.Matricule,a.Code_Compteur,a.DATE_EFFET ,a.UNITE_TENUE,a.DATE_DEB_PER,a.DATE_FIN_PER ,
    a.DATE_FIN_ACQUIS,a.DATE_DEB_ACQUIS,a.MAJ_CONTRAT,a.VISUHOUJ
    --DATE_DEB_PER ,DATE_DEB_ACQUIS = DACS.DSDSC ,MAJ_CONTRAT =N  ,VISUHOUJ ='H' si unite ='H' sinon 'J'
     ) VALUES
     (b.Matricule,b.Code_Compteur,to_char(w_periode,'YYYYMMDD'),b.unite,b.DATE_DEB,'21991231','21991231',b.DATE_DEB,'N',decode(b.unite, 'H', 'H', 'J')
    )
    when matched then
    UPDATE set a.UNITE_TENUE =b.unite ,a.DATE_DEB_PER =b.DATE_DEB ,a.DATE_FIN_PER='21991231' ,
    a.DATE_FIN_ACQUIS='21991231',a.DATE_DEB_ACQUIS=b.DATE_DEB,a.MAJ_CONTRAT='N',a.VISUHOUJ=decode(b.unite, 'H', 'H', 'J');
  END IF;
  END IF;
  FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 premier truncate CAD_RETP_MATRIC_CPT_DELETED');
  w_req:='truncate table CAD_RETP_MATRIC_CPT_DELETED';
   EXECUTE_IMMEDIATE_STRING  (w_req,0);
  FSED_AVANCEMENT(p_id,'maj_CAD30 fin procédure');
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_AVANCEMENT(p_id,'ERR FSED.maj_CAD30 w_cad='||w_cad||'w_req :'||w_req);
  w_req    :='truncate table CAD_RETP_MATRIC_CPT_DELETED';
  FSED_AVANCEMENT(p_id,'FSED.maj_CAD30 second truncate (exception)CAD_RETP_MATRIC_CPT_DELETED' );
   EXECUTE_IMMEDIATE_STRING ( w_req,0);
  FSED_ERREUR( p_id , 'maj_CAD30 ' , NULL, err_code||'-'||err_msg);
  raise_application_error(-20000, 'FSED maj_CAD30  '|| sqlerrm);
END maj_CAD30;
/******************************************************************
PROC : insertData (pNumPac       TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
pCodeTable    TGE_REF_VRREP.CODE_TABLE%TYPE )
DESC :  Insertion dans les tables: TGE_REF_VRREP,TGE_REF_VRDES,
TGE_REF_VRVAL,TGE_REF_RUBRIQUE,TGE_REF_RUBRIQUE_CONTEXTE
TGE_REF_DICOZ
********************************************************************/
PROCEDURE insertData(
    p_id IN NUMBER,
    pNumPac TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
    pCodeTable TGE_REF_VRREP.CODE_TABLE%TYPE )
IS
  v_exist_vrrep NUMBER := 0;
  v_exist_vrdes NUMBER := 0;
BEGIN
 
  IF tab_11R IS NOT NULL THEN
    forall i IN tab_11R.first..tab_11R.last
    INSERT INTO TGE_REF_VRREP VALUES tab_11R
      (i
      );
  END IF;
  IF tab_11D IS NOT NULL THEN
    forall i IN tab_11D.first..tab_11D.last
    INSERT INTO TGE_REF_VRDES VALUES tab_11D
      (i
      );
  END IF;
  IF tab_11D1 IS NOT NULL AND tab_11D1.first > 0 THEN
      forall i IN tab_11D1.first..tab_11D1.last
    --UPDATE TGE_REF_VRDES SET row=tab_11D1(i) WHERE NUMERO_DE_PAC=tab_11D1(i).NUMERO_DE_PAC and CODE_TABLE=tab_11D1(i).CODE_TABLE and NOM_DU_CHAMP=tab_11D1(i).NOM_DU_CHAMP;
    --DIT 76475
    UPDATE TGE_REF_VRDES
    SET MORCEAU_5_NOM_TABLE = tab_11D1(i).MORCEAU_5_NOM_TABLE ,
      MORCEAU_5_COL_DEB     = tab_11D1(i).MORCEAU_5_COL_DEB ,
      MORCEAU_5_COL_FIN     = tab_11D1(i).MORCEAU_5_COL_FIN ,
      MORCEAU_6_NOM_TABLE   = tab_11D1(i).MORCEAU_6_NOM_TABLE ,
      MORCEAU_6_COL_DEB     = tab_11D1(i).MORCEAU_6_COL_DEB ,
      MORCEAU_6_COL_FIN     = tab_11D1(i).MORCEAU_6_COL_FIN ,
      MORCEAU_7_NOM_TABLE   = tab_11D1(i).MORCEAU_7_NOM_TABLE ,
      MORCEAU_7_COL_DEB     = tab_11D1(i).MORCEAU_7_COL_DEB ,
      MORCEAU_7_COL_FIN     = tab_11D1(i).MORCEAU_7_COL_FIN ,
      MORCEAU_8_NOM_TABLE   = tab_11D1(i).MORCEAU_8_NOM_TABLE ,
      MORCEAU_8_COL_DEB     = tab_11D1(i).MORCEAU_8_COL_DEB ,
      MORCEAU_8_COL_FIN     = tab_11D1(i).MORCEAU_8_COL_FIN ,
      MORCEAU_9_NOM_TABLE   = tab_11D1(i).MORCEAU_9_NOM_TABLE ,
      MORCEAU_9_COL_DEB     = tab_11D1(i).MORCEAU_9_COL_DEB ,
      MORCEAU_9_COL_FIN     = tab_11D1(i).MORCEAU_9_COL_FIN
    WHERE NUMERO_DE_PAC     =tab_11D1(i).NUMERO_DE_PAC
    AND CODE_TABLE          =tab_11D1(i).CODE_TABLE
    AND NOM_DU_CHAMP        =tab_11D1(i).NOM_DU_CHAMP;
  END IF;
  IF tab_11V IS NOT NULL THEN
    forall i IN tab_11V.first..tab_11V.last
    INSERT INTO TGE_REF_VRVAL VALUES tab_11V
      (i
      );
  END IF;
  IF tab_15 IS NOT NULL THEN
    forall i IN tab_15.first..tab_15.last
    INSERT INTO TGE_REF_RUBRIQUE VALUES tab_15
      (i
      );
  END IF;
  
  IF tab_15_lib IS NOT NULL and tab_15_lib.exists(1) THEN
   forall i IN tab_15_lib.first..tab_15_lib.last  
     MERGE INTO TGE_REF_LIBRUB_COTIS lib using 
      dual
     on (lib.NUMPAC = tab_15_lib(i).numpac and lib.CODERUB=tab_15_lib(i).coderub and lib.CODECAISSE=tab_15_lib(i).codecaisse)
     when MATCHED THEN 
     UPDATE  set lib.CAISSEREF=tab_15_lib(i).CAISSEREF,
                 lib.LIB_RESOLU=tab_15_lib(i).LIB_RESOLU
     when NOT MATCHED THEN 
     INSERT (NUMPAC,CODERUB,CODECAISSE,CAISSEREF,LIB_RESOLU)
     VALUES (tab_15_lib(i).numpac ,tab_15_lib(i).coderub ,tab_15_lib(i).codecaisse,tab_15_lib(i).CAISSEREF,tab_15_lib(i).LIB_RESOLU);
  END IF;
  IF tab_17CR IS NOT NULL THEN
    forall i IN tab_17CR.first..tab_17CR.last
    INSERT INTO TGE_REF_RUBRIQUE_CONTEXTE VALUES tab_17CR
      (i
      );
  END IF;
  IF tab_17DMF IS NOT NULL THEN
    forall i IN tab_17DMF.first..tab_17DMF.last
    INSERT INTO TGE_REF_DICOZ VALUES tab_17DMF
      (i
      );
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'insertData' , pNumPac||','||pCodeTable , err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED insertion  '|| sqlerrm);
END insertData;
/*****************************************************
PROC : purge_array
DESC :
*****************************************************/
PROCEDURE purge_array
  (
    p_id IN NUMBER
  )
IS
BEGIN
  IF tab_11R IS NOT NULL THEN
    tab_11R.DELETE;
  END IF;
  IF tab_11D IS NOT NULL THEN
    tab_11D.DELETE;
  END IF;
  IF tab_11D1 IS NOT NULL THEN
    tab_11D1.DELETE;
  END IF;
  IF tab_11V IS NOT NULL THEN
    tab_11V.DELETE;
  END IF;
  IF tab_15 IS NOT NULL THEN
    tab_15.DELETE;
  END IF;
  IF tab_15_lib IS NOT NULL THEN
    tab_15_lib.DELETE;
  END IF;
  IF tab_17CR IS NOT NULL THEN
    tab_17CR.DELETE;
  END IF;
  IF tab_17DMF IS NOT NULL THEN
    tab_17DMF.DELETE;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'purge_array' , NULL , err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED purge array  '|| sqlerrm);
END purge_array;
/*********************************************************************
PROC : purge_table (pNumPac       TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
pCodeTable    TGE_REF_VRREP.Code_TABLE%TYPE)
DESC : purge table
**********************************************************************/
PROCEDURE purge_table
  (
    p_id IN NUMBER,
    pNumPac TGE_REF_VRREP.NUMERO_DE_PAC%TYPE,
    pCodeTable TGE_REF_VRREP.Code_TABLE%TYPE,
    numcarte_00 IN NUMBER
  )
IS
  a_count     NUMBER:=0;
  numcarte_99 NUMBER;
BEGIN
  FOR i IN tab_numLigne00.first..tab_numLigne00.last
  LOOP
    IF tab_numLigne00
      (
        i
      )
                  =numcarte_00 THEN
      numcarte_99:=tab_numLigne99
      (
        i
      )
      ;
    END IF;
  END LOOP;
  SELECT COUNT(*)
  INTO a_count
  FROM TGE_IMPORT_FSED
  WHERE SUBSTR(donnees,1,6)=pNumpac
  AND id_trt               =p_id
  AND SUBSTR(donnees,7,2)
    || SUBSTR(donnees,18,1)='11R'
  AND num_lig BETWEEN numcarte_00 AND numcarte_99;
  IF a_count>0 THEN
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_VRREP Pac ('||pNumPac||')');
     --DSH : Les VR mises à jour et non encore envoyé à zadig(code_gestionnaire ='G' and temoin_vr_base = O: Valeurs modifiées non envoyées ou K : Echec du dernier envoi des valeurs ou E : en cours d'envoi ) ne doivent pas être supprimés
 	DELETE FROM TGE_REF_VRREP WHERE NUMERO_DE_PAC=pNumPac and (code_gestionnaire <>'G' or ( code_gestionnaire ='G' and temoin_vr_base <>'O' and temoin_vr_base <>'K' and temoin_vr_base <>'E') );
    
  END IF;
  SELECT COUNT(*)
  INTO a_count
  FROM TGE_IMPORT_FSED
  WHERE SUBSTR(donnees,1,6)=pNumpac
  AND id_trt               =p_id
  AND SUBSTR(donnees,7,2)
    || SUBSTR(donnees,18,1)='11D'
  AND num_lig BETWEEN numcarte_00 AND numcarte_99;
  IF a_count>0 THEN
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_VRDES Pac ('||pNumPac||')');
    DELETE FROM TGE_REF_VRDES WHERE NUMERO_DE_PAC=pNumPac;
  END IF;
  SELECT COUNT(*)
  INTO a_count
  FROM TGE_IMPORT_FSED
  WHERE SUBSTR(donnees,1,6)=pNumpac
  AND id_trt               =p_id
  AND SUBSTR(donnees,7,2)  ='15'
  AND num_lig BETWEEN numcarte_00 AND numcarte_99;
  IF a_count>0 THEN
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_RUBRIQUE Pac ('||pNumPac||')');
    DELETE FROM TGE_REF_RUBRIQUE WHERE numpac=pNumPac;
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_LIBRUB_COTIS Pac ('||pNumPac||')');
    DELETE FROM TGE_REF_LIBRUB_COTIS WHERE numpac = pNumPac;
  END IF;
  SELECT COUNT(*)
  INTO a_count
  FROM TGE_IMPORT_FSED
  WHERE SUBSTR(donnees,1,6)=pNumpac
  AND id_trt               =p_id
  AND SUBSTR(donnees,7,2)
    || SUBSTR(donnees,10,2)='17CR'
  AND num_lig BETWEEN numcarte_00 AND numcarte_99;
  IF a_count>0 THEN
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_RUBRIQUE_CONTEXTE Pac ('||pNumPac||')');
    DELETE FROM TGE_REF_RUBRIQUE_CONTEXTE WHERE numpac=pNumPac;
  END IF;
  SELECT COUNT(*)
  INTO a_count
  FROM TGE_IMPORT_FSED
  WHERE SUBSTR(donnees,1,6)=pNumpac
  AND id_trt               =p_id
  AND SUBSTR(donnees,7,2)
    || SUBSTR(donnees,10,2)
    || SUBSTR(donnees,13,1)='17DMF'
  AND num_lig BETWEEN numcarte_00 AND numcarte_99;
  IF a_count>0 THEN
    FSED_AVANCEMENT(p_id,'Vidage de TGE_REF_DICOZ Pac ('||pNumPac||')');
    DELETE FROM TGE_REF_DICOZ WHERE numpac=pNumPac;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := SQLERRM;
  FSED_ERREUR( p_id , 'purge_table' , pNumPac||','||pCodeTable , err_code||'-'||err_msg );
  raise_application_error(-20000, 'FSED purge array  '|| sqlerrm);
END purge_table;
/**********************************************************************
PROC : retour_Referentiel (p_id IN NUMBER )
DESC :
***********************************************************************/
PROCEDURE retour_Fsed(
    p_id IN NUMBER )
IS
  num_carte    VARCHAR(2) := '';
  carte_00     BOOLEAN    :=false;
  v_numpac     VARCHAR(6);
  exist_numpac NUMBER;
  v_code_table TGE_REF_VRVAL.CODE_TABLE%TYPE;
  v_code_table_Old TGE_REF_VRVAL.CODE_TABLE%TYPE := '$';
  v_table_Old TGE_REF_VRVAL.CODE_TABLE%TYPE      := '$';
  v_cmpt      NUMBER                                  := 0 ;
  v_cmpt_rest NUMBER ;
  v_cmpt1     NUMBER := 0 ;
  v_code TGE_REF_VRVAL.CODE_TABLE%TYPE ;
  v_start         NUMBER;
  v_stop          NUMBER;
  listeTablePurge VARCHAR2(32767):=',';
  v_type_retour   VARCHAR2(2);
  v_moi_retour    NUMBER;
  v_type          VARCHAR2(1);
  isVRVAL         BOOLEAN := false ;
  isVRDES         BOOLEAN := false ;
  isRUBRIQUE      BOOLEAN := false ;
  isDICOZ         BOOLEAN := false ;
  v_id            NUMBER ;
  w_exist         number := -1;
  w_code_gest    tge_ref_vrrep.code_gestionnaire%type;
  v_type_carte    varchar2(3) :=' ';
BEGIN
  v_start := DBMS_UTILITY.GET_TIME;
  v_id    :=p_id;
  getNumLigne(v_id);
  -- Lecture ligne à ligne de la table
   FSED_AVANCEMENT(v_id,'Début Traitement cartes référentiel paie');
  OPEN cur_lig(v_id);
  LOOP
    FETCH cur_lig BULK COLLECT INTO lig limit 10000;
    EXIT
  WHEN lig.count   =0;
    IF lig.first  IS NOT NULL THEN
      v_cmpt_rest := lig.COUNT;
      FOR i IN lig.FIRST..lig.LAST
      LOOP
        --Extraction du numéro de la carte
        num_carte  := SUBSTR(lig(i).donnees,7,2);
        IF num_carte='00' THEN
          v_numpac := SUBSTR(lig(i).donnees,1,6);
          -- test d'existence du pac
          SELECT COUNT(numpac)
          INTO exist_numpac
          FROM TGE_REF_PAC
          WHERE numpac     =v_numpac;
          IF exist_numpac  >0 THEN
            carte_00      :=true;
            v_type_retour := SUBSTR(lig(i).donnees,68,2);
            IF v_type_retour IN('RC','RN') THEN
              v_moi_retour :=SUBSTR(lig(i).donnees,70,6);
              insert_gap_trt(v_id,v_numpac,v_moi_retour,v_type_retour);
            ELSIF v_type_retour ='RR' THEN
              insert_gap_trt(v_id,v_numpac,NULL,v_type_retour);
            END IF;
            insert_gap_trt_suivi(v_id,'DEBUT',NULL,'BATCH',v_type_retour);
          END IF;
          FSED_AVANCEMENT(v_id,'Traitement référentiel Carte 00 type : '||v_type_retour);
        elsif num_carte='99' THEN
          carte_00    :=false;  
          FSED_AVANCEMENT(v_id,'Traitement référentiel Carte 99 ');
          v_id := GAP_TRT_SEQ_ID.nextval;
        END IF;
        -- traitement de chaque type de carte
        IF num_carte='00' THEN
          FSED_AVANCEMENT(v_id,'Traitement référentiel purge tables (numpac='||v_numpac||'/code table ='||v_code_table||'/num ligne='||lig(i).num_lig);
          purge_table(v_id,v_numpac,v_code_table,lig(i).num_lig);
        END IF ;
        IF num_carte    ='11' THEN
          v_code_table := getTableCode (lig(i))||trim(SUBSTR(lig(i).donnees,14,2));
          v_type       :=SUBSTR(lig(i).donnees,18,1);
          v_type_carte := trim(SUBSTR(lig(i).donnees,18,2));
          w_exist:= -1;
          w_code_gest:='';
          if v_type_carte ='V' THEN
          begin
          select CODE_GESTIONNAIRE ,1
          into   w_code_gest,
                 w_exist
          from  tge_ref_vrrep 
          where numero_de_pac     = v_numpac
          and   code_table        = v_code_table;
          exception 
          when no_data_found then 
          w_exist := -1;
          end;
          end if;
        END IF;
        IF carte_00 AND v_code_table_Old        != v_code_table AND num_carte ='11' THEN
           IF (instr(listeTablePurge,v_code_table)=0 AND SUBSTR(lig(i).donnees,18,1)='V' and (w_exist = -1 OR (w_code_gest !='G' AND w_exist=1))) THEN
            DELETE
            FROM TGE_REF_VRVAL
            WHERE NUMERO_DE_PAC=v_numpac
            AND CODE_TABLE     =v_code_table;
            v_code_table_Old  := v_code_table;
            listeTablePurge   :=listeTablePurge||v_code_table||',';
          END IF;
        END IF ;
IF carte_00 
 OR( carte_00 =false and (tab_11V IS NOT NULL OR tab_11R IS NOT NULL  OR tab_11D IS NOT NULL OR tab_11D1 IS NOT NULL 
 OR tab_15 IS NOT NULL OR tab_15_lib IS NOT NULL OR tab_17CR IS NOT NULL OR tab_17DMF IS NOT NULL))
THEN
  v_cmpt           :=v_cmpt              +1 ;
  IF v_type_retour  ='RR' AND num_carte IN ('11','15','17') THEN
    IF num_carte    ='11' AND v_type='V' THEN
      isVRVAL      := true ;
    ELSIF num_carte ='11' AND v_type='D' THEN
      isVRDES      := true ;
    ELSIF num_carte ='15' THEN
      isRUBRIQUE   := true ;
    ELSIF num_carte ='17' THEN
      isDICOZ      := true ;
    END IF;
  END IF;
  
  ---Insertion Intermediaire
  IF v_cmpt      = 10000 OR v_cmpt_rest <10000 THEN
    v_cmpt1     := v_cmpt1   +v_cmpt;
    v_cmpt_rest := lig.COUNT - v_cmpt1;
    
    insertData(v_id,v_numpac,v_code_table);
    --Vider les tableaux
    purge_array(v_id);
    v_cmpt := 0;
  END IF;
  IF num_carte ='11' THEN
    IF w_exist = -1 OR (w_code_gest !='G' AND w_exist=1) THEN
      setCart11(v_id,lig(i),v_numpac,v_code_Table,v_table_Old);
    END IF;
    v_table_Old := v_code_Table ;
  elsif num_carte='15' THEN
    setCart15(v_id,lig(i),v_numpac);
  elsif num_carte ='17' THEN
    setCart17(v_id,lig(i),v_numpac);
  END IF;
END IF;
END LOOP;
IF isVRVAL THEN
    FSED_AVANCEMENT(v_id,'Détection de la présence du dictionnaire VRVAL Pac ('||v_numpac||')' );
    insert_gap_trt_suivi(v_id,'VRVAL',NULL,'BATCH',v_type_retour);
  END IF;
  IF isVRDES THEN
    FSED_AVANCEMENT(v_id,'Détection de la présence du dictionnaire VRDES Pac ('||v_numpac||')' );
    insert_gap_trt_suivi(v_id,'VRDES',NULL,'BATCH',v_type_retour);
  END IF;
  IF isRUBRIQUE THEN
    FSED_AVANCEMENT(v_id,'Détection de la présence du dictionnaire RUBRIQUE Pac ('||v_numpac||')' );
    insert_gap_trt_suivi(v_id,'RUBRIQUE',NULL,'BATCH',v_type_retour);
  END IF;
  IF isDICOZ THEN
    FSED_AVANCEMENT(v_id,'Détection de la présence du dictionnaire DICOZ Pac ('||v_numpac||')' );
    insert_gap_trt_suivi(v_id,'DICOZ',NULL,'BATCH',v_type_retour);
  END IF;
IF tab_11R IS NOT NULL THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_VRREP');
    END IF;
END IF;
IF tab_11D IS NOT NULL THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_VRDES');
    END IF;
END IF;
IF tab_11V IS NOT NULL THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_VRVAL');
    END IF;
END IF;
IF tab_15 IS NOT NULL THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_RUBRIQUE');
    END IF;
END IF;
IF tab_15_lib IS NOT NULL and tab_15_lib.exists(1) THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_LIBRUB_COTIS');
    END IF;
END IF;
 IF tab_17CR IS NOT NULL THEN
    IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_RUBRIQUE_CONTEXTE');
    END IF;
END IF;
IF tab_17DMF IS NOT NULL THEN
IF (v_cmpt_rest<10000) THEN 
     FSED_AVANCEMENT(p_id,'Chargement de TGE_REF_DICOZ');
    END IF;
END IF;
END IF;
IF isVRVAL THEN
    FSED_AVANCEMENT(v_id,'Fin du chargement du dictionnaire VRVAL' );
  END IF;
  IF isVRDES THEN
    FSED_AVANCEMENT(v_id,'Fin du chargement du dictionnaire VRDES' );
  END IF;
  IF isRUBRIQUE THEN
    FSED_AVANCEMENT(v_id,'Fin du chargement du dictionnaire RUBRIQUE' );
  END IF;
  IF isDICOZ THEN
    FSED_AVANCEMENT(v_id,'Fin du chargement du dictionnaire DICOZ' );
  END IF;    
    isVRVAL    :=false;
    isVRDES    :=false;
    isRUBRIQUE :=false;
    isDICOZ    :=false;
  END LOOP;
  CLOSE cur_lig;
  v_stop := DBMS_UTILITY.GET_TIME;
  FSED_AVANCEMENT(v_id,'Fin Traitement cartes référentiel paie');
EXCEPTION
WHEN OTHERS THEN
  err_code := SQLCODE;
  err_msg  := err_msg||' '||SQLERRM;
  FSED_ERREUR( v_id , 'retour_Fsed' , v_id , err_code||'-'||err_msg );
  raise_application_error(-20000, 'retour_Fsed  '|| sqlerrm );
END retour_Fsed;
  /*****************************************************************************
 PROC : getPeriodeRecueilEvol
 DESC : retourne la date debut et fin de la periode de recueil 
 *******************************************************************************/
 PROCEDURE getPeriodeRecueilEvol(
    p_id             IN NUMBER,
    p_numpac         IN TGE_REF_PAC.numpac%type,
    p_periodeEnCours IN TGE_REF_PAC.periodeencours%type,
    p_paiezad        IN TGE_IMPORT_FSED_30.paiezad%type,
    p_dateDeb        IN OUT DATE,
    p_dateFin        IN OUT DATE)
IS
  w_A01_DONNEE TGE_REF_MAPDO.donneegxp%type;
  w_A02_DONNEE TGE_REF_MAPDO.donneegxp%type;
  w_A03_DONNEE TGE_REF_MAPDO.donneegxp%type;
  w_tablegxp    TGE_REF_MAPDO.tablegxp%type;
  w_req CLOB;
  w_pacmat DIC_ADM_CONTRAT_SITU.pacmat%type;--DIT 50818 
  w_activite     VARCHAR2(20);
  w_etablissment VARCHAR2(20);
  w_categorie    VARCHAR2(20);
  
  A01_NOM_ELT    VARCHAR2(20);
  A02_NOM_ELT    VARCHAR2(20);
  A03_NOM_ELT    VARCHAR2(20);
  
  requetePivot  VARCHAR2(3000);
BEGIN

  select A01_NOM_ELT, A02_NOM_ELT, A03_NOM_ELT
  into   A01_NOM_ELT, A02_NOM_ELT, A03_NOM_ELT
  from (
   SELECT NOM_ARG,NOM_ELT FROM TABLE(GET_TGE_MAP_ARG_ELT_BY_NUMPAC(p_numpac))
  )
  pivot (MAX(NOM_ELT) AS NOM_ELT FOR (NOM_ARG) in ('A01' AS A01,'A02' AS A02,'A03' AS A03));	
	
  SELECT pacmat
  INTO   w_pacmat
  FROM   DIC_ADM_CONTRAT_SITU --DIT 50818 
  WHERE  numpac =p_numpac
  AND    paiezad  = p_paiezad
  AND rownum   =1 ;

requetePivot :=    
'SELECT tablegxp ,
  A01_DONNEE ,
  A02_DONNEE,
  A03_DONNEE

FROM
  (SELECT *
  FROM
    ( SELECT DISTINCT c.element,
      c.tablegxp,
      c.DONNEEGXP
    FROM
      (SELECT * FROM user_tables
      ) b,
      tge_ref_mapdo c
    WHERE C.numpac   ='''||p_numpac||'''
    AND b.table_name =c.TABLEGXP
    AND c.element   IN ('''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''')
    UNION ALL
    SELECT DISTINCT c.element,
      c.tablegxp,
      c.DONNEEGXP
    FROM
      (SELECT * FROM user_tables
      ) b,
      tge_ref_mapdo c
    WHERE C.numpac              =''*''
    AND b.table_name            =c.TABLEGXP
    AND c.element              IN ('''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''')
    AND (TABLEGXP,ELEMENT) NOT IN
      (SELECT a.TABLEGXP,
        a.element
      FROM tge_ref_mapdo a,
        (SELECT * FROM user_tables
        ) b
      WHERE a.numpac  ='''||p_numpac||'''
      AND b.table_name=a.TABLEGXP
      AND A.ELEMENT   IN ('''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''')
      )
    ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element) IN(
    '''||A01_NOM_ELT||''' AS A01 ,'''||A02_NOM_ELT||''' AS A02,'''||A03_NOM_ELT||''' AS A03
    ))
  )';
  EXECUTE IMMEDIATE
  requetePivot
  INTO 
  w_tablegxp,
  w_A01_DONNEE,
  w_A02_DONNEE,
  w_A03_DONNEE
  ;
  IF w_A01_DONNEE IS NOT NULL AND w_A02_DONNEE IS NOT NULL AND w_A03_DONNEE IS NOT NULL THEN
    w_req          := 'select distinct '||w_A01_DONNEE||','||w_A02_DONNEE ||','||w_A03_DONNEE ||' from '||w_tablegxp ||' where numpac = :numpac and pacmat= :pacmat and DATE_EFF <= :dateeff and DATE_SORTIE_SIT_BO >= :datesortie ';
    EXECUTE immediate w_req INTO w_activite,w_etablissment,w_categorie
    USING p_numpac,w_pacmat,last_day(to_date(p_periodeEnCours,'YYYYMM')),last_day(to_date(p_periodeEnCours,'YYYYMM'));
  END IF;
   FSED_AVANCEMENT(p_id,'getPeriodeRecueil:w_activite,w_etablissment,w_categorie '||w_activite||','||w_etablissment||','||w_categorie);
  
BEGIN
select a.DT_RECUEIL_DEB ,
       a.DT_RECUEIL_FIN
INTO   p_dateDeb ,
       p_dateFin 
FROM (
SELECT
  CASE
    WHEN TO_CHAR(REC.DATE_DEBUT_1,'YYYYMMDD') IS NOT NULL
    THEN REC.DATE_DEBUT_1
    ELSE to_date(SUBSTR(LTP.ENREGISTREMENT,29,8), 'DDMMYYYY')
  END AS DT_RECUEIL_DEB,
  CASE
    WHEN TO_CHAR(REC.DATE_FIN_1,'YYYYMMDD') IS NOT NULL
    THEN REC.DATE_FIN_1
    ELSE to_date(SUBSTR(LTP.ENREGISTREMENT, 37 ,8 ), 'DDMMYYYY')
  END AS DT_RECUEIL_FIN

FROM TGE_REF_VRVAL LTP
LEFT JOIN DIC_TGE_PERIODES_RECUEIL REC
ON ( REC.PAIEZAD                        = p_paiezad
AND REC.NUMPAC                          = p_numpac)
WHERE LTP.CODE_TABLE                    = 'LTP'
AND NUMERO_DE_PAC                       = p_numpac
AND SUBSTR(LTP.ENREGISTREMENT, 19 , 6 ) = SUBSTR(p_periodeEncours,5, 6)
  ||SUBSTR(p_periodeEncours,0, 4) --expl '012014'
AND w_activite     between SUBSTR(LTP.ENREGISTREMENT,1 ,2) AND  SUBSTR(LTP.ENREGISTREMENT,3,2)
AND w_etablissment between SUBSTR(LTP.ENREGISTREMENT,5 ,5) AND  SUBSTR(LTP.ENREGISTREMENT,10,5)
AND w_categorie    between SUBSTR(LTP.ENREGISTREMENT,15,2) AND  SUBSTR(LTP.ENREGISTREMENT,17,2)
ORDER BY NUMERO_DE_LIGNE ASC) a
where rownum =1;
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
    p_dateDeb := null;
    p_dateFin := null;
FSED_AVANCEMENT(p_id,'ERREUR :getPeriodeRecueil: NO_DATA_FOUND for dateDeb et DateFin');
 WHEN OTHERS THEN
  err_msg := SQLERRM; 
 FSED_AVANCEMENT(p_id,'ERREUR :getPeriodeRecueil:err_msg : '||err_msg );
END ;
EXCEPTION
WHEN OTHERS THEN
  err_msg := SQLERRM;
  FSED_AVANCEMENT(p_id,'ERREUR :getPeriodeRecueil:err_msg : '||err_msg||' req'||w_req||' '||'using '|| p_numpac||','||w_pacmat||','||last_day(to_date(p_periodeEnCours,'YYYYMM'))||','||last_day(to_date(p_periodeEnCours,'YYYYMM')));
END getPeriodeRecueilEvol;
  /*****************************************************************************
 PROC : getClauseSelect
 DESC : la clause SELECT correspondant à une donnée mappée
 *******************************************************************************/
 FUNCTION getClauseSelect(
    p_numpac             IN VARCHAR2,
    p_nom_table_ou_alias IN VARCHAR2,
    p_donneegxp          IN VARCHAR2,
    p_donnfiltre         IN VARCHAR2,
    p_operfiltre         IN VARCHAR2,
    p_valfiltre          IN VARCHAR2,
    p_trtparticulier     IN VARCHAR2,
    p_envoi_systematique IN VARCHAR2,
    p_data_type          IN VARCHAR2,
    p_type_zadig         IN VARCHAR2,
    p_masque             IN VARCHAR2,
    p_occ                IN VARCHAR2,
    p_avec_balises_photo IN BOOLEAN)
  RETURN VARCHAR2
IS
  donnee      VARCHAR(1000);
  donneeChar  VARCHAR(1000);
  donneeFilt  VARCHAR(1000);
BEGIN
  IF p_donneegxp            IS NOT NULL THEN
    donneeChar                      :=p_nom_table_ou_alias||'.'||p_donneegxp;
    IF p_trtparticulier     IS NOT NULL AND NOT (instr(p_trtparticulier,'SI_VIDE=',1)=1 OR instr(p_trtparticulier,'DIV=',1)=1 OR instr(p_trtparticulier,'TAB=',1)=1 OR instr(p_trtparticulier,'INI=',1)=1 OR instr(p_trtparticulier,'SUB=',1)=1 OR instr(p_trtparticulier,'PAYS',1)=1 ) THEN
      donneeChar                    :=REPLACE(p_trtparticulier,'$DONNEEGXP',donneeChar);
      donneeChar                    :=REPLACE(donneeChar,'$NUMPAC',''''||p_numpac||'''');
      donneeChar                    :=REPLACE(donneeChar,'$MATRIC',p_nom_table_ou_alias||'.'||'MATRIC');
      donneeChar                    :=REPLACE(donneeChar,'$TABLE',p_nom_table_ou_alias);
      IF p_avec_balises_photo AND p_envoi_systematique='O' THEN
        --les balises @### et ###@ permettront de remplacer la donnée par une valeur bidon dans la PHOTO et ainsi forcer l'envoi
        donneeChar :='@###'||donneeChar||'###@';
      END IF;
    END IF;
    IF p_data_type   ='DATE' AND p_trtparticulier IS NULL AND p_type_zadig    ='N' AND p_masque IN (1,2,3,4,5,6,7) THEN
      donneeChar            :='to_char('||p_nom_table_ou_alias||'.'||p_donneegxp||',''yyyymmddHH24MISS'')';
    ELSIF p_data_type='DATE' AND p_trtparticulier IS NOT NULL AND p_type_zadig    ='N' AND p_masque IN (1,2,3,4,5,6,7) AND p_donneegxp IS NOT NULL THEN
      donneeChar            :='to_char('||donneechar||',''yyyymmddHH24MISS'')';
    ELSE
      donneeChar:='to_char('||donneeChar||')';
    END IF;
    IF p_donnfiltre    IS NOT NULL AND p_operfiltre IS NOT NULL THEN
      donneeFilt               :=' case when ('||p_nom_table_ou_alias||'.'||p_donnfiltre;
      IF p_valfiltre   IS NULL THEN
        IF p_operfiltre = '=' THEN
          donneeFilt           :=donneeFilt||' IS NULL';
        ELSE
          donneeFilt:=donneeFilt||' IS NOT NULL';
        END IF;
      ELSIF p_operfiltre                  ='IN' THEN
        donneeFilt                               :=donneeFilt||' IN ('||p_valfiltre||')';
      ELSIF p_operfiltre                  ='NI' THEN
        donneeFilt                               :=donneeFilt||' NOT IN ('||p_valfiltre||')';
      ELSIF SUBSTR(upper(p_valfiltre),1,3)='TO_' THEN
        donneeFilt                               :=donneeFilt||p_operfiltre||p_valfiltre;
      ELSE
        donneeFilt:=donneeFilt||p_operfiltre||''''||p_valfiltre||'''';
      END IF;
      donneeFilt:=donneeFilt||') then '||donneeChar||' else ''_NOTSEND_'' end ';
    ELSE
      donneeFilt:=donneeChar;
    END IF;
    IF p_occ   ='*F' THEN
      donnee               :='case when '||p_nom_table_ou_alias||'.'||'ECRADR=''ADR'' then '||donneeFilt||' else ''_NOTSEND_'' end';
    ELSIF p_occ='*I' THEN
      donnee               :='case when '||p_nom_table_ou_alias||'.'||'ECRADR=''ADI'' then '||donneeFilt||' else ''_NOTSEND_'' end';
    ELSE
      donnee:=donneeFilt;
    END IF;
  ELSE
    donnee :=''''||REPLACE(p_trtparticulier,'INI=','')||'''' ;
  END IF;
  IF instr(p_trtparticulier,'SI_VIDE=',1)>0 THEN
    donnee                                      :='nvl('||donnee||','''||REPLACE(p_trtparticulier,'SI_VIDE=','')||''')';
  END IF;
  IF instr(p_trtparticulier,'DIV=',1)>0 THEN
    donnee                                  :='to_char(to_number('||donnee||')/to_number('||REPLACE(p_trtparticulier,'DIV=','')||'))';
  END IF;
  IF instr(p_trtparticulier,'TAB=',1)>0 THEN
    donnee                                  :=donnee;
  END IF;
  IF instr(p_trtparticulier,'SUB=',1)>0 THEN
    donnee                                  :=REPLACE(p_trtparticulier,'SUBSTR=','SUBSTR('||donnee||',')||')';
  END IF;
  RETURN donnee;
END getClauseSelect ;        
END FSED;
##
TAG_CHARSET=@€éèç
##
TOOLS_V5
=SQL=
CREATE OR REPLACE PACKAGE TOOLS_V5 AS
 FUNCTION GET_OBJETS_USED_BY_OP(
   p_op_num VARCHAR2,
   is_ux NUMBER DEFAULT 0) 
   RETURN TAB_REF_OBJ_USED_BY_OBJECT;
   
 FUNCTION GET_OBJETS_USED_BY_ECR(
   p_nom_page VARCHAR2,
   is_ux NUMBER DEFAULT 0)
   RETURN TAB_REF_OBJ_USED_BY_OBJECT;
   
 FUNCTION GET_OBJETS_USED_BY_GRP(
   p_id_groupe VARCHAR2,
   is_ux NUMBER DEFAULT 0)
   RETURN TAB_REF_OBJ_USED_BY_OBJECT;
   
 FUNCTION GET_OBJETS_USED_BY_DON(
   p_nom_donnee VARCHAR2,
   is_ux NUMBER DEFAULT 0)
   RETURN TAB_REF_OBJ_USED_BY_OBJECT;
   
 FUNCTION GET_OBJETS_USED_BY_REG(
   p_id_reglegestion VARCHAR2,
   is_ux NUMBER DEFAULT 0) 
   RETURN TAB_REF_OBJ_USED_BY_OBJECT;
   
END TOOLS_V5;
##
TOOLS_V5
=SQL=
CREATE OR REPLACE PACKAGE BODY TOOLS_V5 AS
  PROCEDURE ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init VARCHAR2, p_nom_table VARCHAR2, p_code_objet VARCHAR2, p_nom_ecran_reference VARCHAR2 DEFAULT NULL, p_nom_table_parent VARCHAR2 DEFAULT NULL, p_code_objet_parent_1 VARCHAR2 DEFAULT NULL, p_code_objet_parent_2 VARCHAR2 DEFAULT NULL) 
  IS
    v_count NUMBER;
    v_cle_table VARCHAR2(4000);
    v_nom_table_parent VARCHAR2(1000);
    v_code_objet_parent_1 VARCHAR2(1000);
    v_code_objet_parent_2 VARCHAR2(1000);
    v_code_objet_tmp_1 VARCHAR2(4000);
    v_code_objet_tmp_2 VARCHAR2(4000);
    v_code_objet_tmp_3 VARCHAR2(4000);
  BEGIN
    IF p_code_objet IS NULL THEN
      RETURN;
    END IF;
    v_nom_table_parent := NVL(p_nom_table_parent,'__NULL__');
    v_code_objet_parent_1 := NVL(p_code_objet_parent_1,'__NULL__');
    v_code_objet_parent_2 := NVL(p_code_objet_parent_2,'__NULL__');
    SELECT COUNT(*) INTO v_count FROM REF_OBJ_USED_BY_OBJECT WHERE CODE_OBJET_INIT=p_code_objet_init AND NOM_TABLE=p_nom_table AND CODE_OBJET=p_code_objet AND NVL(NOM_TABLE_PARENT,'__NULL__')=v_nom_table_parent AND NVL(CODE_OBJET_PARENT_1,'__NULL__')=v_code_objet_parent_1 AND NVL(CODE_OBJET_PARENT_2,'__NULL__')=v_code_objet_parent_2;
    IF v_count>0 THEN
      -- Objet déjà traité : on ne le retraite pas
      RETURN;
    END IF;
    v_cle_table := NULL;
    IF p_nom_table='REF_WKF_OPERATION_ECRANS_INFO' THEN
      v_cle_table := 'OP_NUM';
    ELSIF p_nom_table='REF_ECRAN' THEN
      v_cle_table := 'NOM_PAGE';
    ELSIF p_nom_table='REF_DESTINATION_ECRAN' THEN
      v_cle_table := 'CODE_DESTINATION';
    ELSIF p_nom_table='REF_GROUPE_DONNEES_INFO' THEN
      v_cle_table := 'ID_GROUPE';
    ELSIF p_nom_table='REF_DONNEE_GENERALE' THEN
      v_cle_table := 'NOM_DONNEE';
    ELSIF p_nom_table='REF_DICTIONNAIRE' THEN
      v_cle_table := 'NOM_DICTIONNAIRE';
    ELSIF p_nom_table='REF_REGLEGESTION_DESC' THEN
      v_cle_table := 'ID_REGLEGESTION';
    ELSIF p_nom_table='SYS_REQUETES_JSP' THEN
      v_cle_table := 'NOMPAGE||'' / ''||IDREQUETE';
    ELSIF p_nom_table='SYS_DEF_ERREURS' THEN
      v_cle_table := 'CODERR';
    ELSIF p_nom_table='SYS_VARSYS' THEN
      v_cle_table := 'MODULE||'' / ''||CODVAR';
    END IF;
    INSERT INTO REF_OBJ_USED_BY_OBJECT VALUES (p_code_objet_init, p_nom_table, v_cle_table, p_code_objet, v_nom_table_parent, v_code_objet_parent_1, v_code_objet_parent_2);
    IF p_nom_table='REF_DICTIONNAIRE' THEN
      MERGE INTO REF_OBJ_USED_BY_OBJECT R USING (SELECT p_code_objet_init AS CODE_OBJET_INIT, 'TGE_REF_MAPTA' AS NOM_TABLE, 'ROWNUMBER' AS CLE_TABLE, ROWNUMBER AS CODE_OBJET, p_nom_table AS NOM_TABLE_PARENT, p_code_objet AS CODE_OBJET_PARENT_1, '__NULL__' AS CODE_OBJET_PARENT_2 FROM TGE_REF_MAPTA@RDMOD WHERE NUMPAC='*' AND TABLEPHY=p_code_objet) T
      ON (R.CODE_OBJET_INIT=T.CODE_OBJET_INIT AND R.NOM_TABLE=T.NOM_TABLE AND R.CODE_OBJET=T.CODE_OBJET AND R.NOM_TABLE_PARENT=T.NOM_TABLE_PARENT AND R.CODE_OBJET_PARENT_1=T.CODE_OBJET_PARENT_1 AND R.CODE_OBJET_PARENT_2=T.CODE_OBJET_PARENT_2)
      WHEN NOT MATCHED THEN INSERT VALUES (T.CODE_OBJET_INIT, T.NOM_TABLE, T.CLE_TABLE, T.CODE_OBJET, T.NOM_TABLE_PARENT, T.CODE_OBJET_PARENT_1, T.CODE_OBJET_PARENT_2);
    ELSIF p_nom_table='REF_DONNEE_GENERALE' THEN
      MERGE INTO REF_OBJ_USED_BY_OBJECT R USING (SELECT p_code_objet_init AS CODE_OBJET_INIT, 'TGE_REF_MAPDO' AS NOM_TABLE, 'ELEMENT||'' / ''||OCCURENCE' AS CLE_TABLE, ELEMENT||' / '||OCCURENCE AS CODE_OBJET, p_nom_table AS NOM_TABLE_PARENT, p_code_objet AS CODE_OBJET_PARENT_1, '__NULL__' AS CODE_OBJET_PARENT_2 FROM TGE_REF_MAPDO@RDMOD WHERE NUMPAC='*' AND DONNEEGXP=p_code_objet) T
      ON (R.CODE_OBJET_INIT=T.CODE_OBJET_INIT AND R.NOM_TABLE=T.NOM_TABLE AND R.CODE_OBJET=T.CODE_OBJET AND R.NOM_TABLE_PARENT=T.NOM_TABLE_PARENT AND R.CODE_OBJET_PARENT_1=T.CODE_OBJET_PARENT_1 AND R.CODE_OBJET_PARENT_2=T.CODE_OBJET_PARENT_2)
      WHEN NOT MATCHED THEN INSERT VALUES (T.CODE_OBJET_INIT, T.NOM_TABLE, T.CLE_TABLE, T.CODE_OBJET, T.NOM_TABLE_PARENT, T.CODE_OBJET_PARENT_1, T.CODE_OBJET_PARENT_2);
    ELSIF p_nom_table='SYS_REQUETES_JSP' THEN
      MERGE INTO REF_OBJ_USED_BY_OBJECT R USING (SELECT p_code_objet_init AS CODE_OBJET_INIT, 'TGE_REF_MAPVR' AS NOM_TABLE, 'TABLEZADIG||'' / ''||CHAMPZADIG' AS CLE_TABLE, TABLEZADIG||' / '||CHAMPZADIG AS CODE_OBJET, p_nom_table AS NOM_TABLE_PARENT, p_code_objet AS CODE_OBJET_PARENT_1, '__NULL__' AS CODE_OBJET_PARENT_2 FROM TGE_REF_MAPVR@RDMOD WHERE NUMPAC='*' AND TABLEGXP=(SELECT NOMTABLE FROM SYS_REQUETES_JSP@RDMOD WHERE NOMPAGE||' / '||IDREQUETE=p_code_objet)) T
      ON (R.CODE_OBJET_INIT=T.CODE_OBJET_INIT AND R.NOM_TABLE=T.NOM_TABLE AND R.CODE_OBJET=T.CODE_OBJET AND R.NOM_TABLE_PARENT=T.NOM_TABLE_PARENT AND R.CODE_OBJET_PARENT_1=T.CODE_OBJET_PARENT_1 AND R.CODE_OBJET_PARENT_2=T.CODE_OBJET_PARENT_2)
      WHEN NOT MATCHED THEN INSERT VALUES (T.CODE_OBJET_INIT, T.NOM_TABLE, T.CLE_TABLE, T.CODE_OBJET, T.NOM_TABLE_PARENT, T.CODE_OBJET_PARENT_1, T.CODE_OBJET_PARENT_2);
    END IF;
    IF p_nom_table='REF_WKF_OPERATION_ECRANS_INFO' THEN
      -- Une opération référence :
      --     Des groupes de données :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS_INFO.ID_GROUPE_ECRITURE
        SELECT ID_GROUPE_ECRITURE AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS_INFO@RDMOD WHERE OP_NUM=p_code_objet AND ID_GROUPE_ECRITURE IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS.RECHERCHE_ID_GROUPE_LECTURE
        SELECT RECHERCHE_ID_GROUPE_LECTURE AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet and RECHERCHE_ID_GROUPE_LECTURE IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS.RECAP_ID_GROUPE_1
        SELECT RECAP_ID_GROUPE_1 AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet and RECAP_ID_GROUPE_1 IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS.RECAP_ID_GROUPE_2
        SELECT RECAP_ID_GROUPE_2 AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet and RECAP_ID_GROUPE_2 IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_GROUPE_DONNEES_INFO',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des données :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS_INFO.BTN_SUPPRIMER_DONNEE_COMM
        SELECT BTN_SUPPRIMER_DONNEE_COMM AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS_INFO@RDMOD WHERE OP_NUM=p_code_objet AND BTN_SUPPRIMER_DONNEE_COMM IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS_INFO.BTN_RENVOIDOSSIER_DONNEE_COMM
        SELECT BTN_RENVOIDOSSIER_DONNEE_COMM AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS_INFO@RDMOD WHERE OP_NUM=p_code_objet and BTN_RENVOIDOSSIER_DONNEE_COMM IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des erreurs :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS_INFO.BTN_SUPPRIMER_ERR_COMM_VID
        SELECT BTN_SUPPRIMER_ERR_COMM_VID AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS_INFO@RDMOD WHERE OP_NUM=p_code_objet AND BTN_SUPPRIMER_ERR_COMM_VID IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS_INFO.BTN_RENVOIDOSSIER_ERR_COMM_VID
        SELECT BTN_RENVOIDOSSIER_ERR_COMM_VID AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS_INFO@RDMOD WHERE OP_NUM=p_code_objet and BTN_RENVOIDOSSIER_ERR_COMM_VID IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'SYS_DEF_ERREURS',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des écrans :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS.ECRAN_NOM_PAGE
        SELECT ECRAN_NOM_PAGE AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet AND ECRAN_NOM_PAGE IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS.ECRAN_NOM_PAGE_ALTERNATIF
        SELECT ECRAN_NOM_PAGE_ALTERNATIF AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet and ECRAN_NOM_PAGE_ALTERNATIF IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_ECRAN',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des règles de gestion :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS.ECRAN_ID_REGLEGESTION_COND
        SELECT ECRAN_ID_REGLEGESTION_COND AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet AND ECRAN_ID_REGLEGESTION_COND IS NOT NULL
        UNION
      --         REF_WKF_OPERATION_ECRANS.RECHERCHE_ID_REGLEGESTION_CTL
        SELECT RECHERCHE_ID_REGLEGESTION_CTL AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet and RECHERCHE_ID_REGLEGESTION_CTL IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_REGLEGESTION_DESC',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     un appel table :
      FOR OBJET IN (
      --         REF_WKF_OPERATION_ECRANS.RECHERCHE_REQUETE_NOMPAGE / REF_WKF_OPERATION_ECRANS.RECHERCHE_REQUETE_IDREQUETE
        SELECT DISTINCT RECHERCHE_REQUETE_NOMPAGE||' / '||RECHERCHE_REQUETE_IDREQUETE AS CODE_OBJET FROM REF_WKF_OPERATION_ECRANS@RDMOD WHERE OP_NUM=p_code_objet AND RECHERCHE_REQUETE_NOMPAGE IS NOT NULL AND RECHERCHE_REQUETE_IDREQUETE IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'SYS_REQUETES_JSP',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
    ELSIF p_nom_table='REF_ECRAN' THEN
      -- Un écran référence :
      --     Une destination :
      FOR OBJET IN (
      --         REF_ECRAN.CODE_DESTINATION
        SELECT DISTINCT CODE_DESTINATION AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND CODE_DESTINATION IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DESTINATION_ECRAN',OBJET.CODE_OBJET,p_code_objet,p_nom_table,p_code_objet);
      END LOOP;
      --     Un dictionnaire :
      FOR OBJET IN (
      --         REF_ECRAN.NOM_DICTIONNAIRE
        SELECT DISTINCT NOM_DICTIONNAIRE AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND NOM_DICTIONNAIRE IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DICTIONNAIRE',OBJET.CODE_OBJET,p_code_objet,p_nom_table,p_code_objet);
      END LOOP;
      --     Un groupe de données :
      FOR OBJET IN (
      --         REF_ECRAN.ID_GROUPE_DONNEES
        SELECT DISTINCT ID_GROUPE_DONNEES AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND ID_GROUPE_DONNEES IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_GROUPE_DONNEES_INFO',OBJET.CODE_OBJET,p_code_objet,p_nom_table,p_code_objet);
      END LOOP;
      --     Des règles de gestion :
      FOR OBJET IN (
      --         REF_ECRAN.ID_REGLEGESTION_AUT_RD
        SELECT ID_REGLEGESTION_AUT_RD AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND ID_REGLEGESTION_AUT_RD IS NOT NULL
        UNION
      --         REF_ECRAN.ID_REGLEGESTION_AUT_CLI
        SELECT ID_REGLEGESTION_AUT_CLI AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND ID_REGLEGESTION_AUT_CLI IS NOT NULL
        UNION
      --         REF_ECRAN.ID_REGLEGESTION_CTL_RD
        SELECT ID_REGLEGESTION_CTL_RD AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND ID_REGLEGESTION_CTL_RD IS NOT NULL
        UNION
      --         REF_ECRAN.ID_REGLEGESTION_CTL_CLI
        SELECT ID_REGLEGESTION_CTL_CLI AS CODE_OBJET FROM REF_ECRAN@RDMOD WHERE NOM_PAGE=p_code_objet AND ID_REGLEGESTION_CTL_CLI IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_REGLEGESTION_DESC',OBJET.CODE_OBJET,p_code_objet,p_nom_table,p_code_objet);
      END LOOP;
    ELSIF p_nom_table='REF_DESTINATION_ECRAN' THEN
      -- Une destination d'écran ne référence rien
      NULL;
    ELSIF p_nom_table='REF_GROUPE_DONNEES_INFO' THEN
      -- Un groupe de données référence :
      --     Des règles de gestion :
      FOR OBJET IN (
      --         REF_GROUPE_DONNEES_INFO.ID_REGLEGESTION_AFF_RD
        SELECT ID_REGLEGESTION_AFF_RD AS CODE_OBJET FROM REF_GROUPE_DONNEES_INFO@RDMOD WHERE ID_GROUPE=p_code_objet AND ID_REGLEGESTION_AFF_RD IS NOT NULL
        UNION
      --         REF_GROUPE_DONNEES_INFO.ID_REGLEGESTION_AFF_CLI
        SELECT ID_REGLEGESTION_AFF_CLI AS CODE_OBJET FROM REF_GROUPE_DONNEES_INFO@RDMOD WHERE ID_GROUPE=p_code_objet and ID_REGLEGESTION_AFF_CLI IS NOT NULL
        UNION
      --         REF_GROUPE_DONNEES.ID_REGLEGESTION_CTL_RD_SUPP
        SELECT ID_REGLEGESTION_CTL_RD_SUPP AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and ID_REGLEGESTION_CTL_RD_SUPP IS NOT NULL
        UNION
      --         REF_GROUPE_DONNEES.ID_REGLEGESTION_CTL_CLI_SUPP
        SELECT ID_REGLEGESTION_CTL_CLI_SUPP AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and ID_REGLEGESTION_CTL_CLI_SUPP IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_REGLEGESTION_DESC',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Une donnée :
      FOR OBJET IN (
      --         REF_GROUPE_DONNEES.NOM_DONNEE
        SELECT DISTINCT NOM_DONNEE AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and NOM_DONNEE IS NOT NULL AND NOM_DONNEE NOT LIKE '#%'
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Un groupe de données :
      FOR OBJET IN (
      --         REF_GROUPE_DONNEES.SUFFIXE_OU_LIBELLE
        SELECT DISTINCT SUFFIXE_OU_LIBELLE AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and SUFFIXE_OU_LIBELLE IS NOT NULL AND (NOM_DONNEE LIKE '#GROUPE%' OR NOM_DONNEE LIKE '#RECONDUCTION_DONNEES%')
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_GROUPE_DONNEES_INFO',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Un appel table :
      FOR OBJET IN (
      --         REF_GROUPE_DONNEES.TABLEAU_REQUETE_NOMPAGE / REF_GROUPE_DONNEES.TABLEAU_REQUETE_IDREQUETE
        SELECT DISTINCT TABLEAU_REQUETE_NOMPAGE||' / '||TABLEAU_REQUETE_IDREQUETE AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet AND TABLEAU_REQUETE_NOMPAGE IS NOT NULL AND TABLEAU_REQUETE_IDREQUETE IS NOT NULL AND NOM_DONNEE LIKE '#TABLEAU%'
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'SYS_REQUETES_JSP',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des écrans :
      FOR OBJET IN (
      --         REF_GROUPE_DONNEES.NOM_PAGE_AJOUT
        SELECT DISTINCT NOM_PAGE_AJOUT AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and NOM_PAGE_AJOUT IS NOT NULL AND NOM_DONNEE LIKE '#TABLEAU%'
        UNION
      --         REF_GROUPE_DONNEES.NOM_PAGE_MODIF
        SELECT DISTINCT NOM_PAGE_MODIF AS CODE_OBJET FROM REF_GROUPE_DONNEES@RDMOD WHERE ID_GROUPE=p_code_objet and NOM_PAGE_MODIF IS NOT NULL AND NOM_DONNEE LIKE '#TABLEAU%'
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_ECRAN',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
    ELSIF p_nom_table='REF_DONNEE_GENERALE' THEN
      -- Une donnée référence :
      --     Un dictionnaire :
      FOR OBJET IN (
      --         REF_DONNEE_GENERALE.NOM_DICTIONNAIRE
        SELECT DISTINCT NOM_DICTIONNAIRE AS CODE_OBJET FROM REF_DONNEE_GENERALE@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_DICTIONNAIRE IS NOT NULL
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DICTIONNAIRE',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet);
      END LOOP;
      --     Des données :
      FOR OBJET IN (
      --         REF_DONNEE_GENERALE.NOM_DONNEE_CLE_DIC_REFERENCE
        SELECT NOM_DONNEE_CLE_DIC_REFERENCE AS CODE_OBJET FROM REF_DONNEE_GENERALE@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_DONNEE_CLE_DIC_REFERENCE IS NOT NULL
      )
      LOOP
        v_code_objet_tmp_1 := OBJET.CODE_OBJET||',';
        LOOP
          EXIT WHEN v_code_objet_tmp_1 IS NULL OR INSTR(v_code_objet_tmp_1,',')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,',')-1));
          IF v_code_objet_tmp_2 IS NOT NULL AND v_code_objet_tmp_2 NOT LIKE '#%' AND v_code_objet_tmp_2 NOT LIKE '''%' AND NOT v_code_objet_tmp_2=p_code_objet THEN
            ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',v_code_objet_tmp_2,p_nom_ecran_reference,p_nom_table,p_code_objet);
          END IF;
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,',')+1);
        END LOOP;
      END LOOP;
      FOR OBJET IN (
      --         REF_DONNEE_ECRAN.APPELTABLE_LISTECHAMPS
        SELECT APPELTABLE_LISTECHAMPS AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND APPELTABLE_LISTECHAMPS IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.APPELTABLE_PARAMETRES
        SELECT APPELTABLE_PARAMETRES AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND APPELTABLE_PARAMETRES IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
      )
      LOOP
        v_code_objet_tmp_1 := OBJET.CODE_OBJET||',';
        LOOP
          EXIT WHEN v_code_objet_tmp_1 IS NULL OR INSTR(v_code_objet_tmp_1,',')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,',')-1));
          IF v_code_objet_tmp_2 IS NOT NULL AND v_code_objet_tmp_2 NOT LIKE '#%' AND v_code_objet_tmp_2 NOT LIKE '''%' AND NOT v_code_objet_tmp_2=p_code_objet THEN
            SELECT COUNT(*) INTO v_count FROM REF_DONNEE_GENERALE@RDMOD WHERE NOM_DONNEE=TRIM(v_code_objet_tmp_2);
            IF v_count>0 THEN
              ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',v_code_objet_tmp_2,p_nom_ecran_reference,p_nom_table,p_code_objet,OBJET.CODE_OBJET_PARENT_2);
            END IF;
          END IF;
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,',')+1);
        END LOOP;
      END LOOP;
      --     Un appel table :
      FOR OBJET IN (
      --         REF_DONNEE_ECRAN.APPELTABLE_NOMPAGE / REF_DONNEE_ECRAN.APPELTABLE_IDREQUETE
        SELECT DISTINCT APPELTABLE_NOMPAGE||' / '||APPELTABLE_IDREQUETE AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND APPELTABLE_NOMPAGE IS NOT NULL AND APPELTABLE_IDREQUETE IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'SYS_REQUETES_JSP',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet,OBJET.CODE_OBJET_PARENT_2);
      END LOOP;
      --     Une règle de gestion :
      FOR OBJET IN (
      --         REF_DONNEE_ECRAN.EST_OBLIGATOIRE (R_...)
        SELECT SUBSTR(EST_OBLIGATOIRE,3) AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND REGEXP_LIKE(EST_OBLIGATOIRE,'^R_.*$') AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.VALEUR_DEFAUT (ID_REGLE=...)
        SELECT SUBSTR(VALEUR_DEFAUT,10) AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND REGEXP_LIKE(VALEUR_DEFAUT,'^ID_REGLE=.*$') AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_AUT_RD
        SELECT ID_REGLEGESTION_AUT_RD AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_AUT_RD IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_AUT_CLI
        SELECT ID_REGLEGESTION_AUT_CLI AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_AUT_CLI IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_AFF_RD
        SELECT ID_REGLEGESTION_AFF_RD AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_AFF_RD IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_AFF_CLI
        SELECT ID_REGLEGESTION_AFF_CLI AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_AFF_CLI IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_CTL_RD
        SELECT ID_REGLEGESTION_CTL_RD AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_CTL_RD IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
        UNION
      --         REF_DONNEE_ECRAN.ID_REGLEGESTION_CTL_CLI
        SELECT ID_REGLEGESTION_CTL_CLI AS CODE_OBJET, NOM_PAGE AS CODE_OBJET_PARENT_2 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND ID_REGLEGESTION_CTL_CLI IS NOT NULL AND (p_nom_ecran_reference IS NULL OR NOM_PAGE=p_nom_ecran_reference OR (NOM_PAGE='*' AND NOT EXISTS (SELECT 1 FROM REF_DONNEE_ECRAN@RDMOD WHERE NOM_DONNEE=p_code_objet AND NOM_PAGE=p_nom_ecran_reference)))
      )
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_REGLEGESTION_DESC',OBJET.CODE_OBJET,p_nom_ecran_reference,p_nom_table,p_code_objet,OBJET.CODE_OBJET_PARENT_2);
      END LOOP;
    ELSIF p_nom_table='REF_DICTIONNAIRE' THEN
      -- Un dictionnaire référence :
      --     Des données :
      FOR OBJET IN (
      --         REF_DICTIONNAIRE.CHAMPS_CLE
        SELECT DISTINCT CHAMPS_CLE AS CODE_OBJET FROM REF_DICTIONNAIRE@RDMOD WHERE NOM_DICTIONNAIRE=p_code_objet AND CHAMPS_CLE IS NOT NULL
      )
      LOOP
        v_code_objet_tmp_1 := OBJET.CODE_OBJET||',';
        LOOP
          EXIT WHEN v_code_objet_tmp_1 IS NULL OR INSTR(v_code_objet_tmp_1,',')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,',')-1));
          IF v_code_objet_tmp_2 IS NOT NULL AND v_code_objet_tmp_2 NOT LIKE '#%' AND v_code_objet_tmp_2 NOT LIKE '''%' THEN
            ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',v_code_objet_tmp_2,p_nom_ecran_reference,p_nom_table,p_code_objet);
          END IF;
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,',')+1);
        END LOOP;
      END LOOP;
    ELSIF p_nom_table='REF_REGLEGESTION_DESC' THEN
      -- Une règle de gestion référence :
      --     Des données :
      FOR OBJET IN (
      --         REF_REGLEGESTION.OPERANDE1 / REF_REGLEGESTION.OPERATEUR / REF_REGLEGESTION.OPERANDE2 / REF_REGLEGESTION.RESULTAT
        SELECT DISTINCT '£'||REPLACE(REPLACE(REPLACE(OPERANDE1,'µ','£'),'§','£'),'^','£')||'£'||REPLACE(REPLACE(REPLACE(OPERATEUR,'µ','£'),'§','£'),'^','£')||'£'||REPLACE(REPLACE(REPLACE(OPERANDE2,'µ','£'),'§','£'),'^','£')||'£'||REPLACE(REPLACE(REPLACE(RESULTAT,'µ','£'),'§','£'),'^','£') AS CODE_OBJET FROM REF_REGLEGESTION@RDMOD WHERE ID_REGLEGESTION=p_code_objet
      )
      LOOP
        v_code_objet_tmp_1 := OBJET.CODE_OBJET||'£';
        LOOP
          EXIT WHEN v_code_objet_tmp_1 IS NULL OR INSTR(v_code_objet_tmp_1,'£')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,'£')-1));
          v_code_objet_tmp_3 := NULL;
          IF v_code_objet_tmp_2='DONNEE' THEN
            v_code_objet_tmp_3 := 'REF_DONNEE_GENERALE';
          ELSIF v_code_objet_tmp_2='IDREGLE' THEN
            v_code_objet_tmp_3 := 'REF_REGLEGESTION_DESC';
          ELSIF v_code_objet_tmp_2='NOM_PAGE=VALEUR' THEN
            v_code_objet_tmp_3 := 'SYS_REQUETES_JSP';
          ELSIF v_code_objet_tmp_2='CODEERREUR' THEN
            v_code_objet_tmp_3 := 'SYS_DEF_ERREURS';
          ELSIF v_code_objet_tmp_2='VARSYS' THEN
            v_code_objet_tmp_3 := 'SYS_VARSYS';
          END IF;
          IF v_code_objet_tmp_3 IS NOT NULL THEN
            v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'£')+1);
            v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,'£')-1));
            IF v_code_objet_tmp_3 = 'SYS_REQUETES_JSP' THEN
              v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'£')+1);
              v_code_objet_tmp_3 := SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,'£')-1);
              IF v_code_objet_tmp_3='ID_REQUETE=VALEUR' THEN
                v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'£')+1);
                v_code_objet_tmp_3 := SUBSTR(v_code_objet_tmp_1,1,INSTR(v_code_objet_tmp_1,'£')-1);
                IF v_code_objet_tmp_3 IS NOT NULL THEN
                  v_code_objet_tmp_2 := v_code_objet_tmp_2||' / '||v_code_objet_tmp_3;
                ELSE
                  v_code_objet_tmp_2 := NULL;
                END IF;
              ELSE
                v_code_objet_tmp_2 := NULL;
              END IF;
              v_code_objet_tmp_3 := 'SYS_REQUETES_JSP';
            END IF;
            IF v_code_objet_tmp_2 IS NOT NULL THEN
              ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, v_code_objet_tmp_3,v_code_objet_tmp_2,p_nom_ecran_reference,p_nom_table,p_code_objet);
            END IF;
          END IF;
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'£')+1);
        END LOOP;
      END LOOP;
    ELSIF p_nom_table='SYS_REQUETES_JSP' THEN
      -- Un appel table référence :
      --     Des données :
      FOR OBJET IN (
      --         SYS_REQUETES_JSP.NOMTABLE / SYS_REQUETES_JSP.LISTCOLAFF / SYS_REQUETES_JSP.LISTCOLSET / SYS_REQUETES_JSP.CLAUSEWHERE
        SELECT DISTINCT NOMTABLE||' '||LISTCOLAFF||' '||LISTCOLSET||' '||CLAUSEWHERE AS CODE_OBJET FROM SYS_REQUETES_JSP@RDMOD WHERE (NOMPAGE||' / '||IDREQUETE)=p_code_objet AND NOMTABLE||LISTCOLAFF||LISTCOLSET||CLAUSEWHERE LIKE '%@%'
      )
      LOOP
        v_code_objet_tmp_1 := OBJET.CODE_OBJET||'@';
        LOOP
          EXIT WHEN v_code_objet_tmp_1 IS NULL OR INSTR(v_code_objet_tmp_1,'@')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'@')+1));
          EXIT WHEN v_code_objet_tmp_2 IS NULL OR INSTR(v_code_objet_tmp_2,'@')<=0;
          v_code_objet_tmp_2 := TRIM(SUBSTR(v_code_objet_tmp_2,1,INSTR(v_code_objet_tmp_2,'@')-1));
          IF v_code_objet_tmp_2 IS NOT NULL THEN
            ALIM_OBJETS_USED_BY_OBJET(p_code_objet_init, 'REF_DONNEE_GENERALE',v_code_objet_tmp_2,p_nom_ecran_reference,p_nom_table,p_code_objet);
          END IF;
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'@')+1);
          v_code_objet_tmp_1 := SUBSTR(v_code_objet_tmp_1,INSTR(v_code_objet_tmp_1,'@')+1);
        END LOOP;
      END LOOP;
    ELSIF p_nom_table='SYS_DEF_ERREURS' THEN
      -- Une erreur ne référence rien
      NULL;
    ELSIF p_nom_table='SYS_VARSYS' THEN
      -- Une varsys ne référence rien
      NULL;
    END IF;
  END ALIM_OBJETS_USED_BY_OBJET;
  
  FUNCTION GET_OBJETS_USED_BY_OP(p_op_num VARCHAR2, is_ux NUMBER DEFAULT 0) 
  RETURN TAB_REF_OBJ_USED_BY_OBJECT 
  IS 
    PRAGMA AUTONOMOUS_TRANSACTION;
    all_op_num VARCHAR2(4000);
    tmp_op_num VARCHAR2(4000);
    retour TAB_REF_OBJ_USED_BY_OBJECT := TAB_REF_OBJ_USED_BY_OBJECT();
  BEGIN
    all_op_num := p_op_num||',';
    LOOP
      EXIT WHEN all_op_num IS NULL OR INSTR(all_op_num,',')<=0;
      tmp_op_num := SUBSTR(all_op_num,1,INSTR(all_op_num,',')-1);
      IF tmp_op_num IS NOT NULL THEN
        ALIM_OBJETS_USED_BY_OBJET(tmp_op_num, 'REF_WKF_OPERATION_ECRANS_INFO',tmp_op_num);
      END IF;
      all_op_num := SUBSTR(all_op_num,INSTR(all_op_num,',')+1);
    END LOOP;
    IF is_ux = 1 THEN
      FOR r IN (SELECT DISTINCT NOM_DONNEE FROM REF_DONNEE_MAPPING_UX@RDMOD)
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(r.NOM_DONNEE, 'REF_DONNEE_GENERALE',r.NOM_DONNEE);
      END LOOP;
    END IF;
    FOR r IN (SELECT * FROM REF_OBJ_USED_BY_OBJECT)
    LOOP
      retour.EXTEND();
      retour(retour.COUNT) := LIG_REF_OBJ_USED_BY_OBJECT(r.CODE_OBJET_INIT, r.NOM_TABLE, r.CLE_TABLE, r.CODE_OBJET, r.NOM_TABLE_PARENT, r.CODE_OBJET_PARENT_1, r.CODE_OBJET_PARENT_2);
    END LOOP;
    ROLLBACK;
   RETURN retour;
   EXCEPTION
   WHEN OTHERS THEN ROLLBACK; RETURN NULL;
  END GET_OBJETS_USED_BY_OP;
  
  FUNCTION GET_OBJETS_USED_BY_ECR(p_nom_page VARCHAR2, is_ux NUMBER DEFAULT 0) 
  RETURN TAB_REF_OBJ_USED_BY_OBJECT 
  IS 
    PRAGMA AUTONOMOUS_TRANSACTION;
    all_nom_page VARCHAR2(4000);
    tmp_nom_page VARCHAR2(4000);
    retour TAB_REF_OBJ_USED_BY_OBJECT := TAB_REF_OBJ_USED_BY_OBJECT();
  BEGIN
    all_nom_page := p_nom_page||',';
    LOOP
      EXIT WHEN all_nom_page IS NULL OR INSTR(all_nom_page,',')<=0;
      tmp_nom_page := SUBSTR(all_nom_page,1,INSTR(all_nom_page,',')-1);
      IF tmp_nom_page IS NOT NULL THEN
        ALIM_OBJETS_USED_BY_OBJET(tmp_nom_page, 'REF_ECRAN',tmp_nom_page,tmp_nom_page);
      END IF;
      all_nom_page := SUBSTR(all_nom_page,INSTR(all_nom_page,',')+1);
    END LOOP;
    IF is_ux = 1 THEN
      FOR r IN (SELECT DISTINCT NOM_DONNEE FROM REF_DONNEE_MAPPING_UX@RDMOD)
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(r.NOM_DONNEE, 'REF_DONNEE_GENERALE',r.NOM_DONNEE,tmp_nom_page);
      END LOOP;
    END IF;
    FOR r IN (SELECT * FROM REF_OBJ_USED_BY_OBJECT)
    LOOP
      retour.EXTEND();
      retour(retour.COUNT) := LIG_REF_OBJ_USED_BY_OBJECT(r.CODE_OBJET_INIT, r.NOM_TABLE, r.CLE_TABLE, r.CODE_OBJET, r.NOM_TABLE_PARENT, r.CODE_OBJET_PARENT_1, r.CODE_OBJET_PARENT_2);
    END LOOP;
    ROLLBACK;
   RETURN retour;
   EXCEPTION
   WHEN OTHERS THEN ROLLBACK; RETURN NULL;
  END GET_OBJETS_USED_BY_ECR;
  
  FUNCTION GET_OBJETS_USED_BY_GRP(p_id_groupe VARCHAR2, is_ux NUMBER DEFAULT 0) 
  RETURN TAB_REF_OBJ_USED_BY_OBJECT 
  IS 
    PRAGMA AUTONOMOUS_TRANSACTION;
    all_id_groupe VARCHAR2(4000);
    tmp_id_groupe VARCHAR2(4000);
    retour TAB_REF_OBJ_USED_BY_OBJECT := TAB_REF_OBJ_USED_BY_OBJECT();
  BEGIN
    all_id_groupe := p_id_groupe||',';
    LOOP
      EXIT WHEN all_id_groupe IS NULL OR INSTR(all_id_groupe,',')<=0;
      tmp_id_groupe := SUBSTR(all_id_groupe,1,INSTR(all_id_groupe,',')-1);
      IF tmp_id_groupe IS NOT NULL THEN
        ALIM_OBJETS_USED_BY_OBJET(tmp_id_groupe, 'REF_GROUPE_DONNEES_INFO',tmp_id_groupe);
      END IF;
      all_id_groupe := SUBSTR(all_id_groupe,INSTR(all_id_groupe,',')+1);
    END LOOP;
    IF is_ux = 1 THEN
      FOR r IN (SELECT DISTINCT NOM_DONNEE FROM REF_DONNEE_MAPPING_UX@RDMOD)
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(r.NOM_DONNEE, 'REF_DONNEE_GENERALE',r.NOM_DONNEE);
      END LOOP;
    END IF;
    FOR r IN (SELECT * FROM REF_OBJ_USED_BY_OBJECT)
    LOOP
      retour.EXTEND();
      retour(retour.COUNT) := LIG_REF_OBJ_USED_BY_OBJECT(r.CODE_OBJET_INIT, r.NOM_TABLE, r.CLE_TABLE, r.CODE_OBJET, r.NOM_TABLE_PARENT, r.CODE_OBJET_PARENT_1, r.CODE_OBJET_PARENT_2);
    END LOOP;
    ROLLBACK;
   RETURN retour;
   EXCEPTION
   WHEN OTHERS THEN ROLLBACK; RETURN NULL;
  END GET_OBJETS_USED_BY_GRP;
  
  FUNCTION GET_OBJETS_USED_BY_DON(p_nom_donnee VARCHAR2, is_ux NUMBER DEFAULT 0) 
  RETURN TAB_REF_OBJ_USED_BY_OBJECT 
  IS 
    PRAGMA AUTONOMOUS_TRANSACTION;
    all_nom_donnee VARCHAR2(4000);
    tmp_nom_donnee VARCHAR2(4000);
    retour TAB_REF_OBJ_USED_BY_OBJECT := TAB_REF_OBJ_USED_BY_OBJECT();
  BEGIN
    all_nom_donnee := p_nom_donnee||',';
    LOOP
      EXIT WHEN all_nom_donnee IS NULL OR INSTR(all_nom_donnee,',')<=0;
      tmp_nom_donnee := SUBSTR(all_nom_donnee,1,INSTR(all_nom_donnee,',')-1);
      IF tmp_nom_donnee IS NOT NULL THEN
        ALIM_OBJETS_USED_BY_OBJET(tmp_nom_donnee, 'REF_DONNEE_GENERALE',tmp_nom_donnee);
      END IF;
      all_nom_donnee := SUBSTR(all_nom_donnee,INSTR(all_nom_donnee,',')+1);
    END LOOP;
    IF is_ux = 1 THEN
      FOR r IN (SELECT DISTINCT NOM_DONNEE FROM REF_DONNEE_MAPPING_UX@RDMOD)
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(r.NOM_DONNEE, 'REF_DONNEE_GENERALE',r.NOM_DONNEE);
      END LOOP;
    END IF;
    FOR r IN (SELECT * FROM REF_OBJ_USED_BY_OBJECT)
    LOOP
      retour.EXTEND();
      retour(retour.COUNT) := LIG_REF_OBJ_USED_BY_OBJECT(r.CODE_OBJET_INIT, r.NOM_TABLE, r.CLE_TABLE, r.CODE_OBJET, r.NOM_TABLE_PARENT, r.CODE_OBJET_PARENT_1, r.CODE_OBJET_PARENT_2);
    END LOOP;
    ROLLBACK;
   RETURN retour;
   EXCEPTION
   WHEN OTHERS THEN ROLLBACK; RETURN NULL;
  END GET_OBJETS_USED_BY_DON;
  
  FUNCTION GET_OBJETS_USED_BY_REG(p_id_reglegestion VARCHAR2, is_ux NUMBER DEFAULT 0) 
  RETURN TAB_REF_OBJ_USED_BY_OBJECT 
  IS 
    PRAGMA AUTONOMOUS_TRANSACTION;
    all_id_reglegestion VARCHAR2(4000);
    tmp_id_reglegestion VARCHAR2(4000);
    retour TAB_REF_OBJ_USED_BY_OBJECT := TAB_REF_OBJ_USED_BY_OBJECT();
  BEGIN
    all_id_reglegestion := p_id_reglegestion||',';
    LOOP
      EXIT WHEN all_id_reglegestion IS NULL OR INSTR(all_id_reglegestion,',')<=0;
      tmp_id_reglegestion := SUBSTR(all_id_reglegestion,1,INSTR(all_id_reglegestion,',')-1);
      IF tmp_id_reglegestion IS NOT NULL THEN
        ALIM_OBJETS_USED_BY_OBJET(tmp_id_reglegestion, 'REF_REGLEGESTION_DESC',tmp_id_reglegestion);
      END IF;
      all_id_reglegestion := SUBSTR(all_id_reglegestion,INSTR(all_id_reglegestion,',')+1);
    END LOOP;
    IF is_ux = 1 THEN
      FOR r IN (SELECT DISTINCT NOM_DONNEE FROM REF_DONNEE_MAPPING_UX@RDMOD)
      LOOP
        ALIM_OBJETS_USED_BY_OBJET(r.NOM_DONNEE, 'REF_DONNEE_GENERALE',r.NOM_DONNEE);
      END LOOP;
    END IF;
    FOR r IN (SELECT * FROM REF_OBJ_USED_BY_OBJECT)
    LOOP
      retour.EXTEND();
      retour(retour.COUNT) := LIG_REF_OBJ_USED_BY_OBJECT(r.CODE_OBJET_INIT, r.NOM_TABLE, r.CLE_TABLE, r.CODE_OBJET, r.NOM_TABLE_PARENT, r.CODE_OBJET_PARENT_1, r.CODE_OBJET_PARENT_2);
    END LOOP;
    ROLLBACK;
   RETURN retour;
   EXCEPTION
   WHEN OTHERS THEN ROLLBACK; RETURN NULL;
  END GET_OBJETS_USED_BY_REG;
END TOOLS_V5;
##
ADD_TUILES_ACCUEIL
=SQL=
CREATE OR REPLACE PROCEDURE ADD_TUILES_ACCUEIL
AS
  CURSOR CUR_ELEMENT
  IS
    SELECT DISTINCT S.code_element,
      S.LIBELLE,
      SCH.ORDRE
    FROM SYS_SCH_ELEMENT S,
      SYS_SCH_LISTE L,
      SYS_SCHEMAS SCH
    WHERE SCH.code_schema = L.code_schema
    AND L.NOM_SCHEMA      = upper('COUGAR')
    AND sch.niveau        = 2
    AND s.niveau          =sch.niveau
    AND s.code_element    =sch.CODE_ELT
    AND S.CODE_ROLE = 3
    ORDER BY SCH.ORDRE;
  v_exist NUMBER :=0;
  v_CODE_REGROUP SYS_ACCUEIL.CODE_REGROUP%TYPE;
  v_ACTIF SYS_ACCUEIL.ACTIF%TYPE;
BEGIN
  FOR C IN CUR_ELEMENT
  LOOP
    BEGIN
      SELECT 1,
        CODE_REGROUP,
        ACTIF
      INTO v_exist,
        v_CODE_REGROUP,
        v_ACTIF
      FROM SYS_ACCUEIL
      WHERE TYPE_CADRE = -6
      AND CODE_REGROUP =C.CODE_ELEMENT;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_exist :=0;
    END ;
    IF (v_exist=1 AND v_ACTIF='O') THEN
      INSERT
      INTO SYS_ACCUEIL
        (
          LOGIN,
          CODE_REGROUP,
          CODE_CADRE,
          ACTIF,
          LIBELLE,
          TYPE_CADRE,
          ETENDU
        )
      SELECT '*',
        C.CODE_ELEMENT,
        (SELECT
          (SELECT NVL(MAX(CODE_CADRE),0)
          FROM SYS_ACCUEIL
          WHERE CODE_REGROUP = C.CODE_ELEMENT
          ) + 1
        FROM dual
        ),
        AVEC_WKF,
        'Tâches en attente',
        -21,
        'N'
      FROM SYS_ACCUEIL_ACTIONS
      WHERE CODE_REGROUP = C.CODE_ELEMENT;
      INSERT
      INTO SYS_ACCUEIL
        (
          LOGIN,
          CODE_REGROUP,
          CODE_CADRE,
          ACTIF,
          LIBELLE,
          TYPE_CADRE,
          ETENDU
        )
      SELECT '*',
        C.CODE_ELEMENT,
        (SELECT
          (SELECT NVL(MAX(CODE_CADRE),0)
          FROM SYS_ACCUEIL
          WHERE CODE_REGROUP = C.CODE_ELEMENT
          ) + 1
        FROM dual
        ),
        AVEC_SUIVI,
        'Demandes en cours',
        -22,
        'N'
      FROM SYS_ACCUEIL_ACTIONS
      WHERE CODE_REGROUP = C.CODE_ELEMENT;
    ELSE
      INSERT
      INTO SYS_ACCUEIL
        (
          LOGIN,
          CODE_REGROUP,
          CODE_CADRE,
          ACTIF,
          LIBELLE,
          TYPE_CADRE,
          ETENDU
        )
        VALUES
        (
          '*',
          C.CODE_ELEMENT,
          (SELECT
            (SELECT NVL(MAX(CODE_CADRE),0)
            FROM SYS_ACCUEIL
            WHERE CODE_REGROUP = C.CODE_ELEMENT
            ) + 1
          FROM dual
          ),
          'N',
          'Tâches en attente',
          -21,
          'N'
        );
      INSERT
      INTO SYS_ACCUEIL
        (
          LOGIN,
          CODE_REGROUP,
          CODE_CADRE,
          ACTIF,
          LIBELLE,
          TYPE_CADRE,
          ETENDU
        )
        VALUES
        (
          '*',
          C.CODE_ELEMENT,
          (SELECT
            (SELECT NVL(MAX(CODE_CADRE),0)
            FROM SYS_ACCUEIL
            WHERE CODE_REGROUP = C.CODE_ELEMENT
            ) + 1
          FROM dual
          ),
          'N',
          'Demandes en cours',
          -22,
          'N'
        );
    END IF;
  END LOOP;
END ADD_TUILES_ACCUEIL;
##
TAG_CHARSET=@€éèç
##
ADM_ADD_OR_UPDATE_VARSYS
=SQL=
CREATE OR REPLACE PROCEDURE "ADM_ADD_OR_UPDATE_VARSYS" (
pMODULE IN VARCHAR2,
pCODVAR IN VARCHAR2,
pVALVAR IN VARCHAR2,
pTYPVAR IN VARCHAR2,
pDESCRIPTION IN VARCHAR2)
IS
varsysok NUMBER;
BEGIN
/*
* Cette procédure permet de créer une nouvelle entrée dans la table SYS_VARSYS.
* Dans le cas où la varsys n'existe pas elle sera alors crée.
* Si cette variable existe déjà, dans ce cas, uniquement sa description sera mise à jour.
*/
SELECT COUNT (*)
INTO varsysok
FROM SYS_VARSYS
WHERE MODULE = pMODULE AND CODVAR = pCODVAR;
IF (varsysok = 0) THEN
INSERT INTO SYS_VARSYS(MODULE, CODVAR, VALVAR, TYPVAR, DESCRIPTION)
VALUES (pMODULE, pCODVAR, pVALVAR, pTYPVAR, pDESCRIPTION);
ELSE
UPDATE SYS_VARSYS SET DESCRIPTION = pDESCRIPTION WHERE CODVAR = pCODVAR and MODULE = pMODULE;
END IF;
END ADM_ADD_OR_UPDATE_VARSYS;##
ADM_ADD_PAGE_IN_SCHEMA
=SQL=
create or replace PROCEDURE ADM_ADD_PAGE_IN_SCHEMA( p_code_schema             IN NUMBER,
 p_lib_1                   IN VARCHAR2,
 p_lib_2                   IN VARCHAR2,
 p_lib_3                   IN VARCHAR2,
 p_lib_4                   IN VARCHAR2,
 p_lib_99                  IN VARCHAR2,
 p_nom_page                IN VARCHAR2,
 p_description             IN VARCHAR2,
 code_langue               IN VARCHAR2,
 p_code_role               IN NUMBER DEFAULT NULL)
 
 IS
 p_obj_application         SCH_ELEMENT;
 p_obj_regroupement        SCH_ELEMENT;
 p_obj_theme               SCH_ELEMENT;
 p_obj_classeur            SCH_ELEMENT;
 p_obj_sujet               SCH_ELEMENT;
 
 
 BEGIN
 IF ((p_lib_1 IS NULL) OR (p_lib_2 IS NULL) OR (p_lib_3 IS NULL) OR (p_lib_4 IS NULL) OR (p_lib_99 IS NULL) OR (p_nom_page IS NULL)) THEN
 RAISE_APPLICATION_ERROR(-20001, 'Paramètre(s) invalide(s)');
 END IF;
 
 IF (ADM_PAGE_EXIST_IN_SCHEMA(p_nom_page, p_code_schema) != 0) THEN
 RAISE_APPLICATION_ERROR(-20001, 'La page est déjà présente dans ce schéma');
 END IF;
 
 p_obj_application := ADM_ADD_SCH_APPLICATION(p_code_schema, p_lib_1,p_description, code_langue);
 p_obj_regroupement := ADM_ADD_SCH_REGROUPEMENT(p_code_schema, p_lib_1, p_lib_2, p_obj_application,p_description, p_code_role, code_langue);
 p_obj_theme := ADM_ADD_SCH_THEME(p_code_schema, p_lib_1, p_lib_2, p_lib_3, p_obj_regroupement,p_description, code_langue);
 p_obj_classeur := ADM_ADD_SCH_CLASSEUR(p_code_schema, p_lib_1, p_lib_2, p_lib_3, p_lib_4, p_obj_theme,p_description, code_langue);
 p_obj_sujet := ADM_ADD_SCH_SUJET(p_code_schema, p_lib_1, p_lib_2, p_lib_3, p_lib_4, p_lib_99, p_nom_page, p_obj_classeur,p_description, code_langue);
 
 END ADM_ADD_PAGE_IN_SCHEMA;
 ##
TAG_CHARSET=@€éèç
##
ADM_CHANGE_NOM_PAGE
=SQL=
create or replace
PROCEDURE ADM_CHANGE_NOM_PAGE (old_nom_page VARCHAR2, new_nom_page VARCHAR2)
IS
  BEGIN
  	 UPDATE sys_sch_element SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE sys_sch_PROFIL_MI SET page_mo_interdite = new_nom_page WHERE page_mo_interdite = old_nom_page;
     DELETE FROM sys_sch_PROFIL_OP_PAGE p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM sys_sch_PROFIL_OP_PAGE p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page));
     UPDATE sys_sch_PROFIL_OP_PAGE SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM sys_sch_PROFIL_P p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM sys_sch_PROFIL_P p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page) AND p1.CODE_PROFIL = p2.CODE_PROFIL GROUP BY CODE_PROFIL HAVING COUNT(NOM_PAGE) > 1 );
     UPDATE sys_sch_PROFIL_P SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE UX_BRIDGING SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_SCH_JSON p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_SCH_JSON p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page) AND p1.NOM_JSON = p2.NOM_JSON GROUP BY NOM_JSON HAVING COUNT(NOM_PAGE) > 1 );
     UPDATE sys_sch_json SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_SCH_PAGE_INITIALIZER p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_SCH_PAGE_INITIALIZER p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page));
     UPDATE SYS_SCH_PAGE_INITIALIZER SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE DEL_FONCTIONMETIER SET ID_ECRANPROCESSUS = new_nom_page WHERE ID_ECRANPROCESSUS = old_nom_page;
     UPDATE REQ_INDEX_PAGES SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE GA_CC_ONGLETS SET PAGE_ONGLET = new_nom_page WHERE PAGE_ONGLET = old_nom_page;
     UPDATE GAP_EPP_LIENS SET nompage = new_nom_page WHERE nompage = old_nom_page;
     UPDATE STD_LHW_DONNEE SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE SYS_ACC_REG_LIEN SET lien = new_nom_page WHERE lien = old_nom_page;
     UPDATE SYS_ALERTES SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE SYS_ALERTES SET nom_page1 = new_nom_page WHERE nom_page1 = old_nom_page;
     UPDATE SYS_ALERTES SET nom_page2 = new_nom_page WHERE nom_page2 = old_nom_page;
     UPDATE ALERT_REDIRECT SET page_uri = new_nom_page WHERE page_uri = old_nom_page;
     DELETE FROM SYS_LOCK_MODULE p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_LOCK_MODULE p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page));
     UPDATE SYS_LOCK_MODULE SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_PAGES_MODAL p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_PAGES_MODAL p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page));
     UPDATE SYS_PAGES_MODAL SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_PAGES_MODAL_ML p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_PAGES_MODAL_ML p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page) AND p1.CODLANG = p2.CODLANG GROUP BY CODLANG  HAVING COUNT(NOM_PAGE) > 1 );
     UPDATE SYS_PAGES_MODAL_ML SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_PAGES_MODAL_RESTRICTION p1 WHERE NOM_PAGE_BUR_LIEE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE_BUR_LIEE) as NB FROM SYS_PAGES_MODAL_RESTRICTION p2 WHERE NOM_PAGE_BUR_LIEE IN (old_nom_page,new_nom_page) AND p1.NOM_PAGE_MODALE = p2.NOM_PAGE_MODALE GROUP BY NOM_PAGE_MODALE HAVING COUNT(NOM_PAGE_BUR_LIEE) > 1 );
     UPDATE SYS_PAGES_MODAL_RESTRICTION SET NOM_PAGE_BUR_LIEE = new_nom_page WHERE NOM_PAGE_BUR_LIEE = old_nom_page;
     DELETE FROM SYS_PAGES_MODAL_RESTRICTION p1 WHERE NOM_PAGE_MODALE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE_MODALE) as NB FROM SYS_PAGES_MODAL_RESTRICTION p2 WHERE NOM_PAGE_MODALE IN (old_nom_page,new_nom_page) AND p1.NOM_PAGE_BUR_LIEE = p2.NOM_PAGE_BUR_LIEE GROUP BY NOM_PAGE_BUR_LIEE HAVING COUNT(NOM_PAGE_MODALE) > 1 ) AND NOM_PAGE_BUR_LIEE NOT IN (SELECT NOM_PAGE_BUR_LIEE FROM SYS_PAGES_MODAL_RESTRICTION WHERE NOM_PAGE_MODALE = new_nom_page );
     UPDATE SYS_PAGES_MODAL_RESTRICTION SET NOM_PAGE_MODALE = new_nom_page WHERE NOM_PAGE_MODALE = old_nom_page AND NOM_PAGE_BUR_LIEE NOT IN (SELECT NOM_PAGE_BUR_LIEE FROM SYS_PAGES_MODAL_RESTRICTION WHERE NOM_PAGE_MODALE = new_nom_page ) ;
     DELETE FROM SYS_SCH_DASHBOARD p1 WHERE NOM_PAGE = old_nom_page AND 1 < (SELECT COUNT(NOM_PAGE) as NB FROM SYS_SCH_DASHBOARD p2 WHERE NOM_PAGE IN (old_nom_page,new_nom_page) AND p1.LOGIN = p2.LOGIN GROUP BY LOGIN HAVING COUNT(NOM_PAGE) > 1 );
     UPDATE SYS_SCH_DASHBOARD SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_SCH_ECRANLOGIQUE p1 WHERE NOMPAGE = old_nom_page AND 1 < (SELECT COUNT(NOMPAGE) as NB FROM SYS_SCH_ECRANLOGIQUE p2 WHERE NOMPAGE IN (old_nom_page,new_nom_page) AND p1.NOMPAGESUIV = p2.NOMPAGESUIV GROUP BY NOMPAGESUIV HAVING COUNT(NOMPAGE) > 1 );
     UPDATE SYS_SCH_ECRANLOGIQUE SET nompage = new_nom_page WHERE nompage = old_nom_page;
     DELETE FROM SYS_SCH_ECRANLOGIQUE p1 WHERE NOMPAGESUIV = old_nom_page AND 1 < (SELECT COUNT(NOMPAGESUIV) as NB FROM SYS_SCH_ECRANLOGIQUE p2 WHERE NOMPAGESUIV IN (old_nom_page,new_nom_page) AND p1.NOMPAGE = p2.NOMPAGE GROUP BY NOMPAGE HAVING COUNT(NOMPAGESUIV) > 1 );
     UPDATE SYS_SCH_ECRANLOGIQUE SET NOMPAGESUIV = new_nom_page WHERE NOMPAGESUIV = old_nom_page;
     UPDATE SYS_USR_FAVORIS SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     DELETE FROM SYS_AIDE_DYN_2 p1 WHERE UPPER(SUJET) = UPPER(old_nom_page) AND SUJET <> UPPER(old_nom_page) AND 1 < (SELECT COUNT(SUJET) FROM SYS_AIDE_DYN_2 p2 WHERE UPPER(SUJET) = UPPER(old_nom_page) GROUP BY TYPE,CODLANG HAVING COUNT(SUJET) > 1 );
     DELETE FROM SYS_AIDE_DYN_2 p1 WHERE UPPER(SUJET) = UPPER(new_nom_page) AND SUJET <> UPPER(new_nom_page) AND 1 < (SELECT COUNT(SUJET) FROM SYS_AIDE_DYN_2 p2 WHERE UPPER(SUJET) = UPPER(new_nom_page) GROUP BY TYPE,CODLANG HAVING COUNT(SUJET) > 1 );
     UPDATE SYS_AIDE_DYN_2 p1 SET SUJET = UPPER(old_nom_page) WHERE UPPER(SUJET) = UPPER(old_nom_page) AND UPPER(SUJET) <> SUJET AND CODLANG =  CODLANG AND TYPE = TYPE;
     UPDATE SYS_AIDE_DYN_2 p1 SET SUJET = UPPER(new_nom_page) WHERE UPPER(SUJET) = UPPER(new_nom_page) AND UPPER(SUJET) <> SUJET AND CODLANG =  CODLANG AND TYPE = TYPE;
     DELETE FROM SYS_AIDE_DYN_2 p1 WHERE SUJET = UPPER(old_nom_page) AND 1 < ( SELECT COUNT(SUJET) as NB FROM SYS_AIDE_DYN_2 p2 WHERE SUJET IN (UPPER(old_nom_page),UPPER(new_nom_page)) AND p1.CODLANG = p2.CODLANG AND p1.TYPE = p2.TYPE GROUP BY CODLANG HAVING COUNT(SUJET) > 1);
     UPDATE SYS_AIDE_DYN_2 SET sujet = UPPER(new_nom_page) WHERE UPPER(sujet) = UPPER(old_nom_page);
     DELETE FROM AIDE_DYNAMIQUE_2 p1 WHERE UPPER(SUJET) = UPPER(old_nom_page) AND SUJET <> UPPER(old_nom_page) AND 1 < (SELECT COUNT(SUJET) FROM AIDE_DYNAMIQUE_2 p2 WHERE UPPER(SUJET) = UPPER(old_nom_page) GROUP BY TYPE,CODLANG HAVING COUNT(SUJET) > 1 );
     DELETE FROM AIDE_DYNAMIQUE_2 p1 WHERE UPPER(SUJET) = UPPER(new_nom_page) AND SUJET <> UPPER(new_nom_page) AND 1 < (SELECT COUNT(SUJET) FROM AIDE_DYNAMIQUE_2 p2 WHERE UPPER(SUJET) = UPPER(new_nom_page) GROUP BY TYPE,CODLANG HAVING COUNT(SUJET) > 1 );
     UPDATE AIDE_DYNAMIQUE_2 p1 SET SUJET = UPPER(old_nom_page) WHERE UPPER(SUJET) = UPPER(old_nom_page) AND UPPER(SUJET) <> SUJET AND CODLANG =  CODLANG AND TYPE = TYPE;
     UPDATE AIDE_DYNAMIQUE_2 p1 SET SUJET = UPPER(new_nom_page) WHERE UPPER(SUJET) = UPPER(new_nom_page) AND UPPER(SUJET) <> SUJET AND CODLANG =  CODLANG AND TYPE = TYPE;
     DELETE FROM AIDE_DYNAMIQUE_2 p1 WHERE SUJET = UPPER(old_nom_page) AND 1 < ( SELECT COUNT(SUJET) as NB FROM AIDE_DYNAMIQUE_2 p2 WHERE SUJET IN (UPPER(old_nom_page),UPPER(new_nom_page)) AND p1.CODLANG = p2.CODLANG AND p1.TYPE = p2.TYPE GROUP BY CODLANG HAVING COUNT(SUJET) > 1);
     UPDATE AIDE_DYNAMIQUE_2 SET sujet = UPPER(new_nom_page) WHERE UPPER(sujet) = UPPER(old_nom_page);
     update SYS_AFF_BOUTON_BANDEAU SET nom_page = new_nom_page WHERE nom_page = old_nom_page;
     UPDATE STD_LHW_THEME_PAGE set NOM_PAGE = new_nom_page WHERE NOM_PAGE = old_nom_page;
  	 COMMIT ;  
END ADM_CHANGE_NOM_PAGE;
##
ADM_CREATE_NOM_PAGE
=SQL=
create or replace PROCEDURE ADM_CREATE_NOM_PAGE( p_NIVEAU    IN NUMBER,
 p_LIBELLE   IN VARCHAR2,
 p_NOM_PAGE  IN VARCHAR2,
 p_CODE_ROLE IN NUMBER,
 isRD        IN VARCHAR2)
 IS
 p_code_element NUMBER;
 countnompage   NUMBER:=0;
 countlibelle   NUMBER:=0;
  libelle50   varchar2(50):='';
 BEGIN
 IF LENGTH(p_LIBELLE) > 50 THEN
 libelle50 := SUBSTR(p_LIBELLE,0,47)||'...';
 ELSE 
 libelle50 := p_LIBELLE;
 END IF ;
 IF p_niveau=99 THEN
 SELECT COUNT(*)
 INTO countnompage
 FROM SYS_SCH_ELEMENT
 WHERE niveau=p_niveau
 AND nom_page=p_nom_page;
 ELSE
 SELECT COUNT(*)
 INTO countlibelle
 FROM SYS_SCH_ELEMENT
 WHERE niveau=p_niveau
 AND libelle =libelle50;
 END IF;
 IF (p_niveau=99 AND countnompage>0) THEN
 UPDATE SYS_SCH_ELEMENT
 SET libelle   =libelle50,
 code_role   =p_code_role
 WHERE niveau  =p_niveau
 AND nom_page  =p_nom_page;
 elsif (p_niveau<>99 AND countlibelle>0) THEN
 UPDATE SYS_SCH_ELEMENT
 SET nom_page=p_nom_page,
 code_role =p_code_role
 WHERE niveau=p_niveau
 AND libelle =libelle50;
 ELSE
 IF isRD='true' THEN
 SELECT MIN(code_element)-1
 INTO p_code_element
 FROM SYS_SCH_ELEMENT
 WHERE niveau=p_niveau;
 INSERT
 INTO SYS_SCH_ELEMENT
 (
 NIVEAU,
 CODE_ELEMENT,
 LIBELLE,
 NOM_PAGE,
 CODE_ROLE
 )
 VALUES
 (
 p_NIVEAU,
 p_CODE_ELEMENT,
 libelle50,
 p_NOM_PAGE,
 p_CODE_ROLE
 );
 ELSE
 SELECT MAX(code_element)+1
 INTO p_code_element
 FROM SYS_SCH_ELEMENT
 WHERE niveau=p_niveau;
 INSERT
 INTO SYS_SCH_ELEMENT
 (
 NIVEAU,
 CODE_ELEMENT,
 LIBELLE,
 NOM_PAGE,
 CODE_ROLE
 )
 VALUES
 (
 p_NIVEAU,
 p_CODE_ELEMENT,
 libelle50,
 p_NOM_PAGE,
 p_CODE_ROLE
 );
 END IF;
 END IF;
 END ADM_CREATE_NOM_PAGE;
 ##
ADM_NEWPAGE_SYS_SCHEMAS
=SQL=
CREATE OR REPLACE PROCEDURE adm_newpage_sys_schemas (
    p_nom_page           IN   VARCHAR2,
    p_nom_page_exemple   IN   VARCHAR2
) IS

    p_code_schema            NUMBER := -1;
    p_niveau                 NUMBER;
    p_niveau_exemple         NUMBER;
    p_code_element           NUMBER;
    p_code_element_exemple   NUMBER;
    p_code_asso_pere         NUMBER;
    p_code_asso              NUMBER;
    p_count_exemple          NUMBER;
    p_count                  NUMBER;
    p_ordre                  NUMBER;
    count_code_elt           NUMBER := 0;
    count_code_elt_exemple   NUMBER := 0;
    
BEGIN
     --Vérification existance page exemple dans sys_sch_element
    SELECT
        count(*)
    INTO p_count_exemple
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page_exemple;
    
    IF p_count_exemple = 0 THEN
       RETURN ;
    END IF ;
    
    --Vérification existance page à insérer dans sys_sch_element
    SELECT
        count(*)
    INTO p_count
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page;
    
    IF p_count = 0 THEN
        raise_application_error(-20001, 'la page '||p_nom_page||' n''existe pas dans la table SYS_SCH_ELEMENT ');
    END IF;   

    
    --Vérification du niveau de la page exemple
    SELECT
        min(niveau)
    INTO p_niveau_exemple
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page_exemple;
    
    IF p_niveau_exemple <> 99 THEN
        raise_application_error(-20001, 'Le code niveau '||p_nom_page_exemple||' ne correspond pas à 99');
    END IF;
    
    --Vérification  du niveau de la page
    SELECT
        min(niveau)
    INTO p_niveau
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page;

    IF p_niveau <> 99 THEN
        raise_application_error(-20001, 'Le code niveau '||p_nom_page||' ne correspond pas à 99');
    END IF;
    
    --Récupération du code element de la page à insérer
    SELECT
        MIN(code_element)
    INTO p_code_element
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page;
    
    --Récupération du code element de la page exemple
    SELECT
        MIN(code_element)
    INTO p_code_element_exemple
    FROM
        sys_sch_element
    WHERE
        nom_page = p_nom_page_exemple
        AND niveau = 99;

    --Vérification de la présence de la page dans le schéma
    SELECT
        COUNT(*)
    INTO count_code_elt
    FROM
        sys_schemas
    WHERE
        niveau = 99
    AND code_elt = p_code_element;
    
    --Vérification de la présence de la page exemple dans le schéma
    SELECT
        COUNT(*)
    INTO count_code_elt_exemple
    FROM
        sys_schemas
    WHERE
        niveau = 99
    AND code_elt = p_code_element_exemple;
    
    -- Si la page existe déjà dans le schéma ou si  la page exemple n'existe pas : ne rien insérer
    IF(count_code_elt_exemple > 0 AND count_code_elt = 0  ) THEN
    --Récupération du code asso pere de la page exemple
    SELECT
        code_asso_pere
    INTO p_code_asso_pere
    FROM
        sys_schemas
    WHERE
        code_elt = p_code_element_exemple
    AND niveau = 99;
    
    --Calcul de l'ordre de la page dans le classeur
        SELECT
            MAX(ordre) + 1
        INTO p_ordre
        FROM
            sys_schemas
        WHERE
            code_asso_pere = p_code_asso_pere;

    --Calcul d'un nouveau code asso 
        SELECT
            MAX(code_asso) + 1
        INTO p_code_asso
        FROM
            sys_schemas;
    --Insertion de la page dans le schéma
        INSERT INTO sys_schemas (
            code_schema,
            code_asso,
            code_asso_pere,
            code_elt,
            niveau,
            ordre
        ) VALUES (
            p_code_schema,
            p_code_asso,
            p_code_asso_pere,
            p_code_element,
            p_niveau,
            p_ordre
        );
     END IF ;   
END adm_newpage_sys_schemas;
##
TAG_CHARSET=@€éèç
##
ADM_SUPPRIME_NOM_PAGE
=SQL=
CREATE OR REPLACE
PROCEDURE ADM_SUPPRIME_NOM_PAGE(
    p_nom_page VARCHAR2)
IS
BEGIN
  DELETE
  FROM sys_schemas
  WHERE (niveau,code_elt) IN
    (SELECT niveau, code_element FROM sys_sch_element WHERE nom_page = p_nom_page
    );
  DELETE FROM sys_sch_element WHERE nom_page = p_nom_page;
  DELETE FROM sys_sch_PROFIL_MI WHERE page_mo_interdite = p_nom_page;
  DELETE FROM sys_sch_PROFIL_OP_PAGE WHERE nom_page = p_nom_page;
  DELETE FROM sys_sch_PROFIL_P WHERE nom_page = p_nom_page;
  DELETE FROM UX_BRIDGING WHERE nom_page = p_nom_page;
  DELETE FROM sys_sch_json WHERE nom_page = p_nom_page;
  DELETE FROM DEL_FONCTIONMETIER WHERE ID_ECRANPROCESSUS = p_nom_page;
  DELETE FROM REQ_INDEX_PAGES WHERE nom_page = p_nom_page;
  DELETE FROM GA_CC_ONGLETS WHERE PAGE_ONGLET = p_nom_page;
  DELETE FROM GAP_EPP_LIENS WHERE nompage = p_nom_page;
  UPDATE STD_LHW_DONNEE SET nom_page=NULL WHERE nom_page = p_nom_page;
  DELETE FROM SYS_ACC_REG_LIEN WHERE lien = p_nom_page;
  UPDATE SYS_ALERTES SET nom_page=NULL WHERE nom_page = p_nom_page;
  UPDATE SYS_ALERTES SET nom_page1=NULL WHERE nom_page1 = p_nom_page;
  UPDATE SYS_ALERTES SET nom_page2=NULL WHERE nom_page2 = p_nom_page;
  DELETE FROM SYS_LOCK_MODULE WHERE nom_page = p_nom_page;
  DELETE FROM SYS_PAGES_MODAL WHERE nom_page = p_nom_page;
  DELETE FROM SYS_PAGES_MODAL_ML WHERE nom_page = p_nom_page;
  DELETE FROM SYS_PAGES_MODAL_RESTRICTION WHERE NOM_PAGE_BUR_LIEE = p_nom_page;
  DELETE FROM SYS_PAGES_MODAL_RESTRICTION WHERE NOM_PAGE_MODALE = p_nom_page;
  DELETE FROM SYS_SCH_DASHBOARD WHERE nom_page = p_nom_page;
  DELETE FROM SYS_SCH_ECRANLOGIQUE WHERE nompage = p_nom_page;
  DELETE FROM SYS_SCH_ECRANLOGIQUE WHERE NOMPAGESUIV = p_nom_page;
  DELETE FROM SYS_USR_FAVORIS WHERE nom_page = p_nom_page;
  DELETE FROM SYS_AIDE_DYN_2 WHERE UPPER(sujet) = UPPER(p_nom_page);
  DELETE FROM AIDE_DYNAMIQUE_2 WHERE UPPER(sujet) = UPPER(p_nom_page);
  DELETE FROM STD_LHW_THEME_PAGE WHERE NOM_PAGE = p_nom_page;
  COMMIT ;
END ADM_SUPPRIME_NOM_PAGE;
##
ALIM_IDX_COMPARE_CONTRAT
=SQL IF_PROCEDURE_EXIST=ALIM_IDX_COMPARE_CONTRAT=
DROP PROCEDURE ALIM_IDX_COMPARE_CONTRAT##
ALIM_IDX_COMPARE_CONTRAT_HISTO
=SQL IF_PROCEDURE_EXIST=ALIM_IDX_COMPARE_CONTRAT_HISTO=
DROP PROCEDURE ALIM_IDX_COMPARE_CONTRAT_HISTO##
TAG_CHARSET=@€éèç
##
ALIM_PAIEMENT_TIERS
=SQL=
CREATE OR REPLACE PROCEDURE ALIM_PAIEMENT_TIERS (p_NumpacCible VARCHAR2) AS
 v_requete CLOB;
 v_periode VARCHAR2(6);
 v_statut VARCHAR2(1);
 v_requete_maj_statut CLOB;
 v_tableExiste NUMBER;
 v_MPE VARCHAR2(1);
 
 BEGIN
 -- Initialisation de la période et du statut de la campagne à I
 --select PERIODEENCOURS into v_periode FROM TGE_REF_PAC where NUMPAC = p_NumpacCible;
 select TO_CHAR(max(PERIODEPAIE),'YYYYMM') into v_periode from DIC_TGE_RESPAIE_RUBRIQUE where NUMPAC= p_NumpacCible;
 v_statut := 'I';
 v_requete_maj_statut := 'Update TIERS_PILOTAGE set STATUT = :1 where NUMPAC = '''||p_NumpacCible||''' AND PERIODE = TO_DATE ('||v_periode||',''YYYYMM'')';
 
 
 -- Insertion dans la table de pilotage de la campagne en cours
 DELETE TIERS_PILOTAGE WHERE NUMPAC = p_NumpacCible AND PERIODE = TO_DATE (v_periode,'YYYYMM');
 INSERT INTO TIERS_PILOTAGE (NUMPAC,PERIODE,STATUT,SAISIE_BLOQUE_OPP,SAISIE_BLOQUE_PEN) VALUES (p_NumpacCible, TO_DATE (v_periode,'YYYYMM'),v_statut,'O','O');
 COMMIT;
 
 -- Suppression des lignes pour le numpac cible à la période en cours
 DELETE from DIC_PAIEMENT_TIERS where TIERS_NUMPAC = p_NumpacCible AND TIERS_MOIS_PAIE = TO_DATE (v_periode,'YYYYMM');
 
 
 -- Insertion des Oppositions en mode de paiement Virement pour le numpac cible à la période en cours
 BEGIN
 Insert into DIC_PAIEMENT_TIERS (
 TIERS_MOIS_PAIE,
 TIERS_TYPE,
 TIERS_NUMPAC,
 TIERS_MATRIC,
 TIERS_PACMAT,
 TIERS_PAIEZAD,
 TIERS_NOM,
 TIERS_PRENOM,
 TIERS_CODSTE,
 TIERS_CODETB,
 TIERS_CODE_BQE,
 TIERS_NUMERO,
 TIERS_NUM_DOS,
 TIERS_CODRUB,
 TIERS_LIBELLE,
 TIERS_MONTANT,
 TIERS_ACTIF,
 TIERS_BENEFICIAIRE,
 TIERS_DOM_BQE,
 TIERS_IBAN,
 TIERS_BIC,
 TIERS_POP_GFF)
 
 (select
 to_date(v_periode,'YYYYMM'),
 'O',
 TGE_REF_PAC.NUMPAC,
 DIC_TGE_OPPOSITIONS.MATRIC,
 DIC_TGE_OPPOSITIONS.PACMAT,
 DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD,
 SECUPACMAT.NOM,
 SECUPACMAT.PRENOM,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSSJ,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSCE,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSBE,
 DIC_TGE_OPPOSITIONS.NUM_OPPOSITION,
 DIC_TGE_OPPOSITIONS.NUM_DOSS_OPPOSITION,
 DIC_TGE_RESPAIE_RUBRIQUE.CODERUB,
 DIC_TGE_OPPOSITIONS.LIB_COMP_OPPOSITION,
 ABS(DIC_TGE_RESPAIE_RUBRIQUE.MONTANT),
 'O',
 DIC_TGE_OPPOSITIONS.NOM_BENEFICIAIRE,
 DIC_TGE_OPPOSITIONS.DOMICILIATION_BANQUE,
 DIC_TGE_OPPOSITIONS.CODE_PAYS_IBAN||CLE_IBAN||CODE_IBAN2||CODE_IBAN3||CODE_IBAN4||CODE_IBAN5||CODE_IBAN6||CODE_IBAN7||CODE_IBAN8||CODE_IBAN9,
 DIC_TGE_OPPOSITIONS.BIC_OPPOSITION,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSPOP
 FROM TGE_REF_PAC
 join TIERS_RUB_TRANSCO on TGE_REF_PAC.NUMPAC = TIERS_RUB_TRANSCO.NUMPAC
 join (select rub.numpac,max(rub.paiezad) as paiezad,rub.pacmat,rub.periodepaie,rub.coderub,sum(rub.montant) as montant from DIC_TGE_RESPAIE_RUBRIQUE rub where rub.montant<0 group by (rub.numpac,rub.pacmat,rub.periodepaie,rub.coderub)) DIC_TGE_RESPAIE_RUBRIQUE on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=TGE_REF_PAC.NUMPAC AND TO_CHAR(DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE,'YYYYMM')=v_periode AND DIC_TGE_RESPAIE_RUBRIQUE.CODERUB = TIERS_RUB_TRANSCO.CODRUB
 join DIC_TGE_OPPOSITIONS on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=DIC_TGE_OPPOSITIONS.NUMPAC AND DIC_TGE_RESPAIE_RUBRIQUE.PACMAT=DIC_TGE_OPPOSITIONS.PACMAT AND TO_NUMBER(DIC_TGE_OPPOSITIONS.NUM_OPPOSITION) = TO_NUMBER(TIERS_RUB_TRANSCO.NUMERO)
 join SECUPACMAT on SECUPACMAT.NUMPAC=TGE_REF_PAC.NUMPAC AND SECUPACMAT.PACMAT=DIC_TGE_OPPOSITIONS.PACMAT
 join DIC_TGE_RESPAIE_HISTO on DIC_TGE_RESPAIE_HISTO.NUMPAC = DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC AND DIC_TGE_RESPAIE_HISTO.PAIEZAD=DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD AND DIC_TGE_RESPAIE_HISTO.DTDEB_HISTO=DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE 
 WHERE
 MODE_OPPOSITION = 'V' AND DIC_TGE_RESPAIE_RUBRIQUE.MONTANT<0 AND TIERS_RUB_TRANSCO.TYPE = 'O' AND TGE_REF_PAC.NUMPAC = p_NumpacCible);
 
 --si plantage on met le statut de la campagne à jours en E (Erreur) et on arrete le traitement
 EXCEPTION
 WHEN OTHERS
 THEN
 v_statut := 'E';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 COMMIT;
 RAISE;
 END;
 
 -- Insertion des Pensions 1 en mode de paiement Virement pour le numpac cible à la période en cours
 BEGIN
 Insert into DIC_PAIEMENT_TIERS (
 TIERS_MOIS_PAIE,
 TIERS_TYPE,
 TIERS_NUMPAC,
 TIERS_MATRIC,
 TIERS_PACMAT,
 TIERS_PAIEZAD,
 TIERS_NOM,
 TIERS_PRENOM,
 TIERS_CODSTE,
 TIERS_CODETB,
 TIERS_CODE_BQE,
 TIERS_NUMERO,
 TIERS_CODRUB,
 TIERS_MONTANT,
 TIERS_ACTIF,
 TIERS_BENEFICIAIRE,
 TIERS_DOM_BQE,
 TIERS_IBAN,
 TIERS_BIC,
 TIERS_POP_GFF)
 
 (select
 to_date(v_periode,'YYYYMM'),
 'P',
 TGE_REF_PAC.NUMPAC,
 DIC_PENSION.MATRIC,
 DIC_PENSION.PACMAT,
 DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD,
 SECUPACMAT.NOM,
 SECUPACMAT.PRENOM,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSSJ,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSCE,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSBE,
 TIERS_RUB_TRANSCO.NUMERO,
 DIC_TGE_RESPAIE_RUBRIQUE.CODERUB,
 ABS(DIC_TGE_RESPAIE_RUBRIQUE.MONTANT),
 'O',
 NVL(DIC_PENSION.NOM1_PEN || ' ' || DIC_PENSION.PRENOM1_PEN,DIC_PENSION.ORGA_1) ,
 DIC_PENSION.LIBQE_PEN,
 DIC_PENSION.IBAPA_PEN||IBACC_PEN||IBA21_PEN||IBA31_PEN||IBA41_PEN||IBA51_PEN||IBA61_PEN||IBA71_PEN||IBA81_PEN||IBA91_PEN,
 DIC_PENSION.BIC1_PEN,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSPOP
 FROM TGE_REF_PAC
 join TIERS_RUB_TRANSCO on TGE_REF_PAC.NUMPAC = TIERS_RUB_TRANSCO.NUMPAC
 join (select rub.numpac,max(rub.paiezad) as paiezad,rub.pacmat,rub.periodepaie,rub.coderub,sum(rub.montant) as montant from DIC_TGE_RESPAIE_RUBRIQUE rub where rub.montant<0 group by (rub.numpac,rub.pacmat,rub.periodepaie,rub.coderub))DIC_TGE_RESPAIE_RUBRIQUE on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=TGE_REF_PAC.NUMPAC AND TO_CHAR(DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE,'YYYYMM')=v_periode
 AND DIC_TGE_RESPAIE_RUBRIQUE.CODERUB = TIERS_RUB_TRANSCO.CODRUB
 join DIC_PENSION on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=DIC_PENSION.NUMPAC AND DIC_TGE_RESPAIE_RUBRIQUE.PACMAT=DIC_PENSION.PACMAT
 join SECUPACMAT on SECUPACMAT.NUMPAC=TGE_REF_PAC.NUMPAC AND SECUPACMAT.PACMAT=DIC_PENSION.PACMAT
 join DIC_TGE_RESPAIE_HISTO on DIC_TGE_RESPAIE_HISTO.NUMPAC = DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC AND DIC_TGE_RESPAIE_HISTO.PAIEZAD=DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD AND DIC_TGE_RESPAIE_HISTO.DTDEB_HISTO=DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE
 where
 TO_NUMBER(TIERS_RUB_TRANSCO.NUMERO)=1 AND TIERS_RUB_TRANSCO.TYPE='P' AND DIC_TGE_RESPAIE_RUBRIQUE.MONTANT<0 AND DIC_PENSION.MODPAI1_PEN='V' AND TGE_REF_PAC.NUMPAC = p_NumpacCible);
 
 --si plantage on met le statut de la campagne à jours en E (Erreur) et on arrete le traitement
 EXCEPTION
 WHEN OTHERS
 THEN
 v_statut := 'E';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 COMMIT;
 RAISE;
 END;
 
 -- Insertion des Pensions 2 en mode de paiement Virement pour le numpac cible à la période en cours
 BEGIN
 Insert into DIC_PAIEMENT_TIERS (
 TIERS_MOIS_PAIE,
 TIERS_TYPE,
 TIERS_NUMPAC,
 TIERS_MATRIC,
 TIERS_PACMAT,
 TIERS_PAIEZAD,
 TIERS_NOM,
 TIERS_PRENOM,
 TIERS_CODSTE,
 TIERS_CODETB,
 TIERS_CODE_BQE,
 TIERS_NUMERO,
 TIERS_CODRUB,
 TIERS_MONTANT,
 TIERS_ACTIF,
 TIERS_BENEFICIAIRE,
 TIERS_DOM_BQE,
 TIERS_IBAN,
 TIERS_BIC,
 TIERS_POP_GFF)
 
 (select
 to_date(v_periode,'YYYYMM'),
 'P',
 TGE_REF_PAC.NUMPAC,
 DIC_PENSION.MATRIC,
 DIC_PENSION.PACMAT,
 DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD,
 SECUPACMAT.NOM,
 SECUPACMAT.PRENOM,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSSJ,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSCE,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSBE,
 TIERS_RUB_TRANSCO.NUMERO,
 DIC_TGE_RESPAIE_RUBRIQUE.CODERUB,
 ABS(DIC_TGE_RESPAIE_RUBRIQUE.MONTANT),
 'O',
 NVL(DIC_PENSION.NOM2_PEN || ' ' || DIC_PENSION.PRENOM2_PEN,DIC_PENSION.ORGA_2) ,
 DIC_PENSION.LIBQE2_PEN,
 DIC_PENSION.IBAPA2_PEN||IBACC2_PEN||IBA22_PEN||IBA32_PEN||IBA42_PEN||IBA52_PEN||IBA62_PEN||IBA72_PEN||IBA82_PEN||IBA92_PEN,
 DIC_PENSION.BIC2_PEN,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSPOP
 FROM TGE_REF_PAC
 join TIERS_RUB_TRANSCO on TGE_REF_PAC.NUMPAC = TIERS_RUB_TRANSCO.NUMPAC
 join (select rub.numpac,max(rub.paiezad) as paiezad ,rub.pacmat,rub.periodepaie,rub.coderub,sum(rub.montant) as montant from DIC_TGE_RESPAIE_RUBRIQUE rub 
    where rub.montant<0 group by (rub.numpac,rub.pacmat,rub.periodepaie,rub.coderub))DIC_TGE_RESPAIE_RUBRIQUE on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=TGE_REF_PAC.NUMPAC AND TO_CHAR(DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE,'YYYYMM')=v_periode
 AND DIC_TGE_RESPAIE_RUBRIQUE.CODERUB = TIERS_RUB_TRANSCO.CODRUB
 join DIC_PENSION on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=DIC_PENSION.NUMPAC AND DIC_TGE_RESPAIE_RUBRIQUE.PACMAT=DIC_PENSION.PACMAT
 join SECUPACMAT on SECUPACMAT.NUMPAC=TGE_REF_PAC.NUMPAC AND SECUPACMAT.PACMAT=DIC_PENSION.PACMAT 
 join DIC_TGE_RESPAIE_HISTO on DIC_TGE_RESPAIE_HISTO.NUMPAC = DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC AND DIC_TGE_RESPAIE_HISTO.PAIEZAD=DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD AND DIC_TGE_RESPAIE_HISTO.DTDEB_HISTO=DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE 
 where
 TO_NUMBER(TIERS_RUB_TRANSCO.NUMERO)=2 AND TIERS_RUB_TRANSCO.TYPE='P' AND DIC_TGE_RESPAIE_RUBRIQUE.MONTANT<0 AND DIC_PENSION.MODPAI1_PEN='V' AND TGE_REF_PAC.NUMPAC = p_NumpacCible);
 
 --si plantage on met le statut de la campagne à jours en E (Erreur) et on arrete le traitement
 EXCEPTION
 WHEN OTHERS
 THEN
 v_statut := 'E';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 COMMIT;
 RAISE;
 END;
 
 -- Insertion des Pensions 3 en mode de paiement Virement pour le numpac cible à la période en cours
 BEGIN
 Insert into DIC_PAIEMENT_TIERS (
 TIERS_MOIS_PAIE,
 TIERS_TYPE,
 TIERS_NUMPAC,
 TIERS_MATRIC,
 TIERS_PACMAT,
 TIERS_PAIEZAD,
 TIERS_NOM,
 TIERS_PRENOM,
 TIERS_CODSTE,
 TIERS_CODETB,
 TIERS_CODE_BQE,
 TIERS_NUMERO,
 TIERS_CODRUB,
 TIERS_MONTANT,
 TIERS_ACTIF,
 TIERS_BENEFICIAIRE,
 TIERS_DOM_BQE,
 TIERS_IBAN,
 TIERS_BIC,
 TIERS_POP_GFF)
 
 (select
 to_date(v_periode,'YYYYMM'),
 'P',
 TGE_REF_PAC.NUMPAC,
 DIC_PENSION.MATRIC,
 DIC_PENSION.PACMAT,
 DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD,
 SECUPACMAT.NOM,
 SECUPACMAT.PRENOM,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSSJ,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSCE,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSBE,
 TIERS_RUB_TRANSCO.NUMERO,
 DIC_TGE_RESPAIE_RUBRIQUE.CODERUB,
 ABS(DIC_TGE_RESPAIE_RUBRIQUE.MONTANT),
 'O',
 NVL(DIC_PENSION.NOM3_PEN || ' ' || DIC_PENSION.PRENOM3_PEN,DIC_PENSION.ORGA_3) ,
 DIC_PENSION.LIBQE3_PEN,
 DIC_PENSION.IBAPA3_PEN||IBACC3_PEN||IBA23_PEN||IBA33_PEN||IBA43_PEN||IBA53_PEN||IBA63_PEN||IBA73_PEN||IBA83_PEN||IBA93_PEN,
 DIC_PENSION.BIC3_PEN,
 DIC_TGE_RESPAIE_HISTO.PREVTIERSPOP
 FROM TGE_REF_PAC
 join TIERS_RUB_TRANSCO on TGE_REF_PAC.NUMPAC = TIERS_RUB_TRANSCO.NUMPAC
 join (select rub.numpac,max(rub.paiezad) as paiezad,rub.pacmat,rub.periodepaie,rub.coderub,sum(rub.montant) as montant from DIC_TGE_RESPAIE_RUBRIQUE rub where rub.montant<0 group by (rub.numpac,rub.pacmat,rub.periodepaie,rub.coderub))DIC_TGE_RESPAIE_RUBRIQUE on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=TGE_REF_PAC.NUMPAC AND TO_CHAR(DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE,'YYYYMM')=v_periode
 AND DIC_TGE_RESPAIE_RUBRIQUE.CODERUB = TIERS_RUB_TRANSCO.CODRUB
 join DIC_PENSION on DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC=DIC_PENSION.NUMPAC AND DIC_TGE_RESPAIE_RUBRIQUE.PACMAT=DIC_PENSION.PACMAT
 join SECUPACMAT on SECUPACMAT.NUMPAC=TGE_REF_PAC.NUMPAC AND SECUPACMAT.PACMAT=DIC_PENSION.PACMAT
 join DIC_TGE_RESPAIE_HISTO on DIC_TGE_RESPAIE_HISTO.NUMPAC = DIC_TGE_RESPAIE_RUBRIQUE.NUMPAC AND DIC_TGE_RESPAIE_HISTO.PAIEZAD=DIC_TGE_RESPAIE_RUBRIQUE.PAIEZAD AND DIC_TGE_RESPAIE_HISTO.DTDEB_HISTO=DIC_TGE_RESPAIE_RUBRIQUE.PERIODEPAIE 
 where
 TO_NUMBER(TIERS_RUB_TRANSCO.NUMERO)=3 AND TIERS_RUB_TRANSCO.TYPE='P' AND DIC_TGE_RESPAIE_RUBRIQUE.MONTANT<0 AND DIC_PENSION.MODPAI1_PEN='V' AND TGE_REF_PAC.NUMPAC = p_NumpacCible);
 
 --si plantage on met le statut de la campagne à jours en E (Erreur) et on arrete le traitement
 EXCEPTION
 WHEN OTHERS
 THEN
 v_statut := 'E';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 COMMIT;
 RAISE;
 END;
 
 -- Mise a jour du CODE CHRONO si on est en MPE et qu'on est dans une version où la table DIC_ADM_CONTRAT_SITU existe
 SELECT count(table_name) INTO v_tableExiste FROM USER_TABLES WHERE table_name = upper('DIC_ADM_CONTRAT_SITU');
 SELECT MPE INTO v_MPE FROM TGE_REF_PAC WHERE NUMPAC = p_NumpacCible;
 IF v_tableExiste > 0 and v_MPE='O' THEN
 BEGIN
 UPDATE DIC_PAIEMENT_TIERS set TIERS_CODE_CHRONO = (select CODE_CHRONO from DIC_ADM_CONTRAT_SITU WHERE DIC_PAIEMENT_TIERS.TIERS_PAIEZAD = DIC_ADM_CONTRAT_SITU.PAIEZAD AND DIC_PAIEMENT_TIERS.TIERS_NUMPAC = DIC_ADM_CONTRAT_SITU.NUMPAC)where TIERS_NUMPAC = p_NumpacCible AND TIERS_MOIS_PAIE = TO_DATE (v_periode,'YYYYMM');
 --si plantage on met le statut de la campagne à jours en E (Erreur) et on arrete le traitement
 EXCEPTION
 WHEN OTHERS
 THEN
 v_statut := 'E';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 COMMIT;
 RAISE;
 END;
 END IF;
 
 -- Traitement terminé mise à jours du statut de la table de pilotage C pour campagne en cours et debloquage des saisies
 v_statut := 'C';
 EXECUTE IMMEDIATE v_requete_maj_statut USING v_statut;
 UPDATE TIERS_PILOTAGE SET SAISIE_BLOQUE_OPP='N',SAISIE_BLOQUE_PEN='N' where NUMPAC = p_NumpacCible AND PERIODE = TO_DATE (v_periode,'YYYYMM');
 
 COMMIT;
 
 END;##
BUILD_ALLINDEX
=SQL=
create or replace PROCEDURE "BUILD_ALLINDEX"
AS
/**
 * Procédure de mise à jour complète de la table STD_STRUC_INDEX
 * ATTENTION, cette procédure peut se réveler très longue et doit être appelée rarement
 * (Ex : modification structure de la table STD_STRUC_INDEX)
 */
  CURSOR tabCodts
  IS
    SELECT codts FROM std_struc_type;
  vcodts NUMBER;
 
BEGIN
  -- On commence par vider complètement la table STD_STRUC_INDEX
  EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE std_struc_index',0);
  -- On boucle sur les différents codTs
  OPEN tabCodts;
  LOOP
    FETCH tabCodts INTO vcodts;
    EXIT
  WHEN tabCodts%NOTFOUND ;
    build_index(vcodts, null) ;
  END LOOP;
  CLOSE tabCodts;
END BUILD_ALLINDEX;
 ##
TAG_CHARSET=@€éèç
##
BUILD_INDEX
=SQL=
create or replace PROCEDURE "BUILD_INDEX"(
    p_codts IN std_struc_arbre.codts%TYPE,
    p_dateEff IN std_struc_arbre.date_eff%TYPE, -- Calcul à partir d'une date précise ou calcul de toutes les dates si null (19010101)
    p_cid IN std_struc_index.cid%TYPE default null) -- Le cid peut être null car la procédure peut être appelé par le service client ADP Link
AS
  /**
   * Procédure de mise à jour des données d'une structure dans la table STD_STRUC_INDEX
   * Si p_dateEff n'est pas vide le calcul se fait à partir de la date d'effet
   * sinon le calcul se fait à partir du début (19010101).
   * Le codTs -99 correspond au lancement d'un traitement de défragmentation sur la table
   */

  v_cid std_struc_index.cid%TYPE;
  
  TYPE tcur IS REF CURSOR;
  tabCodtsDate tcur;

  v_lgnReqCodts std_struc_arbre.codts%TYPE;
  v_lgnReqDateEff std_struc_arbre.date_eff%TYPE;
  v_lgnReqDateFin std_struc_arbre.date_fin%TYPE;
  v_codTs99     INTEGER :=NULL;
  v_codTsLock   INTEGER := NULL;
  v_dateEff     VARCHAR2(8);
  v_dateFinBefore VARCHAR2(8);
  v_dateFinAfter  VARCHAR2(8);
  req           VARCHAR2(200);
  retour        INTEGER;
  err_msg  VARCHAR(1000);
  err_code VARCHAR(200);
  
  BEGIN
	  
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramêtre pCid est obligatoire
  	RAISE_APPLICATION_ERROR(-20000, 'Le cid n''est pas passé en paramètre et on est en mode multiclient.');
  END IF;
	  
  -- Récupération si un traitement de "défragmentation" a été lancé (codTs = -99)
  BEGIN
    SELECT codTs
    INTO v_codTs99
    FROM build_index_lock
    WHERE codTs = -99 AND codTs_lock > 0;
  EXCEPTION
    -- Pas du tout de ligne pour le codTs -99
    WHEN NO_DATA_FOUND THEN
      v_codTs99 := NULL;
  END;
  
  -- Récupération si une structure est déjà lockée
  BEGIN
    SELECT codTs_lock, date_eff
    INTO v_codTsLock, v_dateEff
    FROM build_index_lock
    WHERE codTs = p_codts;
  EXCEPTION
    -- La structure n'a pas encore été initialisée dans la table
  WHEN NO_DATA_FOUND THEN
    v_codTsLock := NULL;
    v_dateEff := NULL;
  END; 
  
  IF (v_codTsLock IS NOT NULL AND v_codTsLock > 0) OR (v_codTs99 IS NOT NULL) THEN
    -- La structure est lockée ou un traitement de défragmentation a été lancé
    IF p_codTs <> -99 THEN
      -- On met à jour le lock de la structure 
      -- (sauf pour le traitement de défragmentation qui n'a pas besoin d'être relancé plusieurs fois à la suite)
      req := 'UPDATE build_index_lock SET codTs_lock = '||(v_codTsLock + 1);
      IF v_dateEff IS NULL OR v_dateEff > p_dateEff THEN
        -- On met à jour la date que si celle si est plus petite que la précédente
        req := req||', date_eff = '||p_dateEff;
      END IF;
      req := req||' WHERE codTs = '||p_codTs;
    
      EXECUTE_IMMEDIATE_STRING(req,0);
      COMMIT;
    END IF;
  ELSE
    -- La structure n'est pas lockée, on commence par locker la structure et ensuite on lance le build
    IF v_codTsLock IS NULL THEN
      -- Insertion d'un ligne pour locker la structure
      INSERT INTO build_index_lock (codTs, codTs_lock, date_eff)
      VALUES(p_codTs, 1, null);
    ELSE
      -- Modification de la ligne existante pour locker la structure (on laisse à vide la date d'effet)
      UPDATE build_index_lock
      SET codTs_lock = 1
      WHERE codTs = p_codTs;
    END IF;
    COMMIT; -- Commite de l'insert/update du lock

    v_dateFinBefore := NULL;
    v_dateFinAfter := NULL;

    IF p_dateEff IS NOT NULL THEN
      -- On récupère la date de fin de l'historique qu'on va mettre à jour
      BEGIN
        SELECT date_fin
        INTO v_dateFinBefore
        FROM std_struc_index
        WHERE cid = v_cid and codTs = p_codts and date_eff = p_dateEff and rownum = 1;
      EXCEPTION
        -- L'historique n'existe pas
        WHEN NO_DATA_FOUND THEN
          v_dateFinBefore := NULL;
      END;
    END IF; 

    -- Suppression des lignes qui vont être recalculées 
    -- (pour éviter la fragmentation, un traitement périodique lance régulièrement un truncate de la table)
    DELETE FROM std_struc_index WHERE cid = v_cid and codts = p_codts
    AND date_eff >= nvl(p_dateEff, '19010101');
     
    -- Lancement du build dans la table STD_STRUC_INDEX
    OPEN tabCodtsDate 
      FOR SELECT codts,
        date_eff,
        NVL(lead(date_fin, 1) over(partition BY codts order by date_eff),'20991231' ) AS date_fin
      FROM
        ( SELECT DISTINCT codts,
          date_eff ,
          TO_CHAR(to_date(date_eff,'yyyymmdd')-1,'yyyymmdd') date_fin
        FROM std_struc_arbre
        WHERE cid = v_cid  
          AND codts = p_codts
          AND date_eff >= nvl(p_dateEff, '19010101')
        ORDER BY codts, date_eff
        )
      ORDER BY date_eff, date_fin;
    LOOP
      FETCH tabCodtsDate INTO v_lgnReqCodts, v_lgnReqDateEff, v_lgnReqDateFin;
      EXIT
    WHEN tabCodtsDate%NOTFOUND ;
      DBMS_OUTPUT.PUT_LINE(v_cid||' :' ||p_codts||' :' ||v_lgnReqDateEff|| ' : '||v_lgnReqDateFin);
      retour := BUILD_TABLE_INDEX(v_cid, p_codts, v_lgnReqDateEff, v_lgnReqDateFin) ;
    END LOOP;
    CLOSE tabCodtsDate;

    IF p_dateEff IS NOT NULL THEN
      -- On récupère la date de fin de l'historique qu'on a mis à jour
      BEGIN
        SELECT date_fin
        INTO v_dateFinAfter
        FROM std_struc_index
        WHERE cid = v_cid and codTs = p_codts and date_eff = p_dateEff and rownum = 1;
      EXCEPTION
        -- L'historique n'existe plus
        WHEN NO_DATA_FOUND THEN
          v_dateFinAfter := NULL;
      END;
      
      IF v_dateFinBefore IS NULL AND v_dateFinAfter IS NOT NULL THEN
        -- L'historique a été créé : on met à jour la date précédente pour positionner la date de fin à J-1 du nouvel historique
        UPDATE STD_STRUC_INDEX I1 SET DATE_FIN=TO_CHAR(TO_DATE(p_dateEff,'yyyymmdd')-1,'yyyymmdd') WHERE CID = v_cid and CODTS=p_codts AND NOT DATE_EFF=p_dateEff AND DATE_FIN=v_dateFinAfter;
      ELSIF v_dateFinBefore IS NOT NULL AND v_dateFinAfter IS NULL THEN
        -- L'historique a été supprimé : on met à jour la date précédente pour positionner la date de fin à la date de fin de l'historique supprimé
        UPDATE STD_STRUC_INDEX I1 SET DATE_FIN=v_dateFinBefore WHERE CID = v_cid and CODTS=p_codts AND DATE_FIN=TO_CHAR(TO_DATE(p_dateEff,'yyyymmdd')-1,'yyyymmdd');
      END IF;
    END IF; 

    -- Après le build des index, on vérifie que d'autres build n'ont pas voulu être lancé (dte not null)
    SELECT codTs_lock, date_eff
    INTO v_codTsLock, v_dateEff
    FROM build_index_lock
    WHERE codTs = p_codts;
    
    -- On délock la structure    
    UPDATE build_index_lock SET codTs_lock = 0, date_eff = NULL WHERE codTs = p_codTs;     
    
    -- On commite
    COMMIT;
    
     -- Si la structure avait plus que 1 lock alors on relance la procédure
    IF v_codTsLock > 1 THEN
      BUILD_INDEX(p_codTs, v_dateEff, v_cid);
    END IF;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  -- Tracer l'erreur
   ERR_CODE := SQLCODE;
   ERR_MSG  := SQLERRM;
   INSERT INTO SYS_TRC_ERR VALUES (CURRENT_TIMESTAMP,ERR_CODE||'  MESSAGE='||ERR_MSG,'BUILD_INDEX p_cid='||p_cid||' p_codts='||p_codts||' p_dateEff = '||p_dateEff,'PL_SQL');
  -- Une exception a été lancé, on déclock la structure
  UPDATE build_index_lock 
  SET codTs_lock = 0,
  date_eff = NULL
  WHERE codTs = p_codTs;
  COMMIT;
END BUILD_INDEX;
##
TAG_CHARSET=@€éèç
##
BUILD_INDEX_DEFRAG
=SQL=
create or replace PROCEDURE "BUILD_INDEX_DEFRAG" (p_retour OUT INTEGER)
AS
/**
 * Procédure de "défragmentation" de la table STD_STRUC_INDEX qui consiste en :
 * - la recopie des données dans une table temporaire (sans aucun index, ni pk) STD_STRUC_INDEX_DEFRAG
 * - le truncate de la table STD_STRUC_INDEX
 * - la recopie des données depuis STD_STRUC_INDEX_DEFRAG vers STD_STRUC_INDEX
 * - le recalcul des statistiques
 * La procédure retourne 1 si la défragmentation a pu être lancée, 0 sinon dans le paramètre p_retour
 * Afin d'éviter la concurrence entre cette procédure et la procédure BUILD_INDEX,
 * on utilise un codTs bidon -99 dans la table BUILD_INDEX_LOCK
 * 
 * A la fin de la défragmentation, on appelle également la procédure HRORG_CONSOLIDE_AFFECTATION qui permet de consolider la table STD_STRUC_AFFECTATION
 */
  v_codTs99   INTEGER := NULL;
  v_codTsLock INTEGER := NULL;
BEGIN
  p_retour := 0;
  
  -- Récupération si une structure est déjà lockée ou un traitement de défragmentation
  BEGIN
    SELECT codTs_lock
    INTO v_codTsLock
    FROM build_index_lock
    WHERE codTs_lock > 0
    AND ROWNUM = 1;
  EXCEPTION
    -- Aucune structure lockée
  WHEN NO_DATA_FOUND THEN
    v_codTsLock := NULL;
  END; 
  
  IF v_codTsLock IS NULL THEN
    -- Récupération si le codTs -99 existe déjà dans la table de lock
    BEGIN
      SELECT codTs
      INTO v_codTs99
      FROM build_index_lock
      WHERE codTs = -99;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- Pas de ligne pour le codTs -99
      v_codTs99 := NULL;
    END;
    
    -- Lock dans la table BUILD_INDEX_LOCK
    IF v_codTs99 IS NULL THEN
      INSERT INTO build_index_lock (codTs, codTs_lock)
      values (-99, 1);
    ELSE
      UPDATE build_index_lock
      SET codTs_lock = 1
      WHERE codTs = -99;
    END IF;
    COMMIT; -- Commite de l'insert/update du lock
    
    -- Vidage d'abord de la table de défragmentation
    EXECUTE_IMMEDIATE_STRING('truncate table STD_STRUC_INDEX_DEFRAG',0);
      
    -- Copie dans la table temporaire
    INSERT INTO std_struc_index_defrag
    SELECT * FROM std_struc_index;
    
    -- Truncate de STD_STRUC_INDEX (pour éliminer la fragmentation de la table) 
    EXECUTE_IMMEDIATE_STRING('truncate table STD_STRUC_INDEX',0);
     
    -- Recopie dans STD_STRUC_INDEX
    INSERT INTO std_struc_index
    SELECT * FROM std_struc_index_defrag;
    
    COMMIT;
    
    -- Recacul des statistiques
    SYS_RECALCUL_STATS('std_struc_index');
    
    -- Truncate de STD_STRUC_INDEX_DEFRAG
    EXECUTE_IMMEDIATE_STRING('truncate table STD_STRUC_INDEX_DEFRAG',0);
    
    -- Déclocke 
    UPDATE build_index_lock
    SET codTs_lock = 0
    WHERE codTs = -99;
    COMMIT;
    
    -- Si des build ont été tentés pendant ce traitement, on les lance à la suite
    BEGIN
      FOR tabCodTsLock IN (
        SELECT codTs, date_eff
        FROM build_index_lock
        WHERE codTs_lock > 0)
      LOOP
        -- On commence par délocker la structure
        UPDATE build_index_lock
        SET codTs_lock = 0
        WHERE codTs = tabCodTsLock.codTs;
        COMMIT;
        -- Puis on lance le traitement de build
        BUILD_INDEX(tabCodTsLock.codTs, tabCodTsLock.date_eff);
      END LOOP;
    END;
    
    p_retour := 1;
    
    BEGIN
    	-- Appel à la consolidation des données dans la table STD_STRUC_AFFECTATION
	    EXECUTE_IMMEDIATE_STRING('call HRORG_CONSOLIDE_AFFECTATION()',0);
  	EXCEPTION WHEN OTHERS THEN
  		p_retour := 2;
  	END;
  	
  END IF;
EXCEPTION
WHEN OTHERS THEN
  -- Une exception a été lancé, on déclock la structure
  UPDATE build_index_lock 
  SET codTs_lock = 0 
  WHERE codTs = -99;
  COMMIT;
  
  
END BUILD_INDEX_DEFRAG;
##
COMPILE_ALL
=SQL=
create or replace PROCEDURE COMPILE_ALL
AS
BEGIN
  --DBMS_OUTPUT.Put_Line(' View ');
  --FIXME utiliser la procédure trace_dbms_output()
  FOR cur IN
  (SELECT OBJECT_NAME,
    OBJECT_TYPE
  FROM user_objects
  WHERE object_type = 'VIEW'
  AND status        = 'INVALID'
  )
  LOOP
    BEGIN
      EXECUTE_IMMEDIATE_STRING('alter VIEW ' || cur.OBJECT_NAME || ' compile',0);
      --DBMS_OUTPUT.Put_Line('Vue '|| cur.OBJECT_NAME || ' is compiled');
      --FIXME utiliser la procédure trace_dbms_output()
    EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.Put_Line('Vue '|| cur.OBJECT_NAME || ' is not compiled');
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    END;
  END LOOP;
  --DBMS_OUTPUT.Put_Line(' Fonction ');
  --FIXME utiliser la procédure trace_dbms_output()
  FOR cur IN
  (SELECT OBJECT_NAME,
    OBJECT_TYPE
  FROM user_objects
  WHERE object_type = 'FUNCTION'
  AND status        = 'INVALID'
  )
  LOOP
    BEGIN
      EXECUTE_IMMEDIATE_STRING( 'alter FUNCTION ' || cur.OBJECT_NAME || ' compile',0);
      --DBMS_OUTPUT.Put_Line('Fonction '|| cur.OBJECT_NAME || ' is compiled');
      --FIXME utiliser la procédure trace_dbms_output()
    EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.Put_Line('Fonction '|| cur.OBJECT_NAME || ' is not compiled');
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    END;
  END LOOP;
  --DBMS_OUTPUT.Put_Line(' Procédure ');
  FOR cur IN
  (SELECT OBJECT_NAME,
    OBJECT_TYPE
  FROM user_objects
  WHERE object_type = 'PROCEDURE'
  AND status        = 'INVALID'
  )
  LOOP
    BEGIN
      EXECUTE_IMMEDIATE_STRING('alter PROCEDURE ' || cur.OBJECT_NAME || ' compile',0);
      --DBMS_OUTPUT.Put_Line('Procedure '|| cur.OBJECT_NAME || ' is compiled');
    EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.Put_Line('Procedure '|| cur.OBJECT_NAME || ' is not compiled');
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    END;
  END LOOP;
  --DBMS_OUTPUT.Put_Line(' Package ');
  FOR cur IN
  (SELECT OBJECT_NAME,
    OBJECT_TYPE
  FROM user_objects
  WHERE object_type IN ('PACKAGE','PACKAGE BODY')
  AND status         = 'INVALID'
  )
  LOOP
    BEGIN
      IF cur.OBJECT_TYPE = 'PACKAGE BODY' THEN
        EXECUTE_IMMEDIATE_STRING('alter PACKAGE ' || cur.OBJECT_NAME || ' compile body',0);
      ELSE
        EXECUTE_IMMEDIATE_STRING('alter PACKAGE ' || cur.OBJECT_NAME || ' compile',0);
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.Put_Line('Package '|| cur.OBJECT_NAME || ' is not compiled');
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    END;
  END LOOP;
  --DBMS_OUTPUT.Put_Line(' Trigger ');
  FOR cur IN
  (SELECT OBJECT_NAME,
    OBJECT_TYPE
  FROM user_objects
  WHERE object_type = 'TRIGGER'
  AND status        = 'INVALID'
  )
  LOOP
    BEGIN
      EXECUTE_IMMEDIATE_STRING('alter TRIGGER ' || cur.OBJECT_NAME || ' compile',0);
      --DBMS_OUTPUT.Put_Line('Trigger '|| cur.OBJECT_NAME || ' is compiled');
      --FIXME utiliser la procédure trace_dbms_output()
    EXCEPTION
    WHEN OTHERS THEN
      --DBMS_OUTPUT.Put_Line('Trigger '|| cur.OBJECT_NAME || ' is not compiled');
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    END;
  END LOOP;
END;
##
CREATE_PROC_IDX_CH_RETOUR_PAIE
=SQL=
CREATE OR REPLACE PROCEDURE CREATE_PROC_IDX_CH_RETOUR_PAIE AUTHID CURRENT_USER
AS
  TYPE TypeColNameCountTable IS RECORD (COLUMN_NAME USER_TAB_COLUMNS.COLUMN_NAME%TYPE, COUNT_TABLE NUMBER,COLUMN_TYPE USER_TAB_COLUMNS.DATA_TYPE%TYPE);
  TYPE TYP_COL_NAME IS TABLE OF TypeColNameCountTable;
  TabcolContrat TYP_COL_NAME ;
  TabcolContratHisto TYP_COL_NAME ;
  v_reqCreate CLOB;
  v_reqCreateHistoRuptureContrat CLOB;
  v_reqCreateHistoModifOnly CLOB;
  emptyVal VARCHAR2(7);
BEGIN
  SELECT COLUMN_NAME, 0, DATA_TYPE BULK COLLECT
  INTO TabcolContrat
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME='DIC_ADM_CONTRAT'
  AND COLUMN_NAME IN (SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RETOUR_PAIE)
  ORDER BY COLUMN_NAME;

  SELECT COLUMN_NAME, (SELECT COUNT(*) FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT WHERE NOM_DONNEE=COLUMN_NAME),DATA_TYPE BULK COLLECT
  INTO TabcolContratHisto
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME='DIC_ADM_CONTRAT_HISTO'
  AND COLUMN_NAME IN (SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RETOUR_PAIE)
  ORDER BY COLUMN_NAME;

  v_reqCreate := 'CREATE OR REPLACE PROCEDURE ALIM_IDX_CH_RETOUR_PAIE AS ';
  IF TabcolContrat.count>0 THEN
    v_reqCreate := v_reqCreate||'cursor curContrat is SELECT MATRIC, NUMPAC, PACMAT, NUMCNT, DSDCN, DSFCN';
    FOR i IN TabcolContrat.first..TabcolContrat.last
    LOOP
      v_reqCreate := v_reqCreate||', '||TabcolContrat(i).COLUMN_NAME;
    END LOOP;
    v_reqCreate := v_reqCreate||' FROM DIC_ADM_CONTRAT WHERE (NUMPAC,PACMAT) IN (SELECT NUMPAC,PACMAT FROM SECUPACMAT_TMP_CONTRAT) ORDER BY Matric, Dsdcn;';
    v_reqCreate := v_reqCreate||'TYPE TypeColContrat IS RECORD (MATRIC DIC_ADM_CONTRAT.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT.PACMAT%TYPE, NUMCNT DIC_ADM_CONTRAT.NUMCNT%TYPE, DSDCN DIC_ADM_CONTRAT.DSDCN%TYPE, DSFCN DIC_ADM_CONTRAT.DSFCN%TYPE';
    FOR i IN TabcolContrat.first..TabcolContrat.last
    LOOP
      v_reqCreate := v_reqCreate||', '||TabcolContrat(i).COLUMN_NAME||' DIC_ADM_CONTRAT.'||TabcolContrat(i).COLUMN_NAME||'%TYPE';
    END LOOP;
    v_reqCreate := v_reqCreate||');';
    v_reqCreate := v_reqCreate||'ligContrat TypeColContrat;';
    v_reqCreate := v_reqCreate||'previous_ligContrat TypeColContrat;   ';
  END IF;

  IF TabcolContratHisto.count>0 THEN
    v_reqCreate := v_reqCreate||'cursor curHisto is  SELECT MATRIC, NUMPAC, PACMAT, NUMCNT, DATE_EFF, DATE_FIN';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      v_reqCreate := v_reqCreate||', '||TabcolContratHisto(i).COLUMN_NAME;
    END LOOP;
    v_reqCreate := v_reqCreate||' FROM DIC_ADM_CONTRAT_HISTO WHERE (NUMPAC,PACMAT) IN (SELECT NUMPAC,PACMAT FROM SECUPACMAT_TMP_CONTRAT) ORDER BY Matric, Date_eff;';
    v_reqCreate := v_reqCreate||'TYPE TypeColHisto IS RECORD (MATRIC DIC_ADM_CONTRAT_HISTO.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT_HISTO.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT_HISTO.PACMAT%TYPE, NUMCNT DIC_ADM_CONTRAT_HISTO.NUMCNT%TYPE, DATE_EFF DIC_ADM_CONTRAT_HISTO.DATE_EFF%TYPE, DATE_FIN DIC_ADM_CONTRAT_HISTO.DATE_FIN%TYPE';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      v_reqCreate := v_reqCreate||', '||TabcolContratHisto(i).COLUMN_NAME||' DIC_ADM_CONTRAT_HISTO.'||TabcolContratHisto(i).COLUMN_NAME||'%TYPE';
    END LOOP;
    v_reqCreate := v_reqCreate||');';
    v_reqCreate := v_reqCreate||'ligHisto TypeColHisto;';
    v_reqCreate := v_reqCreate||'previous_ligHisto TypeColHisto;   ';
  END IF;

  IF TabcolContrat.count>0 OR TabcolContratHisto.count>0 THEN
    v_reqCreate := v_reqCreate||'TYPE TYP_LIG_IDX IS RECORD ( ';
    v_reqCreate := v_reqCreate||'  NUMPAC DIC_IDX_CONTRAT_HISTO_TMP.NUMPAC%TYPE, ';
    v_reqCreate := v_reqCreate||'  PACMAT DIC_IDX_CONTRAT_HISTO_TMP.PACMAT%TYPE, ';
    v_reqCreate := v_reqCreate||'  NUMCNT DIC_IDX_CONTRAT_HISTO_TMP.NUMCNT%TYPE, ';
    v_reqCreate := v_reqCreate||'  DATE_EFF DIC_IDX_CONTRAT_HISTO_TMP.DATE_EFF%TYPE, ';
    v_reqCreate := v_reqCreate||'  NOM_DONNEE DIC_IDX_CONTRAT_HISTO_TMP.NOM_DONNEE%TYPE, ';
    v_reqCreate := v_reqCreate||'  IDPACMAT DIC_IDX_CONTRAT_HISTO_TMP.IDPACMAT%TYPE, ';
    v_reqCreate := v_reqCreate||'  DATE_FIN DIC_IDX_CONTRAT_HISTO_TMP.DATE_FIN%TYPE, ';
    v_reqCreate := v_reqCreate||'  RUPTURE_CONTRAT DIC_IDX_CONTRAT_HISTO_TMP.RUPTURE_CONTRAT%TYPE, ';
    v_reqCreate := v_reqCreate||'  DATE_DERNIERE_MODIF DIC_IDX_CONTRAT_HISTO_TMP.DATE_DERNIERE_MODIF%TYPE); ';

    v_reqCreate := v_reqCreate||'TYPE TYP_TAB_IDX IS TABLE OF TYP_LIG_IDX ; ';
    v_reqCreate := v_reqCreate||'Tabidx TYP_TAB_IDX ; ';
    v_reqCreate := v_reqCreate||'Ligidx TYP_LIG_IDX ; ';
  END IF;

  IF TabcolContratHisto.count>0 THEN
    v_reqCreate := v_reqCreate||'TYPE TAB_INDICE_IDX_BY_DONNEE IS TABLE OF NUMBER INDEX BY VARCHAR2(20) ; ';
    v_reqCreate := v_reqCreate||'tabIndice TAB_INDICE_IDX_BY_DONNEE ; ';
    v_reqCreate := v_reqCreate||'bMATRIC NUMBER ; ';
    v_reqCreate := v_reqCreate||'bCNT NUMBER ; ';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' NUMBER ; ';
    END LOOP;
  END IF;

  v_reqCreate := v_reqCreate||'BEGIN ';
  IF TabcolContrat.count=0 AND TabcolContratHisto.count=0 THEN
    v_reqCreate := v_reqCreate||'NULL; ';
  ELSE
    v_reqCreate := v_reqCreate||'Tabidx := TYP_TAB_IDX(); ';
    IF TabcolContrat.count>0 THEN
      v_reqCreate := v_reqCreate||'OPEN curContrat; ';
      v_reqCreate := v_reqCreate||'  LOOP ';
      v_reqCreate := v_reqCreate||' FETCH curContrat INTO ligContrat; ';
      v_reqCreate := v_reqCreate||'   EXIT ';
      v_reqCreate := v_reqCreate||' WHEN curContrat % NOTFOUND; ';
      v_reqCreate := v_reqCreate||' IF previous_ligContrat.PACMAT is null OR NOT previous_ligContrat.MATRIC=ligContrat.MATRIC THEN ';
      v_reqCreate := v_reqCreate||' IF previous_ligContrat.PACMAT is not null THEN ';
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
      v_reqCreate := v_reqCreate||' END IF; ';
      v_reqCreate := v_reqCreate||'ELSE ';
      FOR i IN TabcolContrat.first..TabcolContrat.last
      LOOP
        emptyVal := '_EMPTY_';
        IF (TabcolContrat(i).COLUMN_TYPE = 'NUMBER') THEN
          emptyVal := '0';
        END IF;
        v_reqCreate := v_reqCreate||'
          IF NOT NVL(TO_CHAR(previous_ligContrat.'||TabcolContrat(i).COLUMN_NAME||'),'''||emptyVal||''') = NVL(TO_CHAR(ligContrat.'||TabcolContrat(i).COLUMN_NAME||'),'''||emptyVal||''') THEN ';
        v_reqCreate := v_reqCreate||'Ligidx.NUMPAC := ligContrat.NUMPAC; ';
        v_reqCreate := v_reqCreate||'Ligidx.PACMAT := ligContrat.PACMAT; ';
        v_reqCreate := v_reqCreate||'Ligidx.NUMCNT := ligContrat.NUMCNT; ';
        v_reqCreate := v_reqCreate||'Ligidx.DATE_EFF := ligContrat.DSDCN; ';
        v_reqCreate := v_reqCreate||'Ligidx.DATE_FIN := NVL(ligContrat.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')); ';
        v_reqCreate := v_reqCreate||'Ligidx.NOM_DONNEE := '''||TabcolContrat(i).COLUMN_NAME||'''; ';
        v_reqCreate := v_reqCreate||'Ligidx.RUPTURE_CONTRAT := NULL; ';
        v_reqCreate := v_reqCreate||'Tabidx.extend; ';
        v_reqCreate := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
        v_reqCreate := v_reqCreate||'END IF; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'  previous_ligContrat:=ligContrat;';
      v_reqCreate := v_reqCreate||' end loop;';
      v_reqCreate := v_reqCreate||'close curContrat;';
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
    END IF;
    IF TabcolContratHisto.count>0 THEN
      v_reqCreate := v_reqCreate||'OPEN curHisto; ';
      v_reqCreateHistoRuptureContrat := 'tabIndice.delete(); ';
      v_reqCreateHistoModifOnly := NULL;
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        IF TabcolContratHisto(i).COUNT_TABLE>0 THEN
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.NUMPAC := ligHisto.NUMPAC; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.PACMAT := ligHisto.PACMAT; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.NUMCNT := ligHisto.NUMCNT; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.DATE_EFF := ligHisto.DATE_EFF; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.DATE_FIN := ligHisto.DATE_FIN; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.NOM_DONNEE := '''||TabcolContratHisto(i).COLUMN_NAME||'''; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Ligidx.RUPTURE_CONTRAT := ''O''; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Tabidx.extend; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'Tabidx(Tabidx.last) := Ligidx; ';
          v_reqCreateHistoRuptureContrat := v_reqCreateHistoRuptureContrat||'tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''') := Tabidx.last; ';
        END IF;
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'IF b'||TabcolContratHisto(i).COLUMN_NAME||'=1 THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'IF tabIndice.exists('''||TabcolContratHisto(i).COLUMN_NAME||''') AND Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).DATE_EFF = ligHisto.DATE_EFF THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).RUPTURE_CONTRAT := NULL; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'ELSE ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NUMPAC := ligHisto.NUMPAC; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.PACMAT := ligHisto.PACMAT; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NUMCNT := ligHisto.NUMCNT; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.DATE_EFF := ligHisto.DATE_EFF; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.DATE_FIN := ligHisto.DATE_FIN; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NOM_DONNEE := '''||TabcolContratHisto(i).COLUMN_NAME||'''; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.RUPTURE_CONTRAT := NULL; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx.extend; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(Tabidx.last) := Ligidx; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''') := Tabidx.last; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'END IF; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'ELSIF tabIndice.exists('''||TabcolContratHisto(i).COLUMN_NAME||''') THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).DATE_FIN := ligHisto.DATE_FIN; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'END IF; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'  LOOP ';
      v_reqCreate := v_reqCreate||' FETCH curHisto INTO ligHisto; ';
      v_reqCreate := v_reqCreate||'   EXIT ';
      v_reqCreate := v_reqCreate||' WHEN curHisto % NOTFOUND; ';
      v_reqCreate := v_reqCreate||' IF previous_ligHisto.PACMAT is null OR NOT previous_ligHisto.MATRIC=ligHisto.MATRIC THEN ';
      v_reqCreate := v_reqCreate||'bMATRIC := 1; ';
      v_reqCreate := v_reqCreate||'bCNT := 1; ';
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 0; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
      v_reqCreate := v_reqCreate||'ELSE ';
      v_reqCreate := v_reqCreate||'bMATRIC := 0; ';
      v_reqCreate := v_reqCreate||'IF NOT (previous_ligHisto.NUMPAC=ligHisto.NUMPAC AND previous_ligHisto.PACMAT=ligHisto.PACMAT AND previous_ligHisto.NUMCNT=ligHisto.NUMCNT) THEN ';
      v_reqCreate := v_reqCreate||'bCNT := 1; ';
      v_reqCreate := v_reqCreate||'ELSE ';
      v_reqCreate := v_reqCreate||'bCNT := 0; ';
      v_reqCreate := v_reqCreate||'END IF; ';
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        emptyVal := '_EMPTY_';
        IF (TabcolContratHisto(i).COLUMN_TYPE = 'NUMBER') THEN
          emptyVal := '0';
        END IF;
        v_reqCreate := v_reqCreate||'
          IF NOT NVL(TO_CHAR(previous_ligHisto.'||TabcolContratHisto(i).COLUMN_NAME||'),'''||emptyVal||''') = NVL(TO_CHAR(ligHisto.'||TabcolContratHisto(i).COLUMN_NAME||'),'''||emptyVal||''') THEN ';
        v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 1; ';
        v_reqCreate := v_reqCreate||'ELSE ';
        v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 0; ';
        v_reqCreate := v_reqCreate||'END IF; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'IF bCNT=1 THEN ';
      v_reqCreate := v_reqCreate||v_reqCreateHistoRuptureContrat;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'IF bMATRIC=0 THEN ';
      v_reqCreate := v_reqCreate||v_reqCreateHistoModifOnly;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'  previous_ligHisto:=ligHisto;';
      v_reqCreate := v_reqCreate||' end loop;';
      v_reqCreate := v_reqCreate||'close curHisto;';
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
    END IF;
    IF TabcolContrat.count>0 OR TabcolContratHisto.count>0 THEN
      v_reqCreate := v_reqCreate||'MERGE INTO DIC_IDX_CONTRAT_HISTO IDX USING (SELECT * FROM DIC_IDX_CONTRAT_HISTO_TMP) IDX_TMP ON (IDX.NUMPAC=IDX_TMP.NUMPAC AND IDX.PACMAT=IDX_TMP.PACMAT AND IDX.NUMCNT=IDX_TMP.NUMCNT AND IDX.DATE_EFF=IDX_TMP.DATE_EFF AND IDX.NOM_DONNEE=IDX_TMP.NOM_DONNEE) WHEN MATCHED THEN UPDATE SET DATE_FIN=IDX_TMP.DATE_FIN, RUPTURE_CONTRAT=IDX_TMP.RUPTURE_CONTRAT, DATE_DERNIERE_MODIF=IDX_TMP.DATE_DERNIERE_MODIF WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (IDX_TMP.NUMPAC, IDX_TMP.PACMAT, IDX_TMP.NUMCNT, IDX_TMP.DATE_EFF, IDX_TMP.NOM_DONNEE, IDX_TMP.DATE_FIN, IDX_TMP.RUPTURE_CONTRAT, IDX_TMP.DATE_DERNIERE_MODIF); ';
    END IF;
    v_reqCreate := v_reqCreate||'DELETE FROM DIC_IDX_CONTRAT_HISTO ';
    v_reqCreate := v_reqCreate||' WHERE NOT EXISTS (SELECT 1 FROM DIC_IDX_CONTRAT_HISTO_TMP WHERE NUMPAC=DIC_IDX_CONTRAT_HISTO.NUMPAC AND PACMAT=DIC_IDX_CONTRAT_HISTO.PACMAT AND NUMCNT=DIC_IDX_CONTRAT_HISTO.NUMCNT AND DATE_EFF=DIC_IDX_CONTRAT_HISTO.DATE_EFF AND NOM_DONNEE=DIC_IDX_CONTRAT_HISTO.NOM_DONNEE) ';
    v_reqCreate := v_reqCreate||' AND EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE NUMPAC=DIC_IDX_CONTRAT_HISTO.NUMPAC AND PACMAT=DIC_IDX_CONTRAT_HISTO.PACMAT) ';
    v_reqCreate := v_reqCreate||' AND EXISTS (SELECT 1 FROM DIC_IDX_DONNEE_RETOUR_PAIE WHERE NOM_DONNEE=DIC_IDX_CONTRAT_HISTO.NOM_DONNEE); ';
  END IF;
  v_reqCreate := v_reqCreate||'END ALIM_IDX_CH_RETOUR_PAIE;';
  EXECUTE_IMMEDIATE_STRING(v_reqCreate,0);
END CREATE_PROC_IDX_CH_RETOUR_PAIE;
##
CREATE_PROC_IDX_CH_RETOUR_PAIE
==
CALL CREATE_PROC_IDX_CH_RETOUR_PAIE()
##
TAG_CHARSET=@€éèç
##
CREATE_PROC_IDX_CONTRAT_HISTO
=SQL=
create or replace PROCEDURE CREATE_PROC_IDX_CONTRAT_HISTO AUTHID CURRENT_USER
AS
TYPE TypeColNameCountTable
IS
  RECORD
  (
    COLUMN_NAME USER_TAB_COLUMNS.COLUMN_NAME%TYPE,
    COUNT_TABLE NUMBER,
    COLUMN_TYPE USER_TAB_COLUMNS.DATA_TYPE%TYPE);
TYPE TYP_COL_NAME
IS
  TABLE OF TypeColNameCountTable;
  TabcolContrat TYP_COL_NAME ;
  TabcolContratHisto TYP_COL_NAME ;
  v_reqCreate CLOB;
  v_reqCreateHistoRuptureContrat CLOB;
  v_reqCreateHistoModifOnly CLOB;
  v_reqProcInsertContrat1 CLOB;
  v_reqProcInsertContrat2 CLOB;
  v_reqProcInsertContrat CLOB;
  v_reqProcUpdateContrat1 CLOB;
  v_reqProcUpdateContrat CLOB;
  v_reqProcDeleteContrat1 CLOB;
  v_reqProcDeleteContrat2 CLOB;
  v_reqProcDeleteContrat CLOB;
  v_reqProcInsertContratHisto1 CLOB;
  v_reqProcInsertContratHisto CLOB;
  v_reqProcUpdateContratHisto1 CLOB;
  v_reqProcUpdateContratHisto CLOB;
  v_reqProcDeleteContratHisto CLOB;
  v_listDonneesContratType CLOB;
  v_listDonneesContrat CLOB;
  v_listNullContrat CLOB;
  v_listDonneesContratHistoType CLOB;
  v_listDonneesContratHisto CLOB;
  v_listNullContratHisto CLOB;
  emptyVal VARCHAR2(7);
BEGIN

  -- On crée les types T_LIG_DAC et T_TAB_DAC dynamiquement, avec toutes les colonnes de DAC
  v_listDonneesContratType := NULL;
  v_listDonneesContrat := NULL;
  v_listNullContrat := NULL;
  FOR r IN (SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE FROM USER_TAB_COLUMNS WHERE TABLE_NAME='DIC_ADM_CONTRAT' ORDER BY COLUMN_ID) LOOP
    v_listDonneesContrat := v_listDonneesContrat||r.COLUMN_NAME;
    v_listDonneesContratType := v_listDonneesContratType||r.COLUMN_NAME||' '||r.DATA_TYPE;
    IF r.DATA_TYPE='VARCHAR2' THEN
      v_listDonneesContratType := v_listDonneesContratType||'('||r.DATA_LENGTH||')';
    ELSIF (r.DATA_TYPE='NUMBER' AND r.DATA_PRECISION IS NOT NULL AND r.DATA_SCALE IS NOT NULL) THEN
      v_listDonneesContratType := v_listDonneesContratType || '(' || r.DATA_PRECISION || ',' || r.DATA_SCALE || ')';
    END IF;
    v_listDonneesContrat := v_listDonneesContrat||',';
    v_listDonneesContratType := v_listDonneesContratType||',';
    v_listNullContrat := v_listNullContrat||'NULL,';
  END LOOP;
  v_listDonneesContrat := SUBSTR(v_listDonneesContrat, 1, LENGTH(v_listDonneesContrat)-1);
  v_listDonneesContratType := SUBSTR(v_listDonneesContratType, 1, LENGTH(v_listDonneesContratType)-1);
  v_listNullContrat := SUBSTR(v_listNullContrat, 1, LENGTH(v_listNullContrat)-1);
  BEGIN
    EXECUTE_IMMEDIATE_STRING ('DROP TYPE T_TAB_DAC',0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE TYPE T_LIG_DAC IS OBJECT ('||v_listDonneesContratType||')',0);
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE TYPE T_TAB_DAC IS TABLE OF T_LIG_DAC',0);

  -- On crée la fonction GET_EMPTY_LIG_DAC, qui a besoin du nombre de colonnes de DAC
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_EMPTY_LIG_DAC RETURN T_LIG_DAC IS 
BEGIN 
  RETURN T_LIG_DAC('||v_listNullContrat||');
END GET_EMPTY_LIG_DAC;',0);

  -- On crée la fonction GET_DAC_MULTI_HORS_TRANSAC, qui a besoin de lister également toutes les colonnes de DAC
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DAC_MULTI_HORS_TRANSAC(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) RETURN T_TAB_DAC IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour T_TAB_DAC; 
BEGIN 
  SELECT T_LIG_DAC('||v_listDonneesContrat||') BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT WHERE (NUMPAC,PACMAT,NUMCNT) IN (SELECT NUMPAC, PACMAT, NUMCNT FROM TABLE( p_listeClesIdxContrat )) ORDER BY MATRIC, DSDCN;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DAC();
END GET_DAC_MULTI_HORS_TRANSAC;',0);

  -- On crée la fonction GET_DAC_MATRIC, qui a besoin de lister également toutes les colonnes de DAC
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DAC_MATRIC(p_matric VARCHAR2) RETURN T_TAB_DAC IS 
retour T_TAB_DAC; 
BEGIN 
  SELECT T_LIG_DAC('||v_listDonneesContrat||') BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT WHERE MATRIC=p_matric ORDER BY DSDCN;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DAC();
END GET_DAC_MATRIC;',0);


  -- On crée les types T_LIG_DACH et T_TAB_DACH dynamiquement, avec toutes les colonnes de DACH
  v_listDonneesContratHistoType := NULL;
  v_listDonneesContratHisto := NULL;
  v_listNullContratHisto := NULL;
  FOR r IN (SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE FROM USER_TAB_COLUMNS WHERE TABLE_NAME='DIC_ADM_CONTRAT_HISTO' ORDER BY COLUMN_ID) LOOP
    v_listDonneesContratHisto := v_listDonneesContratHisto||r.COLUMN_NAME;
    v_listDonneesContratHistoType := v_listDonneesContratHistoType||r.COLUMN_NAME||' '||r.DATA_TYPE;
    IF r.DATA_TYPE='VARCHAR2' THEN
      v_listDonneesContratHistoType := v_listDonneesContratHistoType||'('||r.DATA_LENGTH||')';
    ELSIF (r.DATA_TYPE='NUMBER' AND r.DATA_PRECISION IS NOT NULL AND r.DATA_SCALE IS NOT NULL) THEN
      v_listDonneesContratHistoType := v_listDonneesContratHistoType || '(' || r.DATA_PRECISION || ',' || r.DATA_SCALE || ')';
    END IF;
    v_listDonneesContratHisto := v_listDonneesContratHisto||',';
    v_listDonneesContratHistoType := v_listDonneesContratHistoType||',';
    v_listNullContratHisto := v_listNullContratHisto||'NULL,';
  END LOOP;
  v_listDonneesContratHisto := SUBSTR(v_listDonneesContratHisto, 1, LENGTH(v_listDonneesContratHisto)-1);
  v_listDonneesContratHistoType := SUBSTR(v_listDonneesContratHistoType, 1, LENGTH(v_listDonneesContratHistoType)-1);
  v_listNullContratHisto := SUBSTR(v_listNullContratHisto, 1, LENGTH(v_listNullContratHisto)-1);
  BEGIN
    EXECUTE_IMMEDIATE_STRING ('DROP TYPE T_TAB_DACH',0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE TYPE T_LIG_DACH IS OBJECT ('||v_listDonneesContratHistoType||')',0);
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE TYPE T_TAB_DACH IS TABLE OF T_LIG_DACH',0);

  -- On crée la fonction GET_EMPTY_LIG_DACH, qui a besoin du nombre de colonnes de DACH
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_EMPTY_LIG_DACH RETURN T_LIG_DACH IS 
BEGIN 
  RETURN T_LIG_DACH('||v_listNullContratHisto||');
END GET_EMPTY_LIG_DACH;',0);

  -- On crée la fonction GET_DACH_MULTI_HORS_TRANSAC, qui a besoin de lister également toutes les colonnes de DACH
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DACH_MULTI_HORS_TRANSAC(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) RETURN T_TAB_DACH IS 
PRAGMA AUTONOMOUS_TRANSACTION; 
retour T_TAB_DACH; 
BEGIN 
  SELECT T_LIG_DACH('||v_listDonneesContratHisto||') BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE (NUMPAC,PACMAT,NUMCNT,DATE_EFF) IN (SELECT NUMPAC, PACMAT, NUMCNT, DATE_IDX FROM TABLE( p_listeClesIdxContrat )) ORDER BY MATRIC, DATE_EFF;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DACH();
END GET_DACH_MULTI_HORS_TRANSAC;',0);

  -- On crée la fonction GET_DACH_MATRIC, qui a besoin de lister également toutes les colonnes de DACH
  EXECUTE_IMMEDIATE_STRING ('CREATE OR REPLACE FUNCTION GET_DACH_MATRIC(p_matric VARCHAR2) RETURN T_TAB_DACH IS 
retour T_TAB_DACH; 
BEGIN 
  SELECT T_LIG_DACH('||v_listDonneesContratHisto||') BULK COLLECT INTO retour FROM DIC_ADM_CONTRAT_HISTO WHERE MATRIC=p_matric ORDER BY DATE_EFF;
  RETURN retour;
EXCEPTION
  WHEN OTHERS THEN RETURN T_TAB_DACH();
END GET_DACH_MATRIC;',0);


  SELECT COLUMN_NAME,
    0,
    DATA_TYPE BULK COLLECT
  INTO TabcolContrat
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME='DIC_ADM_CONTRAT'
  -- DIC_IDX_DONNEE_RESTRICTION est une table contenant une liste de colonnes restreintes qui doivent être utilisées dans la table DIC_IDX_CONTRAT_HISTO
  -- Si la table est vide, alors on prend toutes les colonnes de DIC_ADM_CONTRAT et DIC_ADM_CONTRAT_HISTO
  -- sinon on prend la liste des colonnes définies dans DIC_IDX_DONNEE_RESTRICTION, DIC_IDX_DONNEE_RETOUR_PAIE et STD_LHW_DONNEE
  AND ((NOT EXISTS
    (SELECT 1 FROM DIC_IDX_DONNEE_RESTRICTION
    )
  AND COLUMN_NAME NOT IN ('IDPACMAT','DATE_EFF_CONTRAT','CURRENT_PAIEZAD','MATRIC','DATE_CREATION','DATE_DERNIERE_MODIF'))
  OR COLUMN_NAME      IN
    (SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RESTRICTION
    UNION ALL
    SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RETOUR_PAIE
    UNION ALL
    SELECT NOM_DONNEE FROM STD_LHW_DONNEE
    ))
  ORDER BY COLUMN_NAME;
  
  SELECT COLUMN_NAME,
    (SELECT COUNT(*)
    FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT
    WHERE NOM_DONNEE=COLUMN_NAME
    ),
    DATA_TYPE BULK COLLECT
  INTO TabcolContratHisto
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME     ='DIC_ADM_CONTRAT_HISTO'
  AND COLUMN_NAME NOT IN
    (SELECT COLUMN_NAME
    FROM USER_TAB_COLUMNS
    WHERE TABLE_NAME='DIC_ADM_CONTRAT'
    )
  -- DIC_IDX_DONNEE_RESTRICTION est une table contenant une liste de colonnes restreintes qui doivent être utilisées dans la table DIC_IDX_CONTRAT_HISTO
  -- Si la table est vide, alors on prend toutes les colonnes de DIC_ADM_CONTRAT et DIC_ADM_CONTRAT_HISTO
  -- sinon on prend la liste des colonnes définies dans DIC_IDX_DONNEE_RESTRICTION, DIC_IDX_DONNEE_RETOUR_PAIE et STD_LHW_DONNEE
  AND ((NOT EXISTS
    (SELECT 1 FROM DIC_IDX_DONNEE_RESTRICTION
    )
  AND COLUMN_NAME NOT IN ('DATE_EFF','DATE_FIN','MATRIC','PAIEZAD','DATE_CREATION','DATE_DERNIERE_MODIF','DATE_FIN_BO','IDPACMAT','DATE_SORTIE_SIT_BO'))
  OR COLUMN_NAME      IN
    (SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RESTRICTION
    UNION ALL
    SELECT NOM_DONNEE FROM DIC_IDX_DONNEE_RETOUR_PAIE
    UNION ALL
    SELECT NOM_DONNEE FROM STD_LHW_DONNEE
    ))
  ORDER BY COLUMN_NAME;
  v_reqCreate          := 'CREATE OR REPLACE PROCEDURE ALIM_IDX_CONTRAT_HISTO (p_onlyFlaggedNumpacPacmat NUMBER) AS ';
  IF TabcolContrat.count>0 THEN
    v_reqCreate        := v_reqCreate||'
    cursor curContrat is SELECT MATRIC, NUMPAC, PACMAT, NUMCNT, DSDCN, DSFCN';
    FOR i IN TabcolContrat.first..TabcolContrat.last
    LOOP
      IF NOT TabcolContrat(i).COLUMN_NAME='MATRIC' AND NOT TabcolContrat(i).COLUMN_NAME='NUMPAC' AND NOT TabcolContrat(i).COLUMN_NAME='PACMAT' AND NOT TabcolContrat(i).COLUMN_NAME='NUMCNT' AND NOT TabcolContrat(i).COLUMN_NAME='DSDCN' AND NOT TabcolContrat(i).COLUMN_NAME='DSFCN' THEN
        v_reqCreate                     := v_reqCreate||', '||TabcolContrat(i).COLUMN_NAME;
      END IF;
    END LOOP;
    v_reqCreate := v_reqCreate||' FROM DIC_ADM_CONTRAT WHERE p_onlyFlaggedNumpacPacmat=0 OR (NUMPAC,PACMAT) IN (SELECT NUMPAC,PACMAT FROM SECUPACMAT_TMP_CONTRAT) ORDER BY Matric, Dsdcn;';
    v_reqCreate := v_reqCreate||'
    TYPE TypeColContrat IS RECORD (MATRIC DIC_ADM_CONTRAT.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT.PACMAT%TYPE, NUMCNT DIC_ADM_CONTRAT.NUMCNT%TYPE, DSDCN DIC_ADM_CONTRAT.DSDCN%TYPE, DSFCN DIC_ADM_CONTRAT.DSFCN%TYPE';
    FOR i IN TabcolContrat.first..TabcolContrat.last
    LOOP
      IF NOT TabcolContrat(i).COLUMN_NAME='MATRIC' AND NOT TabcolContrat(i).COLUMN_NAME='NUMPAC' AND NOT TabcolContrat(i).COLUMN_NAME='PACMAT' AND NOT TabcolContrat(i).COLUMN_NAME='NUMCNT' AND NOT TabcolContrat(i).COLUMN_NAME='DSDCN' AND NOT TabcolContrat(i).COLUMN_NAME='DSFCN' THEN
        v_reqCreate                     := v_reqCreate||', '||TabcolContrat(i).COLUMN_NAME||' DIC_ADM_CONTRAT.'||TabcolContrat(i).COLUMN_NAME||'%TYPE';
      END IF;
    END LOOP;
    v_reqCreate := v_reqCreate||');';
    v_reqCreate := v_reqCreate||'ligContrat TypeColContrat;';
    v_reqCreate := v_reqCreate||'previous_ligContrat TypeColContrat;   ';
  END IF;
  IF TabcolContratHisto.count>0 THEN
    v_reqCreate             := v_reqCreate||'
    cursor curHisto is  SELECT MATRIC, NUMPAC, PACMAT, NUMCNT, DATE_EFF, DATE_FIN';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      IF NOT TabcolContratHisto(i).COLUMN_NAME='MATRIC' AND NOT TabcolContratHisto(i).COLUMN_NAME='NUMPAC' AND NOT TabcolContratHisto(i).COLUMN_NAME='PACMAT' AND NOT TabcolContratHisto(i).COLUMN_NAME='NUMCNT' AND NOT TabcolContratHisto(i).COLUMN_NAME='DATE_EFF' AND NOT TabcolContratHisto(i).COLUMN_NAME='DATE_FIN' THEN
        v_reqCreate                          := v_reqCreate||', '||TabcolContratHisto(i).COLUMN_NAME;
      END IF;
    END LOOP;
    v_reqCreate := v_reqCreate||' FROM DIC_ADM_CONTRAT_HISTO WHERE p_onlyFlaggedNumpacPacmat=0 OR (NUMPAC,PACMAT) IN (SELECT NUMPAC,PACMAT FROM SECUPACMAT_TMP_CONTRAT) ORDER BY Matric, Date_eff;';
    v_reqCreate := v_reqCreate||'
    TYPE TypeColHisto IS RECORD (MATRIC DIC_ADM_CONTRAT_HISTO.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT_HISTO.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT_HISTO.PACMAT%TYPE, NUMCNT DIC_ADM_CONTRAT_HISTO.NUMCNT%TYPE, DATE_EFF DIC_ADM_CONTRAT_HISTO.DATE_EFF%TYPE, DATE_FIN DIC_ADM_CONTRAT_HISTO.DATE_FIN%TYPE';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      IF NOT TabcolContratHisto(i).COLUMN_NAME='MATRIC' AND NOT TabcolContratHisto(i).COLUMN_NAME='NUMPAC' AND NOT TabcolContratHisto(i).COLUMN_NAME='PACMAT' AND NOT TabcolContratHisto(i).COLUMN_NAME='NUMCNT' AND NOT TabcolContratHisto(i).COLUMN_NAME='DATE_EFF' AND NOT TabcolContratHisto(i).COLUMN_NAME='DATE_FIN' THEN
        v_reqCreate                          := v_reqCreate||', '||TabcolContratHisto(i).COLUMN_NAME||' DIC_ADM_CONTRAT_HISTO.'||TabcolContratHisto(i).COLUMN_NAME||'%TYPE';
      END IF;
    END LOOP;
    v_reqCreate := v_reqCreate||');';
    v_reqCreate := v_reqCreate||'ligHisto TypeColHisto;';
    v_reqCreate := v_reqCreate||'previous_ligHisto TypeColHisto;   ';
  END IF;
  IF TabcolContrat.count>0 OR TabcolContratHisto.count>0 THEN
    v_reqCreate        := v_reqCreate||'TYPE TYP_LIG_IDX IS RECORD ( ';
    v_reqCreate        := v_reqCreate||'  NUMPAC DIC_IDX_CONTRAT_HISTO_TMP.NUMPAC%TYPE, ';
    v_reqCreate        := v_reqCreate||'  PACMAT DIC_IDX_CONTRAT_HISTO_TMP.PACMAT%TYPE, ';
    v_reqCreate        := v_reqCreate||'  NUMCNT DIC_IDX_CONTRAT_HISTO_TMP.NUMCNT%TYPE, ';
    v_reqCreate        := v_reqCreate||'  DATE_EFF DIC_IDX_CONTRAT_HISTO_TMP.DATE_EFF%TYPE, ';
    v_reqCreate        := v_reqCreate||'  NOM_DONNEE DIC_IDX_CONTRAT_HISTO_TMP.NOM_DONNEE%TYPE, ';
    v_reqCreate        := v_reqCreate||'  IDPACMAT DIC_IDX_CONTRAT_HISTO_TMP.IDPACMAT%TYPE, ';
    v_reqCreate        := v_reqCreate||'  DATE_FIN DIC_IDX_CONTRAT_HISTO_TMP.DATE_FIN%TYPE, ';
    v_reqCreate        := v_reqCreate||'  RUPTURE_CONTRAT DIC_IDX_CONTRAT_HISTO_TMP.RUPTURE_CONTRAT%TYPE, ';
    v_reqCreate        := v_reqCreate||'  DATE_DERNIERE_MODIF DIC_IDX_CONTRAT_HISTO_TMP.DATE_DERNIERE_MODIF%TYPE); ';
    v_reqCreate        := v_reqCreate||'TYPE TYP_TAB_IDX IS TABLE OF TYP_LIG_IDX ; ';
    v_reqCreate        := v_reqCreate||'Tabidx TYP_TAB_IDX ; ';
    v_reqCreate        := v_reqCreate||'Ligidx TYP_LIG_IDX ; ';
  END IF;
  IF TabcolContratHisto.count>0 THEN
    v_reqCreate             := v_reqCreate||'TYPE TAB_INDICE_IDX_BY_DONNEE IS TABLE OF NUMBER INDEX BY VARCHAR2(20) ; ';
    v_reqCreate             := v_reqCreate||'tabIndice TAB_INDICE_IDX_BY_DONNEE ; ';
    v_reqCreate             := v_reqCreate||'bMATRIC NUMBER ; ';
    v_reqCreate             := v_reqCreate||'bCNT NUMBER ; ';
    FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
    LOOP
      v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' NUMBER ; ';
    END LOOP;
  END IF;
  v_reqCreate          := v_reqCreate||'BEGIN ';
  IF TabcolContrat.count=0 AND TabcolContratHisto.count=0 THEN
    v_reqCreate        := v_reqCreate||'NULL; ';
  ELSE
    v_reqCreate          := v_reqCreate||'Tabidx := TYP_TAB_IDX(); ';
    IF TabcolContrat.count>0 THEN
      v_reqCreate        := v_reqCreate||'OPEN curContrat; ';
      v_reqCreate        := v_reqCreate||'  LOOP ';
      v_reqCreate        := v_reqCreate||' FETCH curContrat INTO ligContrat; ';
      v_reqCreate        := v_reqCreate||'   EXIT ';
      v_reqCreate        := v_reqCreate||' WHEN curContrat % NOTFOUND; ';
      v_reqCreate        := v_reqCreate||' IF previous_ligContrat.PACMAT is null OR NOT previous_ligContrat.MATRIC=ligContrat.MATRIC THEN ';
      v_reqCreate        := v_reqCreate||' IF previous_ligContrat.PACMAT is not null THEN ';
      v_reqCreate        := v_reqCreate||'BEGIN ';
      v_reqCreate        := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate        := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate        := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate        := v_reqCreate||'Tabidx.delete(); ';
      v_reqCreate        := v_reqCreate||' END IF; ';
      v_reqCreate        := v_reqCreate||'Ligidx.NUMPAC := ligContrat.NUMPAC; ';
      v_reqCreate        := v_reqCreate||'Ligidx.PACMAT := ligContrat.PACMAT; ';
      v_reqCreate        := v_reqCreate||'Ligidx.NUMCNT := ligContrat.NUMCNT; ';
      v_reqCreate        := v_reqCreate||'Ligidx.DATE_EFF := ligContrat.DSDCN; ';
      v_reqCreate        := v_reqCreate||'Ligidx.DATE_FIN := NULL; ';
      v_reqCreate        := v_reqCreate||'Ligidx.NOM_DONNEE := ''*''; ';
      v_reqCreate        := v_reqCreate||'Ligidx.RUPTURE_CONTRAT := NULL; ';
      v_reqCreate        := v_reqCreate||'Tabidx.extend; ';
      v_reqCreate        := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
      v_reqCreate        := v_reqCreate||'ELSE ';
      v_reqCreate        := v_reqCreate||'Ligidx.NUMPAC := ligContrat.NUMPAC; ';
      v_reqCreate        := v_reqCreate||'Ligidx.PACMAT := ligContrat.PACMAT; ';
      v_reqCreate        := v_reqCreate||'Ligidx.NUMCNT := ligContrat.NUMCNT; ';
      v_reqCreate        := v_reqCreate||'Ligidx.DATE_EFF := ligContrat.DSDCN; ';
      v_reqCreate        := v_reqCreate||'Ligidx.DATE_FIN := NULL; ';
      v_reqCreate        := v_reqCreate||'Ligidx.NOM_DONNEE := ''+''; ';
      v_reqCreate        := v_reqCreate||'Ligidx.RUPTURE_CONTRAT := NULL; ';
      v_reqCreate        := v_reqCreate||'Tabidx.extend; ';
      v_reqCreate        := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
      FOR i IN TabcolContrat.first..TabcolContrat.last
      LOOP
        emptyVal                        := '_EMPTY_';
        IF (TabcolContrat(i).COLUMN_TYPE = 'NUMBER') THEN
          emptyVal                      := '0';
        END IF;
        v_reqCreate             := v_reqCreate||' 
IF NOT NVL(TO_CHAR(previous_ligContrat.'||TabcolContrat(i).COLUMN_NAME||'),'''||emptyVal||''') = NVL(TO_CHAR(ligContrat.'||TabcolContrat(i).COLUMN_NAME||'),'''||emptyVal||''') THEN ';
        v_reqCreate             := v_reqCreate||'Ligidx.NUMPAC := ligContrat.NUMPAC; ';
        v_reqCreate             := v_reqCreate||'Ligidx.PACMAT := ligContrat.PACMAT; ';
        v_reqCreate             := v_reqCreate||'Ligidx.NUMCNT := ligContrat.NUMCNT; ';
        v_reqCreate             := v_reqCreate||'Ligidx.DATE_EFF := ligContrat.DSDCN; ';
        v_reqCreate             := v_reqCreate||'Ligidx.DATE_FIN := NVL(ligContrat.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')); ';
        v_reqCreate             := v_reqCreate||'Ligidx.NOM_DONNEE := '''||TabcolContrat(i).COLUMN_NAME||'''; ';
        v_reqCreate             := v_reqCreate||'Ligidx.RUPTURE_CONTRAT := NULL; ';
        v_reqCreate             := v_reqCreate||'Tabidx.extend; ';
        v_reqCreate             := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
        v_reqCreate             := v_reqCreate||'END IF; ';
        v_reqProcInsertContrat1 := v_reqProcInsertContrat1||' 
ALIM_IDX.INSERT_DATA_CONTRAT( 
'''||TabcolContrat(i).COLUMN_NAME||''', 
'''||emptyVal||''', 
TO_CHAR(p_lignePrec.'||TabcolContrat(i).COLUMN_NAME||'), 
TO_CHAR(p_ligne.'||TabcolContrat(i).COLUMN_NAME||'), 
p_ligne); ';
        v_reqProcUpdateContrat1 := v_reqProcUpdateContrat1||' 
ALIM_IDX.UPDATE_DATA_CONTRAT( 
'''||TabcolContrat(i).COLUMN_NAME||''', 
'''||emptyVal||''', 
TO_CHAR(p_lignePrec.'||TabcolContrat(i).COLUMN_NAME||'), 
TO_CHAR(p_ligne.'||TabcolContrat(i).COLUMN_NAME||'), 
TO_CHAR(p_ligneSuiv.'||TabcolContrat(i).COLUMN_NAME||'), 
TO_CHAR(v_oldContrat.'||TabcolContrat(i).COLUMN_NAME||'), 
p_lignePrec, 
p_ligne, 
p_ligneSuiv, 
v_listeDonneesIdx, 
p_listeDonneesRupt); ';
        v_reqProcDeleteContrat1 := v_reqProcDeleteContrat1||' 
DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND DATE_EFF=p_listeClesIdxContrat(i).DATE_IDX AND NOM_DONNEE='''||TabcolContrat(i).COLUMN_NAME||'''; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'  previous_ligContrat:=ligContrat;';
      v_reqCreate := v_reqCreate||' end loop;';
      v_reqCreate := v_reqCreate||'close curContrat;';
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
    END IF;
    IF TabcolContratHisto.count       >0 THEN
      v_reqCreate                    := v_reqCreate||'OPEN curHisto; ';
      v_reqCreateHistoRuptureContrat := 'tabIndice.delete(); ';
      v_reqCreateHistoModifOnly      := NULL;
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        IF TabcolContratHisto(i).COUNT_TABLE>0 THEN
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.NUMPAC := ligHisto.NUMPAC; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.PACMAT := ligHisto.PACMAT; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.NUMCNT := ligHisto.NUMCNT; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.DATE_EFF := ligHisto.DATE_EFF; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.DATE_FIN := ligHisto.DATE_FIN; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.NOM_DONNEE := '''||TabcolContratHisto(i).COLUMN_NAME||'''; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Ligidx.RUPTURE_CONTRAT := ''O''; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Tabidx.extend; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'Tabidx(Tabidx.last) := Ligidx; ';
          v_reqCreateHistoRuptureContrat   := v_reqCreateHistoRuptureContrat||'tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''') := Tabidx.last; ';
          v_reqProcInsertContrat2          := v_reqProcInsertContrat2||' 
BEGIN
MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE='''||TabcolContratHisto(i).COLUMN_NAME||''') WHEN MATCHED THEN UPDATE SET DATE_FIN=NVL(p_ligne.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')), RUPTURE_CONTRAT=''O'', DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_FIN,RUPTURE_CONTRAT,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DSDCN,'''||TabcolContratHisto(i).COLUMN_NAME||''',NVL(p_ligne.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')),''O'',SYSDATE); 
EXCEPTION
 WHEN DUP_VAL_ON_INDEX THEN NULL;
 WHEN OTHERS THEN 
 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
 TGE_IMPORT_AVANCEMENT_proc(''ALIM_IDX_INSERT_CONTRAT'',''Erreur merge idpacmat '' || p_ligne.NUMPAC || p_ligne.PACMAT);
 END;';
          v_reqProcDeleteContrat2          := v_reqProcDeleteContrat2||' 
DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND DATE_EFF=p_listeClesIdxContrat(i).DATE_IDX AND NOM_DONNEE='''||TabcolContratHisto(i).COLUMN_NAME||''' AND RUPTURE_CONTRAT=''O''; ';
        END IF;
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'IF b'||TabcolContratHisto(i).COLUMN_NAME||'=1 THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'IF tabIndice.exists('''||TabcolContratHisto(i).COLUMN_NAME||''') AND Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).DATE_EFF = ligHisto.DATE_EFF THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).RUPTURE_CONTRAT := NULL; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'ELSE ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NUMPAC := ligHisto.NUMPAC; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.PACMAT := ligHisto.PACMAT; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NUMCNT := ligHisto.NUMCNT; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.DATE_EFF := ligHisto.DATE_EFF; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.DATE_FIN := ligHisto.DATE_FIN; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.NOM_DONNEE := '''||TabcolContratHisto(i).COLUMN_NAME||'''; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Ligidx.RUPTURE_CONTRAT := NULL; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx.extend; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(Tabidx.last) := Ligidx; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''') := Tabidx.last; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'END IF; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'ELSIF tabIndice.exists('''||TabcolContratHisto(i).COLUMN_NAME||''') THEN ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'Tabidx(tabIndice('''||TabcolContratHisto(i).COLUMN_NAME||''')).DATE_FIN := ligHisto.DATE_FIN; ';
        v_reqCreateHistoModifOnly := v_reqCreateHistoModifOnly||'END IF; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'  LOOP ';
      v_reqCreate := v_reqCreate||' FETCH curHisto INTO ligHisto; ';
      v_reqCreate := v_reqCreate||'   EXIT ';
      v_reqCreate := v_reqCreate||' WHEN curHisto % NOTFOUND; ';
      v_reqCreate := v_reqCreate||' IF previous_ligHisto.PACMAT is null OR NOT previous_ligHisto.MATRIC=ligHisto.MATRIC THEN ';
      v_reqCreate := v_reqCreate||'bMATRIC := 1; ';
      v_reqCreate := v_reqCreate||'bCNT := 1; ';
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        v_reqCreate := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 0; ';
      END LOOP;
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
      v_reqCreate := v_reqCreate||'ELSE ';
      v_reqCreate := v_reqCreate||'bMATRIC := 0; ';
      v_reqCreate := v_reqCreate||'IF NOT (previous_ligHisto.NUMPAC=ligHisto.NUMPAC AND previous_ligHisto.PACMAT=ligHisto.PACMAT AND previous_ligHisto.NUMCNT=ligHisto.NUMCNT) THEN ';
      v_reqCreate := v_reqCreate||'bCNT := 1; ';
      v_reqCreate := v_reqCreate||'ELSE ';
      v_reqCreate := v_reqCreate||'bCNT := 0; ';
      v_reqCreate := v_reqCreate||'END IF; ';
      FOR i IN TabcolContratHisto.first..TabcolContratHisto.last
      LOOP
        emptyVal                             := '_EMPTY_';
        IF (TabcolContratHisto(i).COLUMN_TYPE = 'NUMBER') THEN
          emptyVal                           := '0';
        END IF;
        v_reqCreate                  := v_reqCreate||' 
IF NOT NVL(TO_CHAR(previous_ligHisto.'||TabcolContratHisto(i).COLUMN_NAME||'),'''||emptyVal||''') = NVL(TO_CHAR(ligHisto.'||TabcolContratHisto(i).COLUMN_NAME||'),'''||emptyVal||''') THEN ';
        v_reqCreate                  := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 1; ';
        v_reqCreate                  := v_reqCreate||'ELSE ';
        v_reqCreate                  := v_reqCreate||'b'||TabcolContratHisto(i).COLUMN_NAME||' := 0; ';
        v_reqCreate                  := v_reqCreate||'END IF; ';
        v_reqProcInsertContratHisto1 := v_reqProcInsertContratHisto1||' 
ALIM_IDX.INSERT_DATA_CONTRAT_HISTO( 
'''||TabcolContratHisto(i).COLUMN_NAME||''', 
'''||emptyVal||''', 
TO_CHAR(p_lignePrec.'||TabcolContratHisto(i).COLUMN_NAME||'), 
TO_CHAR(p_ligne.'||TabcolContratHisto(i).COLUMN_NAME||'), 
TO_CHAR(p_ligneSuiv.'||TabcolContratHisto(i).COLUMN_NAME||'), 
p_ligne, 
p_ligneSuiv, 
v_dsfcn, 
v_listeDonneesIdx, 
v_listeDonneesRupt); ';
        v_reqProcUpdateContratHisto1 := v_reqProcUpdateContratHisto1||' 
ALIM_IDX.UPDATE_DATA_CONTRAT_HISTO( 
'''||TabcolContratHisto(i).COLUMN_NAME||''', 
'''||emptyVal||''', 
TO_CHAR(p_lignePrec.'||TabcolContratHisto(i).COLUMN_NAME||'), 
TO_CHAR(p_ligne.'||TabcolContratHisto(i).COLUMN_NAME||'), 
TO_CHAR(p_ligneSuiv.'||TabcolContratHisto(i).COLUMN_NAME||'), 
TO_CHAR(v_oldContratHisto.'||TabcolContratHisto(i).COLUMN_NAME||'), 
p_lignePrec, 
p_ligne, 
p_ligneSuiv, 
v_dsdcn, 
v_dsfcn, 
v_listeDonneesIdx, 
p_listeDonneesRupt); ';
      END LOOP;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'IF bCNT=1 THEN ';
      v_reqCreate := v_reqCreate||v_reqCreateHistoRuptureContrat;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'IF bMATRIC=0 THEN ';
      v_reqCreate := v_reqCreate||v_reqCreateHistoModifOnly;
      v_reqCreate := v_reqCreate||'END IF; ';
      v_reqCreate := v_reqCreate||'  previous_ligHisto:=ligHisto;';
      v_reqCreate := v_reqCreate||' end loop;';
      v_reqCreate := v_reqCreate||'close curHisto;';
      v_reqCreate := v_reqCreate||'BEGIN ';
      v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
      v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_CONTRAT_HISTO_TMP (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (Tabidx(i).NUMPAC, Tabidx(i).PACMAT, Tabidx(i).NUMCNT, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN, Tabidx(i).RUPTURE_CONTRAT, SYSDATE); ';
      v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
      v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
    END IF;
    IF TabcolContrat.count>0 OR TabcolContratHisto.count>0 THEN
      v_reqCreate        := v_reqCreate||'BEGIN
      MERGE INTO DIC_IDX_CONTRAT_HISTO IDX USING (SELECT * FROM DIC_IDX_CONTRAT_HISTO_TMP) IDX_TMP ON (IDX.NUMPAC=IDX_TMP.NUMPAC AND IDX.PACMAT=IDX_TMP.PACMAT AND IDX.NUMCNT=IDX_TMP.NUMCNT AND IDX.DATE_EFF=IDX_TMP.DATE_EFF AND IDX.NOM_DONNEE=IDX_TMP.NOM_DONNEE) WHEN MATCHED THEN UPDATE SET DATE_FIN=IDX_TMP.DATE_FIN, RUPTURE_CONTRAT=IDX_TMP.RUPTURE_CONTRAT, DATE_DERNIERE_MODIF= (case when (IDX_TMP.DATE_FIN<>IDX.DATE_FIN or NVL(IDX.RUPTURE_CONTRAT,''N'')<>NVL(IDX_TMP.RUPTURE_CONTRAT,''N'') ) then IDX_TMP.DATE_DERNIERE_MODIF else IDX.DATE_DERNIERE_MODIF end) WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_FIN, RUPTURE_CONTRAT, DATE_DERNIERE_MODIF) VALUES (IDX_TMP.NUMPAC, IDX_TMP.PACMAT, IDX_TMP.NUMCNT, IDX_TMP.DATE_EFF, IDX_TMP.NOM_DONNEE, IDX_TMP.DATE_FIN, IDX_TMP.RUPTURE_CONTRAT, IDX_TMP.DATE_DERNIERE_MODIF); 
      EXCEPTION
	 WHEN DUP_VAL_ON_INDEX THEN NULL;
	 WHEN OTHERS THEN 
	 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
	 TGE_IMPORT_AVANCEMENT_proc(''ALIM_IDX_INSERT_CONTRAT'',''Erreur merge idpacmat IDX '');
	 END;';
    END IF;
    v_reqCreate := v_reqCreate||'IF p_onlyFlaggedNumpacPacmat=1 THEN ';
    v_reqCreate := v_reqCreate||'DELETE FROM DIC_IDX_CONTRAT_HISTO ';
    v_reqCreate := v_reqCreate||' WHERE NOT EXISTS (SELECT 1 FROM DIC_IDX_CONTRAT_HISTO_TMP WHERE NUMPAC=DIC_IDX_CONTRAT_HISTO.NUMPAC AND PACMAT=DIC_IDX_CONTRAT_HISTO.PACMAT AND NUMCNT=DIC_IDX_CONTRAT_HISTO.NUMCNT AND DATE_EFF=DIC_IDX_CONTRAT_HISTO.DATE_EFF AND NOM_DONNEE=DIC_IDX_CONTRAT_HISTO.NOM_DONNEE) ';
    v_reqCreate := v_reqCreate||' AND EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE NUMPAC=DIC_IDX_CONTRAT_HISTO.NUMPAC AND PACMAT=DIC_IDX_CONTRAT_HISTO.PACMAT); ';
    v_reqCreate := v_reqCreate||'ELSE ';
    v_reqCreate := v_reqCreate||'DELETE FROM DIC_IDX_CONTRAT_HISTO ';
    v_reqCreate := v_reqCreate||' WHERE NOT EXISTS (SELECT 1 FROM DIC_IDX_CONTRAT_HISTO_TMP WHERE NUMPAC=DIC_IDX_CONTRAT_HISTO.NUMPAC AND PACMAT=DIC_IDX_CONTRAT_HISTO.PACMAT AND NUMCNT=DIC_IDX_CONTRAT_HISTO.NUMCNT AND DATE_EFF=DIC_IDX_CONTRAT_HISTO.DATE_EFF AND NOM_DONNEE=DIC_IDX_CONTRAT_HISTO.NOM_DONNEE); ';
    v_reqCreate := v_reqCreate||'END IF; ';
  END IF;
  v_reqCreate := v_reqCreate||'END ALIM_IDX_CONTRAT_HISTO;';
  EXECUTE_IMMEDIATE_STRING(v_reqCreate,0);
  -- Procédure de mise à jour plus fine
  v_reqProcInsertContrat :=
  ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_INSERT_CONTRAT(p_lignePrec T_LIG_DAC, p_ligne T_LIG_DAC, p_ligneSuiv T_LIG_DAC) IS 
BEGIN 
IF p_lignePrec.NUMPAC IS NULL THEN
BEGIN 
MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=''*'') WHEN MATCHED THEN UPDATE SET DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DSDCN,''*'',SYSDATE);
EXCEPTION
 WHEN DUP_VAL_ON_INDEX THEN NULL;
 WHEN OTHERS THEN 
 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
 TGE_IMPORT_AVANCEMENT_proc(''ALIM_IDX_INSERT_CONTRAT'',''Erreur merge idpacmat '' || p_ligne.NUMPAC || p_ligne.PACMAT);
 END; 
ELSE 
BEGIN
MERGE INTO DIC_IDX_CONTRAT_HISTO USING (SELECT 1 FROM DUAL) ON (NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN AND NOM_DONNEE=''+'') WHEN MATCHED THEN UPDATE SET DATE_DERNIERE_MODIF=SYSDATE WHEN NOT MATCHED THEN INSERT (NUMPAC,PACMAT,NUMCNT,DATE_EFF,NOM_DONNEE,DATE_DERNIERE_MODIF) VALUES (p_ligne.NUMPAC,p_ligne.PACMAT,p_ligne.NUMCNT,p_ligne.DSDCN,''+'',SYSDATE); 
EXCEPTION
 WHEN DUP_VAL_ON_INDEX THEN NULL;
 WHEN OTHERS THEN 
 -- les merge ne doivent pas tout faire planter, si cela arrive, on trace juste le probleme
 TGE_IMPORT_AVANCEMENT_proc(''ALIM_IDX_INSERT_CONTRAT'',''Erreur merge idpacmat '' || p_ligne.NUMPAC || p_ligne.PACMAT);
 END;'
  || v_reqProcInsertContrat1||' 
 END IF; '|| v_reqProcInsertContrat2||'
 END ALIM_IDX_INSERT_CONTRAT;';
  v_reqProcUpdateContrat :=
  ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_UPDATE_CONTRAT(p_lignePrec T_LIG_DAC, p_ligne T_LIG_DAC, p_ligneSuiv T_LIG_DAC, p_tabDac T_TAB_DAC, p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE) IS 
v_oldContrat T_LIG_DAC := GET_EMPTY_LIG_DAC(); 
TYPE tcur IS REF CURSOR; 
cur tcur; 
v_nomDonnee VARCHAR2(30); 
v_dateEff DATE; 
v_listeDonneesIdx ALIM_IDX.T_EXISTE_IDX_DONNEE; 
BEGIN 
FOR i in 1..p_tabDac.COUNT LOOP
  IF p_tabDac(i).NUMPAC=p_ligne.NUMPAC 
      AND p_tabDac(i).PACMAT=p_ligne.PACMAT 
      AND p_tabDac(i).NUMCNT=p_ligne.NUMCNT THEN
    v_oldContrat := p_tabDac(i);
    EXIT WHEN v_oldContrat IS NOT NULL;
  END IF;
END LOOP;
OPEN cur FOR 
SELECT NOM_DONNEE, DATE_EFF 
FROM DIC_IDX_CONTRAT_HISTO 
WHERE ((NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_EFF=p_ligne.DSDCN) 
OR (NUMPAC=p_ligneSuiv.NUMPAC AND PACMAT=p_ligneSuiv.PACMAT AND NUMCNT=p_ligneSuiv.NUMCNT AND DATE_EFF=p_ligneSuiv.DSDCN)) 
AND NOM_DONNEE IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME=''DIC_ADM_CONTRAT'') 
ORDER BY NOM_DONNEE, DATE_EFF; 
LOOP 
FETCH cur INTO v_nomDonnee, v_dateEff; 
EXIT WHEN cur % NOTFOUND; 
IF v_dateEff = p_ligne.DSDCN THEN 
v_listeDonneesIdx(v_nomDonnee) := 1; 
ELSIF v_dateEff = p_ligneSuiv.DSDCN THEN 
v_listeDonneesIdx(v_nomDonnee||''+1'') := 1; 
END IF; 
END LOOP; 
CLOSE cur; '
  || v_reqProcUpdateContrat1||' 
IF NOT NVL(TO_CHAR(v_oldContrat.DSFCN),''_EMPTY_'')=NVL(TO_CHAR(p_ligne.DSFCN),''_EMPTY_'') THEN 
UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=NVL(p_ligne.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')) WHERE NUMPAC=p_ligne.NUMPAC AND PACMAT=p_ligne.PACMAT AND NUMCNT=p_ligne.NUMCNT AND DATE_FIN=NVL(v_oldContrat.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')); 
END IF; 
END ALIM_IDX_UPDATE_CONTRAT;';
  v_reqProcDeleteContrat      := ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_DELETE_CONTRAT(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) IS 
BEGIN 
FOR i in 1..p_listeClesIdxContrat.count LOOP 
DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND DATE_EFF=p_listeClesIdxContrat(i).DATE_IDX AND NOM_DONNEE IN (''*'',''+''); '|| v_reqProcDeleteContrat1|| v_reqProcDeleteContrat2||' 
END LOOP; 
END ALIM_IDX_DELETE_CONTRAT;';
  v_reqProcInsertContratHisto :=
  ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_INSERT_CONTRAT_HISTO(p_lignePrec T_LIG_DACH, p_ligne T_LIG_DACH, p_ligneSuiv T_LIG_DACH) IS 
v_dsfcn DATE; 
TYPE tcur IS REF CURSOR; 
cur tcur; 
v_nomDonnee VARCHAR2(30); 
v_idxContratHistoPrec DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_idxContratHisto DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_idxContratHistoSuiv DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_listeDonneesIdx ALIM_IDX.T_IDX_DONNEE; 
v_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE; 
BEGIN 
v_dsfcn := NVL(GET_CONTRAT(p_ligne.NUMPAC, p_ligne.PACMAT, p_ligne.NUMCNT).DSFCN,TO_DATE(''20991231'',''yyyymmdd'')); 
OPEN cur FOR 
SELECT * 
FROM DIC_IDX_CONTRAT_HISTO 
WHERE (NUMPAC,PACMAT,NUMCNT) IN (SELECT NUMPAC,PACMAT,NUMCNT FROM DIC_ADM_CONTRAT WHERE MATRIC=p_ligne.MATRIC) 
AND NOM_DONNEE IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME=''DIC_ADM_CONTRAT_HISTO'') 
ORDER BY NOM_DONNEE, DATE_EFF; 
LOOP 
FETCH cur INTO v_idxContratHisto; 
EXIT WHEN cur % NOTFOUND; 
IF p_ligne.DATE_EFF BETWEEN v_idxContratHisto.DATE_EFF AND v_idxContratHisto.DATE_FIN THEN 
IF p_ligne.DATE_EFF = v_idxContratHisto.DATE_EFF THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE) := v_idxContratHisto; 
IF v_idxContratHistoPrec.NOM_DONNEE = v_idxContratHisto.NOM_DONNEE THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''-1'') := v_idxContratHistoPrec; 
END IF; 
ELSE 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''-1'') := v_idxContratHisto; 
END IF; 
ELSIF v_idxContratHisto.DATE_EFF > p_ligne.DATE_EFF AND NOT v_listeDonneesIdx.exists(v_idxContratHisto.NOM_DONNEE||''+1'') THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''+1'') := v_idxContratHisto; 
END IF; 
v_idxContratHistoPrec := v_idxContratHisto; 
END LOOP; 
CLOSE cur; 
OPEN cur FOR 
SELECT NOM_DONNEE 
FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT; 
LOOP 
FETCH cur INTO v_nomDonnee; 
EXIT WHEN cur % NOTFOUND; 
v_listeDonneesRupt(v_nomDonnee) := 1; 
END LOOP; 
CLOSE cur; 
IF p_lignePrec.NUMPAC IS NOT NULL THEN NULL; '
  || v_reqProcInsertContratHisto1||' 
END IF; 
END ALIM_IDX_INSERT_CONTRAT_HISTO;';
  v_reqProcUpdateContratHisto :=
  ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_UPDATE_CONTRAT_HISTO(p_lignePrec T_LIG_DACH, p_ligne T_LIG_DACH, p_ligneSuiv T_LIG_DACH, p_tabDach T_TAB_DACH, p_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE) IS 
v_oldContratHisto T_LIG_DACH := GET_EMPTY_LIG_DACH(); 
v_oldContrat DIC_ADM_CONTRAT%ROWTYPE; 
v_dsdcn DATE; 
v_dsfcn DATE; 
TYPE tcur IS REF CURSOR; 
cur tcur; 
v_nomDonnee VARCHAR2(30); 
v_idxContratHistoPrec DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_idxContratHisto DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_idxContratHistoSuiv DIC_IDX_CONTRAT_HISTO%ROWTYPE; 
v_listeDonneesIdx ALIM_IDX.T_IDX_DONNEE; 
BEGIN 
IF NOT NVL(p_ligneSuiv.NUMPAC,''_EMPTY_'')=''_SUPP_'' THEN 
FOR i in 1..p_tabDach.COUNT LOOP
  IF p_tabDach(i).NUMPAC=p_ligne.NUMPAC 
      AND p_tabDach(i).PACMAT=p_ligne.PACMAT 
      AND p_tabDach(i).NUMCNT=p_ligne.NUMCNT 
      AND p_tabDach(i).DATE_EFF=p_ligne.DATE_EFF THEN
    v_oldContratHisto := p_tabDach(i);
    EXIT WHEN v_oldContratHisto IS NOT NULL;
  END IF;
END LOOP;
END IF; 
v_oldContrat := GET_CONTRAT(p_ligne.NUMPAC, p_ligne.PACMAT, p_ligne.NUMCNT); 
v_dsdcn := v_oldContrat.DSDCN; 
v_dsfcn := NVL(v_oldContrat.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')); 
OPEN cur FOR 
SELECT * 
FROM DIC_IDX_CONTRAT_HISTO 
WHERE (NUMPAC,PACMAT,NUMCNT) IN (SELECT NUMPAC,PACMAT,NUMCNT FROM DIC_ADM_CONTRAT WHERE MATRIC=p_ligne.MATRIC) 
AND NOM_DONNEE IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME=''DIC_ADM_CONTRAT_HISTO'') 
ORDER BY NOM_DONNEE, DATE_EFF; 
LOOP 
FETCH cur INTO v_idxContratHisto; 
EXIT WHEN cur % NOTFOUND; 
IF p_ligne.DATE_EFF BETWEEN v_idxContratHisto.DATE_EFF AND v_idxContratHisto.DATE_FIN THEN 
IF p_ligne.DATE_EFF = v_idxContratHisto.DATE_EFF THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE) := v_idxContratHisto; 
IF v_idxContratHistoPrec.NOM_DONNEE = v_idxContratHisto.NOM_DONNEE THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''-1'') := v_idxContratHistoPrec; 
END IF; 
ELSE 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''-1'') := v_idxContratHisto; 
END IF; 
ELSIF v_idxContratHisto.DATE_EFF > p_ligne.DATE_EFF AND NOT v_listeDonneesIdx.exists(v_idxContratHisto.NOM_DONNEE||''+1'') THEN 
v_listeDonneesIdx(v_idxContratHisto.NOM_DONNEE||''+1'') := v_idxContratHisto; 
END IF; 
v_idxContratHistoPrec := v_idxContratHisto; 
END LOOP; 
CLOSE cur; '
  || v_reqProcUpdateContratHisto1||' 
END ALIM_IDX_UPDATE_CONTRAT_HISTO;';
  v_reqProcDeleteContratHisto :=
  ' 
CREATE OR REPLACE PROCEDURE ALIM_IDX_DELETE_CONTRAT_HISTO(p_listeClesIdxContrat T_CLES_IDX_CONTRAT_HISTO) IS 
TYPE tcur IS REF CURSOR; 
cur tcur; 
v_nomDonneePrec VARCHAR2(30); 
v_nomDonnee VARCHAR2(30); 
v_dateEffPrec DATE; 
v_dateEff DATE; 
v_dateFin DATE; 
v_listeDonneesRupt ALIM_IDX.T_EXISTE_RUPT_DONNEE; 
BEGIN 
OPEN cur FOR 
SELECT NOM_DONNEE 
FROM DIC_IDX_DONNEE_RUPTURE_CONTRAT; 
LOOP 
FETCH cur INTO v_nomDonnee; 
EXIT WHEN cur % NOTFOUND; 
v_listeDonneesRupt(v_nomDonnee) := 1; 
END LOOP; 
CLOSE cur; 
FOR i in 1..p_listeClesIdxContrat.count LOOP 
OPEN cur FOR 
SELECT NOM_DONNEE, DATE_EFF, DATE_FIN 
FROM DIC_IDX_CONTRAT_HISTO 
WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND (DATE_EFF=p_listeClesIdxContrat(i).DATE_IDX OR DATE_FIN=p_listeClesIdxContrat(i).DATE_IDX-1) 
AND NOM_DONNEE IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME=''DIC_ADM_CONTRAT_HISTO'') 
ORDER BY NOM_DONNEE, DATE_EFF; 
LOOP 
FETCH cur INTO v_nomDonnee, v_dateEff, v_dateFin; 
EXIT WHEN cur % NOTFOUND; 
IF v_dateEff = p_listeClesIdxContrat(i).DATE_IDX THEN 
IF v_nomDonnee = v_nomDonneePrec THEN 
UPDATE DIC_IDX_CONTRAT_HISTO SET DATE_DERNIERE_MODIF=SYSDATE, DATE_FIN=v_dateFin WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND NOM_DONNEE=v_nomDonnee AND DATE_EFF=v_dateEffPrec; 
END IF; 
DELETE FROM DIC_IDX_CONTRAT_HISTO WHERE NUMPAC=p_listeClesIdxContrat(i).NUMPAC AND PACMAT=p_listeClesIdxContrat(i).PACMAT AND NUMCNT=p_listeClesIdxContrat(i).NUMCNT AND DATE_EFF=p_listeClesIdxContrat(i).DATE_IDX AND NOM_DONNEE=v_nomDonnee; 
END IF; 
v_nomDonneePrec := v_nomDonnee; 
v_dateEffPrec := v_dateEff; 
END LOOP; 
CLOSE cur; 
ALIM_IDX.COMPARE_CONTRAT_HISTO(p_listeClesIdxContrat, ''D'', NULL, v_listeDonneesRupt); 
END LOOP; 
END ALIM_IDX_DELETE_CONTRAT_HISTO;';

  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcInsertContrat,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcUpdateContrat,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcDeleteContrat,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcInsertContratHisto,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcUpdateContratHisto,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN
    EXECUTE_IMMEDIATE_STRING (v_reqProcDeleteContratHisto,0);
  EXCEPTION WHEN OTHERS THEN NULL; END;
END CREATE_PROC_IDX_CONTRAT_HISTO;
##
CREATE_PROC_IDX_CONTRAT_HISTO
==
CALL CREATE_PROC_IDX_CONTRAT_HISTO()
##
CREATE_PROC_IDX_PERSO_HISTO
=SQL=
CREATE OR REPLACE PROCEDURE CREATE_PROC_IDX_PERSO_HISTO AUTHID CURRENT_USER
AS
  TYPE TYP_COL_NAME IS TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
  Tabcol TYP_COL_NAME ; 
  v_reqCreate CLOB;
BEGIN
  SELECT COLUMN_NAME BULK COLLECT
  INTO Tabcol
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME='DIC_ADM_PERSO_HISTO'
  AND COLUMN_NAME NOT IN ('MATRIC','DATE_EFF','DATE_FIN','DATE_CREATION','DATE_DERNIERE_MODIF','TYPE_WRITER')
  ORDER BY COLUMN_ID;
  EXECUTE_IMMEDIATE_STRING('CREATE OR REPLACE VIEW DIC_ADM_PERSO_HISTO_FOR_IDX AS SELECT DIC_ADM_PERSO_HISTO.*, (SELECT COUNT(*) FROM DIC_ADM_PERSO_HISTO H, DIC_ADM_PERSO P WHERE H.MATRIC=P.MATRIC AND H.DATE_EFF<=NVL(P.DSNAI,H.DATE_EFF) AND H.MATRIC=DIC_ADM_PERSO_HISTO.MATRIC) AS EXIST_DSNAI_IN_HISTO FROM DIC_ADM_PERSO_HISTO',0);
  v_reqCreate := 'CREATE OR REPLACE PROCEDURE ALIM_IDX_PERSO_HISTO (p_onlyFlaggedMatric NUMBER) ';
  v_reqCreate := v_reqCreate||'AS ';
  v_reqCreate := v_reqCreate||'TYPE TYP_TAB_PERSO IS TABLE OF DIC_ADM_PERSO%Rowtype ; ';
  v_reqCreate := v_reqCreate||'Tabperso TYP_TAB_PERSO ; ';
  v_reqCreate := v_reqCreate||'TYPE TYP_TAB_HISTO IS TABLE OF DIC_ADM_PERSO_HISTO_FOR_IDX%Rowtype ; ';
  v_reqCreate := v_reqCreate||'Tabhisto TYP_TAB_HISTO ; ';
  v_reqCreate := v_reqCreate||'TYPE TYP_TAB_IDX IS TABLE OF DIC_IDX_PERSO_HISTO%Rowtype ; ';
  v_reqCreate := v_reqCreate||'Tabidx TYP_TAB_IDX ; ';
  v_reqCreate := v_reqCreate||'Ligidx DIC_IDX_PERSO_HISTO%rowtype ; ';
  v_reqCreate := v_reqCreate||'TYPE TAB_INDICE_IDX_BY_DONNEE IS TABLE OF NUMBER INDEX BY VARCHAR2(20) ; ';
  v_reqCreate := v_reqCreate||'tabIndice TAB_INDICE_IDX_BY_DONNEE ; ';
  v_reqCreate := v_reqCreate||'BEGIN ';
  v_reqCreate := v_reqCreate||'IF p_onlyFlaggedMatric=1 THEN ';
  v_reqCreate := v_reqCreate||'DELETE FROM DIC_IDX_PERSO_HISTO WHERE MATRIC IN (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO); ';
  v_reqCreate := v_reqCreate||'Select * BULK COLLECT Into Tabhisto From DIC_ADM_PERSO_HISTO_FOR_IDX Where MATRIC In (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO) Order By Matric, date_eff; ';
  v_reqCreate := v_reqCreate||'ELSE ';
  v_reqCreate := v_reqCreate||'DELETE FROM DIC_IDX_PERSO_HISTO; ';
  v_reqCreate := v_reqCreate||'Select * BULK COLLECT Into Tabhisto From DIC_ADM_PERSO_HISTO_FOR_IDX Order By Matric, date_eff; ';
  v_reqCreate := v_reqCreate||'END IF; ';
  v_reqCreate := v_reqCreate||'Tabidx := TYP_TAB_IDX(); ';
  v_reqCreate := v_reqCreate||'IF Tabhisto.count>0 THEN ';
  v_reqCreate := v_reqCreate||'FOR i IN Tabhisto.first..Tabhisto.last LOOP ';
  v_reqCreate := v_reqCreate||'IF i=1 OR NOT Tabhisto(i-1).MATRIC=Tabhisto(i).MATRIC THEN ';
  v_reqCreate := v_reqCreate||'tabIndice.delete(); ';
  v_reqCreate := v_reqCreate||'BEGIN ';
  v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
  v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_PERSO_HISTO VALUES (Tabidx(i).MATRIC, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN); ';
  v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
  v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
  v_reqCreate := v_reqCreate||'IF Tabhisto(i).EXIST_DSNAI_IN_HISTO>0 THEN ';
  v_reqCreate := v_reqCreate||'Ligidx.MATRIC := Tabhisto(i).MATRIC; ';
  v_reqCreate := v_reqCreate||'Ligidx.DATE_EFF := Tabhisto(i).DATE_EFF; ';
  v_reqCreate := v_reqCreate||'Ligidx.DATE_FIN := NULL; ';
  v_reqCreate := v_reqCreate||'Ligidx.NOM_DONNEE := ''*''; ';
  v_reqCreate := v_reqCreate||'Tabidx.extend; ';
  v_reqCreate := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
  v_reqCreate := v_reqCreate||'ELSE ';
  IF Tabcol.count>0 THEN
    FOR i IN Tabcol.first..Tabcol.last LOOP
      v_reqCreate := v_reqCreate||'Ligidx.MATRIC := Tabhisto(i).MATRIC; ';
      v_reqCreate := v_reqCreate||'Ligidx.DATE_EFF := Tabhisto(i).DATE_EFF; ';
      v_reqCreate := v_reqCreate||'Ligidx.DATE_FIN := Tabhisto(i).DATE_FIN; ';
      v_reqCreate := v_reqCreate||'Ligidx.NOM_DONNEE := '''||Tabcol(i)||'''; ';
      v_reqCreate := v_reqCreate||'Tabidx.extend; ';
      v_reqCreate := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
      v_reqCreate := v_reqCreate||'tabIndice('''||Tabcol(i)||''') := Tabidx.last; ';
    END LOOP;
    v_reqCreate := v_reqCreate||'END IF; ';
    v_reqCreate := v_reqCreate||'ELSE ';
    FOR i IN Tabcol.first..Tabcol.last LOOP
      v_reqCreate := v_reqCreate||'
IF NOT NVL(TO_CHAR(Tabhisto(i-1).'||Tabcol(i)||'),''_EMPTY_'')=NVL(TO_CHAR(Tabhisto(i).'||Tabcol(i)||'),''_EMPTY_'') THEN ';
      v_reqCreate := v_reqCreate||'Ligidx.MATRIC := Tabhisto(i).MATRIC; ';
      v_reqCreate := v_reqCreate||'Ligidx.DATE_EFF := Tabhisto(i).DATE_EFF; ';
      v_reqCreate := v_reqCreate||'Ligidx.DATE_FIN := Tabhisto(i).DATE_FIN; ';
      v_reqCreate := v_reqCreate||'Ligidx.NOM_DONNEE := '''||Tabcol(i)||'''; ';
      v_reqCreate := v_reqCreate||'Tabidx.extend; ';
      v_reqCreate := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
      v_reqCreate := v_reqCreate||'tabIndice('''||Tabcol(i)||''') := Tabidx.last; ';
      v_reqCreate := v_reqCreate||'ELSIF tabIndice.exists('''||Tabcol(i)||''') THEN ';
      v_reqCreate := v_reqCreate||'Tabidx(tabIndice('''||Tabcol(i)||''')).DATE_FIN := Tabhisto(i).DATE_FIN; ';
      v_reqCreate := v_reqCreate||'END IF; ';
    END LOOP;
  ELSE
  	v_reqCreate := v_reqCreate||'NULL; ';
    v_reqCreate := v_reqCreate||'END IF; ';
    v_reqCreate := v_reqCreate||'ELSE ';
  	v_reqCreate := v_reqCreate||'NULL; ';
  END IF;
  v_reqCreate := v_reqCreate||'END IF; ';
  v_reqCreate := v_reqCreate||'END LOOP; ';
  v_reqCreate := v_reqCreate||'END IF; ';
  v_reqCreate := v_reqCreate||'BEGIN ';
  v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
  v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_PERSO_HISTO VALUES (Tabidx(i).MATRIC, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN); ';
  v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
  v_reqCreate := v_reqCreate||'Tabidx.delete(); ';
  v_reqCreate := v_reqCreate||'IF p_onlyFlaggedMatric=1 THEN ';
  v_reqCreate := v_reqCreate||'Select * BULK COLLECT Into Tabperso From DIC_ADM_PERSO Where DSNAI IS NOT NULL AND MATRIC NOT IN (SELECT MATRIC FROM DIC_IDX_PERSO_HISTO WHERE NOM_DONNEE=''*'') AND MATRIC In (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO) Order By Matric; ';
  v_reqCreate := v_reqCreate||'ELSE ';
  v_reqCreate := v_reqCreate||'Select * BULK COLLECT Into Tabperso From DIC_ADM_PERSO Where DSNAI IS NOT NULL AND MATRIC NOT IN (SELECT MATRIC FROM DIC_IDX_PERSO_HISTO WHERE NOM_DONNEE=''*'') Order By Matric; ';
  v_reqCreate := v_reqCreate||'END IF; ';
  v_reqCreate := v_reqCreate||'IF Tabperso.count>0 THEN ';
  v_reqCreate := v_reqCreate||'FOR i IN Tabperso.first..Tabperso.last LOOP ';
  v_reqCreate := v_reqCreate||'Ligidx.MATRIC := Tabperso(i).MATRIC; ';
  v_reqCreate := v_reqCreate||'Ligidx.DATE_EFF := Tabperso(i).DSNAI; ';
  v_reqCreate := v_reqCreate||'Ligidx.DATE_FIN := NULL; ';
  v_reqCreate := v_reqCreate||'Ligidx.NOM_DONNEE := ''*''; ';
  v_reqCreate := v_reqCreate||'Tabidx.extend; ';
  v_reqCreate := v_reqCreate||'Tabidx(Tabidx.last) := Ligidx; ';
  v_reqCreate := v_reqCreate||'END LOOP; ';
  v_reqCreate := v_reqCreate||'END IF; ';
  v_reqCreate := v_reqCreate||'BEGIN ';
  v_reqCreate := v_reqCreate||'FORALL i IN 1..Tabidx.COUNT SAVE EXCEPTIONS ';
  v_reqCreate := v_reqCreate||'INSERT INTO DIC_IDX_PERSO_HISTO VALUES (Tabidx(i).MATRIC, Tabidx(i).DATE_EFF, Tabidx(i).NOM_DONNEE, Tabidx(i).DATE_FIN); ';
  v_reqCreate := v_reqCreate||'EXCEPTION WHEN OTHERS THEN NULL; END; ';
  v_reqCreate := v_reqCreate||'END ALIM_IDX_PERSO_HISTO;';
  EXECUTE_IMMEDIATE_STRING( v_reqCreate,0);
END CREATE_PROC_IDX_PERSO_HISTO;
##
CREATE_PROC_IDX_PERSO_HISTO
==
CALL CREATE_PROC_IDX_PERSO_HISTO()
##
ALIM_IDX_PERSO_HISTO
==
CALL ALIM_IDX_PERSO_HISTO(0)
##
CREATE_PROC_SECNAV_MAJ_DATA
=SQL=
create or replace PROCEDURE CREATE_PROC_SECNAV_MAJ_DATA AUTHID CURRENT_USER
AS
TYPE TYP_COL_ROW
IS
     TABLE OF USER_TAB_COLUMNS%Rowtype ;
     Tabcol TYP_COL_ROW ;
     v_nbColPerso NUMBER;
     v_reqCreateProcPerso CLOB;
     v_nbColPersoHisto NUMBER;
     v_reqCreateProcPersoHisto CLOB;
     v_nbColContrat NUMBER;
     v_reqCreateProcContrat CLOB;
     v_nbColContratHisto NUMBER;
     v_reqCreateProcContratHisto CLOB;
     v_reqTmp CLOB;
     v_colsDACH CLOB;
BEGIN
     v_nbColPerso       :=0;
     v_nbColPersoHisto  :=0;
     v_nbColContrat     :=0;
     v_nbColContratHisto:=0;
     v_colsDACH := 'NUMPAC,PACMAT,NUMCNT,DATE_EFF';
     SELECT D.* BULK COLLECT
     INTO Tabcol
     FROM USER_TAB_COLUMNS S,
          USER_TAB_COLUMNS D
     WHERE S.COLUMN_NAME     =D.COLUMN_NAME
      AND S.COLUMN_NAME NOT IN ('MATRIC','DATE_EFF_PERSO','NUMPAC','PACMAT','IDPACMAT','CURRENT_NUMCNT','DATE_EFF_CONTRAT')
      AND S.TABLE_NAME       ='SECUPACMAT'
      AND D.TABLE_NAME      IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO')
     ORDER BY S.COLUMN_ID;
     IF Tabcol.count>0 THEN
          FOR i IN Tabcol.first..Tabcol.last
          LOOP
               v_reqTmp             := Tabcol(i).COLUMN_NAME||'=';
               IF Tabcol(i).DATA_TYPE='DATE' THEN
                    v_reqTmp        := v_reqTmp||'TO_CHAR(';
               END IF;
               v_reqTmp             := v_reqTmp||Tabcol(i).TABLE_NAME||'.'||Tabcol(i).COLUMN_NAME;
               IF Tabcol(i).DATA_TYPE='DATE' THEN
                    v_reqTmp        := v_reqTmp||',''yyyymmdd'')';
               END IF;
               IF Tabcol(i).TABLE_NAME         ='DIC_ADM_PERSO' THEN
                    v_nbColPerso              := v_nbColPerso+1;
                    IF v_reqCreateProcPerso   IS NOT NULL THEN
                         v_reqCreateProcPerso := v_reqCreateProcPerso||',';
                    END IF;
                    v_reqCreateProcPerso           := v_reqCreateProcPerso||v_reqTmp;
               ELSIF Tabcol(i).TABLE_NAME           ='DIC_ADM_PERSO_HISTO' THEN
                    v_nbColPersoHisto              := v_nbColPersoHisto+1;
                    IF v_reqCreateProcPersoHisto   IS NOT NULL THEN
                         v_reqCreateProcPersoHisto := v_reqCreateProcPersoHisto||',';
                    END IF;
                    v_reqCreateProcPersoHisto   := v_reqCreateProcPersoHisto||v_reqTmp;
               ELSIF Tabcol(i).TABLE_NAME        ='DIC_ADM_CONTRAT' THEN
                    v_nbColContrat              := v_nbColContrat+1;
                    IF v_reqCreateProcContrat   IS NOT NULL THEN
                         v_reqCreateProcContrat := v_reqCreateProcContrat||',';
                    END IF;
                    v_reqCreateProcContrat           := v_reqCreateProcContrat||v_reqTmp;
               ELSIF Tabcol(i).TABLE_NAME             ='DIC_ADM_CONTRAT_HISTO' THEN
                    v_nbColContratHisto              := v_nbColContratHisto+1;
                    IF v_reqCreateProcContratHisto   IS NOT NULL THEN
                         v_reqCreateProcContratHisto := v_reqCreateProcContratHisto||',';
                    END IF;
                    v_colsDACH := v_colsDACH||','||Tabcol(i).COLUMN_NAME;
                    v_reqCreateProcContratHisto := v_reqCreateProcContratHisto||v_reqTmp;
               END IF;
          END LOOP;
          IF v_nbColPerso            =0 THEN
               v_reqCreateProcPerso := 'NULL;';
          ELSE
               v_reqTmp             := 'MERGE INTO ## USING DIC_ADM_PERSO ON (DIC_ADM_PERSO.MATRIC=##.MATRIC AND ##.MATRIC IN (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO)) WHEN MATCHED THEN UPDATE SET '||v_reqCreateProcPerso||';';
               v_reqCreateProcPerso := 'IF p_alimTmp=0 THEN '||REPLACE(v_reqTmp, '##', 'SECUPACMAT')||' ELSE '||REPLACE(v_reqTmp, '##', 'SECUPACMAT_TMP')||' END IF;';
          END IF;
          v_reqCreateProcPerso := 'CREATE OR REPLACE PROCEDURE SECNAV_MAJ_DATA_PERSO(p_alimTmp NUMBER) IS BEGIN '||v_reqCreateProcPerso||' END SECNAV_MAJ_DATA_PERSO;';
          EXECUTE_IMMEDIATE_STRING(v_reqCreateProcPerso,0);
          IF v_nbColPersoHisto            =0 THEN
               v_reqCreateProcPersoHisto := 'NULL;';
          ELSE
               v_reqTmp                  := 'MERGE INTO ## USING DIC_ADM_PERSO_HISTO ON (DIC_ADM_PERSO_HISTO.MATRIC=##.MATRIC AND DIC_ADM_PERSO_HISTO.DATE_EFF=##.DATE_EFF_PERSO AND ##.MATRIC IN (SELECT MATRIC FROM SECUPACMAT_TMP_PERSO)) WHEN MATCHED THEN UPDATE SET '||v_reqCreateProcPersoHisto||';';
               v_reqCreateProcPersoHisto := 'IF p_alimTmp=0 THEN '||REPLACE(v_reqTmp, '##', 'SECUPACMAT')||' ELSE '||REPLACE(v_reqTmp, '##', 'SECUPACMAT_TMP')||' END IF;';
          END IF;
          v_reqCreateProcPersoHisto := 'CREATE OR REPLACE PROCEDURE SECNAV_MAJ_DATA_PERSO_HISTO(p_alimTmp NUMBER) IS BEGIN '||v_reqCreateProcPersoHisto||' END SECNAV_MAJ_DATA_PERSO_HISTO;';
          EXECUTE_IMMEDIATE_STRING( v_reqCreateProcPersoHisto,0);
          IF v_nbColContrat            =0 THEN
               v_reqCreateProcContrat := 'NULL;';
          ELSE
               v_reqTmp               := 'MERGE INTO ## USING DIC_ADM_CONTRAT ON (DIC_ADM_CONTRAT.NUMPAC=##.NUMPAC AND DIC_ADM_CONTRAT.PACMAT=##.PACMAT AND DIC_ADM_CONTRAT.NUMCNT=##.CURRENT_NUMCNT AND (##.NUMPAC,##.PACMAT) IN (SELECT NUMPAC, PACMAT FROM SECUPACMAT_TMP_CONTRAT)) WHEN MATCHED THEN UPDATE SET '||v_reqCreateProcContrat||';';
               v_reqCreateProcContrat := 'IF p_alimTmp=0 THEN '||REPLACE(v_reqTmp, '##', 'SECUPACMAT')||' ELSE '||REPLACE(v_reqTmp, '##', 'SECUPACMAT_TMP')||' END IF;';
          END IF;
          v_reqCreateProcContrat := 'CREATE OR REPLACE PROCEDURE SECNAV_MAJ_DATA_CONTRAT(p_alimTmp NUMBER) IS BEGIN '||v_reqCreateProcContrat||' END SECNAV_MAJ_DATA_CONTRAT;';
          EXECUTE_IMMEDIATE_STRING (v_reqCreateProcContrat,0);
          IF v_nbColContratHisto            =0 THEN
               v_reqCreateProcContratHisto := 'NULL;';
          ELSE
               v_reqTmp                    := 'MERGE INTO ## USING (SELECT '||v_colsDACH||' FROM DIC_ADM_CONTRAT_HISTO) DIC_ADM_CONTRAT_HISTO ON (DIC_ADM_CONTRAT_HISTO.NUMPAC=##.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=##.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=##.CURRENT_NUMCNT AND DIC_ADM_CONTRAT_HISTO.DATE_EFF=##.DATE_EFF_CONTRAT AND (##.NUMPAC,##.PACMAT) IN (SELECT NUMPAC, PACMAT FROM SECUPACMAT_TMP_CONTRAT)) WHEN MATCHED THEN UPDATE SET '||v_reqCreateProcContratHisto||';';
               v_reqCreateProcContratHisto := 'IF p_alimTmp=0 THEN '||REPLACE(v_reqTmp, '##', 'SECUPACMAT')||' ELSE '||REPLACE(v_reqTmp, '##', 'SECUPACMAT_TMP')||' END IF;';
          END IF;
          v_reqCreateProcContratHisto := 'CREATE OR REPLACE PROCEDURE SECNAV_MAJ_DATA_CONTRAT_HISTO(p_alimTmp NUMBER) IS BEGIN '||v_reqCreateProcContratHisto||' END SECNAV_MAJ_DATA_CONTRAT_HISTO;';
          EXECUTE_IMMEDIATE_STRING( v_reqCreateProcContratHisto,0);
     END IF;
END CREATE_PROC_SECNAV_MAJ_DATA;
##
CREATE_PROC_SECNAV_MAJ_DATA
==
CALL CREATE_PROC_SECNAV_MAJ_DATA()
##
TAG_CHARSET=@€éèç
##
DBMS_JOB_SUBMIT_MASSE
=SQL=
CREATE OR REPLACE PROCEDURE DBMS_JOB_SUBMIT_MASSE(listJobMasseAsyncTab IN TAB_VARCHAR, traceStr VARCHAR2)
AS
  listJobMasseAsync varchar2(4000) := NULL;
  v_jobAsyncMasseIdx NUMBER;
BEGIN
  IF NOT listJobMasseAsyncTab.exists(1) THEN
    RETURN;
  END IF;
  -- On va jusqu'à listJobMasseAsyncTab.last+1 pour traiter les derniers job dans la boucle
  FOR j IN listJobMasseAsyncTab.first..listJobMasseAsyncTab.last+1
  LOOP
    IF j = listJobMasseAsyncTab.last+1 OR (j <= listJobMasseAsyncTab.last AND LENGTH(listJobMasseAsync)+LENGTH(listJobMasseAsyncTab(j))>3500) THEN
      -- Le résultat de la concaténation va dépasser 3500 caractères (plus de qu'on va ajouter avant et après, il ne faut pas dépasser les 4000), ou alors on a fini de boucler : on envoie ce qu'on a

      DBMS_JOB.SUBMIT(v_jobAsyncMasseIdx , 'BEGIN NULL; END;' , sysdate+1);
      DBMS_JOB.WHAT(v_jobAsyncMasseIdx , '
        BEGIN
          TGE_IMPORT_AVANCEMENT_proc(''TGE_JOB_MASSE_'||v_jobAsyncMasseIdx||''',''début ASYNC '||traceStr||'''); 
          ' || REPLACE(listJobMasseAsync,'#JOB#',v_jobAsyncMasseIdx) || '
          TGE_IMPORT_AVANCEMENT_proc(''TGE_JOB_MASSE_'||v_jobAsyncMasseIdx||''',''fin ASYNC '||traceStr||' OK''); 
        EXCEPTION
          WHEN OTHERS THEN
            TGE_IMPORT_AVANCEMENT_proc(''TGE_JOB_MASSE_'||v_jobAsyncMasseIdx||''',''fin ASYNC '||traceStr||' KO : ''|| SQLCODE|| SQLERRM); 
        END;');
 	  DBMS_JOB.NEXT_DATE(v_jobAsyncMasseIdx ,  sysdate-1);


      IF j <= listJobMasseAsyncTab.last THEN
        listJobMasseAsync := listJobMasseAsyncTab(j);
      END IF;
    ELSE
      listJobMasseAsync := listJobMasseAsync||listJobMasseAsyncTab(j);
    END IF;
  END LOOP;
END DBMS_JOB_SUBMIT_MASSE;
##
DELETE_TRG_TABLE_IN_MAPTA
=SQL=
create or replace PROCEDURE DELETE_TRG_TABLE_IN_MAPTA
AS
 req                        CLOB;
 table_exist                INTEGER;
BEGIN
  FOR i IN (SELECT trigger_name, table_name FROM user_triggers 
            WHERE table_name NOT IN (SELECT tablephy FROM tge_ref_mapta WHERE allerretour IN('A', '2','I')) 
            AND table_name LIKE 'DIC_%'
            AND trigger_name = 'TRG_' || table_name)
  LOOP
    req := 'DROP TRIGGER ' || i.trigger_name;
    EXECUTE_IMMEDIATE_STRING( req,0);
  END LOOP;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20000, 'Problème(s) durant la suppression des triggers: ' || SQLCODE || '-' || sqlerrm); 
END DELETE_TRG_TABLE_IN_MAPTA;
##
TAG_CHARSET=@€éèç
##
DIC_AJOUT_CHAMP_REQUETE
=SQL=
create or replace PROCEDURE DIC_AJOUT_CHAMP_REQUETE(p_nomTable IN user_tables.table_name%TYPE,p_nomCol IN user_tab_cols.column_name%TYPE) AS
TYPE TypeTrancoTypeChamp IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(1);
tableTranscotypeChamp TypeTrancoTypeChamp;
nomRequete EDI_REQ_SQL.NOMREQ%type;
listeRequete TAB_VARCHAR;
typeDon REF_DONNEE_GENERALE.TYPE_DONNEE%type;
masqueDon REF_DONNEE_GENERALE.LONGUEUR_MASQUE_NB_ENTIERS%type;
decimaux REF_DONNEE_GENERALE.NB_DECIMAUX%type;
typeChampQuery EDI_REQ_SQL_CF.TYPEDATA%type;
champSelect EDI_REQ_SQL_CF.VALEURSELECT%type;
libel REF_DONNEE_GENERALE.LIBELLE_DONNEE%type;
compteur integer;
compId META_DICTIONNAIRE_IHM.COMPANY_ID%type := '*';
BEGIN
	champSelect := p_nomTable || '.' || p_nomCol;
	
	tableTranscotypeChamp('X') := 'T';
	tableTranscotypeChamp('9') := 'N';
	tableTranscotypeChamp('D') := 'T';
	tableTranscotypeChamp('N') := 'T';
	
	-- formatage du champ
	begin
		select DG.TYPE_DONNEE,DG.LONGUEUR_MASQUE_NB_ENTIERS, DG.NB_DECIMAUX, DG.LIBELLE_DONNEE into typeDon, masqueDon,decimaux, libel from REF_DONNEE_GENERALE DG where DG.NOM_DICTIONNAIRE = p_nomTable and NOM_DONNEE = p_nomCol and DG.COMPANY_ID = compId;
		EXCEPTION
			WHEN others THEN
			typeDon := 'X';
			masqueDon := null;
			decimaux := null;
	end;

	begin
		typeChampQuery := tableTranscotypeChamp(typeDon);
		EXCEPTION
		WHEN others THEN
			typeChampQuery := 'T';
	end;
			
	if typeDon = 'D' then
		champSelect := 'TO_CHAR(' || champSelect || ',''' || masqueDon || ''')';
	end if;
	-- fin formatage du champ
	
		
	-- établie la liste des requètes impactée par le nouveau champ
	if p_nomTable = 'DIC_ADM_PERSO' then
		listeRequete := TAB_VARCHAR('STD_REQ_DIC_ADM_PERSO','STD_REQ_DIC_PERSO_H','STD_REQ_DIC_PERSO_CONTRAT_H');
	elsif p_nomTable = 'DIC_ADM_PERSO_HISTO' then
		listeRequete := TAB_VARCHAR('STD_REQ_DIC_ADM_PERSO_HISTO','STD_REQ_DIC_PERSO_H');		
	elsif p_nomTable = 'DIC_ADM_CONTRAT' then
		listeRequete := TAB_VARCHAR('STD_REQ_DIC_ADM_CONTRAT','STD_REQ_DIC_CONTRAT_H','STD_REQ_DIC_PERSO_CONTRAT_H');	
	elsif p_nomTable = 'DIC_ADM_CONTRAT_HISTO' then
		listeRequete := TAB_VARCHAR('STD_REQ_DIC_ADM_CONTRAT_HISTO','STD_REQ_DIC_PERSO_CONTRAT_H','STD_REQ_DIC_CONTRAT_H');
	else
		listeRequete := TAB_VARCHAR();
		listeRequete.extend;
		listeRequete(listeRequete.last) := 'STD_REQ_' || p_nomTable;
		
	end if;

	--ajout du champ
	
	for elem in 1 .. listeRequete.last loop
		select nvl(max(ORDRE),0) +1 into compteur from EDI_REQ_SQL_CF where NOMREQ = listeRequete(elem);
		-- insertion des champs de la requète
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE)
			values (listeRequete(elem),p_nomCol,champSelect,null,compteur,typeChampQuery,substr(libel,1,50),0);
		EXCEPTION
			WHEN others THEN
				null;
		end;


	end loop;
	
	--commit;
END DIC_AJOUT_CHAMP_REQUETE;
##
TAG_CHARSET=@€éèç
##
DIC_AJOUT_TABLE_REQUETE
=SQL=
create or replace PROCEDURE DIC_AJOUT_TABLE_REQUETE(p_nomTable IN user_tables.table_name%TYPE,p_nomRequete EDI_REQ_SQL.NOMREQ%type) AS
	TYPE typeTrancoClefs IS TABLE OF VARCHAR2(200) INDEX BY VARCHAR2(1);
	TYPE TypeTrancoTypeChamp IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(1);
	retourChampSplit TAB_VARCHAR;
	tableTranscoCleSal typeTrancoClefs;
	tableTranscotypeChamp TypeTrancoTypeChamp;
	dictionnaire REF_DONNEE_GENERALE.NOM_DICTIONNAIRE%type;
	nomRequete EDI_REQ_SQL.NOMREQ%type;
	champSelect EDI_REQ_SQL_CF.VALEURSELECT%type;
	typeChampQuery EDI_REQ_SQL_CF.TYPEDATA%type;
	cleSalarieDictinnaire META_DICTIONNAIRE_IHM.TYPE_CLE_SALARIE%type;
	cleDictionnaire META_DICTIONNAIRE_IHM.CHAMPS_CLE%type;
	cleHistoriseDictionnaire META_DICTIONNAIRE_IHM.HISTORISE%type;
	cleClauseWhere varchar2(1000);	
	compId META_DICTIONNAIRE_IHM.COMPANY_ID%type := '*';
	compteur integer;
	typeDon REF_DONNEE_GENERALE.TYPE_DONNEE%type;
	masqueDon REF_DONNEE_GENERALE.LONGUEUR_MASQUE_NB_ENTIERS%type;
	decimaux REF_DONNEE_GENERALE.NB_DECIMAUX%type;
	gestionNumCnt integer;
begin
	tableTranscoCleSal('R') := 'MATRIC';
	tableTranscoCleSal('M') := 'NUMPAC,PACMAT';
	tableTranscoCleSal('P') := 'NUMPAC,PAIEZAD';
	tableTranscoCleSal('O') := 'DATE_EFF';
	
	tableTranscotypeChamp('X') := 'T';
	tableTranscotypeChamp('9') := 'N';
	tableTranscotypeChamp('D') := 'T';
	tableTranscotypeChamp('N') := 'T';
	
	dictionnaire := p_nomTable;
	nomRequete := p_nomRequete;

	--recherche si la table à traiter possede la clé NUMCNT --
	begin
	    gestionNumCnt := 0;
  
		select 1 into gestionNumCnt from USER_TAB_COLS where table_name = dictionnaire  AND COLUMN_NAME = 'NUMCNT';
    
		EXCEPTION
		WHEN others THEN
		gestionNumCnt := 0;
	end;
	
	
	-- cherche les clefs salarié et les autres clé fonctionnelles du dictionnaire --
	begin
		select TYPE_CLE_SALARIE,CHAMPS_CLE,HISTORISE into cleSalarieDictinnaire, cleDictionnaire , cleHistoriseDictionnaire from META_DICTIONNAIRE_IHM where NOM_DICTIONNAIRE = dictionnaire and COMPANY_ID = compId;
		
		EXCEPTION
		WHEN others THEN
		cleSalarieDictinnaire := null;
		cleDictionnaire := null;
		cleHistoriseDictionnaire := null;
	end;
	-- mémorise les clefs fonctionnelles du dictionnaire
	cleClauseWhere := cleDictionnaire;
	
	-- ajout la clef salarié -------------------------------------------------------------------
	begin
		if cleClauseWhere is not null then
			cleClauseWhere := cleClauseWhere || ',' || tableTranscoCleSal(cleSalarieDictinnaire);
			else
			cleClauseWhere := tableTranscoCleSal(cleSalarieDictinnaire);
		end if;
		
		EXCEPTION
		WHEN others THEN
		null;
	end;
	-- fin ajout la clef salarié ---------------------------------------------------------------------------------
	
	-- ajout la clef effdt si table historisé-------------------------------------------------------------------
	
	-- si cleHistoriseDictionnaire != 'O' cleClauseWhere ne change pas car on par en exception
	begin
		if cleClauseWhere is not null then
			cleClauseWhere := cleClauseWhere || ',' || tableTranscoCleSal(cleHistoriseDictionnaire);
			else
			cleClauseWhere := tableTranscoCleSal(cleHistoriseDictionnaire);
			end if;
			
		EXCEPTION
		WHEN others THEN
		null;
	end;
	

  	-- ajout de NUMCNT dans la clauseWhere pour les tables contenant la clé NUMCNT
	begin
        if gestionNumCnt=1 then
          if cleClauseWhere IS NOT NULL THEN
            cleClauseWhere  := cleClauseWhere || ',NUMCNT ';
          else
            cleClauseWhere := 'NUMCNT';
          end if;
        end if;

		EXCEPTION
		WHEN others THEN
		null;
	end;
	
	-- fin ajout la clef effdt ---------------------------------------------------------------------------------
	
	retourChampSplit := split_string_into_tab(cleClauseWhere,',');
	
	-- on reutilise la variable pour non plus stocker les colonnes clefs, mais la clause where du select
	cleClauseWhere := '';
	
	-- construit la clause where avec champs fusions, les champs dynamiques et attache un calendrider pour les dates -------------------------------------------------------------------
	compteur := 1; -- indexe des champs  pour la table EDI_REQ_SQL_FCT
	for elem in 1 .. retourChampSplit.last loop
		if retourChampSplit(elem) is not null then
			if retourChampSplit(elem) = 'DATE_EFF' then
				cleClauseWhere := cleClauseWhere || retourChampSplit(elem) || ' = to_date(''_@' || retourChampSplit(elem) || '@_'',''dd.mm.yyyy'')' || ' AND ';
				begin
					Insert into EDI_REQ_SQL_FCT (NOMREQ,CODE,CODEFCT,PARAM1,PARAM2,PARAM3,ORDRE) values (nomRequete,compteur,'1','...',retourChampSplit(elem),'dd.mm.yyyy',0);
				EXCEPTION
					WHEN others THEN
						null;
				end;
				compteur := compteur + 1;
			elsif retourChampSplit(elem) = 'MATRIC' or retourChampSplit(elem) = 'PACMAT' or retourChampSplit(elem) = 'PAIEZAD' or retourChampSplit(elem) = 'NUMPAC' OR retourChampSplit(elem) = 'NUMCNT' then
				cleClauseWhere := cleClauseWhere || retourChampSplit(elem) || ' = ''_@' || retourChampSplit(elem) || '@_''' || ' AND ';
			else
				begin
					select DG.TYPE_DONNEE,DG.LONGUEUR_MASQUE_NB_ENTIERS, DG.NB_DECIMAUX into typeDon, masqueDon,decimaux from REF_DONNEE_GENERALE DG where DG.NOM_DICTIONNAIRE = dictionnaire and NOM_DONNEE = retourChampSplit(elem) and DG.COMPANY_ID = compId;
					EXCEPTION
					WHEN others THEN
					typeDon := 'X';
					masqueDon := null;
					decimaux := null;
				end;
				if typeDon = 'D' then
					cleClauseWhere := cleClauseWhere || retourChampSplit(elem) || ' = to_date(''_@' || retourChampSplit(elem) || '@_'',''' || masqueDon || ''')' || ' AND ';
					begin
						Insert into EDI_REQ_SQL_FCT (NOMREQ,CODE,CODEFCT,PARAM1,PARAM2,PARAM3,ORDRE) values (nomRequete,compteur,'1','...',retourChampSplit(elem),'dd.mm.yyyy',0);
					EXCEPTION
					WHEN others THEN
						null;
					end;
					compteur := compteur + 1;
				elsif typeDon = '9' then
					cleClauseWhere := cleClauseWhere || retourChampSplit(elem) || ' = _@' || retourChampSplit(elem) || '@_' || ' AND ';
				else 
					cleClauseWhere := cleClauseWhere || retourChampSplit(elem) || ' = ''_@' || retourChampSplit(elem) || '@_''' || ' AND ';
				end if;

				end if;
			-- insertion parametre dynamique
			begin
				insert into EDI_REQ_PARAM (NOMREQ,NOMPARAM,FACULTATIF) values (nomRequete,retourChampSplit(elem),'false');
			EXCEPTION
				WHEN others THEN
					null;
			end;
		end if;
	end loop;
	
	--ajout du where si la clause existe
	if cleClauseWhere is not null then
		cleClauseWhere := ' where ' || cleClauseWhere;
	end if;
	
	-- supprime le dernier and inutile
	cleClauseWhere := REGEXP_REPLACE(cleClauseWhere , '\.*AND \.*$', '') ;
	
	-- insertion requète, clause
	begin
		Insert into EDI_REQ_SQL (NOMREQ,FINREQ,DELIMITEUR_TEXT,SEPAR_CHAMP,SEPAR_CHAMP_SR,AFFICHE_SR_VIDE,SANSDOUBLONS,PROPRIETAIRE) values (nomRequete ,'from ' || dictionnaire || cleClauseWhere ,'~',';','-','N','0',null);
	EXCEPTION
		WHEN others THEN
			null;
	end;	
	-- fin construit la clause where avec champs fusions, les champs dynamiques et attache un calendrider pour les dates -------------------------------------------------------------------
	
	
	-- ajout des champs du dictionnaire dans la requète ---------------------------------------------------------------------------------------------
	compteur := 1;
	for dic in (select UTC.COLUMN_ID,NOM_DONNEE,LIBELLE_DONNEE,NOM_DICTIONNAIRE,DG.TYPE_DONNEE,DG.LONGUEUR_MASQUE_NB_ENTIERS, DG.NB_DECIMAUX from REF_DONNEE_GENERALE DG, user_tab_columns UTC where DG.NOM_DICTIONNAIRE = dictionnaire and UTC.TABLE_NAME = dictionnaire and UTC.COLUMN_NAME = DG.NOM_DONNEE and DG.COMPANY_ID = compId order by UTC.COLUMN_ID)  loop
		champSelect := dictionnaire || '.' || dic.NOM_DONNEE;
		
		begin
			typeChampQuery := tableTranscotypeChamp(dic.TYPE_DONNEE);
			EXCEPTION
			WHEN others THEN
			typeChampQuery := 'T';
		end;
		if dic.TYPE_DONNEE = 'D' then
			champSelect := 'TO_CHAR(' || champSelect || ',''' || dic.LONGUEUR_MASQUE_NB_ENTIERS || ''')';
		end if;
		
		-- insertion des champs de la requète
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE)
			values (nomRequete,dic.NOM_DONNEE,champSelect,null,compteur,typeChampQuery,substr(dic.LIBELLE_DONNEE,1,50),0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
			end loop;
	--ajout des clef dans les champs fusions
	if cleSalarieDictinnaire = 'R' then
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'MATRIC', dictionnaire || '.' || 'MATRIC',null,compteur,'T','Identifiant RH',0);
			compteur:= compteur + 1;
			EXCEPTION
			WHEN others THEN
				null;
		end;
	end if;
	if cleSalarieDictinnaire = 'M' then
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'NUMPAC', dictionnaire || '.' || 'NUMPAC',null,compteur,'T','Pac',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'PACMAT', dictionnaire || '.' || 'PACMAT',null,compteur,'T','Matricule Paie',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'MATRIC', dictionnaire || '.' || 'MATRIC',null,compteur,'T','Identifiant RH',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;			
	end if;
	if cleSalarieDictinnaire = 'P' then
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'MATRIC', dictionnaire || '.' || 'MATRIC',null,compteur,'T','Identifiant RH',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;			
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'PAIEZAD', dictionnaire || '.' || 'PAIEZAD',null,compteur,'T','Periode d''emploi',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'NUMPAC', dictionnaire || '.' || 'NUMPAC',null,compteur,'T','Pac',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'PACMAT', dictionnaire || '.' || 'PACMAT',null,compteur,'T','Matricule Paie',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;			
	end if;
	
	if cleHistoriseDictionnaire = 'O' then
		begin
			Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE) 
			values (nomRequete,'DATE_EFF', 'to_char(' || dictionnaire || '.' || 'DATE_EFF' || ',''dd.mm.yyyy'')',null,compteur,'T','Date d''effet',0);
			compteur:= compteur + 1;
		EXCEPTION
			WHEN others THEN
				null;
		end;
	end if;
	
	if  gestionNumCnt = 1  THEN
    	begin 
      		Insert into EDI_REQ_SQL_CF (NOMREQ,NOMCHAMPFUSION,VALEURSELECT,SEPAR_CHAMP,ORDRE,TYPEDATA,LIBCHAMPFUSION,TAILLE)
      		Values (nomRequete,'NUMCNT', dictionnaire || '.' || 'NUMCNT', NULL, compteur,'T', 'Numero de contrat', 0);
        
      		compteur:= compteur + 1;
    
    	EXCEPTION
    		WHEN OTHERS THEN NULL;
    	end;
  	end if;
	
end;
##
DIC_CREATE_TRG_HORO
=SQL=
CREATE OR REPLACE PROCEDURE DIC_CREATE_TRG_HORO (nomTable VARCHAR2) AS
  existeColonnesHORO NUMBER; -- Les colonnes d'horodatage existent-elles ?
  reqTrgHoro VARCHAR2(4000);
BEGIN
  SELECT count(*) INTO existeColonnesHORO FROM user_tab_columns WHERE table_name= nomTable and column_name in ('DATE_CREATION','DATE_DERNIERE_MODIF');
  IF existeColonnesHORO=2 AND nomTable <> 'SECUPACMAT' THEN
    reqTrgHoro := '
CREATE OR REPLACE TRIGGER HORO_'|| nomTable ||' 
BEFORE INSERT OR UPDATE ON '|| nomTable ||' 
FOR EACH ROW 
BEGIN ';
    IF nomTable = 'DIC_ADM_PERSO' THEN
      reqTrgHoro := reqTrgHoro || '
  IF INSERTING OR (UPDATING AND NOT UPDATING(''DATE_EFF_PERSO'') AND NOT UPDATING(''CURRENT_NUMPAC'') AND NOT UPDATING(''CURRENT_PACMAT'') AND NOT UPDATING(''CURRENT_NUMCNT'') AND NOT UPDATING(''DATE_EFF_CONTRAT'')) THEN ';
    ELSIF nomTable = 'DIC_ADM_CONTRAT' THEN
      reqTrgHoro := reqTrgHoro || '
  IF INSERTING OR (UPDATING AND NOT UPDATING(''DATE_EFF_CONTRAT'') AND NOT UPDATING(''CURRENT_PAIEZAD'')) THEN ';
    END IF;
    reqTrgHoro := reqTrgHoro || '
  IF UPDATING AND NVL(:NEW.DATE_DERNIERE_MODIF,SYSDATE)=TO_DATE(''19010101'',''yyyymmdd'') THEN
    :NEW.DATE_DERNIERE_MODIF := :OLD.DATE_DERNIERE_MODIF;
  ELSE
    :NEW.DATE_DERNIERE_MODIF := SYSDATE; 
  END IF;
  IF INSERTING THEN 
    :NEW.DATE_CREATION := SYSDATE; 
  END IF; ';
    IF nomTable = 'DIC_ADM_PERSO' OR nomTable = 'DIC_ADM_CONTRAT' THEN
      reqTrgHoro := reqTrgHoro || '
  END IF;';
    END IF;
    reqTrgHoro := reqTrgHoro || '
END;';
    EXECUTE_IMMEDIATE_STRING(reqTrgHoro,0);
  END IF;
  BEGIN
    TGE_CREATE_TRIGGER(nomTable);
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END;
END DIC_CREATE_TRG_HORO;
##
DIC_GESTION_BACASABLE
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE( NOM_DICTIONNAIRE          IN VARCHAR2 ,
 NOM_DICTIONNAIRE_IDPROJET IN VARCHAR2 ,
 LISTKEYS                  IN VARCHAR2 ) AUTHID CURRENT_USER
 AS
 TYPE TYP_COL_NAME
 IS
 TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
 Tabcol TYP_COL_NAME ;
 req  VARCHAR2(512);
 lkey VARCHAR2(512);
 ListCle TYP_COL_NAME ;
 selectCle VARCHAR2(512);
 v_nbMatric NUMBER(10);
 BEGIN
 BEGIN
 EXECUTE_IMMEDIATE_STRING('DROP TABLE '||NOM_DICTIONNAIRE_IDPROJET ,0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('table absente '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
  SELECT cols.column_name BULK COLLECT INTO ListCle
  FROM USER_CONSTRAINTS cons, user_cons_columns cols
  WHERE cols.table_name = NOM_DICTIONNAIRE
  AND cons.constraint_type = 'P'
  AND cons.constraint_name = cols.constraint_name
  AND cols.column_name IN ('NUMPAC','PACMAT','PAIEZAD','MATRIC')
  AND cons.owner = cols.owner
  ORDER BY cols.table_name, cols.position;
  IF (ListCle.COUNT = 1 AND ListCle(1) = 'NUMPAC') OR ListCle.COUNT = 0 THEN
    BEGIN
   EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select * from '||NOM_DICTIONNAIRE,0) ;
   EXCEPTION
   WHEN OTHERS THEN
   --dbms_output.put('impossible de créer la table '||NOM_DICTIONNAIRE_IDPROJET);
   --FIXME utiliser la procédure trace_dbms_output()
   NULL;
    END ;
  ELSE
    selectCle := 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select DISTINCT '||NOM_DICTIONNAIRE||'.* from '||NOM_DICTIONNAIRE||',CLE_BAC_A_SABLE ';
    IF ListCle.count>0 THEN
       FOR i IN ListCle.first..ListCle.last
       LOOP
         IF i  = 1 THEN
         selectCle:=selectCle||' WHERE '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         ELSE 
         selectCle:=selectCle||' AND '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         END IF;
       END LOOP;
    END IF; 
    EXECUTE_IMMEDIATE_STRING( selectCle,0) ;
  END IF;

 IF LISTKEYS IS NULL THEN
 SELECT cols.column_name BULK COLLECT
 INTO Tabcol
 FROM user_constraints cons,
 user_cons_columns cols
 WHERE cols.table_name    = NOM_DICTIONNAIRE
 AND cons.constraint_type = 'P'
 AND cons.constraint_name = cols.constraint_name
 AND cons.owner           = cols.owner
 ORDER BY cols.table_name,
 cols.position ;
 IF Tabcol.count>0 THEN
 FOR i IN Tabcol.first..Tabcol.last
 LOOP
 IF i   > 1 THEN
 lkey:=lkey||',';
 END IF;
 lkey:=lkey||Tabcol(i);
 END LOOP;
 END IF;
 IF LENGTH(lkey)>0 THEN
 req         :='ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||lkey||')';
 dbms_output.put_line('lkey : '||lkey);
 EXECUTE_IMMEDIATE_STRING (req,0);
 END IF ;
 ELSE
 BEGIN
 EXECUTE_IMMEDIATE_STRING('ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||LISTKEYS||')',0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('impossible de positionner les clés '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
 END IF;
 END DIC_GESTION_BACASABLE;
##
DIC_GESTION_BACASABLE_POP
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE_POP AS
v_nbMatric NUMBER(10);
 BEGIN
 DELETE FROM CLE_BAC_A_SABLE;
 SELECT COUNT(MATRIC) into v_nbMatric from MATRIC_BAC_A_SABLE;
 IF v_nbMatric = 0 then
  INSERT INTO MATRIC_BAC_A_SABLE SELECT MATRIC FROM (select DISTINCT MATRIC from secupacmat ORDER BY MATRIC DESC) WHERE ROWNUM < 500;
 END IF;
 INSERT INTO CLE_BAC_A_SABLE (NUMPAC,PACMAT,PAIEZAD,MATRIC) SELECT DISTINCT DACH.NUMPAC,DACH.PACMAT,DACH.PAIEZAD,DACH.MATRIC FROM DIC_ADM_CONTRAT_HISTO DACH,MATRIC_BAC_A_SABLE WHERE DACH.MATRIC = MATRIC_BAC_A_SABLE.MATRIC;
 END DIC_GESTION_BACASABLE_POP;
##
DIC_GESTION_LIVRAISON
=SQL=
CREATE OR REPLACE PROCEDURE DIC_GESTION_LIVRAISON AS 
  nomTable VARCHAR(24); -- Nom de la table définitive (sans le suffix C99)
  existeTable NUMBER; -- La table définitive existe-t-elle ?
  existeColonne NUMBER; -- La colonne existe-t-elle dans la table définitive ?
  existeTableDansMapping NUMBER; -- La table est-elle dans TGE_REF_MAPTA, en aller ou en aller/retour ?
  existeTablePH_PH NUMBER; -- La table PH_PH existe-t-elle ?
  existeTablePHOTO NUMBER; -- La table PHOTO existe-t-elle ?
  theType user_tab_cols.data_type%TYPE;
  theLength user_tab_cols.data_length%TYPE;
  thePrecision user_tab_cols.data_precision%TYPE;
  theScale user_tab_cols.data_scale%TYPE;
  existeColonnesHORO NUMBER; -- Les colonnes d'horodatage existent-elles ?
  reqTrgHoro VARCHAR(4000);
BEGIN
  -- On parcours les tables C99
  FOR une_table IN (SELECT table_name FROM user_tables WHERE table_name LIKE 'C99_%')
  LOOP
    BEGIN
      existeTableDansMapping := -1;
      existeTablePH_PH := -1;
      existeTablePHOTO := -1;
      nomTable := SUBSTR(une_table.table_name,INSTR(une_table.table_name,'_')+1);
      SELECT count(*) INTO existeTable FROM user_tables WHERE table_name= nomTable;
      IF existeTable=0 THEN
        -- La table définitive n'existe pas : on renomme la table C99 pour en faire la table définitive
        EXECUTE_IMMEDIATE_STRING ('ALTER TABLE '||une_table.table_name||' RENAME TO '||nomTable,0);
        -- On crée les tables photo si besoin
        DIC_GESTION_PHOTO(nomTable);
        -- ajoute la creation d'une requète sur la table
        DIC_AJOUT_TABLE_REQUETE(nomTable,'STD_REQ_' || nomTable);
      ELSE
        -- La table définitive existe : on parcours les colonnes de la table C99 pour détecter celles à créer et à modifier
        FOR une_colonne IN (SELECT column_name, data_type, data_length, data_precision, data_scale FROM user_tab_cols WHERE table_name=une_table.table_name)
        LOOP
          SELECT COUNT(*) INTO existeColonne FROM user_tab_cols WHERE table_name=nomTable AND column_name=une_colonne.column_name;
          IF existeColonne=0 THEN
            -- Une colonne qui n'existe pas : on la crée
            DIC_MODIF_STRUCTURE(nomTable, une_colonne.column_name, NULL, NULL, NULL, NULL, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
          ELSE
            -- Une colonne qui existe : on la modifie si besoin
            SELECT data_type, data_length, data_precision, data_scale INTO theType, theLength, thePrecision, theScale FROM user_tab_cols WHERE table_name=nomTable AND column_name=une_colonne.column_name;
            DIC_MODIF_STRUCTURE(nomTable, une_colonne.column_name, theType, theLength, thePrecision, theScale, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
          END IF;
          IF existeTableDansMapping = -1 THEN
            -- On ne va chercher l'info qu'une seule fois par table, et pas une fois par colonne de la table
            SELECT COUNT(*) INTO existeTableDansMapping FROM TGE_REF_MAPDO DO, TGE_REF_MAPTA TA WHERE TA.tablephy=nomTable AND DO.tablegxp=TA.tableparam AND TA.allerretour in ('A','2');
            SELECT COUNT(*) INTO existeTablePH_PH FROM user_tables WHERE table_name='PH_PH_'||nomTable;
            SELECT COUNT(*) INTO existeTablePHOTO FROM user_tables WHERE table_name='PHOTO_'||nomTable;
          END IF;
          IF existeTableDansMapping=0 THEN
            -- La table définitive n'est pas dans le mapping : on supprime les tables photos si elles existent
            IF existeTablePH_PH>0 THEN
              EXECUTE_IMMEDIATE_STRING('DROP TABLE PH_PH_'||nomTable,0);
              existeTablePH_PH := 0;
            END IF;
            IF existeTablePHOTO>0 THEN
              EXECUTE_IMMEDIATE_STRING( 'DROP TABLE PHOTO_'||nomTable,0);
              existeTablePHOTO := 0;
            END IF;
          ELSE
            -- La table définitive est dans le mapping : on crée/modifie les tables photos
            IF existeTablePH_PH=0 OR existeTablePHOTO=0 THEN
              -- Si il manque une des 2 tables photo, pas de pitié, on recrée les 2
              DIC_GESTION_PHOTO(nomTable);
              existeTablePH_PH := 1;
              existeTablePHOTO := 1;
            ELSE
              SELECT COUNT(*) INTO existeColonne FROM user_tab_cols WHERE table_name='PH_PH_'||nomTable AND column_name=une_colonne.column_name;
              IF existeColonne=0 THEN
                -- Une colonne qui n'existe pas : on la crée (pour les colonnes CURRENT_IDPACMAT et IDPACMAT, on force en VARCHAR2(14) car dans les tables DIC c'est une colonne calculée)
                IF une_colonne.column_name = 'CURRENT_IDPACMAT' OR une_colonne.column_name = 'IDPACMAT' THEN
                  DIC_MODIF_STRUCTURE('PH_PH_'||nomTable, une_colonne.column_name, NULL, NULL, NULL, NULL, 'VARCHAR', 14, NULL, NULL);
                ELSE
                  DIC_MODIF_STRUCTURE('PH_PH_'||nomTable, une_colonne.column_name, NULL, NULL, NULL, NULL, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
                END IF;
              ELSE
                -- Une colonne qui existe : on la modifie si besoin
                SELECT data_type, data_length, data_precision, data_scale INTO theType, theLength, thePrecision, theScale FROM user_tab_cols WHERE table_name='PH_PH_'||nomTable AND column_name=une_colonne.column_name;
                DIC_MODIF_STRUCTURE('PH_PH_'||nomTable, une_colonne.column_name, theType, theLength, thePrecision, theScale, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
              END IF;
              
              SELECT COUNT(*) INTO existeColonne FROM user_tab_cols WHERE table_name='PHOTO_'||nomTable AND column_name=une_colonne.column_name;
              IF existeColonne=0 THEN
                -- Une colonne qui n'existe pas : on la crée (pour les colonnes CURRENT_IDPACMAT et IDPACMAT, on force en VARCHAR2(14) car dans les tables DIC c'est une colonne calculée)
                IF une_colonne.column_name = 'CURRENT_IDPACMAT' OR une_colonne.column_name = 'IDPACMAT' THEN
                  DIC_MODIF_STRUCTURE('PHOTO_'||nomTable, une_colonne.column_name, NULL, NULL, NULL, NULL, 'VARCHAR', 14, NULL, NULL);
                ELSE
                  DIC_MODIF_STRUCTURE('PHOTO_'||nomTable, une_colonne.column_name, NULL, NULL, NULL, NULL, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
                END IF;
              ELSE
                -- Une colonne qui existe : on la modifie si besoin
                SELECT data_type, data_length, data_precision, data_scale INTO theType, theLength, thePrecision, theScale FROM user_tab_cols WHERE table_name='PHOTO_'||nomTable AND column_name=une_colonne.column_name;
                DIC_MODIF_STRUCTURE('PHOTO_'||nomTable, une_colonne.column_name, theType, theLength, thePrecision, theScale, une_colonne.data_type, une_colonne.data_length, une_colonne.data_precision, une_colonne.data_scale);
              END IF;
            END IF;
          END IF;
        END LOOP;
      END IF;
    EXCEPTION 
      WHEN OTHERS THEN
        --dbms_output.put_line('Erreur avec la table : ' || nomTable || ' (' || SQLERRM || ')');
        --FIXME utiliser la procédure trace_dbms_ouput()
        CONTINUE;
    END;
    IF existeTable=1 THEN
      EXECUTE_IMMEDIATE_STRING( 'DROP TABLE '||une_table.table_name,0);
    END IF;
    DIC_CREATE_TRG_HORO(nomTable);
  END LOOP;
END DIC_GESTION_LIVRAISON;
##
DIC_GESTION_PHOTO
=SQL=
CREATE OR REPLACE PROCEDURE DIC_GESTION_PHOTO(nomTable VARCHAR2) AS 
  nombre NUMBER;
  requete CLOB;
  numpac VARCHAR2(40) := 'NUMPAC VARCHAR2(6), PACMAT VARCHAR2(8)';
  cle VARCHAR2(50);
BEGIN
  SELECT COUNT(*) INTO nombre FROM TGE_REF_MAPDO DO, TGE_REF_MAPTA TA WHERE TA.tablephy=nomTable AND DO.tablegxp=TA.tableparam AND TA.allerretour in ('A','2');
      IF nombre>0 THEN
        requete := '';
        FOR une_ligne IN (SELECT column_name, data_type, data_length, data_precision, data_scale
                          FROM user_tab_cols
                          WHERE table_name=nomTable)
        LOOP
          IF une_ligne.column_name != 'CURRENT_IDPACMAT' AND une_ligne.column_name != 'IDPACMAT' AND une_ligne.column_name != 'NUMPAC' AND une_ligne.column_name != 'PACMAT' THEN
            IF une_ligne.data_type='DATE' THEN
              requete := requete || ',' || une_ligne.column_name || ' DATE';
            ELSIF une_ligne.data_type='NUMBER' THEN
              requete := requete || ',' || une_ligne.column_name || ' ' || une_ligne.data_type || '(' || une_ligne.data_precision || ', ' || une_ligne.data_scale || ')';
            ELSE
              requete := requete || ',' || une_ligne.column_name || ' ' || une_ligne.data_type || '(' || une_ligne.data_length || ')';
            END IF;
          ELSIF une_ligne.column_name = 'CURRENT_IDPACMAT' OR une_ligne.column_name = 'IDPACMAT' THEN
            requete := requete || ',' || une_ligne.column_name || ' VARCHAR2(14)';
          END IF;
        END LOOP;
        requete := numpac || requete;
        BEGIN
          EXECUTE_IMMEDIATE_STRING('DROP TABLE PH_PH_' || nomTable,0);
        EXCEPTION WHEN OTHERS THEN NULL; END;
        EXECUTE_IMMEDIATE_STRING('CREATE TABLE PH_PH_' || nomTable || ' (' || requete || ')',0) ;
        BEGIN
          EXECUTE_IMMEDIATE_STRING('DROP TABLE PHOTO_' || nomTable,0);
        EXCEPTION WHEN OTHERS THEN NULL; END;
        EXECUTE_IMMEDIATE_STRING('CREATE TABLE PHOTO_' || nomTable || ' AS SELECT * FROM PH_PH_' || nomTable,0);
        
        cle := 'NUMPAC,PACMAT';
        FOR une_cle IN (SELECT cc.table_name, cc.column_name
                        FROM user_cons_columns cc, user_constraints u
                        WHERE cc.table_name=nomTable
                        AND cc.constraint_name = u .constraint_name
                        AND u.constraint_type='P')
        LOOP
          IF une_cle.column_name != 'NUMPAC' AND une_cle.column_name != 'PACMAT' THEN
            cle := cle || ',' || une_cle.column_name;
          END IF;
        END LOOP;
        EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE PH_PH_' || nomTable || ' ADD PRIMARY KEY (' || cle || ')',0);
        EXECUTE_IMMEDIATE_STRING ('ALTER TABLE PHOTO_' || nomTable || ' ADD PRIMARY KEY (' || cle || ')',0);
      END IF;
END DIC_GESTION_PHOTO;
##
DIC_GESTION_PURGEC99
=SQL=
CREATE OR REPLACE PROCEDURE DIC_GESTION_PURGEC99
AS
BEGIN
  DECLARE
    CURSOR c_tabs
    IS
      SELECT table_name FROM user_tables WHERE table_name LIKE 'C99%';
    nom_obj VARCHAR(500) ;
  BEGIN
    FOR curs_tab IN c_tabs
    LOOP
      nom_obj:=curs_tab.table_name;
      EXECUTE_IMMEDIATE_STRING( 'drop table ' || nom_obj ,0);
    END LOOP;
  END;
END DIC_GESTION_PURGEC99;
##
DIC_MODIF_STRUCTURE
=SQL=
create or replace PROCEDURE DIC_MODIF_STRUCTURE(
    p_nomTable IN user_tables.table_name%TYPE,
    p_nomCol IN user_tab_cols.column_name%TYPE,
    p_oldType IN user_tab_cols.data_type%TYPE,
    p_oldLength IN user_tab_cols.data_length%TYPE,
    p_oldPrecision IN user_tab_cols.data_precision%TYPE,
    p_oldScale IN user_tab_cols.data_scale%TYPE,
    p_newType IN user_tab_cols.data_type%TYPE,
    p_newLength IN user_tab_cols.data_length%TYPE,
    p_newPrecision IN user_tab_cols.data_precision%TYPE,
    p_newScale IN user_tab_cols.data_scale%TYPE) AS 
  oldLength user_tab_cols.data_length%TYPE;
  oldPrecision user_tab_cols.data_precision%TYPE;
  oldScale user_tab_cols.data_scale%TYPE;
  newLength user_tab_cols.data_length%TYPE;
  newPrecision user_tab_cols.data_precision%TYPE;
  newScale user_tab_cols.data_scale%TYPE;
  maxLgPartieEntiere NUMBER;
  maxLgPartieDecimale NUMBER;
  maxPrecision NUMBER;
  maxScale NUMBER;
  req CLOB;
BEGIN
  oldLength := p_oldLength;
  oldPrecision := p_oldPrecision;
  IF oldPrecision IS NULL THEN
    oldPrecision := 38;
  END IF;
  oldScale := p_oldScale;
  IF oldScale IS NULL THEN
    oldScale := 38;
  END IF;

  newLength := p_newLength;
  newPrecision := p_newPrecision;
  IF newPrecision IS NULL THEN
    newPrecision := 38;
  END IF;
  newScale := p_newScale;
  IF newScale IS NULL THEN
    newScale := 38;
  END IF;

  req := 'ALTER TABLE ' || p_nomTable;
  
  IF p_oldType IS NULL THEN
    -- La colonne n'existe pas dans la table : on ajoute
    req := req || ' ADD';
    oldLength := 0;
    oldPrecision := 0;
    oldScale := 0;
    DIC_AJOUT_CHAMP_REQUETE(p_nomTable,p_nomCol);
  ELSE
    -- La colonne existe dans la table : on modifie seulement si on est sur le même type
    IF NOT p_newType=p_oldType THEN
      --DBMS_OUTPUT.PUT_LINE('Types différents : pas de modification');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN;
    END IF;
    req := req || ' MODIFY';
  END IF;
  req := req || ' (' || p_nomCol || ' ' || p_newType;
  IF p_newType='VARCHAR2' THEN
    IF newLength<=oldLength THEN
      --DBMS_OUTPUT.PUT_LINE('VARCHAR2 de longueur plus petite ou égale : pas de modification');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN;
    END IF;
    req := req || '(' || newLength || ')';
  ELSIF p_newType='NUMBER' THEN
    IF(oldPrecision = 38) THEN
      --DBMS_OUTPUT.PUT_LINE('COLONNE '||p_nomCol||' de type NUMBER déjà à 38 , on ne fait rien');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN;
    END IF;
    
    IF (newPrecision-newScale)>(oldPrecision-oldScale) THEN
      maxLgPartieEntiere := (newPrecision-newScale);
    ELSE
      maxLgPartieEntiere := (oldPrecision-oldScale);
    END IF;
    IF newScale>oldScale THEN
      maxLgPartieDecimale := newScale;
    ELSE
      maxLgPartieDecimale := oldScale;
    END IF;
    maxPrecision := (maxLgPartieEntiere+maxLgPartieDecimale);
    maxScale := maxLgPartieDecimale;
    IF maxPrecision<=oldPrecision AND maxScale<=oldScale THEN
      --DBMS_OUTPUT.PUT_LINE('NUMBER de précision ou scale plus petite ou égale : pas de modification');
      --FIXME utiliser la procédure trace_dbms_output()
      RETURN;
    END IF;
    IF (maxPrecision > 38) THEN
      maxPrecision :=38;
    END IF ;
    req := req || '(' || maxPrecision || ', ' || maxScale || ')';
  ELSIF p_oldType IS NOT NULL THEN
    --DBMS_OUTPUT.PUT_LINE('Type autre que VARCHAR2 ou NUMBER : pas de modification');
    --FIXME utiliser la procédure trace_dbms_output()
    RETURN;
  END IF;
  req := req || ')';
  --DBMS_OUTPUT.PUT_LINE(req);
  --FIXME utiliser la procédure trace_dbms_output()
  BEGIN
    EXECUTE_IMMEDIATE_STRING (req,0);
    IF UPPER(p_nomTable)='SECUPACMAT' THEN
      req := REPLACE(req, 'ALTER TABLE ' || p_nomTable, 'ALTER TABLE ' || p_nomTable || '_TMP');
      --DBMS_OUTPUT.PUT_LINE(req);
      --FIXME utiliser la procédure trace_dbms_output()
      EXECUTE_IMMEDIATE_STRING( req,0);
    END IF;
  EXCEPTION 
      WHEN OTHERS THEN
        --dbms_output.put_line('Erreur avec la modification de la table  : ' || p_nomTable || ' et de la colonne ' || p_nomCol || ')');
        --FIXME utiliser la procédure trace_dbms_output()
        RETURN;
    END;
END DIC_MODIF_STRUCTURE;
##
DIF_FSED_HISTO_REP
=SQL=
CREATE OR REPLACE PROCEDURE DIF_FSED_HISTO_REP 
IS
 req                   CLOB;
 tab1   TAB_VARCHAR;
 table_name             VARCHAR2(50);
 aujourdhui             VARCHAR2(8);
 type_mois              NUMBER;
 test_trt               NUMBER;
 p_id                   NUMBER;
 p_periode              VARCHAR2(6);
 p_numpac         TGE_REF_PAC.numpac%TYPE;
 p_PERIODEENCOURS TGE_REF_PAC.PERIODEENCOURS%TYPE;
 p_DEB_HISTO_RETRO TGE_REF_PAC.DEB_HISTO_RETRO%TYPE;
 p_DEB_RETRO TGE_REF_PAC.DEB_RETRO%TYPE;
 p_NB_MOIS_RETRO TGE_REF_PAC.NB_MOIS_RETRO%TYPE;
 
 BEGIN

 p_id := GAP_TRT_SEQ_ID.nextval;
 FSED.FSED_AVANCEMENT(p_id,'*** Réparation DIF_FSED_HISTO start ***');

--Sauvegarde DFH à la date du jour et purge
 SELECT to_char(sysdate,'yyyymmdd') into aujourdhui from dual;
 req :='CREATE TABLE DIF_FSED_HISTO_'||aujourdhui||' AS SELECT * FROM DIF_FSED_HISTO';
 FSED.FSED_AVANCEMENT(p_id,'Sauvegarde à date du jour '||req);
 EXECUTE immediate req;
 COMMIT;
 req :='TRUNCATE TABLE dif_fsed_histo';
 FSED.FSED_AVANCEMENT(p_id,'Vidage '||req);
 EXECUTE immediate req;
 
 --Boucle sur les mois DIF_FSED_ssaamm
 FOR C in ( SELECT substr(table_name,10,length(table_name)) as periode from user_tables where table_name like 'DIF_FSED_%' and is_number(substr(table_name,10,length(table_name))) is not null order by
 substr(table_name,10,length(table_name)) asc ) 
 LOOP

table_name := 'DIF_FSED_'||C.periode ;
p_periode  := C.periode ;
req :='SELECT DISTINCT numpac from '||table_name;
EXECUTE immediate req bulk collect INTO tab1 ;

--Boucle sur les Pacs
FOR i IN tab1.first..tab1.last
 LOOP
 p_numpac := tab1(i);

 SELECT DEB_HISTO_RETRO,   DEB_RETRO,   NB_MOIS_RETRO,   PERIODEENCOURS
 INTO p_DEB_HISTO_RETRO, p_DEB_RETRO, p_NB_MOIS_RETRO, p_PERIODEENCOURS
 FROM TGE_REF_PAC WHERE NUMPAC =p_numpac;
 
 --Booléen (type_mois) 0/1/2 le mois pour ce Pac est concerné
 SELECT CASE WHEN (p_periode >  greatest(p_DEB_HISTO_RETRO,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'),-1*p_NB_MOIS_RETRO),'yyyymm')) and p_periode < p_PERIODEENCOURS) THEN 2
             WHEN (p_periode >= greatest(p_DEB_HISTO_RETRO,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'),-1*p_NB_MOIS_RETRO),'yyyymm')) and p_periode < p_PERIODEENCOURS) THEN 1
             ELSE 0 END INTO type_mois FROM dual;
IF type_mois = 0 THEN
 FSED.FSED_AVANCEMENT(p_id,'*** Période='||p_periode||' Pac='||p_numpac||' non concernée (deb_histo_retro='||p_DEB_HISTO_RETRO||' nb_mois='||p_NB_MOIS_RETRO||' periodeencours='||p_PERIODEENCOURS||')');
 ELSE
 FSED.FSED_AVANCEMENT(p_id,'*** Période='||p_periode||' Pac='||p_numpac||' : lancement du traitement');

 --Comptage des ID absents de GAP_TRT et création si nécessaire
 req :='SELECT COUNT(DISTINCT id_trt) from '||table_name||' z WHERE NOT EXISTS (SELECT 1 from gap_trt t where t.id_trt=z.id_trt)';
 EXECUTE immediate req INTO test_trt;
 IF test_trt > 0 THEN

 req :='DELETE FROM gap_trt_liste_mat WHERE id_trt IN (
 SELECT DISTINCT id_trt from '||table_name||' z
 WHERE NOT EXISTS (SELECT 1 from gap_trt t where t.id_trt=z.id_trt) )';
 FSED.FSED_AVANCEMENT(p_id,'Nettoyage préalable de GAP_TRT_LISTE_MAT ' ||req);
 EXECUTE immediate req;
 
 req :='INSERT INTO gap_trt_liste_mat (ID_TRT,NUMPAC,PACMAT,TRAITE)
 SELECT DISTINCT id_trt,'''||p_numpac||''',z.pacmat,''DIF_FSED_HISTO_REP'' from '||table_name||' z
 WHERE NOT EXISTS (SELECT 1 from gap_trt t where t.id_trt=z.id_trt)';
 FSED.FSED_AVANCEMENT(p_id,'Création des ID manquants dans GAP_TRT_LISTE_MAT ' ||req);
 EXECUTE immediate req;

 req :='INSERT INTO gap_trt_suivi (ID_TRT,DATE_EVT,STATUT,CODE_RETOUR_ZPP,LOGIN)
 SELECT DISTINCT id_trt,(SELECT sysdate from dual),''PA'',''00'',''DIF_FSED_HISTO_REP'' from '||table_name||' z
 WHERE NOT EXISTS (SELECT 1 from gap_trt t where t.id_trt=z.id_trt)';
 FSED.FSED_AVANCEMENT(p_id,'Création des ID manquants dans GAP_TRT_SUIVI ' ||req);
 EXECUTE immediate req;

 req :='INSERT INTO gap_trt (ID_TRT,NUMPAC,PERIODE_PAIE,NUMERO_ECHANGE,MODELE,NATURE,DATE_FIN_TRT)
 SELECT DISTINCT id_trt,a.numpac,'''||p_periode||''',''0001'',a.modele,a.nature,(SELECT sysdate from dual) from '||table_name||' z,
 (SELECT numpac,modele,nature FROM TGE_SCHEMA_PRODUCTION WHERE numpac='''||p_numpac||''' AND modele||nature =
  (SELECT max(a2.modele||a2.nature) FROM TGE_SCHEMA_PRODUCTION a2 WHERE a2.numpac='''||p_numpac||''' AND a2.TYPE_PAIE=''CONTROLE'' AND a2.date_fin is null)) a
 WHERE NOT EXISTS (SELECT 1 from gap_trt t where t.id_trt=z.id_trt)';
 FSED.FSED_AVANCEMENT(p_id,'Création des ID manquants dans GAP_TRT ' ||req);
 EXECUTE immediate req;

 COMMIT;

 END IF; 

 /*Partie 1 : recopie du mois en cours.
   Comme la table a été vidée, pas besoin de DELETE préalable.*/

 req := 'INSERT INTO dif_fsed_histo
 WITH max_id_trt AS (SELECT pacmat,MAX(b.id_trt) as id_trt
 FROM TGE_SCHEMA_PRODUCTION a, GAP_TRT b, GAP_TRT_LISTE_MAT m, GAP_TRT_SUIVI c
 WHERE a.numpac                 ='''||p_numpac||'''
 AND a.TYPE_PAIE               IN (''PRECONTR'',''CONTROLE'',''RECYCLAG'',''PARTICUL'',''REGLE'',''REGLEALL'',''GAPSELMA'')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND a.numpac                   =m.numpac
 AND b.id_trt                   =c.id_trt
 AND b.id_trt                   =m.id_trt
 AND c.statut                  IN (''PA'',''EX'',''DEMSEA'')
 AND NVL(c.code_retour_zpp,''00'')=''00''
 AND b.PERIODE_PAIE             = '''||p_periode||'''
 AND b.numero_echange          <>''0000''
 GROUP BY pacmat)
 SELECT '''||p_periode||''' AS PERIODE,NUMPAC,CLE,z.PACMAT,PAIEZAD,ELEM,OCC,VALEUR,CODEOP,TYPE_DONNEE,DTEFFET
 FROM '||table_name||' z, max_id_trt
 WHERE z.numpac                 ='''||p_numpac||'''
 AND z.pacmat = max_id_trt.pacmat
 AND z.id_trt = max_id_trt.id_trt';
 FSED.FSED_AVANCEMENT(p_id,'Partie 1.0 '||req);
 EXECUTE IMMEDIATE req ;

 --Les parties 2 et 3 ne sont faites qu'à partir du 2ème mois histo rétro minimum
 IF type_mois = 2 THEN

 /*Partie 2 : Cas des embauches rétro à partir de DEB_RETRO jusqu'à M-1.
   On détruit toutes les lignes de toutes les périodes comprises entre le mois rétro d’embauche et la paie en cours de rattrapage.
   Puis on insère les embauches sur la bonne période rétro. Il y a donc 1 DELETE + 1 INSERT à exécuter sur chaque mois.*/

 req :='DELETE FROM dif_fsed_histo h WHERE h.periode<'''||p_periode||''' and h.numpac='''||p_numpac ||''' AND EXISTS (
 WITH max_id_trt AS (SELECT pacmat,MAX(b.id_trt) as id_trt
 FROM TGE_SCHEMA_PRODUCTION a, GAP_TRT b, GAP_TRT_LISTE_MAT m, GAP_TRT_SUIVI c
 WHERE a.numpac                 ='''||p_numpac||'''
 AND a.TYPE_PAIE               IN (''PRECONTR'',''CONTROLE'',''RECYCLAG'',''PARTICUL'',''REGLE'',''REGLEALL'',''GAPSELMA'')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND a.numpac                   =m.numpac
 AND b.id_trt                   =c.id_trt
 AND b.id_trt                   =m.id_trt
 AND c.statut                  IN (''PA'',''EX'',''DEMSEA'')
 AND NVL(c.code_retour_zpp,''00'')=''00''
 AND b.PERIODE_PAIE             = '''||p_periode||'''
 AND b.numero_echange          <>''0000''
 GROUP BY pacmat)
 SELECT 1
 FROM '||table_name ||' z INNER JOIN  max_id_trt
 ON z.pacmat = max_id_trt.pacmat
 AND z.id_trt = max_id_trt.id_trt
 LEFT JOIN secupacmat s
 ON s.numpac=z.numpac AND s.pacmat = z.pacmat
 WHERE NUMPAC='''||p_numpac ||'''
 AND h.periode>=greatest(NVL( s.PREMIERE_PAIE, ''190101''),to_char(z.dteffet,''yyyymm''),'''||p_DEB_HISTO_RETRO||''')
 AND h.paiezad=z.paiezad
 AND z.dteffet < to_date('''||p_periode||''',''yyyymm'')
 AND z.elem =''A001'' and z.codeop=''C''

 )'; 
 FSED.FSED_AVANCEMENT(p_id,'Partie 2.1 '||req);
 EXECUTE IMMEDIATE req ;

 --Validation des modifs pour pouvoir analyser les tables et la dernière requête
 COMMIT;

 req :='INSERT INTO dif_fsed_histo
 WITH max_id_trt AS (SELECT pacmat,MAX(b.id_trt) as id_trt
 FROM TGE_SCHEMA_PRODUCTION a, GAP_TRT b, GAP_TRT_LISTE_MAT m, GAP_TRT_SUIVI c
 WHERE a.numpac                 ='''||p_numpac||'''
 AND a.TYPE_PAIE               IN (''PRECONTR'',''CONTROLE'',''RECYCLAG'',''PARTICUL'',''REGLE'',''REGLEALL'',''GAPSELMA'')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND a.numpac                   =m.numpac
 AND b.id_trt                   =c.id_trt
 AND b.id_trt                   =m.id_trt
 AND c.statut                  IN (''PA'',''EX'',''DEMSEA'')
 AND NVL(c.code_retour_zpp,''00'')=''00''
 AND b.PERIODE_PAIE             = '''||p_periode||'''
 AND b.numero_echange          <>''0000''
 GROUP BY pacmat),
 dif_a001 as --dates deffet des embauches rétro
 (SELECT NUMPAC,PAIEZAD,PACMAT,z.ID_TRT,DTEFFET
 FROM '||table_name||' z, max_id_trt
 WHERE NUMPAC='''||p_numpac||'''
 AND dteffet < to_date('''||p_periode||''',''yyyymm'')
 AND z.elem =''A001'' and z.codeop=''C''
 AND z.pacmat = max_id_trt.pacmat
 AND z.id_trt = max_id_trt.id_trt
 )
 SELECT DISTINCT GREATEST(NVL( s.PREMIERE_PAIE, ''190101''),to_char(a.dteffet,''yyyymm''),'''||p_DEB_HISTO_RETRO||''') AS PERIODE,a.NUMPAC,CLE,PACMAT,a.PAIEZAD,ELEM,OCC,VALEUR,CODEOP,TYPE_DONNEE,a.DTEFFET
 FROM dif_a001 a INNER JOIN  '||table_name||' f
 ON  a.paiezad=f.paiezad
 AND a.id_trt=f.id_trt
 LEFT JOIN secupacmat s
 ON s.numpac=a.numpac AND s.pacmat = a.pacmat
 WHERE f.numpac='''||p_numpac||'''';
 FSED.FSED_AVANCEMENT(p_id,'Partie 2.2 '||req);
 EXECUTE IMMEDIATE req ;

 /*Partie 3 : Corrections rétro. On détruit les éléments corrigés en rétro sur toutes les périodes comprises entre le mois rétro et la paie en cours de rattrapage.
   Puis on insère les éléments corrigés sur la bonne période rétro. Il y a donc 1 DELETE + 1 INSERT à exécuter sur chaque mois.*/

 req :='DELETE FROM dif_fsed_histo h WHERE h.periode<'''||p_periode||''' and h.numpac='''||p_numpac ||''' 
 AND h.elem IN (SELECT element FROM tge_ref_dicoz WHERE numpac='''||p_numpac||''' AND calcul_retro=1) AND EXISTS (
 WITH max_id_trt AS (SELECT pacmat,MAX(b.id_trt) as id_trt
 FROM TGE_SCHEMA_PRODUCTION a, GAP_TRT b, GAP_TRT_LISTE_MAT m, GAP_TRT_SUIVI c
 WHERE a.numpac                 ='''||p_numpac||'''
 AND a.TYPE_PAIE               IN (''PRECONTR'',''CONTROLE'',''RECYCLAG'',''PARTICUL'',''REGLE'',''REGLEALL'',''GAPSELMA'')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND a.numpac                   =m.numpac
 AND b.id_trt                   =c.id_trt
 AND b.id_trt                   =m.id_trt
 AND c.statut                  IN (''PA'',''EX'',''DEMSEA'')
 AND NVL(c.code_retour_zpp,''00'')=''00''
 AND b.PERIODE_PAIE             = '''||p_periode||'''
 AND b.numero_echange          <>''0000''
 GROUP BY pacmat)
 SELECT 1
 FROM '||table_name ||' z INNER JOIN  max_id_trt
 ON z.pacmat = max_id_trt.pacmat
 AND z.id_trt = max_id_trt.id_trt
 LEFT Join secupacmat s
 ON s.numpac=z.numpac AND s.pacmat = z.pacmat
 WHERE NUMPAC='''||p_numpac ||'''
 AND h.periode>=greatest(NVL( s.PREMIERE_PAIE, ''190101''),to_char(z.dteffet,''yyyymm''),'''||p_DEB_HISTO_RETRO||''')
 AND h.paiezad=z.paiezad
 AND h.elem=z.elem
 AND h.occ=z.occ
 AND z.dteffet < to_date('''||p_periode||''',''yyyymm'')

 )';
 FSED.FSED_AVANCEMENT(p_id,'Partie 3.1 '||req);
 EXECUTE IMMEDIATE req ;

 --Validation des modifs pour pouvoir analyser les tables et la dernière requête
 COMMIT;

 req :='INSERT INTO dif_fsed_histo
 WITH max_id_trt AS (SELECT pacmat,MAX(b.id_trt) as id_trt
 FROM TGE_SCHEMA_PRODUCTION a, GAP_TRT b, GAP_TRT_LISTE_MAT m, GAP_TRT_SUIVI c
 WHERE a.numpac                 ='''||p_numpac||'''
 AND a.TYPE_PAIE               IN (''PRECONTR'',''CONTROLE'',''RECYCLAG'',''PARTICUL'',''REGLE'',''REGLEALL'',''GAPSELMA'')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND a.numpac                   =m.numpac
 AND b.id_trt                   =c.id_trt
 AND b.id_trt                   =m.id_trt
 AND c.statut                  IN (''PA'',''EX'',''DEMSEA'')
 AND NVL(c.code_retour_zpp,''00'')=''00''
 AND b.PERIODE_PAIE             = '''||p_periode||'''
 AND b.numero_echange          <>''0000''
 GROUP BY pacmat)
 SELECT DISTINCT GREATEST(NVL( s.PREMIERE_PAIE, ''190101''),to_char(z.dteffet,''yyyymm''),'''||p_DEB_HISTO_RETRO||''') AS PERIODE,NUMPAC,CLE,z.PACMAT,PAIEZAD,ELEM,OCC,VALEUR,CODEOP,TYPE_DONNEE,DTEFFET
 FROM '||table_name||' z INNER JOIN  max_id_trt
 ON z.pacmat = max_id_trt.pacmat
 AND z.id_trt = max_id_trt.id_trt
 LEFT Join secupacmat s
 ON s.numpac=z.numpac AND s.pacmat = z.pacmat
 WHERE z.numpac='''||p_numpac||'''
 AND elem in (SELECT element from tge_ref_dicoz where numpac='''||p_numpac||''' and calcul_retro=1)
 AND z.dteffet < to_date('''||p_periode||''',''yyyymm'')';
 FSED.FSED_AVANCEMENT(p_id,'Partie 3.2 '||req);
 EXECUTE IMMEDIATE req ;

 END IF;
 END IF;

 --Fin boucle sur les Pacs
 END LOOP;
 --Fin boucle sur les mois
 END LOOP;

 FSED.FSED_AVANCEMENT(p_id,'*** Réparation DIF_FSED end ***');

 EXCEPTION
 WHEN OTHERS THEN
 req :='Une erreur est survenue lors de la réparation de DIF_FSED_HISTO.
 Veuillez consulter la table TGE_FSED_ERREUR.
 Pour reprendre le script, adapter SSAAMMJJ et lancer ceci :
 TRUNCATE TABLE dif_fsed_histo;
 INSERT INTO dif_fsed_histo SELECT * FROM dif_fsed_histo_SSAAMMJJ;
 DROP TABLE dif_fsed_histo_SSAAMMJJ;
 CALL DIF_FSED_HISTO_REP();';
 FSED.FSED_AVANCEMENT(p_id,req);
 FSED.FSED_ERREUR(p_id,'PURGE_HISTO_DIF_FSED',P_NUMPAC,SQLCODE||'-'||SQLERRM);
 --Validation des modifs pour pouvoir analyser les tables et la dernière requête
 COMMIT;
 raise;
 END DIF_FSED_HISTO_REP;
 ##
TAG_CHARSET=@€éèç
##
DUPLIQUE_DONNEES
=SQL=
create or replace
PROCEDURE DUPLIQUE_DONNEES (p_table VARCHAR2, p_whereOldValues VARCHAR2, p_colonne1 VARCHAR2 DEFAULT NULL, p_newVal1 VARCHAR2 DEFAULT NULL, p_colonne2 VARCHAR2 DEFAULT NULL, p_newVal2 VARCHAR2 DEFAULT NULL, p_colonne3 VARCHAR2 DEFAULT NULL, p_newVal3 VARCHAR2 DEFAULT NULL, p_colonne4 VARCHAR2 DEFAULT NULL, p_newVal4 VARCHAR2 DEFAULT NULL, p_colonne5 VARCHAR2 DEFAULT NULL, p_newVal5 VARCHAR2 DEFAULT NULL, p_colonne6 VARCHAR2 DEFAULT NULL, p_newVal6 VARCHAR2 DEFAULT NULL, p_colonne7 VARCHAR2 DEFAULT NULL, p_newVal7 VARCHAR2 DEFAULT NULL, p_colonne8 VARCHAR2 DEFAULT NULL, p_newVal8 VARCHAR2 DEFAULT NULL, p_colonne9 VARCHAR2 DEFAULT NULL, p_newVal9 VARCHAR2 DEFAULT NULL) 
AS
  TYPE TYP_COL_NAME IS TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
  Tabcol  TYP_COL_NAME ;
  v_reqInsert CLOB;
  v_listCols CLOB;
  v_listVals CLOB;
  v_flagCol NUMBER;
  v_tableSource VARCHAR2(100);
  v_tableCible VARCHAR2(30);
BEGIN
  IF INSTR(p_table,'-->')>0 THEN
    -- p_table est au format TABLE1-->TABLE2 : on duplique de TABLE1 dans TABLE2
    v_tableSource := SUBSTR(p_table,1,INSTR(p_table,'-->')-1);
    v_tableCible := SUBSTR(p_table,INSTR(p_table,'-->')+3);
  ELSE
    -- p_table est au format TABLE : on duplique de TABLE dans elle-même
    v_tableSource := p_table;
    v_tableCible := p_table;
  END IF;
  SELECT COLUMN_NAME BULK COLLECT Into Tabcol FROM USER_TAB_COLS WHERE UPPER(TABLE_NAME)=UPPER(v_tableCible) AND VIRTUAL_COLUMN='NO' AND HIDDEN_COLUMN='NO' AND COLUMN_ID IS NOT NULL ORDER BY COLUMN_ID;
  IF Tabcol.count>0 THEN
    FOR i IN Tabcol.first..Tabcol.last LOOP
      v_flagCol := 0;
      v_listCols := v_listCols||UPPER(Tabcol(i));
      IF UPPER(Tabcol(i))=UPPER(p_colonne1) THEN
        v_listVals := v_listVals||p_newVal1;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne2) THEN
        v_listVals := v_listVals||p_newVal2;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne3) THEN
        v_listVals := v_listVals||p_newVal3;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne4) THEN
        v_listVals := v_listVals||p_newVal4;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne5) THEN
        v_listVals := v_listVals||p_newVal5;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne6) THEN
        v_listVals := v_listVals||p_newVal6;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne7) THEN
        v_listVals := v_listVals||p_newVal7;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne8) THEN
        v_listVals := v_listVals||p_newVal8;
        v_flagCol := 1;
      END IF;
      IF UPPER(Tabcol(i))=UPPER(p_colonne9) THEN
        v_listVals := v_listVals||p_newVal9;
        v_flagCol := 1;
      END IF;
      IF v_flagCol=0 THEN
        v_listVals := v_listVals||Tabcol(i);
      END IF;
      IF i<Tabcol.last THEN
        v_listCols := v_listCols||',';
        v_listVals := v_listVals||',';
      END IF;
    END LOOP;
    v_reqInsert := 'INSERT INTO '||v_tableCible||' ('||v_listCols||') SELECT '||v_listVals||' FROM '||v_tableSource||' WHERE '||p_whereOldValues;
    EXECUTE_IMMEDIATE_STRING (v_reqInsert,0);
  END IF;
END DUPLIQUE_DONNEES;
##
TAG_CHARSET=@€éèç
##
DUPLIQUE_PLUSIEURS_LIGNES_DANS_TABLE
=SQL=
create or replace
PROCEDURE DUPLIQUE_PLUSIEURS_LIGNES_DANS_TABLE (pTableAModifier VARCHAR2, pTableGxp VARCHAR2, pListeElements TAB_VARCHAR) AS
p_whereOldValues VARCHAR(1000) := '' ;
BEGIN
 FOR i IN pListeElements.first..pListeElements.last LOOP
     IF pTableGxp IS NOT NULL THEN
       p_whereOldValues := 'NUMPAC=''*'' AND ELEMENT='''||pListeElements(i)||''' AND NOT TABLEGXP='''||pTableGxp||'''';
     ELSE
        p_whereOldValues := 'NUMPAC=''*'' AND ELEMENT='''||pListeElements(i)||'''' ;  
     END IF ;
     FOR n IN (SELECT NUMPAC FROM TGE_REF_PAC P WHERE NOT EXISTS (SELECT 1 FROM TGE_REF_MAPDO M WHERE M.NUMPAC=P.NUMPAC AND M.ELEMENT=pListeElements(i))) LOOP
      -- On duplique la ligne ayant NUMPAC = * , ELEMENT = <Element courant> et TABLEGXP != DIC_PENSION_ALIM (dans le cas où on passe le script une 2nde fois) sur un 'vrai' PAC
       DUPLIQUE_DONNEES(pTableAModifier,p_whereOldValues,'NUMPAC',''''||n.NUMPAC||'''','','','','','','','','','','','','','','','','');
     END LOOP;
  END LOOP;
END DUPLIQUE_PLUSIEURS_LIGNES_DANS_TABLE;
##
EXECUTE_IMMEDIATE_STRING
=SQL=
CREATE OR REPLACE PROCEDURE EXECUTE_IMMEDIATE_STRING 
(
  P_REQ IN CLOB , 
  P_FlagCommit IN NUMBER
) AUTHID CURRENT_USER AS 
BEGIN
  execute immediate P_REQ;
  IF P_FlagCommit =1 THEN 
   COMMIT;
  END IF;
END EXECUTE_IMMEDIATE_STRING;
##
EXTR_HRO_CORR
=SQL=
CREATE OR REPLACE
PROCEDURE "EXTR_HRO_CORR"
AS
  CURSOR cur
  IS
    SELECT * FROM extr_hro_correspondance ORDER BY codts, code_entite,date_eff;
  ligne extr_hro_correspondance%rowtype ;
  exit_function EXCEPTION;
  colonne       VARCHAR2(25);
  code_ent      VARCHAR2(25);
  req           VARCHAR2(4000);
  niveau_entite std_struc_niv.niveau%type;
BEGIN
  EXECUTE_IMMEDIATE_STRING ('truncate table extr_hro_correspondance',0);
  EXECUTE_IMMEDIATE_STRING ('insert into extr_hro_correspondance  (codts,code_entite, date_eff) select distinct codts, code_entite, date_eff from std_struc_arbre_ratt_indirect',0) ;
  OPEN cur;
  LOOP
    BEGIN
      FETCH cur INTO ligne;
      EXIT
    WHEN cur % NOTFOUND;
      EXECUTE_IMMEDIATE_STRING ('update extr_hro_correspondance set date_fin=(select max(date_fin) from std_struc_arbre_ratt_indirect where codts = '||ligne.codts||'  and code_entite= '''||ligne.code_entite||'''                and date_eff='''||ligne.date_eff||''') where codts = '||ligne.codts||'  and code_entite= '''||ligne.code_entite||''' and date_eff='''||ligne.date_eff||'''',0);
      SELECT DISTINCT niveau
      INTO niveau_entite
      FROM std_struc_niv niv,
        std_struc_entite e
      WHERE niv.codts     = ligne.codts
      AND niv.type_entite = e.type_entite
      AND e.code_entite   = ligne.code_entite
      AND ligne.date_eff BETWEEN e.date_eff AND NVL(e.date_fin,'20991231')
      AND ligne.date_eff BETWEEN niv.date_eff AND NVL(niv.date_fin,'20991231') ;
      code_ent := 'CODNIV'||niveau_entite;
      EXECUTE_IMMEDIATE_STRING ( 'update extr_hro_correspondance set '||code_ent||'='''|| ligne.code_entite||''' where codts = '||ligne.codts||'  and code_entite= '''||ligne.code_entite||'''                and date_eff='''||ligne.date_eff||'''                and date_fin='''|| ligne.date_fin||'''' ,0);
      FOR i IN 1..niveau_entite-1
      LOOP
        colonne := 'CODNIV'||i;
        req     := 'update extr_hro_correspondance corr  set '||colonne||' =  (select s.code_ent_mere from ( select code_ent_mere, niveau from std_struc_arbre_ratt_indirect ratt,std_struc_niv niv  where ratt.codts = niv.codts and  ratt.type_ent_mere = niv.type_entite and  ratt.codts ='||ligne.codts||'        and ratt.code_entite= '''||ligne.code_entite||'''        and ratt.date_eff='''||ligne.date_eff||'''               and ratt.date_eff between niv.date_eff and nvl (niv.date_fin,''20991231'') )s         where s.niveau = ' || i ||' )        where corr.codts = '||ligne.codts||'        and corr.code_entite= '''||ligne.code_entite||'''        and corr.date_eff='''||ligne.date_eff||'''        and corr.date_fin='''|| ligne.date_fin||'''';
       EXECUTE_IMMEDIATE_STRING ('update extr_hro_correspondance corr  set '||colonne||' =  (select s.code_ent_mere from ( select code_ent_mere, niveau from std_struc_arbre_ratt_indirect ratt,std_struc_niv niv  where ratt.codts = niv.codts and  ratt.type_ent_mere = niv.type_entite and  ratt.codts ='||ligne.codts||'        and ratt.code_entite= '''||ligne.code_entite||'''        and ratt.date_eff='''||ligne.date_eff||'''              and ratt.date_eff between niv.date_eff and nvl (niv.date_fin,''20991231'') )s         where s.niveau = ' || i ||' )        where corr.codts = '||ligne.codts||'        and corr.code_entite= '''||ligne.code_entite||'''        and corr.date_eff='''||ligne.date_eff||'''        and corr.date_fin='''|| ligne.date_fin||'''',0);
      END LOOP;
    EXCEPTION
    WHEN OTHERS THEN
      RAISE exit_function;
    END;
  END LOOP;
  CLOSE cur;
END;
##
EXTR_HRO_CORR_CREATE_IDX
=SQL=
CREATE OR REPLACE
PROCEDURE EXTR_HRO_CORR_CREATE_IDX
IS
  I INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO I
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_HRO_CORR';
  IF I             = 0 THEN
    EXECUTE_IMMEDIATE_STRING( 'CREATE INDEX IDX_EXTR_HRO_CORR on extr_hro_correspondance (CODTS, CODE_ENTITE,  DATE_EFF)',0);
  END IF;
END ;
##
EXTR_HRO_CORR_DROP_IDX
=SQL=
CREATE OR REPLACE
PROCEDURE EXTR_HRO_CORR_DROP_IDX
IS
  K INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO K
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_HRO_CORR';
  IF K             > 0 THEN
    EXECUTE_IMMEDIATE_STRING ('DROP INDEX IDX_EXTR_HRO_CORR ',0);
  END IF;
END ;
##
EXTR_STD_STRUC_CREATE_IDX
=SQL=
CREATE OR REPLACE
PROCEDURE EXTR_STD_STRUC_CREATE_IDX
IS
  I INTEGER;
  J INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO I
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_STD_STRUC_ARBRE';
  IF I             = 0 THEN
    EXECUTE_IMMEDIATE_STRING ( 'CREATE INDEX IDX_EXTR_STD_STRUC_ARBRE on EXTR_STD_STRUC_ARBRE(NIV_ENT_MERE, CODTS, CODE_ENTITE,  DATE_EFF)',0);
  END IF;
  SELECT COUNT(*)
  INTO J
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_STRUC_CODTS_DTEFF';
  IF J             = 0 THEN
    EXECUTE_IMMEDIATE_STRING ( 'CREATE INDEX IDX_EXTR_STRUC_CODTS_DTEFF ON EXTR_STD_STRUC_ARBRE( CODTS,  DATE_EFF)',0);
  END IF;
END ;
##
EXTR_STD_STRUC_DROP_IDX
=SQL=
CREATE OR REPLACE
PROCEDURE EXTR_STD_STRUC_DROP_IDX
IS
  I INTEGER;
  J INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO I
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_STD_STRUC_ARBRE';
  IF I             > 0 THEN
    EXECUTE_IMMEDIATE_STRING ( 'DROP INDEX IDX_EXTR_STD_STRUC_ARBRE  ',0);
  END IF;
  SELECT COUNT(*)
  INTO J
  FROM user_indexes
  WHERE index_name = 'IDX_EXTR_STRUC_CODTS_DTEFF';
  IF J             > 0 THEN
    EXECUTE_IMMEDIATE_STRING ( 'DROP INDEX IDX_EXTR_STRUC_CODTS_DTEFF ',0);
  END IF;
END ;
##
GET_SUSPENSION_JOUR_PLUS_UN
=SQL=
create or replace PROCEDURE GET_SUSPENSION_JOUR_PLUS_UN(
  p_id_trt                  NUMBER)
AS
  v_req_insert_dif_fsed     CLOB;                                    -- requête d'insertion de ligne dans DIF_FSED

  TYPE t_valeur             IS TABLE OF dif_fsed.valeur%TYPE;
  tab_req_valeur            t_valeur := t_valeur();                  -- tableau de requêtes pour DIF_FSED.VALEUR

  TYPE t_type_element       IS TABLE OF tge_ref_mapdo.element%TYPE;
  tab_element               t_type_element := t_type_element();      -- table de valeur TGE_REF_MAPDO.ELEMENT

  v_periodeencours          tge_ref_pac.periodeencours%TYPE;         -- valeur de TGE_REF_PAC.PERIODEENCOURS
  v_cle                     dif_fsed.cle%TYPE;                       -- valeur de DIF_FSED.CLE
  v_numcnt                  dic_adm_contrat_histo.numcnt%TYPE;       -- valeur de DIF_FSED.NUMCNT
  v_date_eff                dic_adm_contrat_histo.date_eff%TYPE;     -- valeur de DIF_FSED.DATE_EFF
  v_paiezad				   	dic_adm_contrat_histo.paiezad%TYPE;      -- valeur de DIF_FSED.PAIEZAD
  v_date_fin_mois           tge_ref_per.date_fin_mois%TYPE;          -- valeur de TGE_REF_PER.DATE_FIN_MOIS

  v_first                   BOOLEAN := TRUE;
  v_indice                  INTEGER := 0;

  v_donneegxp_A301          tge_ref_mapdo.donneegxp%TYPE;
  v_indice_A301             INTEGER := 0;

  TYPE t_type_donnee        IS TABLE OF VARCHAR(1000);
  tab_type_donnee           t_type_donnee := t_type_donnee();
  v_type_donnee             dif_fsed.type_donnee%TYPE;
BEGIN
  FOR i IN (SELECT numpac, pacmat FROM gap_trt_liste_mat WHERE id_trt = p_id_trt)
  LOOP
    IF (v_first) THEN
      v_indice := 0;
      tab_req_valeur.EXTEND(3);
      tab_element.EXTEND(3);
      tab_type_donnee.EXTEND(3);

      FOR j IN (SELECT numpac, element, donneegxp, tablegxp, REPLACE(REPLACE(trtparticulier, '$DONNEEGXP', donneegxp), '$TABLE', tablegxp) AS trtparticulier FROM tge_ref_mapdo WHERE element IN ('A301','A302','A962') AND (numpac = i.numpac)
                 UNION ALL
                SELECT numpac, element, donneegxp, tablegxp, REPLACE(REPLACE(trtparticulier, '$DONNEEGXP', donneegxp), '$TABLE', tablegxp) AS trtparticulier FROM tge_ref_mapdo WHERE element IN ('A301','A302','A962') AND (numpac = '*') 
                 AND (numpac, element) NOT IN (SELECT '*', element FROM tge_ref_mapdo WHERE element IN ('A301','A302','A962') AND (numpac = i.numpac))
               )
      LOOP
        v_indice := v_indice + 1;
        -- DIF_FSED.VALEUR et DIF_FSED_TYPE_DONNEE
        IF (j.trtparticulier IS NOT NULL) THEN
          tab_req_valeur(v_indice) := 'SELECT ' || j.trtparticulier || ' AS VALEUR FROM ' || j.tablegxp;
          tab_type_donnee(v_indice) := 'SELECT CASE  WHEN tge_ref_dicoz.type = ''A'' THEN (''A'') '
                                                 || 'WHEN tge_ref_dicoz.type = ''P'' THEN (''N'') '
                                                 || 'WHEN tge_ref_dicoz.type = ''N'' AND masque IN(1, 2, 3, 4, 5, 6, 7) THEN (''D'') '
                                                 || 'WHEN tge_ref_dicoz.type = ''N'' AND masque NOT IN(1, 2, 3, 4, 5, 6, 7) THEN (''N'') '
                                            || 'ELSE NULL END AS TYPE_DONNEE ' 
                                    || 'FROM tge_ref_dicoz WHERE element = ''' || j.element || ''' AND numpac = ''' || i.numpac || '''';
        ELSE
          tab_req_valeur(v_indice) := 'SELECT ' || j.donneegxp || ' AS VALEUR FROM ' || j.tablegxp;
          tab_type_donnee(v_indice) := 'SELECT CASE WHEN data_type = ''DATE'' THEN (''D'') '
                                                || 'WHEN data_type = ''NUMBER'' THEN (''N'') '
                                            || 'ELSE ''A'' END AS TYPE_DONNEE '
                                    || 'FROM user_tab_cols where table_name = ''' || j.tablegxp || ''' AND column_name = ''' || j.donneegxp || '''';

          SELECT CASE WHEN data_type = 'DATE' THEN ('D') WHEN data_type = 'NUMBER' THEN ('N') ELSE 'A' END AS TYPE_DONNEE INTO v_type_donnee FROM user_tab_cols where table_name = j.tablegxp AND column_name = j.donneegxp;
          IF (v_type_donnee = 'D') THEN
            tab_req_valeur(v_indice) := 'SELECT TO_CHAR(' || j.donneegxp || ', ''YYYYMMDDHH24MISS'') AS VALEUR FROM ' || j.tablegxp;
          END IF;
        END IF;
        tab_element(v_indice) := j.element;

        IF (j.element = 'A301') THEN
          v_indice_A301 := v_indice;
          v_donneegxp_A301 := j.donneegxp;
        END IF;
      END LOOP;

      -- TGE_REF_PER.DATE_FIN_MOIS
      SELECT periodeencours INTO v_periodeencours FROM tge_ref_pac WHERE numpac = i.numpac;
      SELECT date_fin_mois INTO v_date_fin_mois FROM tge_ref_per WHERE numpac = i.numpac AND periodeencours = v_periodeencours;

      v_first := FALSE;
    END IF;

    -- DIC_ADM_CONTRAT_HISTO.NUMCNT
    SELECT MAX(numcnt) INTO v_numcnt FROM dic_adm_contrat_histo WHERE numpac = i.numpac AND pacmat = i.pacmat ORDER BY numcnt, date_eff DESC;

    -- DIC_ADM_CONTRAT_HISTO.DATE_EFF
    SELECT MAX(date_eff) INTO v_date_eff FROM dic_adm_contrat_histo WHERE numpac = i.numpac AND pacmat = i.pacmat AND numcnt = v_numcnt ORDER BY numcnt, date_eff DESC;

	-- DIC_ADM_CONTRAT_HISTO.PAIEZAD
	SELECT PAIEZAD INTO v_paiezad FROM dic_adm_contrat_histo WHERE numpac = i.numpac AND pacmat = i.pacmat AND numcnt = v_numcnt AND date_eff = v_date_eff;
  
    -- DIF_FSED.CLE
    v_cle := i.numpac || '#' || i.pacmat || '#' || v_numcnt || '#' || TO_CHAR(v_date_eff, 'YYYYMMDD');

    -- DIF_FSED
    FOR n IN tab_req_valeur.first..tab_req_valeur.last
    LOOP
        v_req_insert_dif_fsed := 'INSERT INTO dif_fsed (id_trt, numpac, cle, pacmat, elem, valeur, codeop, type_donnee, dteffet,paiezad) (SELECT '
                       || p_id_trt || ', '''                                                                                                             -- DIF_FSED.ID_TRT
                       || i.numpac || ''', '''                                                                                                           -- DIF_FSED.NUMPAC
                       || REPLACE(v_cle, chr(39), chr(39) || chr(39)) || ''', '''                                                                        -- DIF_FSED.CLE
                       || i.pacmat  || ''', '''                                                                                                          -- DIF_FSED.PACMAT
                       || tab_element(n) || ''',  '                                                                                                      -- DIF_FSED.ELEM
                       || '(' || tab_req_valeur(n) || ' WHERE numpac = ''' || i.numpac || ''' AND pacmat = ''' || i.pacmat
                                                                                       || ''' AND numcnt = ''' || v_numcnt
                                                                                       || ''' AND date_eff = ''' || v_date_eff || '''), '                -- DIF_FSED.VALEUR
                       || '''C'', '                                                                                                                      -- DIF_FSED.CODEOP
                       || '(' || tab_type_donnee(n) || '), '                                                                                             -- DIF_FSED.TYPE_DONNEE
					   || 'TO_DATE(' || v_date_fin_mois || ', ''YYYYMMDD'') , '''                                                                          -- DIF_FSED.DTEFFET
					   || v_paiezad ||   ''''                                                                     								   -- DIF_FSED.PAIEZAD
                       || ' FROM dual WHERE EXISTS (' ||  tab_req_valeur(v_indice_A301) || ' WHERE numpac = ''' || i.numpac || ''' AND pacmat = ''' || i.pacmat
                                                                                                                           || ''' AND numcnt = ''' || v_numcnt
                                                                                                                           || ''' AND date_eff = ''' || v_date_eff
                                                                                                                           || ''' AND '|| v_donneegxp_A301 ||' IS NOT NULL AND ' || v_donneegxp_A301 || ' = TO_DATE(' || v_date_fin_mois || ', ''YYYYMMDD'') + INTERVAL ''1'' DAY))';
      EXECUTE_IMMEDIATE_STRING ( v_req_insert_dif_fsed,0);
    END LOOP;
  END LOOP;
  EXCEPTION WHEN OTHERS THEN
  raise_application_error(-20000, 'Problème(s) durant l''opération d''insertion dans DIF_FSED: ' || v_req_insert_dif_fsed || ',' || SQLCODE || '-' || sqlerrm);
END GET_SUSPENSION_JOUR_PLUS_UN;
##
HRGP_INITIALISE_BUDGET
=SQL=
CREATE OR REPLACE
PROCEDURE HRGP_INITIALISE_BUDGET(
    codescn  IN VARCHAR,
    moisaug  IN NUMBER,
    multi    IN NUMBER ,
    moisaug2 IN NUMBER,
    multi2   IN NUMBER,
    moisaug3 IN NUMBER,
    multi3   IN NUMBER)
AS
  CURSOR c_bud
  IS
    SELECT * FROM hrgp_budget_prepare WHERE codscn = codescn;
  lig hrgp_budget_prepare % rowtype;
  salavaug  NUMBER;
  salapaug1 NUMBER;
  salapaug2 NUMBER;
  salapaug3 NUMBER;
  tmp hrgp_affectations % rowtype;
  exit_function EXCEPTION;
BEGIN
  OPEN c_bud;
  LOOP
    BEGIN
      FETCH c_bud INTO lig;
      EXIT
    WHEN c_bud % NOTFOUND;
      salavaug        := hrgp_salaire_mensuel(lig.matric, lig.anneeprec);
      lig.salprec     := salavaug  *12;
      salapaug1       := salavaug  *multi;
      salapaug2       := salapaug1 *multi2;
      salapaug3       := salapaug2 *multi3;
      IF moisaug       > 1 THEN
        lig.sal_mois1 := salavaug;
      ELSE
        lig.sal_mois1 := salapaug1;
      END IF;
      IF moisaug       > 2 THEN
        lig.sal_mois2 := salavaug;
      ELSE
        lig.sal_mois2 := salapaug1;
      END IF;
      IF moisaug       > 3 THEN
        lig.sal_mois3 := salavaug;
      ELSE
        lig.sal_mois3 := salapaug1;
      END IF;
      IF moisaug       > 4 THEN
        lig.sal_mois4 := salavaug;
      ELSE
        lig.sal_mois4 := salapaug1;
      END IF;
      IF moisaug       > 5 THEN
        lig.sal_mois5 := salavaug;
      ELSE
        lig.sal_mois5 := salapaug1;
      END IF;
      IF moisaug       > 6 THEN
        lig.sal_mois6 := salavaug;
      ELSE
        lig.sal_mois6 := salapaug1;
      END IF;
      IF moisaug       > 7 THEN
        lig.sal_mois7 := salavaug;
      ELSE
        lig.sal_mois7 := salapaug1;
      END IF;
      IF moisaug       > 8 THEN
        lig.sal_mois8 := salavaug;
      ELSE
        lig.sal_mois8 := salapaug1;
      END IF;
      IF moisaug       > 9 THEN
        lig.sal_mois9 := salavaug;
      ELSE
        lig.sal_mois9 := salapaug1;
      END IF;
      IF moisaug        > 10 THEN
        lig.sal_mois10 := salavaug;
      ELSE
        lig.sal_mois10 := salapaug1;
      END IF;
      IF moisaug        > 11 THEN
        lig.sal_mois11 := salavaug;
      ELSE
        lig.sal_mois11 := salapaug1;
      END IF;
      IF moisaug        > 12 THEN
        lig.sal_mois12 := salavaug;
      ELSE
        lig.sal_mois12 := salapaug1;
      END IF;
      IF moisaug2      > 1 AND moisaug<1 THEN
        lig.sal_mois1 := salapaug1;
      ELSE
        IF moisaug2     <=1 THEN
          lig.sal_mois1 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 2 AND moisaug<2 THEN
        lig.sal_mois2 := salapaug1;
      ELSE
        IF moisaug2     <=2 THEN
          lig.sal_mois2 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 3 AND moisaug<3 THEN
        lig.sal_mois3 := salapaug1;
      ELSE
        IF moisaug2     <=3 THEN
          lig.sal_mois3 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 4 AND moisaug<4 THEN
        lig.sal_mois4 := salapaug1;
      ELSE
        IF moisaug2     <=4 THEN
          lig.sal_mois4 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 5 AND moisaug<5 THEN
        lig.sal_mois5 := salapaug1;
      ELSE
        IF moisaug2     <=5 THEN
          lig.sal_mois5 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 6 AND moisaug<6 THEN
        lig.sal_mois6 := salapaug1;
      ELSE
        IF moisaug2     <=6 THEN
          lig.sal_mois6 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 7 AND moisaug<7 THEN
        lig.sal_mois7 := salapaug1;
      ELSE
        IF moisaug2     <=7 THEN
          lig.sal_mois7 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 8 AND moisaug<8 THEN
        lig.sal_mois8 := salapaug1;
      ELSE
        IF moisaug2     <=8 THEN
          lig.sal_mois8 := salapaug2;
        END IF;
      END IF;
      IF moisaug       > 9 AND moisaug<9 THEN
        lig.sal_mois9 := salapaug1;
      ELSE
        IF moisaug2     <=9 THEN
          lig.sal_mois9 := salapaug2;
        END IF;
      END IF;
      IF moisaug        > 10 AND moisaug<10 THEN
        lig.sal_mois10 := salapaug1;
      ELSE
        IF moisaug2      <=10 THEN
          lig.sal_mois10 := salapaug2;
        END IF;
      END IF;
      IF moisaug        > 11 AND moisaug<11 THEN
        lig.sal_mois11 := salapaug1;
      ELSE
        IF moisaug2      <=11 THEN
          lig.sal_mois11 := salapaug2;
        END IF;
      END IF;
      IF moisaug        > 12 AND moisaug<12 THEN
        lig.sal_mois12 := salapaug1;
      ELSE
        IF moisaug2      <=12 THEN
          lig.sal_mois12 := salapaug2;
        END IF;
      END IF;
      IF moisaug3      > 1 AND moisaug2<1 AND moisaug<1 THEN
        lig.sal_mois1 := salapaug2;
      ELSE
        IF moisaug3     <=1 THEN
          lig.sal_mois1 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 2 AND moisaug2<2 AND moisaug<1 THEN
        lig.sal_mois2 := salapaug2;
      ELSE
        IF moisaug3     <=2 THEN
          lig.sal_mois2 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 3 AND moisaug2<3 AND moisaug<1 THEN
        lig.sal_mois3 := salapaug2;
      ELSE
        IF moisaug3     <=3 THEN
          lig.sal_mois3 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 4 AND moisaug2<4 AND moisaug<1 THEN
        lig.sal_mois4 := salapaug2;
      ELSE
        IF moisaug3     <=4 THEN
          lig.sal_mois4 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 5 AND moisaug2<5 AND moisaug<1 THEN
        lig.sal_mois5 := salapaug2;
      ELSE
        IF moisaug3     <=5 THEN
          lig.sal_mois5 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 6 AND moisaug2<6 AND moisaug<1 THEN
        lig.sal_mois6 := salapaug2;
      ELSE
        IF moisaug3     <=6 THEN
          lig.sal_mois6 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 7 AND moisaug2<7 AND moisaug<1 THEN
        lig.sal_mois7 := salapaug2;
      ELSE
        IF moisaug3     <=7 THEN
          lig.sal_mois7 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 8 AND moisaug2<8 AND moisaug<1 THEN
        lig.sal_mois8 := salapaug2;
      ELSE
        IF moisaug3     <=8 THEN
          lig.sal_mois8 := salapaug3;
        END IF;
      END IF;
      IF moisaug3      > 9 AND moisaug2<9 AND moisaug<1 THEN
        lig.sal_mois9 := salapaug2;
      ELSE
        IF moisaug3     <=9 THEN
          lig.sal_mois9 := salapaug3;
        END IF;
      END IF;
      IF moisaug3       > 10 AND moisaug2<10 AND moisaug<1 THEN
        lig.sal_mois10 := salapaug2;
      ELSE
        IF moisaug3      <=10 THEN
          lig.sal_mois10 := salapaug3;
        END IF;
      END IF;
      IF moisaug3       > 11 AND moisaug2<11 AND moisaug<1 THEN
        lig.sal_mois11 := salapaug2;
      ELSE
        IF moisaug3      <=11 THEN
          lig.sal_mois11 := salapaug3;
        END IF;
      END IF;
      IF moisaug3       > 12 AND moisaug2<12 AND moisaug<1 THEN
        lig.sal_mois12 := salapaug2;
      ELSE
        IF moisaug3      <=12 THEN
          lig.sal_mois12 := salapaug3;
        END IF;
      END IF;
      lig.sal := lig.sal_mois1 + lig.sal_mois2 + lig.sal_mois3 + lig.sal_mois4 + lig.sal_mois5 + lig.sal_mois6 + lig.sal_mois7 + lig.sal_mois8 + lig.sal_mois9 + lig.sal_mois10 + lig.sal_mois11 + lig.sal_mois12;
      BEGIN
        SELECT *
        INTO tmp
        FROM hrgp_affectations
        WHERE matric   = lig.matric
        AND dtdeb     <= TO_CHAR(sysdate, 'yyyyMMdd')
        AND(dtfin     IS NULL
        OR dtfin      >= TO_CHAR(sysdate, 'yyyyMMdd'))
        AND est_prev   = '0'
        AND typeaff    = '1';
        lig.codefam   := tmp.codefam;
        lig.codemet   := tmp.codemet;
        lig.codeempt  := tmp.codeempt;
        lig.codeempl  := tmp.codeempl;
        lig.codeposte := tmp.codeposte;
      EXCEPTION
      WHEN no_data_found THEN
        lig.codefam   := '*';
        lig.codemet   := '*';
        lig.codeempt  := '*';
        lig.codeempl  := '*';
        lig.codeposte := '*';
      END;
      UPDATE hrgp_budget_prepare
      SET ROW      = lig
      WHERE codscn = codescn
      AND matric   = lig.matric;
    EXCEPTION
    WHEN OTHERS THEN
      RAISE exit_function;
    END;
  END LOOP;
  CLOSE c_bud;
END hrgp_initialise_budget;
##
TAG_CHARSET=@€éèç
##
HRORG_CONSOLIDE_AFFECTATION
=SQL=
create or replace PROCEDURE HRORG_CONSOLIDE_AFFECTATION AS
 TYPE tcur
 IS
 REF
 CURSOR;
 c_struc_affec tcur;
 aff_codts               NUMBER;
 aff_matric              VARCHAR2 (32);
 aff_code_entite         VARCHAR2 (25);
 aff_date_eff            VARCHAR2 (8);
 aff_date_fin            VARCHAR2 (8);
 aff_est_affec_principal VARCHAR2 (1);
 pre_codts               NUMBER;
 pre_matric              VARCHAR2 (32);
 pre_code_entite         VARCHAR2 (25);
 pre_date_eff            VARCHAR2 (8);
 pre_date_fin            VARCHAR2 (8);
 pre_est_affec_principal  VARCHAR2 (1);
 pre_tmp_date_fin        DATE ;
 aff_tmp_date_eff        DATE ;
 exit_function           EXCEPTION;
 BEGIN
 /** 
  * Le rôle de cette procédure est de réduire le nombre de lignes dans la table STD_STRUC_AFFECTATION :
  * quand 2 lignes se suivent pour un collaborateur/codts et que ces 2 lignes correspondant au même code_entite afin de regrouper les dates d'effet
  */ 
 EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE std_struc_affectation_consolid',0);
 
 OPEN c_struc_affec FOR SELECT codts, matric,date_eff,date_fin,code_entite,est_affec_principal FROM std_struc_affectation ORDER BY codts,matric,date_eff;
 LOOP
 FETCH c_struc_affec
 INTO aff_codts,
 aff_matric,
 aff_date_eff,
 aff_date_fin,
 aff_code_entite,
 aff_est_affec_principal;
 EXIT WHEN c_struc_affec % NOTFOUND;
 
 IF (pre_code_entite IS NULL AND pre_date_eff IS NULL AND pre_date_fin IS NULL) THEN
 -- Première affectation
 pre_codts         := aff_codts;
 pre_matric        := aff_matric;
 pre_date_eff      := aff_date_eff;
 pre_date_fin      := aff_date_fin;
 pre_code_entite   := aff_code_entite;
 pre_est_affec_principal := aff_est_affec_principal;
 
 ELSIF (pre_codts <> aff_codts or pre_matric <> aff_matric or pre_code_entite <> aff_code_entite) THEN
 -- Rupture : sur le codTs ou le matricule ou le code_entite
 -- On enregistre la ligne
 INSERT INTO STD_STRUC_AFFECTATION_CONSOLID (CODTS, MATRIC, DATE_EFF, DATE_FIN, CODE_ENTITE, EST_AFFEC_PRINCIPAL)
 VALUES (pre_codts, pre_matric, pre_date_eff, pre_date_fin, pre_code_entite, pre_est_affec_principal);
 -- On conserve les informations
 pre_codts        := aff_codts;
 pre_matric       := aff_matric;
 pre_date_eff     := aff_date_eff;
 pre_date_fin     := aff_date_fin;
 pre_code_entite  := aff_code_entite;
 pre_est_affec_principal := aff_est_affec_principal;
 ELSE
 -- Pas de rupture, on contrôle les dates
 pre_tmp_date_fin     := to_date(pre_date_fin,'YYYYMMDD') ;
 aff_tmp_date_eff     := to_date(aff_date_eff,'YYYYMMDD') ;
 
 IF(pre_tmp_date_fin+1 = aff_tmp_date_eff) THEN
 -- On consolide
 pre_date_fin       := aff_date_fin;
 ELSE
 -- On enregistre la ligne
 INSERT INTO STD_STRUC_AFFECTATION_CONSOLID(CODTS, MATRIC, DATE_EFF, DATE_FIN, CODE_ENTITE, EST_AFFEC_PRINCIPAL)
 VALUES(pre_codts, pre_matric, pre_date_eff, pre_date_fin, pre_code_entite, pre_est_affec_principal);
 -- On conserve les informations
 pre_codts       := aff_codts;
 pre_matric      := aff_matric;
 pre_date_eff    := aff_date_eff;
 pre_date_fin    := aff_date_fin;
 pre_code_entite := aff_code_entite;
 pre_est_affec_principal := aff_est_affec_principal;
 END IF ;
 END IF ;
 END LOOP;
 CLOSE c_struc_affec;
 -- On enregistre la dernière ligne
 INSERT INTO std_struc_affectation_consolid(CODTS, MATRIC, DATE_EFF, DATE_FIN, CODE_ENTITE, EST_AFFEC_PRINCIPAL)
 VALUES(pre_codts, pre_matric, pre_date_eff, pre_date_fin, pre_code_entite, pre_est_affec_principal);
 
 -- On remplace les données de  STD_STRUC_AFFECTATION par les données que l'on vient de consolider
 EXECUTE_IMMEDIATE_STRING('TRUNCATE TABLE std_struc_affectation',0);
 INSERT INTO std_struc_affectation (select * from STD_STRUC_AFFECTATION_CONSOLID);
 
 END HRORG_CONSOLIDE_AFFECTATION;
##
HRORG_DATE_FIN_AFFECTATION
=SQL=
CREATE or REPLACE PROCEDURE "HRORG_DATE_FIN_AFFECTATION" 
AS
  	CURSOR tabAffPb
IS
   	/* Récupération des matricules/codTs qui ont plusieurs dates de fin à 2099 */
   	SELECT codts, matric FROM std_struc_affectation WHERE date_fin = '20991231'
   	GROUP BY matric, codts
   	HAVING COUNT(*)>1;
	
   	lignesRequetes tabAffPb%ROWTYPE;
		
BEGIN
	OPEN tabAffPb;
	LOOP
    	FETCH tabAffPb INTO lignesRequetes;
		EXIT
    WHEN tabAffPb % NOTFOUND;
		UPDATE std_struc_affectation a
       	SET date_fin = 
       		/* On met à jour la date de fin avec la date d'effet suivante - 1 jour */
        	NVL(
            	TO_CHAR(
					TO_DATE(
						(SELECT MIN(a2.date_eff) 
						FROM std_struc_affectation a2
						WHERE
                            a2.codts = lignesRequetes.codts 
                            AND a2.matric = lignesRequetes.matric 
                            AND a2.date_eff > a.date_eff
                        )
						, 'YYYYMMDD'
					) -1
				, 'YYYYMMDD'
				)
			,'20991231'
            )
        WHERE 
        	a.codts = lignesRequetes.codts 
        	AND a.matric = lignesRequetes.matric;
        COMMIT;
    END LOOP;
    CLOSE tabAffPb;
END HRORG_DATE_FIN_AFFECTATION;
##
HRORG_INIT_AFFECTATION
=SQL=
create or replace PROCEDURE HRORG_INIT_AFFECTATION AS
  matric DIC_ADM_CONTRAT_HISTO.MATRIC%type;
  dateEff DIC_ADM_CONTRAT_HISTO.DATE_EFF%type;
  dateFin DIC_ADM_CONTRAT_HISTO.DATE_FIN%type;
  dateFinBo DIC_ADM_CONTRAT_HISTO.DATE_SORTIE_SIT_BO%type;
  entite varchar2(100);
  TYPE EmpCurTyp IS REF CURSOR;  -- define weak REF CURSOR type
  CUR EmpCurTyp;
  dateDebIns varchar2(8);
  dateFinIns varchar2(8);
BEGIN
  --maj du champs DATE_FIN
  MAJ_DATE_FIN_CONTRAT_HISTO();

  --maj du champs DATE_SORTIE_SIT_BO
  R_DATE_SORTIE_SIT_BO_CNT_HISTO();

  FOR codts_actif in (select codts,nomcol_secumatric from std_struc_type where nomcol_secumatric IS NOT NULL) LOOP
    -- purge des types de structures gérée par un champs de contrat
    delete from STD_STRUC_AFFECTATION where codts = codts_actif.codts;
      
    -- insertion dans la table des affectations
    OPEN CUR FOR 'SELECT MATRIC,DATE_EFF,DATE_FIN,DATE_SORTIE_SIT_BO,NVL(' || codts_actif.nomcol_secumatric || ',''@NON_AFFECTE@'') from DIC_ADM_CONTRAT_HISTO';
    LOOP
      FETCH CUR INTO matric, dateEff, dateFin, dateFinBo, entite;
      EXIT WHEN CUR%NOTFOUND;
      IF (matric is null or dateEff is null or dateFin is null ) THEN
        CONTINUE;
      END IF;
      begin
        dateDebIns := to_char(dateEff,'yyyymmdd');
        dateFinIns := to_char(dateFin,'yyyymmdd');
        insert into STD_STRUC_AFFECTATION (MATRIC,CODTS,DATE_EFF,CODE_ENTITE,DATE_FIN,EST_AFFEC_PRINCIPAL) values(matric, codts_actif.codts, dateDebIns, entite,dateFinIns, 1);
      IF (dateFinBo > dateFin) THEN
        dateDebIns := to_char(dateFin+1,'yyyymmdd');
        dateFinIns := to_char(dateFinBo,'yyyymmdd');
        insert into STD_STRUC_AFFECTATION (MATRIC,CODTS,DATE_EFF,CODE_ENTITE,DATE_FIN,EST_AFFEC_PRINCIPAL) values(matric, codts_actif.codts, dateDebIns, '@NON_AFFECTE@',dateFinIns, 1);
      END IF;
      EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
        NULL;
      END;
    END LOOP;
    CLOSE CUR;
    COMMIT;-- commit par code types
  END LOOP;

  --consolidation
  HRORG_CONSOLIDE_AFFECTATION();
  COMMIT;
END HRORG_INIT_AFFECTATION;
##
TAG_CHARSET=@€éèç
##
HRORG_MAJ_AFFEC_HERITE_ENT
=SQL=
create or replace
PROCEDURE HRORG_MAJ_AFFEC_HERITE_ENT(
 p_codts               NUMBER,
 p_matric              VARCHAR2,
 p_code_entite         VARCHAR2,
 p_date_eff            VARCHAR2,
 p_date_fin            VARCHAR2,
 p_est_affec_principal VARCHAR2,
 p_cid   IN std_struc_entite.cid%TYPE default null)
 AS
 TYPE tcur
 IS
 REF
 CURSOR;
 c_struc_heritees tcur;
 c_entites_mere tcur;
 v_codts               NUMBER;
 v_niv_heritage        NUMBER;
 v_niv_entite          NUMBER;
 v_code_ent_mere       VARCHAR2(25);
 v_date_eff_mere       VARCHAR2(8);
 v_date_fin_mere       VARCHAR2(8);
 v_entite_mere_checked NUMBER;
 v_cid std_struc_entite.cid%TYPE;
 BEGIN
 	v_cid := p_cid;
   	IF (v_cid IS NULL) THEN
  		BEGIN
  			SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  		EXCEPTION
  		WHEN NO_DATA_FOUND THEN
  			v_cid := null;
  		END;
	END IF;
  	IF (v_cid IS NULL) THEN
  		-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  		RETURN;
  	END IF;
	 
	 
 v_entite_mere_checked:=0;
 IF (NOT p_code_entite ='@NON_AFFECTE@') THEN
 SELECT n.niveau
 INTO v_niv_entite
 FROM std_struc_entite e,
 std_struc_niv n
 WHERE
 e.cid = v_cid
 AND e.type_entite=n.type_entite
 AND e.code_entite  =p_code_entite
 AND n.codts        =p_codts
 AND p_date_eff BETWEEN e.date_eff AND e.date_fin
 AND p_date_eff BETWEEN n.date_eff AND n.date_fin;
 ELSE
 v_niv_entite:=NULL;
 END IF;
 OPEN c_struc_heritees FOR SELECT codts,
 hrorg_niv_mere_affec_heritage(codts, p_date_eff)
 AS
 niv_heritage FROM std_struc_type WHERE lien_codts=p_codts ORDER BY codts;
 LOOP
 FETCH c_struc_heritees INTO v_codts, v_niv_heritage;
 EXIT
 WHEN c_struc_heritees % NOTFOUND;
 IF (v_niv_heritage IS NOT NULL AND v_niv_heritage>0) THEN
 IF (p_code_entite ='@NON_AFFECTE@' OR (v_niv_entite IS NOT NULL AND v_niv_entite=v_niv_heritage)) THEN
 INSERT
 INTO STD_STRUC_AFFECTATION VALUES
 (
 p_matric,
 v_codts,
 p_date_eff,
 p_code_entite,
 p_date_fin,
 p_est_affec_principal
 );
 ELSE
 IF (v_entite_mere_checked=0 AND v_niv_entite IS NOT NULL AND v_niv_entite>v_niv_heritage) THEN
 OPEN c_entites_mere FOR SELECT code_ent_mere,
 date_eff,
 date_fin FROM std_struc_arbre WHERE cid = v_cid and codts=p_codts AND code_entite=p_code_entite AND date_eff<=p_date_fin AND date_fin>=p_date_eff AND code_ent_mere IS NOT NULL ORDER BY date_eff;
 LOOP
 FETCH c_entites_mere INTO v_code_ent_mere, v_date_eff_mere, v_date_fin_mere;
 EXIT
 WHEN c_entites_mere % NOTFOUND;
 IF (v_date_eff_mere<p_date_eff) THEN
 v_date_eff_mere :=p_date_eff;
 END IF;
 IF (v_date_fin_mere>p_date_fin) THEN
 v_date_fin_mere :=p_date_fin;
 END IF;
 HRORG_MAJ_AFFEC_HERITE_ENT(p_codts, p_matric, v_code_ent_mere, v_date_eff_mere, v_date_fin_mere, p_est_affec_principal, v_cid);
 v_entite_mere_checked:=1;
 END LOOP;
 CLOSE c_entites_mere;
 END IF;
 END IF;
 END IF;
 END LOOP;
 CLOSE c_struc_heritees;
 END HRORG_MAJ_AFFEC_HERITE_ENT;
 ##
TAG_CHARSET=@€éèç
##
HRORG_MAJ_AFFEC_HERITE_STRUC
=SQL=
create or replace
PROCEDURE HRORG_MAJ_AFFEC_HERITE_STRUC(
 p_codts             NUMBER,
 p_matric            VARCHAR2,
 p_date_eff_heritage VARCHAR2,
 -- TODO VRI : ZEU FE, quand on gèrera il faudra remplacer par la table STD_STRUC_AFFECTATION 
 p_cid   IN std_struc_entite.cid%TYPE default null)
 AS
 TYPE tcur
 IS
 REF
 CURSOR;
 c_struc_heritees tcur;
 c_aff tcur;
 v_codts                 NUMBER;
 v_niv_heritage          NUMBER;
 aff_matric              VARCHAR2 (32);
 aff_code_entite         VARCHAR2 (25);
 aff_date_eff            VARCHAR2 (8);
 aff_date_fin            VARCHAR2 (8);
 aff_est_affec_principal VARCHAR2 (1);
 -- TODO VRI : ZEU FE, quand on gèrera il faudra remplacer par la table STD_STRUC_AFFECTATION
 v_cid std_struc_entite.cid%TYPE;
 exit_function           EXCEPTION;
 BEGIN
  
  v_cid := p_cid;
  IF (v_cid IS NULL) THEN
  	BEGIN
  		SELECT VALVAR INTO v_cid FROM SYS_VARSYS where CODVAR = 'NS_CLIENT_ID';
  	EXCEPTION
  	WHEN NO_DATA_FOUND THEN
  		v_cid := null;
  	END;
  END IF;
  IF (v_cid IS NULL) THEN
  	-- En mode multiclient, la varsys peut être null et le passage du paramètre pCid est obligatoire
  	RETURN;
  END IF;
	 
 OPEN c_struc_heritees FOR SELECT codts, hrorg_niv_mere_affec_heritage(codts, p_date_eff_heritage)
 AS
 niv_heritage FROM std_struc_type WHERE lien_codts=p_codts ORDER BY codts;
 LOOP
 FETCH c_struc_heritees INTO v_codts, v_niv_heritage;
 EXIT
 WHEN c_struc_heritees % NOTFOUND;
 IF (v_niv_heritage IS NOT NULL AND v_niv_heritage>0) THEN
 IF (p_matric     IS NULL) THEN
 DELETE FROM STD_STRUC_AFFECTATION WHERE codts=v_codts;
 ELSE
 DELETE FROM STD_STRUC_AFFECTATION WHERE codts=v_codts AND matric=p_matric;
 END IF;
 END IF;
 END LOOP;
 CLOSE c_struc_heritees;
 IF (p_matric IS NULL) THEN
 OPEN c_aff FOR SELECT matric,
 code_entite,
 date_eff,
 date_fin,
 -- TODO VRI : ZEU FE, ajouter v_cid dans le where
 est_affec_principal FROM std_struc_affectation WHERE codts=p_codts ORDER BY matric,
 date_eff;
 ELSE
 OPEN c_aff FOR SELECT matric,
 code_entite,
 date_eff,
 date_fin,
 -- TODO VRI : ZEU FE, ajouter v_cid dans le where
 est_affec_principal FROM std_struc_affectation WHERE codts=p_codts AND matric=p_matric ORDER BY date_eff;
 END IF;
 LOOP
 FETCH c_aff
 INTO aff_matric,
 aff_code_entite,
 aff_date_eff,
 aff_date_fin,
 aff_est_affec_principal;
 EXIT
 WHEN c_aff % NOTFOUND;
 -- Ici on utilise le CID passé en paramètre et pas celui qu'on pourrait récupérer dans la requête (de toute façon ce serait le même)
 HRORG_MAJ_AFFEC_HERITE_ENT(p_codts, aff_matric, aff_code_entite, aff_date_eff, aff_date_fin, aff_est_affec_principal, v_cid);
 END LOOP;
 CLOSE c_aff;
 OPEN c_struc_heritees FOR SELECT codts,
 hrorg_niv_mere_affec_heritage(codts, p_date_eff_heritage)
 AS
 niv_heritage FROM std_struc_type WHERE lien_codts=p_codts ORDER BY codts;
 LOOP
 FETCH c_struc_heritees INTO v_codts, v_niv_heritage;
 EXIT
 WHEN c_struc_heritees % NOTFOUND;
 IF (v_niv_heritage IS NOT NULL AND v_niv_heritage>0) THEN
 HRORG_MAJ_AFFEC_HERITE_STRUC(v_codts, p_matric, p_date_eff_heritage);
 END IF;
 END LOOP;
 END HRORG_MAJ_AFFEC_HERITE_STRUC;
 ##
HRORG_MAJ_DOSSIERS_PERDUS
=SQL=
CREATE OR REPLACE
PROCEDURE HRORG_MAJ_DOSSIERS_PERDUS
AS
  CURSOR c_dos
  IS
    SELECT * FROM HRORG_DOSSIERS_PERDUS WHERE gv_valide IS NOT NULL;
  lig HRORG_DOSSIERS_PERDUS % rowtype;
  exit_function EXCEPTION;
BEGIN
  OPEN c_dos;
  LOOP
    BEGIN
      FETCH c_dos INTO lig;
      EXIT
    WHEN c_dos % NOTFOUND;
      UPDATE WKF_POSSESSION
      SET CODE_USER   = lig.gv_valide
      WHERE TRACE_NUM = lig.trace_num;
      IF lig.type_ko  = 'PERDU' THEN
        UPDATE WKF_TRACABILITE SET ETAT = 'D' WHERE TRACE_NUM = lig.trace_num;
        UPDATE WKF_POSSESSION SET ROLE_USER = 'GV' WHERE TRACE_NUM = lig.trace_num;
      END IF;
      IF lig.type_ko = 'OBSOLETE' THEN
        UPDATE WKF_TRACABILITE
        SET ETAT        ='D',
          DOS_DESC      =DOS_DESCIN,
          DATE_DEB_REEL =NULL,
          DATE_FIN_REEL =NULL
        WHERE TRACE_NUM = lig.trace_num;
      END IF;
      INSERT
      INTO WKF_TRACES_MAJ_GV VALUES
        (
          lig.trace_num,
          lig.gv_valide,
          lig.type_ko,
          TO_CHAR(sysdate,'yyyymmddhh24miss')
        );
    EXCEPTION
    WHEN OTHERS THEN
      RAISE exit_function;
    END;
  END LOOP;
  CLOSE c_dos;
END HRORG_MAJ_DOSSIERS_PERDUS;
##
LVRD_DELETE
=SQL=
CREATE OR REPLACE PROCEDURE LVRD_DELETE(
    P_NUM_LIVRABLE IN NUMBER,
    P_COMPANY_ID   IN VARCHAR2)
AS
BEGIN
  IF (P_NUM_LIVRABLE IS NOT NULL AND P_COMPANY_ID IS NOT NULL) THEN
    DELETE FROM SYS_JSP_STATS WHERE ID_GENERATION = 'Liv_' || TO_CHAR(P_NUM_LIVRABLE);
    DELETE FROM SYS_JSP_STATS_INFO WHERE ID_GENERATION = 'Liv_' || TO_CHAR(P_NUM_LIVRABLE);
    DELETE FROM SYS_JSP_STATS_DETAILS WHERE ID_GENERATION = 'Liv_' || TO_CHAR(P_NUM_LIVRABLE);
    DELETE FROM TMPL_WKF_TRANSITIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_WKF_PROCESSUS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_WKF_OPERATION_ECRANS_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_WKF_OPERATION_ECRANS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_WKF_OPERATIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_WKF_BRANCH_GEN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_SYS_REQUETES_JSP WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_SYS_DEF_ERREURS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_REGLEGESTION_DESC WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_REGLEGESTION WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_PROJET_OBJET WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_PROJET WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_LIVRABLE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_GROUPE_DONNEES_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_GROUPE_DONNEES WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_GROUPE_DONNEES_TABLEAUX WHERE  NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_DONNEE_GENERALE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_DONNEE_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_DICTIONNAIRE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM TMPL_DESTINATION_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM REF_OBJ_LIVRABLES WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_TRANSITIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_PROCESSUS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_OPERATION_ECRANS_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_OPERATION_ECRANS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_OPERATIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_WKF_BRANCH_GEN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_SYS_REQUETES_JSP WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_SYS_DEF_ERREURS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_REGLEGESTION_DESC WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_REGLEGESTION WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_GROUPE_DONNEES_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_GROUPE_DONNEES WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_DONNEE_GENERALE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_DONNEE_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_DICTIONNAIRE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM MARQ_DESTINATION_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_TRANSITIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_PROCESSUS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_OPERATION_ECRANS_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_OPERATION_ECRANS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_OPERATIONS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_WKF_BRANCH_GEN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_SYS_REQUETES_JSP WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_SYS_DEF_ERREURS WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_REGLEGESTION_DESC WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_REGLEGESTION WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_PROJET_OBJET WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_PROJET WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_LIVRABLE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_GROUPE_DONNEES_INFO WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_GROUPE_DONNEES WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_GROUPE_DONNEES_TABLEAUX WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_ECR_GRP_DONNEE_LGT_TBL WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_DONNEE_GENERALE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_DONNEE_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_DICTIONNAIRE WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM LVRD_DESTINATION_ECRAN WHERE NUM_LIVRABLE = P_NUM_LIVRABLE AND COMPANY_ID = P_COMPANY_ID;
    DELETE FROM COMP_LIVR_LIEN WHERE ID_COMP IN (SELECT ID_COMP FROM COMP_LIVRABLES WHERE NUM_LIVRABLE_1 = P_NUM_LIVRABLE OR NUM_LIVRABLE_2 = P_NUM_LIVRABLE);
    DELETE FROM COMP_LIVRABLES WHERE NUM_LIVRABLE_1 = P_NUM_LIVRABLE OR NUM_LIVRABLE_2 = P_NUM_LIVRABLE;
  END IF;
END LVRD_DELETE;
##
MAJ_DATE_FIN_CONTRAT_HISTO
=SQL=
CREATE OR REPLACE PROCEDURE MAJ_DATE_FIN_CONTRAT_HISTO 
IS 
BEGIN
  -- Procédure de reprise des dates de fin  dans la table DIC_ADM_CONTRAT_HISTO
  BEGIN
    EXECUTE_IMMEDIATE_STRING( 'DROP TABLE TABLE_DATE_FIN',0);
  EXCEPTION WHEN OTHERS THEN NULL; END;

  EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE TABLE_DATE_FIN(NUMPAC VARCHAR2(6),PACMAT  VARCHAR2(8),NUMCNT NUMBER,DATE_EFF DATE,DATE_FIN_OLD DATE,DATE_FIN_NEW DATE,PRIMARY KEY(NUMPAC,PACMAT,NUMCNT,DATE_EFF))',0);

  EXECUTE_IMMEDIATE_STRING( 'INSERT INTO TABLE_DATE_FIN(SELECT NUMPAC,PACMAT,NUMCNT,DATE_EFF,DATE_FIN  AS DATE_FIN_OLD,LEAST(NVL(LEAD(DATE_EFF_MOINS_UN) OVER(PARTITION BY NUMPAC,PACMAT,NUMCNT ORDER BY DATE_EFF), TO_DATE(''20991231'',''yyyymmdd'')),DSFCN) AS DATE_FIN_NEW FROM
 (SELECT DISTINCT dach.NUMPAC,dach.PACMAT,dach.NUMCNT,dach.DATE_EFF,dach.DATE_FIN,dach.DATE_EFF-1 AS DATE_EFF_MOINS_UN,NVL(dac.DSFCN,TO_DATE(''20991231'',''yyyymmdd'')) AS DSFCN FROM DIC_ADM_CONTRAT dac,DIC_ADM_CONTRAT_HISTO dach
  WHERE dac.NUMPAC      =dach.NUMPAC AND dac.PACMAT      =dach.PACMAT AND dac.NUMCNT      =dach.NUMCNT))',0);

  EXECUTE_IMMEDIATE_STRING( 'MERGE INTO DIC_ADM_CONTRAT_HISTO C USING(SELECT * FROM TABLE_DATE_FIN WHERE NVL(DATE_FIN_NEW,to_date(''19001231'',''yyyymmdd'')) <> NVL(DATE_FIN_OLD,to_date(''19001231'',''yyyymmdd'')))
T ON (T.NUMPAC=C.NUMPAC AND T.PACMAT=C.PACMAT AND T.NUMCNT=C.NUMCNT AND T.DATE_EFF=C.DATE_EFF)
WHEN MATCHED THEN UPDATE SET TYPE_WRITER=''N'', C.DATE_FIN = T.DATE_FIN_NEW',0);

  EXECUTE_IMMEDIATE_STRING( 'DROP TABLE TABLE_DATE_FIN',0);
  -- Fin
  COMMIT;
END MAJ_DATE_FIN_CONTRAT_HISTO;
##
MAJ_DATE_FIN_PERSO_HISTO
=SQL=
CREATE OR REPLACE PROCEDURE MAJ_DATE_FIN_PERSO_HISTO 
IS 
BEGIN 
  UPDATE dic_adm_perso_histo
  SET date_fin=
    (SELECT MIN(h.date_eff)-1
    FROM dic_adm_perso_histo h
    WHERE h.matric=dic_adm_perso_histo.matric
    AND h.date_eff>dic_adm_perso_histo.date_eff
    )
  WHERE EXISTS
    (SELECT *
    FROM dic_adm_perso_histo h
    WHERE h.matric=dic_adm_perso_histo.matric
    AND h.date_eff>dic_adm_perso_histo.date_eff
    );
END MAJ_DATE_FIN_PERSO_HISTO;
##
TAG_CHARSET=@€éèç
##
MAJ_REFERENCE_DATA_GLOBAL_DATA
=SQL=
create or replace PROCEDURE MAJ_REFERENCE_DATA_GLOBAL_DATA AS
 V_CONSUMERAPPOID    VARCHAR2(50 BYTE);
 VREF_CONSUMERAPPOID VARCHAR2(50 BYTE);
 CURSOR cur_consumerappoid IS
  SELECT mc.CONSUMER_APP_OID, mc.CONSUMER_APP_OID_REF FROM MP_CONSUMERAPPOID mc WHERE CONSUMER_APP_OID_REF IS NOT NULL;
 CURSOR curref_consumerappoid IS
  SELECT rc.CONSUMER_APP_OID FROM MP_REF_CONSUMERAPPOID rc;
BEGIN
 OPEN cur_consumerappoid;
  LOOP
   FETCH cur_consumerappoid INTO V_CONSUMERAPPOID,VREF_CONSUMERAPPOID;
   EXIT WHEN cur_consumerappoid%NOTFOUND;
   
   -- Traitement dans MP_SECU_URI
   -- Si pour une application présente dans MP_CONSUMERAPPOID, une ligne existe dans MP_REF_SECU_URI, et pas dans MP_SECU_URI, on l'ajoute dans MP_SECU_URI
   MERGE INTO MP_SECU_URI a 
   USING (
    SELECT CONSUMER_APP_OID,URI_ID
    FROM MP_REF_SECU_URI
    WHERE CONSUMER_APP_OID     = VREF_CONSUMERAPPOID
   ) b 
   ON (a.CONSUMER_APP_OID = V_CONSUMERAPPOID AND a.URI_ID = b.URI_ID)
   WHEN NOT MATCHED THEN INSERT (CONSUMER_APP_OID,URI_ID) VALUES (V_CONSUMERAPPOID,b.URI_ID);
 
   -- Traitement dans MP_SECU_DATA
   -- Une ligne existe dans MP_REF_SECU_DATA avec la valeur 'Y' dans la colonne MANDATORY, et pas dans MP_SECU_DATA, on l'ajoute dans MP_SECU_DATA
   MERGE INTO MP_SECU_DATA a 
   USING (
    SELECT distinct r.URI_ID,d.DATA_NAME_MP_ALP
    FROM MP_REF_SECU_DATA r, mp_ref_data_alp d 
    WHERE r.CONSUMER_APP_OID = VREF_CONSUMERAPPOID AND r.DATA_NAME_MP = d.DATA_NAME_MP AND r.MANDATORY='Y'
   ) b 
   ON (a.CONSUMER_APP_OID = V_CONSUMERAPPOID AND Upper(a.URI_ID||' '||a.DATA_NAME_MP_ALP) = Upper(b.URI_ID||' '||b.DATA_NAME_MP_ALP))
   WHEN NOT MATCHED THEN INSERT (CONSUMER_APP_OID,DATA_NAME_MP_ALP,URI_ID) VALUES (V_CONSUMERAPPOID,b.DATA_NAME_MP_ALP,b.URI_ID);
 END LOOP;
 CLOSE cur_consumerappoid;
 OPEN curref_consumerappoid;
 LOOP
  FETCH curref_consumerappoid INTO VREF_CONSUMERAPPOID;
  EXIT WHEN curref_consumerappoid%NOTFOUND;
   
   -- Traitement dans MP_SECU_URI
   -- Une ligne existe dans MP_SECU_URI et pas dans MP_REF_SECU_URI, on la supprime de MP_SECU_URI
   DELETE FROM MP_SECU_URI a
   WHERE EXISTS (
     SELECT 1
     FROM MP_CONSUMERAPPOID
     WHERE CONSUMER_APP_OID = a.CONSUMER_APP_OID AND CONSUMER_APP_OID_REF = VREF_CONSUMERAPPOID
   )
   AND NOT EXISTS (
    SELECT 1
    FROM MP_REF_SECU_URI b
    WHERE a.URI_ID         =b.URI_ID
    AND b.CONSUMER_APP_OID = VREF_CONSUMERAPPOID
   );
   
   -- Traitement dans MP_SECU_DATA
   -- Une ligne existe dans MP_SECU_DATA et pas dans MP_REF_SECU_DATA, on la supprime de MP_SECU_DATA
   DELETE FROM MP_SECU_DATA a
   WHERE EXISTS (
     SELECT 1
     FROM MP_CONSUMERAPPOID
     WHERE CONSUMER_APP_OID = a.CONSUMER_APP_OID AND CONSUMER_APP_OID_REF = VREF_CONSUMERAPPOID
   )
   AND NOT EXISTS (
    SELECT 1
    FROM MP_REF_SECU_DATA ref, mp_ref_data_alp 
    WHERE ref.DATA_NAME_MP= mp_ref_data_alp.DATA_NAME_MP 
    AND ref.CONSUMER_APP_OID = VREF_CONSUMERAPPOID 
    AND a.URI_ID = ref.URI_ID
    AND a.DATA_NAME_MP_ALP = mp_ref_data_alp.DATA_NAME_MP_ALP
   );
 END LOOP;
 CLOSE curref_consumerappoid;
 COMMIT;
END MAJ_REFERENCE_DATA_GLOBAL_DATA;
##
MAJ_RETRO_MAX_LISTE_MAT_HISTO
=SQL=
create or replace PROCEDURE MAJ_RETRO_MAX_LISTE_MAT_HISTO IS


w_DEB_HISTO_RETRO TGE_REF_PAC.DEB_HISTO_RETRO%TYPE;
w_DEB_RETRO TGE_REF_PAC.DEB_RETRO%TYPE;

 BEGIN
   FOR C in (select distinct H.numpac,H.pacmat from GAP_TRT_LISTE_MAT_HISTO H where H.retro_max is null ) loop
    
     select GREATEST(T.DEB_HISTO_RETRO,NVL( S.PREMIERE_PAIE, '190101'))  AS DEB_HISTO_RETRO , T.DEB_RETRO
     INTO   w_DEB_HISTO_RETRO ,w_DEB_RETRO
     FROM TGE_REF_PAC T LEFT JOIN SECUPACMAT S ON T.NUMPAC = S.NUMPAC  where T.numpac =C.numpac and S.pacmat = C.pacmat ;
     
       update GAP_TRT_LISTE_MAT_HISTO g set retro_max = (
       select min(greatest(to_char(dteffet,'yyyymm'),w_DEB_HISTO_RETRO)) as retro_max from dif_fsed_histo h
       where greatest(to_char(dteffet,'yyyymm'),w_DEB_HISTO_RETRO) < h.periode 
       and elem in (select element from tge_ref_dicoz dz where dz.numpac=C.numpac and calcul_retro=1)
       and g.numpac=h.numpac and g.pacmat=h.pacmat and g.periode_paie=h.periode)
       where g.numpac=C.numpac and g.periode_paie >=w_DEB_RETRO and retro_max is null ;
    
       commit; 
     
   END LOOP;
   
 COMMIT;
 END MAJ_RETRO_MAX_LISTE_MAT_HISTO;

##
MAJ_WKF_METIER_GENERIQUE
=SQL=
create or replace PROCEDURE MAJ_WKF_METIER_GENERIQUE(
    P_NOM_DIC      IN VARCHAR2 ,
    P_NOM_DONNEE   IN VARCHAR2 ,
    P_VALUE        IN VARCHAR2 ,
    P_CLAUSE_WHERE IN VARCHAR2 ,
    P_WHERE_PARAMS IN VARCHAR2)
AS
  CURSOR cur_wkf
  IS
    SELECT * FROM WKF_METIER_GENERIQUE ;
  CURSOR cur_node (p_dosnum IN VARCHAR2,p_nomDic IN VARCHAR2)
  IS
    SELECT node_name
    FROM XMLTable('/DATA_DOS/*' passing
      (SELECT xml_datas FROM WKF_METIER_GENERIQUE WHERE dos_num= p_dosnum
      ) columns node_name VARCHAR2(30) path 'name(.)' , node_value VARCHAR2(30) path '.')
    WHERE node_name LIKE (p_nomDic
      ||'_%');
    err_msg   VARCHAR(200);
    err_code  VARCHAR(200);
    w_nbligne NUMBER := 0 ;
    params    tab_varchar;
    w_donnee  tab_varchar;
    requete   CLOB;
    w_value   VARCHAR2(1000);
  BEGIN
    IF P_WHERE_PARAMS IS NOT NULL THEN
    
      requete         := 'WITH test AS (SELECT  ' ||P_WHERE_PARAMS;
      requete         := requete||' str FROM dual  )select ROWNUM, regexp_substr (str, ''[^,]+'', 1, rownum) split  from test connect by level <= length (regexp_replace (str, ''[^,]+''))  + 1';
      EXECUTE immediate requete bulk collect INTO w_donnee ;
      params:= tab_varchar ();
      
    END IF;
    FOR C IN cur_wkf
    LOOP
      IF w_donnee.exists(1) THEN
        FOR j IN w_donnee.first..w_donnee.last
        LOOP
          params.extend;
          BEGIN
            SELECT extractvalue(wkf.xml_datas,'/DATA_DOS/'
              ||P_NOM_DIC
              ||'/'
              ||w_donnee(j))
            INTO params(j)
            FROM WKF_METIER_GENERIQUE wkf
            WHERE dos_num= C.dos_num
            AND wkf.xml_datas.existsnode('/DATA_DOS/'
              ||P_NOM_DIC
              ||'/'
              ||w_donnee(j)) = 1;
          EXCEPTION
          WHEN OTHERS THEN
            err_msg := SQLERRM;
          END;
        END LOOP;
      END IF;
      IF params.exists(1) THEN
        NULL;
        requete := 'SELECT  ' ||P_CLAUSE_WHERE||'    FROM dual ';
        EXECUTE immediate requete INTO w_value ;
      END IF;
      FOR K IN cur_node (C.dos_num,P_NOM_DIC)
      LOOP
        BEGIN
          SELECT extractvalue(wkf.xml_datas,'/DATA_DOS/'
            ||K.node_name
            ||'/'
            ||K.node_name
            ||'_NB_LIGNES')
          INTO w_nbligne
          FROM WKF_METIER_GENERIQUE wkf
          WHERE dos_num= C.dos_num
          AND wkf.xml_datas.existsnode('/DATA_DOS/'
            ||K.node_name
            ||'/'
            ||K.node_name
            ||'_NB_LIGNES') = 1;
        EXCEPTION
        WHEN OTHERS THEN
          w_nbligne := 0;
          err_msg   := SQLERRM;
        END;
        IF w_nbligne =0 THEN
          UPDATE WKF_METIER_GENERIQUE
          SET xml_datas = INSERTCHILDXML(xml_datas, '/DATA_DOS/'
            ||K.node_name, P_NOM_DONNEE, XMLType('<'
            ||P_NOM_DONNEE
            ||'>'
            ||NVL(w_value,P_VALUE)
            ||'</'
            ||P_NOM_DONNEE
            ||'>'))
          WHERE dos_num = C.dos_num;
        ELSE
          FOR i IN 0..w_nbligne- 1
          LOOP
            UPDATE WKF_METIER_GENERIQUE
            SET xml_datas = INSERTCHILDXML(xml_datas, '/DATA_DOS/'
              ||K.node_name
              ||'/'
              ||K.node_name
              ||'_LIGNE_'
              ||i, P_NOM_DONNEE, XMLType('<'
              ||P_NOM_DONNEE
              ||'>'
              ||NVL(w_value,P_VALUE)
              ||'</'
              ||P_NOM_DONNEE
              ||'>'))
            WHERE dos_num = C.dos_num;
          END LOOP;
        END IF;
      END LOOP;
    END LOOP;
  EXCEPTION
  WHEN OTHERS THEN
    err_code := SQLCODE;
    err_msg  := SQLERRM;
    raise_application_error(-20000, 'MAJ_WKF_METIER_GENERIQUE'|| sqlerrm);
  END MAJ_WKF_METIER_GENERIQUE;
##
MASS_MISAJOUR
=SQL=
CREATE OR REPLACE PROCEDURE MASS_MISEAJOUR 
(
  P_NUMSAISIE IN VARCHAR2 
, P_NUMPAC IN VARCHAR2 
, P_PACMAT IN VARCHAR2 
, P_NUMCNT IN VARCHAR2 
, P_DATE_EFF IN DATE 
, P_NOMDONNEE IN VARCHAR2 
, P_VALEUR IN VARCHAR2 
, P_VALIDE IN VARCHAR2
) IS 
valeurmodifier  NUMBER(38,3) :=0;   
BEGIN
  select count(*) into valeurmodifier  from MASS_SAISIES where NUM_SAISIE =  P_NUMSAISIE
			   AND NUMPAC = P_NUMPAC
			   AND  PACMAT = P_PACMAT
			   AND  NUMCNT = P_NUMCNT
			   AND DATE_EFF = P_DATE_EFF
         AND NOM_DONNEE = P_NOMDONNEE
         AND NVL(VALEUR_SAISIE,'XYZ') = NVL(P_VALEUR,'XYZ');  
  
  --la valeur a été modifier
  IF valeurmodifier = 0 THEN
    UPDATE MASS_SAISIES_LIGNE SET MODIFIE='O', VALIDE = NVL(P_VALIDE, 'N') WHERE NUM_SAISIE =  P_NUMSAISIE
			   AND NUMPAC = P_NUMPAC
			   AND  PACMAT = P_PACMAT
			   AND  NUMCNT = P_NUMCNT
			   AND DATE_EFF = P_DATE_EFF;
   
    UPDATE MASS_SAISIES SET    
			   VALEUR_SAISIE = P_VALEUR
			   WHERE  NUM_SAISIE =  P_NUMSAISIE
			   AND NUMPAC = P_NUMPAC
			   AND  PACMAT = P_PACMAT
			   AND  NUMCNT = P_NUMCNT
			   AND DATE_EFF = P_DATE_EFF
			   AND  NOM_DONNEE = P_NOMDONNEE;
  
  
  END IF;
  
  
END MASS_MISEAJOUR;
##
META_MODIF_STRUCTURE
=SQL=
create or replace PROCEDURE META_MODIF_STRUCTURE(suffixeTable VARCHAR2, nomColonne VARCHAR2, definitionColonne VARCHAR2, valeurColonne VARCHAR2 DEFAULT NULL) IS
 listePrefix TAB_VARCHAR:=META_LISTE_PREFIX_TABLE();
 nomTable VARCHAR2(30);
 nomTableLiee VARCHAR2(30);
 existeTable NUMBER;
 existeColonne NUMBER;
 action VARCHAR2(10);
 BEGIN
 -- supprimer définitivement la table HIS_xxx
 BEGIN
 EXECUTE_IMMEDIATE_STRING( 'DROP TABLE HIS_' || suffixetable,0);
 EXCEPTION WHEN OTHERS THEN
 NULL; -- ne rien faire
 END;
 
 EXECUTE_IMMEDIATE_STRING( 'ALTER TRIGGER TRG_ALTER_META DISABLE',0);
 FOR i IN listePrefix.first..listePrefix.last
 LOOP
 nomTable:=listePrefix(i);
 IF NOT SUBSTR(suffixeTable,1,1)='_' THEN
 nomTable:=nomTable||'_';
 END IF;
 nomTable:=nomTable||suffixeTable;
 SELECT COUNT(*) INTO existeTable FROM USER_TABLES WHERE TABLE_NAME=nomTable;
 IF existeTable=1 THEN
 SELECT COUNT(*) INTO existeColonne FROM USER_TAB_COLUMNS WHERE TABLE_NAME=nomTable AND COLUMN_NAME=nomColonne;
 action:=NULL;
 IF definitionColonne IS NULL THEN
 IF existeColonne=1 THEN
 action:='DROP';
 END IF;
 ELSIF existeColonne=0 THEN
 action:='ADD';
 ELSE
 action:='MODIFY';
 END IF;
 IF action IS NOT NULL THEN
 EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE '||nomTable||' '||action||' ('||nomColonne||' '||definitionColonne||')',0);
 IF action ='ADD' and valeurColonne is not null THEN
 EXECUTE_IMMEDIATE_STRING( 'UPDATE '||nomTable||' SET '||nomColonne||'='||valeurColonne||' ',0);
 END IF;
 END IF;
 nomTableLiee := NULL;
 IF nomTable = 'META_DONNEE_GENERALE' THEN
 nomTableLiee := 'REF_DONNEE_GEN_MODEL';
 ELSIF nomTable = 'META_DONNEE_ECRAN' THEN
 nomTableLiee := 'REF_DONNEE_ECR_MODEL';
 END IF;
 IF nomTableLiee IS NOT NULL THEN
 SELECT COUNT(*) INTO existeColonne FROM USER_TAB_COLUMNS WHERE TABLE_NAME=nomTableLiee AND COLUMN_NAME=nomColonne;
 action:=NULL;
 IF definitionColonne IS NULL THEN
 IF existeColonne=1 THEN
 action:='DROP';
 END IF;
 ELSIF existeColonne=0 THEN
 action:='ADD';
 ELSE
 action:='MODIFY';
 END IF;
 IF action IS NOT NULL THEN
 EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE '||nomTableLiee||' '||action||' ('||nomColonne||' '||definitionColonne||')',0);
 END IF;
 END IF;
 END IF;
 END LOOP;
 EXECUTE_IMMEDIATE_STRING( 'ALTER TRIGGER TRG_ALTER_META ENABLE',0);
 EXCEPTION
 WHEN OTHERS THEN
 EXECUTE_IMMEDIATE_STRING( 'ALTER TRIGGER TRG_ALTER_META ENABLE',0);
 END META_MODIF_STRUCTURE;
##
PAC_SEQUENCE_CREATE
=SQL=
create or replace
PROCEDURE PAC_SEQUENCE_CREATE(p_numpac VARCHAR2) AUTHID CURRENT_USER IS BEGIN
 IF PAC_SEQUENCE_CHECK_EXISTS(p_numpac)=0 THEN
 EXECUTE_IMMEDIATE_STRING( 'CREATE SEQUENCE '||PAC_SEQUENCE_GET_NAME(p_numpac)||' MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE NOORDER NOCYCLE',0);
 END IF;
 END PAC_SEQUENCE_CREATE;
##
PARTITIONNEMENT
=SQL=
create or replace PROCEDURE PARTITIONNEMENT(
  p_table                   IN VARCHAR2,
  p_column                  IN VARCHAR2,
  p_column_date             IN VARCHAR2,
  p_force_statistics        IN NUMBER)
AS
  v_user                    VARCHAR2(255);
  v_table                   VARCHAR2(255);	-- le nom de la table partitionnée (issue de p_table)
  v_table_sav               VARCHAR2(255); -- le nom de p_table après le renommage
  v_type                    VARCHAR2(255);
  v_type_name               VARCHAR2(255);
  v_columns                 CLOB; -- liste des colonnes de p_table
  v_columns_with_struct     CLOB; -- liste des colonnes avec leur type de p_table
  v_pk_unique_index         VARCHAR2(255); -- nom de l'index préfixé par PK_ de la table partitionnée

  v_max_length_table_name   INTEGER := 30; -- longeur maximale autorisée pour le nom d'une table
  v_max_length_index_name   INTEGER := 30; -- longeur maximale autorisée pour le nom d'un index

  v_nb_null                 NUMBER := 0; -- nombre de valeur à NULL pour les colonnes clés des partitions

  CURSOR c_indexes          IS SELECT table_name,
                                      index_name,
                                      TRIM(REPLACE(REPLACE(REPLACE(dbms_metadata.get_ddl('INDEX', index_name),
                                                                   CHR(34) || v_user || CHR(34) || '.'
                                                                  ),
                                                           CHR(34)
                                                          ),
                                                    ';'
                                                   )
                                          )AS sql_code
                               FROM user_indexes
                                WHERE table_name = v_table;

  CURSOR c_constraints      IS SELECT table_name,
                                      constraint_name,
                                      TRIM(REPLACE(REPLACE(REPLACE(dbms_metadata.get_ddl('CONSTRAINT', constraint_name),
                                                                   CHR(34) || v_user || CHR(34) || '.'
                                                                  ),
                                                           CHR(34)
                                                          ),
                                                   ';'
                                                  )
                                          ) AS sql_code
                               FROM user_constraints
                                WHERE table_name = v_table AND constraint_type = 'P';

  CURSOR c_triggers         IS SELECT table_name,
                                      trigger_name,
                                      TRIM(REPLACE(REPLACE(dbms_metadata.get_ddl('TRIGGER', trigger_name),
                                                           CHR(34) || v_user || CHR(34) || '.'
                                                          ),
                                                   CHR(34)
                                                  )
                                          ) AS sql_code
                               FROM user_triggers
                                WHERE table_name = v_table;

  CURSOR c_virtuals         IS SELECT table_name,
                                      column_name,
                                      data_default,
                                      data_length,
                                      data_type
                               FROM user_tab_cols
                                WHERE table_name = v_table AND virtual_column = 'YES';

  v_option_by_list          BOOLEAN := FALSE;
  v_option_by_hash          BOOLEAN := FALSE;
  v_option_by_range         BOOLEAN := FALSE;
  v_error                   CLOB;
BEGIN
  -- TYPE DE PARTITIONNEMENT À LANCER
  IF (p_column = 'CODTS' AND p_column_date IS NULL) THEN
    v_option_by_list := TRUE;
  ELSIF (p_column = 'NUMPAC' AND p_column_date IS NULL) THEN
    v_option_by_hash := TRUE;
  ELSIF (p_column = 'NUMPAC' AND p_column_date IS NOT NULL) THEN
    v_option_by_range := TRUE;
  END IF;

  -- VÉRIFIER QUE LA TABLE EST CONFORME
  BEGIN
    IF (v_option_by_range) THEN
      SELECT DISTINCT(table_name) INTO v_table FROM user_tab_cols WHERE column_name IN (p_column, p_column_date)
       AND table_name = p_table AND table_name NOT IN (SELECT DISTINCT(table_name) FROM user_tab_partitions);
    ELSIF (v_option_by_hash OR v_option_by_list) THEN
      SELECT DISTINCT(table_name) INTO v_table FROM user_tab_cols WHERE column_name = p_column
       AND table_name = p_table AND table_name NOT IN (SELECT DISTINCT(table_name) FROM user_tab_partitions);
    END IF;
  EXCEPTION WHEN OTHERS THEN
    v_table := NULL;
  END;

   -- VÉRIFIER QUE LES COLONNES SERVANT DE CLES POUR LES PARTITIONS NE CONTIENNENT PAS DE VALEUR NULL
  BEGIN 
    IF (v_option_by_range) THEN
      EXECUTE IMMEDIATE 'SELECT count(*) FROM ' || p_table || ' WHERE ' || p_column || ' IS NULL OR ' || p_column_date || ' IS NULL' INTO v_nb_null;
      IF (v_nb_null > 0) THEN
        RAISE_APPLICATION_ERROR(-20000, 'Les colonnes clés des partitions contiennent des valeurs (' || v_nb_null || ') à NULL');
      END IF;
    ELSIF (v_option_by_hash OR v_option_by_list) THEN
      EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table || ' WHERE ' || p_column || ' IS NULL' INTO v_nb_null;
      IF (v_nb_null > 0) THEN
        RAISE_APPLICATION_ERROR(-20000, 'La colonnes clé de la partition contient des valeurs (' || v_nb_null || ') à NULL');
      END IF;
    END IF;
  EXCEPTION WHEN OTHERS THEN
    v_table := NULL;
  END;

  IF (v_table = p_table) THEN -- TABLE CONFORME ET NON PARTITIONNÉE

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, p_table, 'Lancement de la procédure PARTITIONNEMENT(' || NVL(p_table, 'NULL') || ',' || NVL(p_column, 'NULL') || ',' || NVL(p_column_date, 'NULL') || ',' || p_force_statistics || ')'); COMMIT;

    -- EFFACER LES ANCIENNES SAUVEGARDES DE STRUCTURES (EVITE LES DOUBLONS)
    DELETE FROM partition_sav_struct_table WHERE partition_sav_struct_table.table_name IN (p_table); COMMIT;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, 'PARTITION_SAV_STRUCT_TABLE', '  1 - Effacer les anciennes sauvegardes de structures'); COMMIT;

    SELECT user INTO v_user FROM dual;

    v_table_sav := 'SAV_' || v_table;
    IF (LENGTH(v_table_sav) > v_max_length_table_name) THEN
      v_table_sav := SUBSTR(v_table_sav, 0, v_max_length_table_name);
    END IF;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '  2 - Sauvegarde de structure pour ' || v_table); COMMIT;

    -- SAUVEGARDER LES INDEX
    FOR v_indexes IN c_indexes
    LOOP
      -- ON PREFIXE L'INDEX PAR PK_
      v_pk_unique_index := 'PK_' || v_indexes.index_name;
      IF (LENGTH(v_pk_unique_index) > v_max_length_index_name) THEN
        v_pk_unique_index := SUBSTR(v_pk_unique_index, 0, v_max_length_index_name);
      END IF;

      -- AVEC INDEX LOCAL
      IF (INSTR(v_indexes.sql_code, p_column) != 0) OR (INSTR(v_indexes.sql_code, p_column_date) != 0) THEN

        IF v_option_by_list THEN
          INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
           VALUES(v_indexes.table_name, 'INDEX', v_indexes.index_name, REPLACE(v_indexes.sql_code, 'CREATE UNIQUE INDEX ' || v_indexes.index_name, 'CREATE UNIQUE INDEX ' || v_pk_unique_index) ||
                                                                      ' LOCAL (PARTITION CODTS_1, ' ||
                                                                              'PARTITION CODTS_2, ' ||
                                                                              'PARTITION CODTS_3, ' ||
                                                                              'PARTITION CODTS_4, ' ||
                                                                              'PARTITION CODTS_5, ' ||
                                                                              'PARTITION CODTS_6, ' ||
                                                                              'PARTITION CODTS_DEFAULT' ||
                                                                             ')'); COMMIT;
       ELSIF v_option_by_hash THEN
          INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
           VALUES(v_indexes.table_name, 'INDEX', v_indexes.index_name, REPLACE(v_indexes.sql_code, 'CREATE UNIQUE INDEX ' || v_indexes.index_name, 'CREATE UNIQUE INDEX ' || v_pk_unique_index) ||
                                                                      ' LOCAL (PARTITION NUMPAC_1, ' ||
                                                                              'PARTITION NUMPAC_2, ' ||
                                                                              'PARTITION NUMPAC_3, ' ||
                                                                              'PARTITION NUMPAC_4, ' ||
                                                                              'PARTITION NUMPAC_5, ' ||
                                                                              'PARTITION NUMPAC_6, ' ||
                                                                              'PARTITION NUMPAC_7, ' ||
                                                                              'PARTITION NUMPAC_8' ||
                                                                             ')'); COMMIT;
        ELSIF v_option_by_range THEN
          INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
           VALUES(v_indexes.table_name, 'INDEX', v_indexes.index_name, REPLACE(v_indexes.sql_code, 'CREATE UNIQUE INDEX ' || v_indexes.index_name, 'CREATE UNIQUE INDEX ' || v_pk_unique_index) || ' LOCAL'); COMMIT;
        END IF;

      -- SANS INDEX LOCAL
      ELSE
        INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
         VALUES(v_indexes.table_name, 'INDEX', v_indexes.index_name, REPLACE(v_indexes.sql_code, 'CREATE UNIQUE INDEX ' || v_indexes.index_name, 'CREATE UNIQUE INDEX ' || v_pk_unique_index)); COMMIT;
      END IF;

    END LOOP;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '      Index sauvegardé(s)'); COMMIT;

    -- SAUVEGARDE LES CONTRAINTES
    FOR v_constraints IN c_constraints
    LOOP
      INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
       VALUES(v_constraints.table_name, 'CONSTRAINT', v_constraints.constraint_name, v_constraints.sql_code); COMMIT;
    END LOOP;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '      Contrainte(s) sauvegardée(s)'); COMMIT;

     -- SAUVEGARDER LES DECLENCHEURS
    FOR v_triggers IN c_triggers
    LOOP
      INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
       VALUES (v_triggers.table_name, 'TRIGGER', v_triggers.trigger_name, REGEXP_REPLACE(REPLACE(v_triggers.sql_code, 'ALTER TRIGGER ' || v_triggers.trigger_name || ' ENABLE'), '/' || CHR(10) || ';')); COMMIT;
    END LOOP;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '      Déclencheur(s) sauvegardé(s)'); COMMIT;

    -- SAUVEGARDER LES COLONNES VIRTUELLES
    FOR v_virtuals IN c_virtuals
    LOOP
      INSERT INTO partition_sav_struct_table(table_name, type, type_name, sql_code)
       VALUES(v_virtuals.table_name, 'VIRTUAL COLUMN', v_virtuals.column_name, 'ALTER TABLE ' || v_table || ' ADD ' || v_virtuals.column_name || ' ' || v_virtuals.data_type || '(' || v_virtuals.data_length || ' BYTE) GENERATED ALWAYS AS (' || v_virtuals.data_default || ') VIRTUAL VISIBLE'); COMMIT;
    END LOOP;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '      Colonnes virtuelles sauvegardée(s)'); COMMIT;

    -- RENOMMER TABLE PAR SAV_xxx
    EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE ' || v_table || ' RENAME TO '  || v_table_sav,1);-- COMMIT;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '  3 - Renommer la table ' || v_table || ' en SAV_' || v_table_sav || ' terminé'); COMMIT;

    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, '  4 - Creation de la table partitionnée'); COMMIT;

    IF v_option_by_list THEN
      EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE ' || v_table || ' PARTITION BY LIST (CODTS) (PARTITION CODTS_1 VALUES(1), ' ||
                                                                                      'PARTITION CODTS_2 VALUES(2), ' ||
                                                                                      'PARTITION CODTS_3 VALUES(3), ' ||
                                                                                      'PARTITION CODTS_4 VALUES(4), ' ||
                                                                                      'PARTITION CODTS_5 VALUES(5), ' ||
                                                                                      'PARTITION CODTS_6 VALUES(6), ' ||
                                                                                      'PARTITION CODTS_DEFAULT VALUES(DEFAULT)) ' ||
                       'AS SELECT * FROM ' || v_table_sav,1);-- COMMIT;

      INSERT INTO partition_log_struct_table(dte, table_name, log)
       VALUES (SYSDATE, v_table, '      Partition BY LIST(CODTS) terminé'); COMMIT;

    ELSIF v_option_by_hash THEN
      EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE ' || v_table || ' PARTITION BY HASH (NUMPAC) (PARTITION NUMPAC_1, ' ||
                                                                                         'PARTITION NUMPAC_2, ' ||
                                                                                         'PARTITION NUMPAC_3, ' ||
                                                                                         'PARTITION NUMPAC_4, ' ||
                                                                                         'PARTITION NUMPAC_5, ' ||
                                                                                         'PARTITION NUMPAC_6, ' ||
                                                                                         'PARTITION NUMPAC_7, ' ||
                                                                                         'PARTITION NUMPAC_8) ' || 
                         'AS SELECT * FROM ' || v_table_sav,1);-- COMMIT;

      INSERT INTO partition_log_struct_table(dte, table_name, log)
       VALUES (SYSDATE, v_table, '      Partition BY HASH(NUMPAC) terminé'); COMMIT;

    ELSIF v_option_by_range THEN
       FOR m IN (SELECT column_name, data_type ||
                 CASE
                 WHEN data_precision IS NOT NULL AND nvl(data_scale, 0) > 0 THEN '(' || data_precision || ',' || data_scale || ')'
                 WHEN data_precision IS NOT NULL AND nvl(data_scale, 0) = 0 THEN '(' || data_precision || ')'
                 WHEN data_precision IS NULL AND data_scale IS NOT NULL THEN '(*,' || data_scale || ')'
                 WHEN char_length > 0 THEN '(' || char_length ||
                  CASE char_used
                   WHEN 'B' THEN ' BYTE'
                   WHEN 'C' THEN ' CHAR'
                   ELSE NULL 
                  END || ')'
                 END --|| DECODE(nullable, 'N', ' NOT NULL')
               AS data_type
               FROM user_tab_cols WHERE table_name = v_table_sav AND virtual_column = 'NO' ORDER BY column_id ASC)
       LOOP
         v_columns := v_columns || m.column_name || ',';
         v_columns_with_struct := v_columns_with_struct || m.column_name || ' ' || m.data_type || ',';
       END LOOP;
       v_columns := substr(v_columns, 0, LENGTH(v_columns) - 1);
       v_columns_with_struct := substr(v_columns_with_struct, 0, LENGTH(v_columns_with_struct) - 1);

       -- CRÉATION NOUVELLE TABLE PARTITIONNÉE
       EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE ' || v_table || ' ('
                    || v_columns_with_struct
                    || ') PARTITION BY RANGE (' || p_column_date || ') INTERVAL (NUMTOYMINTERVAL(1, ''MONTH''))'
                    || ' SUBPARTITION BY HASH (NUMPAC)'
                    || ' SUBPARTITIONS 8 (PARTITION BEFORE_2013 VALUES LESS THAN (TO_DATE(''01-01-2013'', ''dd-MM-yyyy'')))',1);--COMMIT;

       -- COPIE DES DONNÉES DANS LA NOUVELLE TABLE
       EXECUTE_IMMEDIATE_STRING( 'INSERT INTO ' || v_table || ' (' || v_columns || ') SELECT ' || v_columns || ' FROM ' || v_table_sav,1);--COMMIT;

        INSERT INTO partition_log_struct_table(dte, table_name, log)
      VALUES (SYSDATE, v_table, '      Partition BY RANGE(' || p_column_date || ') + SUBPARTITION BY HASH(NUMPAC) terminé'); COMMIT;
     END IF;

     INSERT INTO partition_log_struct_table(dte, table_name, log)
      VALUES (SYSDATE, v_table_sav, '  5 - Supprimer la table ' || v_table_sav); COMMIT;

     -- SUPPRIMER TABLE _SAV
     EXECUTE_IMMEDIATE_STRING( 'DROP TABLE ' || v_table_sav,0);

     -- RECALCUL DES STATISTIQUES
     BEGIN
       IF (p_force_statistics = 1) THEN
         INSERT INTO partition_log_struct_table(dte, table_name, log)
          VALUES (SYSDATE, v_table, '  6 - Relancer les statistiques pour ' || v_table); COMMIT;
         dbms_stats.gather_table_stats(ownname => sys_context('USERENV','SESSION_SCHEMA'), tabname => v_table, cascade => true);
       END IF;
     EXCEPTION WHEN OTHERS THEN
       v_error := SQLCODE || '-' || sqlerrm;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, p_table, '      Recalcul des statistiques impossible. ' || v_error); COMMIT;
     END;

     INSERT INTO partition_log_struct_table(dte, table_name, log)
      VALUES (SYSDATE, v_table, '  7 - Structure de table ' || v_table); COMMIT;

     -- MISE EN PLACE DES COLONNES VIRTUELLES
     BEGIN
       FOR j IN (SELECT * FROM partition_sav_struct_table WHERE table_name = v_table AND type = 'VIRTUAL COLUMN')
       LOOP
         v_type := j.type;
         v_type_name := j.type_name;
         EXECUTE_IMMEDIATE_STRING( j.sql_code,1);--COMMIT;
       END LOOP;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, v_table, '      Mise en place des colonnes virtuelles terminée'); COMMIT;
     EXCEPTION WHEN OTHERS THEN
       v_error := SQLCODE || '-' || sqlerrm;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, p_table, '      Mise en place des colonnes virtuelles impossible. ' || v_error); COMMIT;
     END;

     -- MISE EN PLACE DES INDEX
     BEGIN
       FOR j IN (SELECT * FROM partition_sav_struct_table WHERE table_name = v_table AND type = 'INDEX')
       LOOP
         v_type := j.type;
         v_type_name := j.type_name;
         EXECUTE_IMMEDIATE_STRING( j.sql_code,1);--COMMIT;
       END LOOP;  
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, v_table, '      Mise en place des index terminée'); COMMIT;
     EXCEPTION WHEN OTHERS THEN
       v_error := SQLCODE || '-' || sqlerrm;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, p_table, '      Mise en place des index impossible. ' || v_error); COMMIT;
     END;

     -- MISE EN PLACE DES CONTRAINTES
     BEGIN
       FOR j IN (SELECT * FROM partition_sav_struct_table WHERE table_name = v_table AND type = 'CONSTRAINT')
       LOOP
         v_type := j.type;
         v_type_name := j.type_name;
         EXECUTE_IMMEDIATE_STRING( j.sql_code,1);--COMMIT;
       END LOOP;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, v_table, '      Mise en place des contraintes terminée'); COMMIT;
     EXCEPTION WHEN OTHERS THEN
       v_error := SQLCODE || '-' || sqlerrm;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, p_table, '      Mise en place des contraintes impossible. ' || v_error); COMMIT;
     END;

     -- MISE EN PLACE DES DECLENCHEURS
     BEGIN
       FOR j IN (SELECT * FROM partition_sav_struct_table WHERE table_name = v_table AND type = 'TRIGGER')
       LOOP
         v_type := j.type;
         v_type_name := j.type_name;
         EXECUTE_IMMEDIATE_STRING( j.sql_code,1);--COMMIT;
       END LOOP;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, v_table, '      Mise en place des déclencheurs terminée'); COMMIT;
     EXCEPTION WHEN OTHERS THEN
       v_error := SQLCODE || '-' || sqlerrm;
       INSERT INTO partition_log_struct_table(dte, table_name, log)
        VALUES (SYSDATE, p_table, '      Mise en place des déclencheurs impossible. ' || v_error); COMMIT;
     END;
  END IF;

  EXCEPTION WHEN OTHERS THEN
    v_error := SQLCODE || '-' || sqlerrm;
    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, v_table, ('Erreur: ' || v_error || '[table=' || v_table || '], [table_sav=' || v_table_sav || '], [type=' || v_type || '], [type_name=' || v_type_name || ']')); COMMIT;
    RAISE_APPLICATION_ERROR(-20000, 'Problème(s) durant le partitionnement des tables. ' || v_error);
END PARTITIONNEMENT;
##
PARTITIONNEMENT_MULTI
=SQL=
create or replace PROCEDURE PARTITIONNEMENT_MULTI(
  p_request                 IN VARCHAR2, -- SELECT table_name FROM user_tab_cols WHERE column_name = 'CODTS' AND table_name NOT LIKE 'TMP%' AND table_name NOT LIKE 'FOR%' AND table_name NOT LIKE '%Z2X%' AND  table_name not like 'C99%'
  p_column                  IN VARCHAR2,
  p_column_date             IN VARCHAR2,
  p_force_statistics        IN NUMBER)
AS
  v_error                   CLOB;

  TYPE t_ref_table          IS REF CURSOR;
  c_tables                  t_ref_table;
  v_table                   VARCHAR2(255);
BEGIN
  OPEN c_tables FOR p_request;
  LOOP
    FETCH c_tables INTO v_table; -- récupère les tables une à une
    EXIT WHEN c_tables%NOTFOUND;
    IF (v_table IS NOT NULL) THEN
      partitionnement(v_table, p_column, p_column_date, p_force_statistics);
    END IF;
  END LOOP;
  EXCEPTION WHEN OTHERS THEN
    v_error := SQLCODE || '-' || sqlerrm;
    INSERT INTO partition_log_struct_table(dte, table_name, log)
     VALUES (SYSDATE, '', 'Erreur (PARTITIONNEMENT_MULTI): ' || v_error); COMMIT;
    RAISE_APPLICATION_ERROR(-20000, 'Problème(s) durant le partitionnement des tables ' || v_error);
END PARTITIONNEMENT_MULTI;
##
PURGE_HISTO_DIF_FSED
=SQL=
create or replace PROCEDURE PURGE_HISTO_DIF_FSED(
    p_id     IN NUMBER,
    P_NUMPAC IN VARCHAR2,
    P_PERIODEENCOURS IN TGE_REF_PAC.PERIODEENCOURS%type,
    P_DEB_RETRO IN  TGE_REF_PAC.DEB_RETRO%type,
    P_DEB_HISTO_RETRO IN TGE_REF_PAC.DEB_HISTO_RETRO%type,
    P_NB_MOIS_RETRO IN TGE_REF_PAC.NB_MOIS_RETRO%type,
    P_PERIDOE_HISTO_LIMITE IN TGE_REF_PAC.PERIODEENCOURS%type)
AS
  P_REQ     VARCHAR2(2000);
  w_isRetro NUMBER ;
  w_periode_partition TGE_REF_PAC.PERIODEENCOURS%type;
  w_subpartition_0 VARCHAR2(20);
  w_subpartition VARCHAR2(20);
  w_subpartition_del VARCHAR2(20);
BEGIN

  IF  to_date(P_PERIODEENCOURS,'YYYYMM')>=to_date(P_DEB_HISTO_RETRO,'YYYYMM') THEN
      select to_char(ADD_MONTHS(TO_DATE(P_PERIODEENCOURS,'yyyymm'),1),'yyyymm') into w_periode_partition from dual;
     FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partitions des HISTO (DEB CREAT PARTITION DIF_FSED_HISTO)','Début Création des partitions  de la table DIF_FSED_HISTO avant purge');
     
  IF is_number(P_NUMPAC)IS NOT NULL THEN 
     w_subpartition_0 := '"'||P_NUMPAC||'_000000"';
     w_subpartition :='"'||P_NUMPAC||'_'||P_PERIODEENCOURS||'"';
  ELSE
     w_subpartition_0 :=P_NUMPAC;
     w_subpartition :=P_NUMPAC||'_'||P_PERIODEENCOURS;
  END IF; 
    
    BEGIN     
      p_req := 'Alter TABLE DIF_FSED_HISTO add partition NUMPAC_'||P_NUMPAC||' VALUES('''||P_NUMPAC||''')(SUBPARTITION '||w_subpartition_0||'  VALUES LESS THAN(''000000'')) UPDATE INDEXES ';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION PARTITION DIF_FSED_HISTO','Création partition NUMPAC_'||P_NUMPAC||'sur la table DIF_FSED_HISTO p_req '||p_req);
      EXECUTE_IMMEDIATE_STRING( p_req,0);
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION PARTITION DIF_FSED_HISTO','Fin création partition NUMPAC_'||P_NUMPAC||'sur la table DIF_FSED_HISTO ');
    EXCEPTION
    WHEN OTHERS THEN
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION PARTITION DIF_FSED_HIST_RETRO','Partition NUMPAC_'||P_NUMPAC||'de la table DIF_FSED_HISTO existe');
    END ;
    BEGIN
      p_req := 'ALTER TABLE DIF_FSED_HISTO  MODIFY PARTITION NUMPAC_'||P_NUMPAC||' ADD SUBPARTITION '||w_subpartition||' VALUES LESS THAN ('''||w_periode_partition||''') UPDATE INDEXES';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION SOUS PARTITION DIF_FSED_HISTO','Création SOUS partition PERIODE_'||P_PERIODEENCOURS||' de NUMPAC_'||P_NUMPAC||'sur la table DIF_FSED_HISTO p_req '||p_req);
      EXECUTE_IMMEDIATE_STRING( p_req,0);
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION SOUS PARTITION DIF_FSED_HISTO','Fin création SOUS partition PERIODE_'||P_PERIODEENCOURS||' de NUMPAC_'||P_NUMPAC||'sur la table DIF_FSED_HISTO ');
    EXCEPTION
    WHEN OTHERS THEN
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'CREATION PARTITION DIF_FSED_HISTO','SOUS partition PERIODE_'||P_PERIODEENCOURS||' de NUMPAC_'||P_NUMPAC||'sur la table DIF_FSED_HISTO existe ');
    END ;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partitions des HISTO (Fin CREAT PARTITION DIF_FSED_HISTO)','Fin Créatin des partitions  de la table DIF_FSED_HISTO avant purge');
  
    --purge de DIF_FSED_HISTO 
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (DEBUT Supp DIF_FSED_HISTO)','DEBUT Purge de la table DIF_FSED_HISTO  pour les periodes inférieurs à '||P_PERIDOE_HISTO_LIMITE);
    FOR K IN
    (SELECT DISTINCT periode
    FROM DIF_FSED_HISTO
    WHERE to_date(periode,'YYYYMM') <add_months(to_date(P_PERIODEENCOURS,'yyyymm'),-1*P_NB_MOIS_RETRO)
    AND NUMPAC                      =P_NUMPAC
    )
    LOOP
      IF is_number(P_NUMPAC)IS NOT NULL THEN 
        w_subpartition_del :='"'||P_NUMPAC||'_'||K.PERIODE||'"';
      ELSE
        w_subpartition_del :=P_NUMPAC||'_'||K.PERIODE;
      END IF;
      p_req := 'ALTER TABLE DIF_FSED_HISTO TRUNCATE SUBPARTITION '||w_subpartition_del||' DROP STORAGE';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED ( Supp Sous partition DIF_FSED_HISTO)','suppression sous partition '||P_NUMPAC||'_'||K.PERIODE||' de DIF_FSED_HISTO p_req '||p_req);
      EXECUTE_IMMEDIATE_STRING( p_req,0);
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED ( Fin Supp Sous partition DIF_FSED_HISTO)','Fin suppression sous partition '||P_NUMPAC||'_'||K.PERIODE||' de DIF_FSED_HISTO ');
    END LOOP;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (FIN Supp DIF_FSED_HISTO)','FIN Purge de la table DIF_FSED_HISTO  pour les periodes inférieurs à '||P_PERIDOE_HISTO_LIMITE);
    --historisation
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (Debut INSERT de DIF_FSED IN DIF_FSED_HISTO)','Remplissage  de la table DIF_FSED_HISTO à partir de DIF_FSED');
    --Merge 1
    MERGE INTO DIF_FSED_HISTO T USING
    (SELECT p_PERIODEENCOURS AS PERIODE,
      NUMPAC ,
      CLE ,
      PACMAT ,
      PAIEZAD ,
      ELEM ,
      OCC ,
      VALEUR ,
      CODEOP ,
      TYPE_DONNEE ,
      DTEFFET
    FROM DIF_FSED z
    WHERE NUMPAC = p_numpac
    AND ID_TRT   =
      ( SELECT max(ID_TRT)  from GAP_TRT_DERNIER_ENVOI  e
      WHERE z.pacmat =e.pacmat
      AND z.numpac   =e.numpac
      AND z.PAIEZAD  =e.paiezad
      )
    )i ON (i.PERIODE= T.PERIODE AND i.NUMPAC=T.NUMPAC AND i.CLE=T.CLE AND i.PACMAT=T.PACMAT AND i.PAIEZAD=T.PAIEZAD AND i.ELEM=T.ELEM AND i.OCC=T.OCC)
  WHEN NOT MATCHED THEN
    INSERT
      (
        PERIODE,
        NUMPAC,
        CLE,
        PACMAT,
        PAIEZAD,
        ELEM,
        OCC,
        VALEUR,
        CODEOP,
        TYPE_DONNEE,
        DTEFFET
      )
      VALUES
      (
        i.PERIODE,
        i.NUMPAC,
        i.CLE,
        i.PACMAT,
        i.PAIEZAD,
        i.ELEM,
        i.OCC,
        i.VALEUR,
        i.CODEOP,
        i.TYPE_DONNEE,
        i.DTEFFET
      );
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (Fin INSERT de DIF_FSED IN DIF_FSED_HISTO)','Fin remplissage  de la table DIF_FSED_HISTO à partir de DIF_FSED ');
    --DELETE 1
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (DEBUT DELETE de DIF_FSED_HISTO)','Supression de DIF_FSED_HISTO dont la référence numpac/pacmat/periode est dans DIF_FSED_PARTIERETRO par périodes ');   
    DELETE
    FROM DIF_FSED_HISTO retro
    WHERE retro.numpac=p_numpac
    AND EXISTS
        (SELECT 1
        FROM DIF_FSED_PARTIERETRO z
        WHERE z.paiezad                =retro.paiezad
        AND z.pacmat                   =retro.pacmat
        AND z.numpac                   =retro.numpac
        AND z.periode                  =retro.periode
        AND z.ID_TRT                   =
          (SELECT max(ID_TRT)  from GAP_TRT_DERNIER_ENVOI  e         
          WHERE z.pacmat  =e.pacmat
          AND z.numpac    =e.numpac
          AND z.PAIEZAD   =e.paiezad
          )
        );
       FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (FIN DELETE de DIF_FSED_HISTO)','Fin Supression de DIF_FSED_HISTO');   
       --MERGE 2 
       FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (DEBUT INSERT de DIF_FSED_PARTIERETRO IN DIF_FSED_HISTO)','Remplissage de la table DIF_FSED_HISTO à partir de DIF_FSED_PARTIERETRO ');
        MERGE INTO DIF_FSED_HISTO T USING
         (SELECT r.PERIODE AS PERIODE,
                 r.NUMPAC ,
                 r.CLE ,
                 r.PACMAT ,
                 r.PAIEZAD ,
                 r.ELEM ,
                 r.OCC ,
                 r.VALEUR ,
                 r.CODEOP ,
                 r.TYPE_DONNEE ,
                 r.DTEFFET
       FROM DIF_FSED_PARTIERETRO r
       WHERE r.NUMPAC   = p_numpac
       AND   r.ID_TRT  =
          (SELECT max(ID_TRT)  from GAP_TRT_DERNIER_ENVOI  e          
          WHERE r.pacmat =e.pacmat
          AND r.numpac   =e.numpac
          AND r.PAIEZAD  =e.paiezad
          )
     )i ON (i.PERIODE= T.PERIODE AND i.NUMPAC=T.NUMPAC AND i.PACMAT=T.PACMAT AND i.PAIEZAD=T.PAIEZAD AND i.ELEM=T.ELEM AND i.OCC=T.OCC)
    WHEN NOT MATCHED THEN
     INSERT
      (PERIODE,
       NUMPAC,
       CLE,
       PACMAT,
       PAIEZAD,
       ELEM,
       OCC,
       VALEUR,
       CODEOP,
       TYPE_DONNEE,
       DTEFFET)
     VALUES
      (i.PERIODE,
       i.NUMPAC,
       i.CLE,
       i.PACMAT,
       i.PAIEZAD,
       i.ELEM,
       i.OCC,
       i.VALEUR,
       i.CODEOP,
       i.TYPE_DONNEE,
       i.DTEFFET);
       FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED (FIN INSERT de DIF_FSED_PARTIERETRO IN DIF_FSED_HISTO)','Fin remplissage de la table DIF_FSED_HISTO à partir de DIF_FSED_PARTIERETRO ');

  END IF;
  
EXCEPTION
WHEN OTHERS THEN
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'PURGE_HISTO_DIF_FSED  ', 'Une erreur est survenue lors de l historisation Rétro de DIF_FSED . Veuillez consulter la table TGE_FSED_ERREUR.');
  FSED.FSED_ERREUR(p_id,'PURGE_HISTO_DIF_FSED',P_NUMPAC,SQLCODE||'-'||SQLERRM);
  raise;
END PURGE_HISTO_DIF_FSED;
##
TAG_CHARSET=@€éèç
##
MAJ_TABLES_REF_A_PARTIR_DE_HIS
==
CALL REF_MISAJOUR('')
##
REF_MISAJOUR
=SQL=
create or replace PROCEDURE REF_MISAJOUR(p_company_id VARCHAR2) AS BEGIN
  if p_company_id is not null then
    delete ref_ecran;
    insert into ref_ecran select * from meta_ecran where company_id=p_company_id;
    update ref_ecran set company_id='*';
    delete ref_dictionnaire;
    insert into ref_dictionnaire select * from meta_dictionnaire where company_id=p_company_id;
    update ref_dictionnaire set company_id='*';
    delete  ref_donnee_generale;
    insert into ref_donnee_generale select * from meta_donnee_generale where company_id=p_company_id;
    update ref_donnee_generale set company_id='*';
    delete ref_donnee_ecran;
    insert into ref_donnee_ecran select * from meta_donnee_ecran where company_id=p_company_id;
    update ref_donnee_ecran set company_id='*';
    delete  ref_destination_ecran;
    insert into ref_destination_ecran select * from meta_destination_ecran where company_id=p_company_id;
    update ref_destination_ecran set company_id='*';
    delete  ref_groupe_donnees_info;
    insert into ref_groupe_donnees_info  select * from meta_groupe_donnees_info where company_id=p_company_id;
    update ref_groupe_donnees_info set company_id='*';
    delete ref_groupe_donnees;
    insert into ref_groupe_donnees  select * from meta_groupe_donnees where company_id=p_company_id;
    update ref_groupe_donnees set company_id='*';
    delete ref_reglegestion_desc;
    insert into ref_reglegestion_desc select * from meta_reglegestion_desc where company_id=p_company_id;
    update ref_reglegestion_desc set company_id='*';
    delete ref_reglegestion;
    insert into ref_reglegestion  select * from meta_reglegestion where company_id=p_company_id;
    update ref_reglegestion set company_id='*';
    delete ref_wkf_operation_ecrans_info;
    insert into ref_wkf_operation_ecrans_info  select * from meta_wkf_operation_ecrans_info where company_id=p_company_id;
    update ref_wkf_operation_ecrans_info set company_id='*';
    delete ref_wkf_operation_ecrans;
    insert into ref_wkf_operation_ecrans  select * from meta_wkf_operation_ecrans where company_id=p_company_id;
    update ref_wkf_operation_ecrans set company_id='*';
    delete ref_donnee_mapping_ux;
 	insert into ref_donnee_mapping_ux  select * from meta_donnee_mapping_ux where company_id=p_company_id;
 	update ref_donnee_mapping_ux set company_id='*';
 	delete ref_groupe_donnees_tableaux;
 	insert into ref_groupe_donnees_tableaux  select * from meta_groupe_donnees_tableaux where company_id=p_company_id;
 	update ref_groupe_donnees_tableaux set company_id='*';
 	
 	BEGIN
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_ERREURS_PARAMETRAGES');
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_MODELE_DONNEES');
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_RECHERCHE_GLOBALE');
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_VAL_ZONE');
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_WORKFLOWS');
 	  DBMS_MVIEW.REFRESH('META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS');
 	EXCEPTION WHEN OTHERS THEN NULL; END;
  end if;
END REF_MISAJOUR;
##
TAG_CHARSET=@€éèç
##
R_CREATE_TRIGGER
=SQL=
CREATE OR REPLACE PROCEDURE R_CREATE_TRIGGER AS 
  w_err VARCHAR2(2000);
  --Curseur sur les tables codées dans MAPTA
  CURSOR cur_table IS
    SELECT DISTINCT TABLEPHY
    FROM TGE_REF_MAPTA
    WHERE ALLERRETOUR IN ('A','2','I')
    ORDER BY TABLEPHY;
  lig_table cur_table%ROWTYPE;

BEGIN
  TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','*** Début *** Fabrication de tous les triggers');
  OPEN cur_table;
  --Boucle sur les tables codées dans MAPTA
  LOOP 
    FETCH cur_table INTO lig_table;
    EXIT WHEN cur_table%NOTFOUND ;
    TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','TGE_CREATE_TRIGGER('||lig_table.tablephy||')');
    BEGIN
      --Génération du trigger d'une table
      TGE_CREATE_TRIGGER(lig_table.tablephy);
    EXCEPTION
      WHEN OTHERS THEN
        w_err := SQLCODE;
        w_err := '*** ERREUR *** '||lig_table.tablephy||' : '||w_err|| SQLERRM;
        TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER', SUBSTR(w_err,1,2000));
    END;
  END LOOP;
  CLOSE cur_table;
  TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','*** Fin ***');
  COMMIT;
END R_CREATE_TRIGGER;
##
R_DATE_FIN_BO_CONTRAT_HISTO
=SQL=
create or replace
PROCEDURE R_DATE_FIN_BO_CONTRAT_HISTO AS 
BEGIN
  -- Procédure de reprise des dates de fin BO dans la table DIC_ADM_CONTRAT_HISTO
  BEGIN
    EXECUTE_IMMEDIATE_STRING( 'DROP TABLE TABLE_DATE_FIN_BO',0);
  EXCEPTION WHEN OTHERS THEN NULL; END;

  EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE TABLE_DATE_FIN_BO(NUMPAC VARCHAR2(6),PAIEZAD VARCHAR2(8),DATE_EFF DATE,DATE_FIN_BO_OLD DATE,DATE_FIN_BO_NEW DATE,PRIMARY KEY(NUMPAC,PAIEZAD,DATE_EFF))',0);

  EXECUTE_IMMEDIATE_STRING( 'INSERT INTO TABLE_DATE_FIN_BO (SELECT NUMPAC,PAIEZAD,DATE_EFF,DATE_FIN_BO AS DATE_FIN_BO_OLD,NVL(LEAD(DATE_EFF_MOINS_UN) OVER(PARTITION BY NUMPAC,PAIEZAD ORDER BY DATE_EFF), TO_DATE(''20991231'',''yyyymmdd'')) AS DATE_FIN_BO_NEW FROM (SELECT DISTINCT NUMPAC,PAIEZAD,DATE_EFF,DATE_FIN_BO,DATE_EFF-1 AS DATE_EFF_MOINS_UN FROM DIC_ADM_CONTRAT_HISTO WHERE PAIEZAD IS NOT NULL))',0);

  EXECUTE_IMMEDIATE_STRING( 'MERGE INTO DIC_ADM_CONTRAT_HISTO C USING  (SELECT * FROM TABLE_DATE_FIN_BO WHERE  NVL(DATE_FIN_BO_NEW,to_date(''19001231'',''yyyymmdd'')) <> NVL(DATE_FIN_BO_OLD,to_date(''19001231'',''yyyymmdd''))) T ON  (T.NUMPAC=C.NUMPAC  AND T.PAIEZAD=C.PAIEZAD  AND T.DATE_EFF=C.DATE_EFF) WHEN MATCHED THEN UPDATE SET TYPE_WRITER=''N'', C.DATE_FIN_BO  = T.DATE_FIN_BO_NEW',0);

  EXECUTE_IMMEDIATE_STRING( 'DROP TABLE TABLE_DATE_FIN_BO',0);
  -- Fin
  COMMIT;
END R_DATE_FIN_BO_CONTRAT_HISTO;
##
R_DATE_SORTIE_SIT_BO_CNT_HISTO
=SQL=
create or replace
PROCEDURE R_DATE_SORTIE_SIT_BO_CNT_HISTO AS 
BEGIN
  -- Procédure de reprise des dates de sortie BO dans la table DIC_ADM_CONTRAT_HISTO 
  EXECUTE_IMMEDIATE_STRING( 'INSERT INTO TABLE_SORTIE_SIT_BO_TEMPORARY (SELECT MATRIC,DATE_EFF,DATE_SORTIE_SIT_BO AS DATE_SORTIE_SIT_BO_OLD,NVL(LEAD(DATE_EFF_MOINS_UN) OVER(PARTITION BY MATRIC ORDER BY DATE_EFF), TO_DATE(''20991231'',''yyyymmdd'')) AS DATE_SORTIE_SIT_BO_NEW FROM (SELECT DISTINCT MATRIC,DATE_EFF,DATE_SORTIE_SIT_BO,DATE_EFF-1 AS DATE_EFF_MOINS_UN FROM DIC_ADM_CONTRAT_HISTO WHERE MATRIC IS NOT NULL))',1);
  --COMMIT;
  EXECUTE_IMMEDIATE_STRING( 'MERGE INTO DIC_ADM_CONTRAT_HISTO C USING  (SELECT * FROM TABLE_SORTIE_SIT_BO_TEMPORARY WHERE  NVL(DATE_SORTIE_SIT_BO_NEW,to_date(''19001231'',''yyyymmdd'')) <> NVL(DATE_SORTIE_SIT_BO_OLD,to_date(''19001231'',''yyyymmdd''))) T ON  (T.MATRIC=C.MATRIC AND T.DATE_EFF=C.DATE_EFF) WHEN MATCHED THEN UPDATE SET TYPE_WRITER=''N'', C.DATE_SORTIE_SIT_BO  = T.DATE_SORTIE_SIT_BO_NEW',1);
  --COMMIT;
  EXECUTE_IMMEDIATE_STRING( 'TRUNCATE TABLE TABLE_SORTIE_SIT_BO_TEMPORARY',0);
  -- Fin
EXCEPTION WHEN OTHERS THEN
 EXECUTE_IMMEDIATE_STRING( 'TRUNCATE TABLE TABLE_SORTIE_SIT_BO_TEMPORARY',0);
END R_DATE_SORTIE_SIT_BO_CNT_HISTO;
##
TAG_CHARSET=@€éèç
##
R_PRESENT_FICHIER_PAIE
=SQL=
create or replace PROCEDURE R_PRESENT_FICHIER_PAIE( NUMPAC_TRAITEMENT IN SECUPACMAT.NUMPAC%Type , PACMAT_TRAITEMENT IN SECUPACMAT.PACMAT%Type ) IS 
PERIODEENCOURS_TRAITEMENT TGE_REF_PAC.PERIODEENCOURS%type;
BEGIN
-- récupère la periode en cours du pac
  BEGIN 
   SELECT PERIODEENCOURS into PERIODEENCOURS_TRAITEMENT from TGE_REF_PAC where NUMPAC=NUMPAC_TRAITEMENT;
   EXCEPTION
   WHEN NO_DATA_FOUND then
    RETURN;
  END;
--fait le merge ds secupacmat
MERGE INTO SECUPACMAT A
USING (
SELECT NUMPAC,
  PACMAT,
  CASE
    WHEN EXISTS
      ( WITH table_dates_eff (pacmat,paiezad,date_eff) AS
      ( SELECT DISTINCT dach2.pacmat,
        dach2.paiezad,
        MAX(date_eff) OVER(PARTITION BY dach2.pacmat,dach2.paiezad)
      FROM dic_adm_contrat_histo dach2
      WHERE dach2.numpac     = NUMPAC_TRAITEMENT
      AND dach2.pacmat       = NVL(PACMAT_TRAITEMENT,dach2.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
      AND dach2.date_eff    <= last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') )
      AND dach2.date_sortie_sit_bo >= add_months( (TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') ), -
        (SELECT valvar                                                                     -1
        FROM sys_varsys
        WHERE codvar ='NB_MOIS_PAIE_INIT'
        AND module   ='GAP'
        ) )
      )
    SELECT 1
    FROM dic_adm_contrat_histo dach
    INNER JOIN table_dates_eff t
    ON dach.pacmat    = t.pacmat
    AND dach.paiezad  = t.paiezad
    AND dach.date_eff = t.date_eff
    LEFT JOIN dic_tge_respaie_unique dtru
    ON dtru.numpac                     = NUMPAC_TRAITEMENT
    AND dtru.pacmat                    = dach.pacmat
    AND dtru.paiezad                   = dach.paiezad
    WHERE dach.numpac                  = NUMPAC_TRAITEMENT
    AND dach.pacmat                    = NVL(PACMAT_TRAITEMENT,dach.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
    AND sec.pacmat                     = dach.pacmat
    AND (dtru.numpac                  IS NULL
    OR ( NVL(dtru.prfpai, 'M')         != 'A'
    OR NVL(dtru.dtfpai, TO_DATE('20991231','yyyyMMdd'))    > last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'YYYYMM') )
    OR ( dach.ZREACT                  IS NOT NULL
    AND dtru.dtfpai                   <= dach.zreact
    AND EXTRACT(YEAR FROM dach.zreact) = SUBSTR(PERIODEENCOURS_TRAITEMENT,1,4) )
    OR dtru.dtfpai                     < dach.dssad ))
      )
    THEN 'O'
    ELSE 'N'
  END PRESENT_FICHIER_PAIE
FROM SECUPACMAT SEC
WHERE numpac     = NUMPAC_TRAITEMENT
AND pacmat       = NVL(PACMAT_TRAITEMENT,pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
) B
ON (A.NUMPAC = B.NUMPAC and A.PACMAT = B.PACMAT)
WHEN MATCHED THEN UPDATE SET A.PRESENT_FICHIER_PAIE = B.PRESENT_FICHIER_PAIE ;

END R_PRESENT_FICHIER_PAIE;
##
TAG_CHARSET=@€éèç
##
SECNAV_MAJ_ALL
=SQL=
CREATE OR REPLACE PROCEDURE SECNAV_MAJ_ALL(p_doRaz NUMBER) IS 
  TYPE TYP_COL_ROW IS TABLE OF USER_TAB_COLS%Rowtype ;
  Tabcol  TYP_COL_ROW ;
  v_listeColonnesSECUPACMAT CLOB;
BEGIN
  IF p_doRaz=1 THEN
    DELETE FROM SECUPACMAT_TMP;
    -- On insère les couples NUMPAC/PACMAT ayant un contrat
    INSERT INTO SECUPACMAT_TMP (NUMPAC,PACMAT,MATRIC) SELECT NUMPAC,PACMAT,MIN(MATRIC) FROM DIC_ADM_CONTRAT GROUP BY NUMPAC,PACMAT;
    -- On insère les couples NUMPAC/PACMAT présents dans DIC_ADM_PERSO (colonnes CURRENT_NUMPAC/CURRENT_PACMAT) n'existant pas dans SECUPACMAT_TMP (NUMPAC='TMPPAC' ou couple NUMPAC/PACMAT pour lequel un contrat a été créé puis supprimé)
    INSERT INTO SECUPACMAT_TMP (NUMPAC,PACMAT,MATRIC) SELECT CURRENT_NUMPAC, CURRENT_PACMAT, MATRIC FROM DIC_ADM_PERSO WHERE CURRENT_NUMPAC IS NOT NULL AND CURRENT_PACMAT IS NOT NULL AND (CURRENT_NUMPAC, CURRENT_PACMAT) NOT IN (SELECT NUMPAC, PACMAT FROM SECUPACMAT_TMP);
    --Recalcul des stats de SECUPACMAT_TMP
    SYS_RECALCUL_STATS('SECUPACMAT_TMP');
  END IF;

  -- On insère une valeur bidon dans SECUPACMAT_TMP.MATRIC : ça sert de flag pour savoir que la procédure est en cours
  INSERT INTO SECUPACMAT_TMP (MATRIC,NUMPAC,PACMAT) VALUES ('SECNAV','SECNAV','SECNAV');
  -- On commite pour que le flag soit visible de suite par les autres sessions
  COMMIT;

  DELETE FROM SECUPACMAT_TMP_PERSO;
  -- DIT 47820 : SECUPACMAT_TMP_CONTRAT is a temporary table 
  -- Truncate table instead of deleting 
  EXECUTE_IMMEDIATE_STRING( 'TRUNCATE  TABLE SECUPACMAT_TMP_CONTRAT',0);
  INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM DIC_ADM_PERSO;
  INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT NUMPAC, PACMAT, MIN(MATRIC) FROM DIC_ADM_CONTRAT GROUP BY NUMPAC,PACMAT;
  --Recalcul des stats de SECUPACMAT_TMP_PERSO & SECUPACMAT_TMP_CONTRAT
  SYS_RECALCUL_STATS('SECUPACMAT_TMP_CONTRAT');
  SYS_RECALCUL_STATS('SECUPACMAT_TMP_PERSO');

  -- On supprime le flag pour ne pas bloquer les mises à jour depuis les procédures SECNAV_MAJ_CURRENT_CONTRAT et SECNAV_MAJ_CURRENT_PERSO
  DELETE FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';

  -- 1) On met à jour les clés de la situation CONTRAT courante, avec mise à jour des données CONTRAT et CONTRAT_HISTO
  SECNAV_MAJ_CURRENT_CONTRAT('DO_MAJ', 1, 1, p_doRaz);
  -- 2) On met à jour les clés de la situation PERSO courante, avec mise à jour des données PERSO et PERSO_HISTO
  SECNAV_MAJ_CURRENT_PERSO('DO_MAJ', 1, 1, p_doRaz);

  -- On ré-insère le flag
  INSERT INTO SECUPACMAT_TMP (MATRIC,NUMPAC,PACMAT) VALUES ('SECNAV','SECNAV','SECNAV');

  DELETE FROM SECUPACMAT_TMP_PERSO;
  EXECUTE_IMMEDIATE_STRING( 'TRUNCATE  TABLE SECUPACMAT_TMP_CONTRAT',0);
  --Recalcul des stats de SECUPACMAT_TMP_PERSO & SECUPACMAT_TMP_CONTRAT
  SYS_RECALCUL_STATS('SECUPACMAT_TMP_CONTRAT');
  SYS_RECALCUL_STATS('SECUPACMAT_TMP_PERSO');
  
  IF p_doRaz=1 THEN
    -- Pour toutes les colonnes de SECUPACMAT qui ne sont pas issues de DIC_ADM (et qui ne sont pas des colonnes calculées par le traitement : NUMPAC, PACMAT, CURRENT_NUMCNT, DATE_EFF_CONTRAT, MATRIC, DATE_EFF_PERSO, PRIORITE_SITUATION, IDPACMAT), on récupère les valeurs avant écrasement
    SELECT * BULK COLLECT Into Tabcol FROM USER_TAB_COLS WHERE TABLE_NAME='SECUPACMAT' AND COLUMN_NAME NOT IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME LIKE 'DIC_ADM%') AND COLUMN_NAME NOT IN ('NUMPAC','PACMAT','CURRENT_NUMCNT','DATE_EFF_CONTRAT','MATRIC','DATE_EFF_PERSO','PRIORITE_SITUATION','IDPACMAT') AND COLUMN_ID IS NOT NULL;
    FOR i IN Tabcol.first..Tabcol.last LOOP
      -- On appelle DIC_MODIF_STRUCTURE pour ajouter la colonne a SECUPACMAT_TMP, au cas où elle n'existe pas (si elle existe, il n'y a pas de plantage)
      DIC_MODIF_STRUCTURE('SECUPACMAT_TMP', Tabcol(i).COLUMN_NAME, NULL, NULL, NULL, NULL, Tabcol(i).DATA_TYPE, Tabcol(i).DATA_LENGTH, Tabcol(i).DATA_PRECISION, Tabcol(i).DATA_SCALE);
      EXECUTE_IMMEDIATE_STRING( 'UPDATE SECUPACMAT_TMP SET ' || Tabcol(i).COLUMN_NAME || '=(SELECT ' || Tabcol(i).COLUMN_NAME || ' FROM SECUPACMAT WHERE SECUPACMAT.NUMPAC=SECUPACMAT_TMP.NUMPAC AND SECUPACMAT.PACMAT=SECUPACMAT_TMP.PACMAT)',0);
    END LOOP;
    DELETE FROM SECUPACMAT;
    SELECT * BULK COLLECT Into Tabcol FROM USER_TAB_COLS WHERE TABLE_NAME='SECUPACMAT' AND VIRTUAL_COLUMN='NO' AND COLUMN_ID IS NOT NULL ORDER BY COLUMN_ID;
    v_listeColonnesSECUPACMAT := NULL;
    FOR i IN Tabcol.first..Tabcol.last LOOP
      -- On appelle DIC_MODIF_STRUCTURE pour ajouter la colonne a SECUPACMAT_TMP, au cas où elle n'existe pas (si elle existe, il n'y a pas de plantage)
      DIC_MODIF_STRUCTURE('SECUPACMAT_TMP', Tabcol(i).COLUMN_NAME, NULL, NULL, NULL, NULL, Tabcol(i).DATA_TYPE, Tabcol(i).DATA_LENGTH, Tabcol(i).DATA_PRECISION, Tabcol(i).DATA_SCALE);
      IF v_listeColonnesSECUPACMAT IS NOT NULL THEN
        v_listeColonnesSECUPACMAT := v_listeColonnesSECUPACMAT||',';
      END IF;
      v_listeColonnesSECUPACMAT := v_listeColonnesSECUPACMAT || Tabcol(i).COLUMN_NAME;
    END LOOP;
    -- On supprime le flag avant l'insertion dans SECUPACMAT (sinon on va l'insérer aussi)
    DELETE FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';
    EXECUTE_IMMEDIATE_STRING( 'INSERT INTO SECUPACMAT (' || v_listeColonnesSECUPACMAT || ') SELECT ' || v_listeColonnesSECUPACMAT || ' FROM SECUPACMAT_TMP',0);
    EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE SECUPACMAT ENABLE ROW MOVEMENT',0);
    EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE SECUPACMAT SHRINK SPACE',0);
    EXECUTE_IMMEDIATE_STRING( 'CALL DBMS_STATS.UNLOCK_TABLE_STATS(USER,''SECUPACMAT'')',0);
    EXECUTE_IMMEDIATE_STRING( 'CALL DBMS_STATS.GATHER_TABLE_STATS(USER,''SECUPACMAT'')',0);
  END IF;
  -- On supprime le flag
  DELETE FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';
EXCEPTION
  WHEN OTHERS THEN
    -- Erreur
    -- On rollback tout ce qui a été fait depuis le COMMIT de l'insertion de 'SECNAV' dans SECUPACMAT_TMP
    ROLLBACK;
    -- On supprime le flag en cas d'exception (pour ne pas tout bloquer)
    DELETE FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';
    -- On commit la suppression du flag, sinon il reste
    COMMIT;
    Raise;
END SECNAV_MAJ_ALL;
##
SECNAV_MAJ_CURRENT_CONTRAT
=SQL=
CREATE OR REPLACE PROCEDURE SECNAV_MAJ_CURRENT_CONTRAT(p_matric VARCHAR2, p_majDataContrat NUMBER, p_majDataContratHisto NUMBER, p_alimTmp NUMBER) AS
  v_dateEff DATE;
BEGIN
  IF p_matric='DO_MAJ' THEN
    -- On se met à minuit
    v_dateEff := TRUNC(SYSDATE,'dd');

    -- On met à jour CURRENT_DSDCN_MATRIC dans la table temporaire (date de début du contrat courant pour le MATRIC)
    UPDATE SECUPACMAT_TMP_CONTRAT SET CURRENT_DSDCN_MATRIC=(SELECT MAX(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.MATRIC=SECUPACMAT_TMP_CONTRAT.MATRIC AND v_dateEff BETWEEN DSDCN AND NVL(DSFCN, TO_DATE('20991231','yyyymmdd')));
    UPDATE SECUPACMAT_TMP_CONTRAT SET CURRENT_DSDCN_MATRIC=(SELECT MIN(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.MATRIC=SECUPACMAT_TMP_CONTRAT.MATRIC AND DSDCN>v_dateEff) WHERE CURRENT_DSDCN_MATRIC IS NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET CURRENT_DSDCN_MATRIC=(SELECT MAX(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.MATRIC=SECUPACMAT_TMP_CONTRAT.MATRIC AND DSDCN<v_dateEff) WHERE CURRENT_DSDCN_MATRIC IS NULL;

    -- On met à jour CURRENT_NUMCNT_PACMAT et CURRENT_DSDCN_PACMAT dans la table temporaire (contrat courant et date de début correspondante pour le NUMPAC/PACMAT)
    UPDATE SECUPACMAT_TMP_CONTRAT SET (CURRENT_NUMCNT_PACMAT, CURRENT_DSDCN_PACMAT)=(SELECT MAX(NUMCNT), MAX(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND v_dateEff BETWEEN DSDCN AND NVL(DSFCN, TO_DATE('20991231','yyyymmdd')));
    UPDATE SECUPACMAT_TMP_CONTRAT SET (CURRENT_NUMCNT_PACMAT, CURRENT_DSDCN_PACMAT)=(SELECT MIN(NUMCNT), MIN(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DSDCN>v_dateEff) WHERE CURRENT_NUMCNT_PACMAT IS NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET (CURRENT_NUMCNT_PACMAT, CURRENT_DSDCN_PACMAT)=(SELECT MAX(NUMCNT), MAX(DSDCN) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DSDCN<v_dateEff) WHERE CURRENT_NUMCNT_PACMAT IS NULL;

    -- On met à jour DATE_EFF_CONTRAT_PACMAT dans la table temporaire (date effet courante du contrat courant pour le NUMPAC/PACMAT)
    UPDATE SECUPACMAT_TMP_CONTRAT SET DATE_EFF_CONTRAT_PACMAT=(SELECT MAX(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=SECUPACMAT_TMP_CONTRAT.CURRENT_NUMCNT_PACMAT AND v_dateEff BETWEEN DATE_EFF AND DATE_FIN) WHERE CURRENT_NUMCNT_PACMAT IS NOT NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET DATE_EFF_CONTRAT_PACMAT=(SELECT MIN(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=SECUPACMAT_TMP_CONTRAT.CURRENT_NUMCNT_PACMAT AND DATE_EFF>v_dateEff) WHERE CURRENT_NUMCNT_PACMAT IS NOT NULL AND DATE_EFF_CONTRAT_PACMAT IS NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET DATE_EFF_CONTRAT_PACMAT=(SELECT MAX(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=SECUPACMAT_TMP_CONTRAT.CURRENT_NUMCNT_PACMAT AND DATE_EFF<v_dateEff) WHERE CURRENT_NUMCNT_PACMAT IS NOT NULL AND DATE_EFF_CONTRAT_PACMAT IS NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET DATE_EFF_CONTRAT_PACMAT=(SELECT DSDCN FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT.PACMAT=SECUPACMAT_TMP_CONTRAT.PACMAT AND DIC_ADM_CONTRAT.NUMCNT=SECUPACMAT_TMP_CONTRAT.CURRENT_NUMCNT_PACMAT) WHERE CURRENT_NUMCNT_PACMAT IS NOT NULL AND DATE_EFF_CONTRAT_PACMAT IS NULL;

    -- On met à jour PRIORITE_SITUATION dans la table temporaire (Différence en jour entre la date de début du contrat courant pour le NUMPAC/PACMAT et la date de début du contrat courant pour le MATRIC)
    UPDATE SECUPACMAT_TMP_CONTRAT SET PRIORITE_SITUATION=(CURRENT_DSDCN_PACMAT-CURRENT_DSDCN_MATRIC) WHERE CURRENT_DSDCN_PACMAT IS NOT NULL AND CURRENT_DSDCN_MATRIC IS NOT NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET PRIORITE_SITUATION=0 WHERE CURRENT_DSDCN_PACMAT IS NULL AND CURRENT_DSDCN_MATRIC IS NULL;
    UPDATE SECUPACMAT_TMP_CONTRAT SET PRIORITE_SITUATION=(WITH LIST_NUMPAC AS (SELECT NUMPAC, ROWNUM AS RN FROM (SELECT NUMPAC FROM TGE_REF_PAC ORDER BY NUMPAC DESC) UNION SELECT '*', 999999999 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM TGE_REF_PAC WHERE NUMPAC='*')) SELECT RN-(SELECT MIN(RN) FROM LIST_NUMPAC WHERE NUMPAC IN (SELECT NUMPAC FROM SECUPACMAT_TMP_CONTRAT T WHERE T.MATRIC=SECUPACMAT_TMP_CONTRAT.MATRIC)) FROM LIST_NUMPAC WHERE LIST_NUMPAC.NUMPAC=SECUPACMAT_TMP_CONTRAT.NUMPAC) WHERE PRIORITE_SITUATION=0 AND MATRIC IN (SELECT MATRIC FROM (SELECT MATRIC, COUNT(*) AS NB_SIT_0 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.PRIORITE_SITUATION=0 GROUP BY MATRIC) WHERE NB_SIT_0>1);

    -- On met à jour CURRENT_NUMCNT, DATE_EFF_CONTRAT et PRIORITE_SITUATION de SECUPACMAT (ou SECUPACMAT_TMP)
    IF p_alimTmp=0 THEN
      UPDATE SECUPACMAT     SET (CURRENT_NUMCNT,DATE_EFF_CONTRAT,PRIORITE_SITUATION)=(SELECT CURRENT_NUMCNT_PACMAT,DATE_EFF_CONTRAT_PACMAT,PRIORITE_SITUATION FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=SECUPACMAT    .NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=SECUPACMAT    .PACMAT) WHERE EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=SECUPACMAT    .NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=SECUPACMAT    .PACMAT);
      UPDATE SECUPACMAT     SET PRIORITE_SITUATION=0 WHERE PRIORITE_SITUATION IS NULL AND NOT EXISTS (SELECT 1 FROM SECUPACMAT     S WHERE PRIORITE_SITUATION=0 AND S.MATRIC=SECUPACMAT    .MATRIC);
      UPDATE SECUPACMAT     SET PRIORITE_SITUATION=99 WHERE PRIORITE_SITUATION IS NULL;
      UPDATE SECUPACMAT     SET PRIORITE_SITUATION=0 WHERE NUMPAC='TMPPAC';
    ELSE
      UPDATE SECUPACMAT_TMP SET (CURRENT_NUMCNT,DATE_EFF_CONTRAT,PRIORITE_SITUATION)=(SELECT CURRENT_NUMCNT_PACMAT,DATE_EFF_CONTRAT_PACMAT,PRIORITE_SITUATION FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=SECUPACMAT_TMP.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=SECUPACMAT_TMP.PACMAT) WHERE EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=SECUPACMAT_TMP.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=SECUPACMAT_TMP.PACMAT);
      UPDATE SECUPACMAT_TMP SET PRIORITE_SITUATION=0 WHERE PRIORITE_SITUATION IS NULL AND NOT EXISTS (SELECT 1 FROM SECUPACMAT_TMP S WHERE PRIORITE_SITUATION=0 AND S.MATRIC=SECUPACMAT_TMP.MATRIC);
      UPDATE SECUPACMAT_TMP SET PRIORITE_SITUATION=99 WHERE PRIORITE_SITUATION IS NULL;
      UPDATE SECUPACMAT_TMP SET PRIORITE_SITUATION=0 WHERE NUMPAC='TMPPAC';
    END IF;

    -- On met à jour DATE_EFF_CONTRAT de DIC_ADM_CONTRAT
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', DATE_EFF_CONTRAT=(SELECT MAX(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND v_dateEff BETWEEN DATE_EFF AND DATE_FIN) WHERE EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=DIC_ADM_CONTRAT.PACMAT);
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', DATE_EFF_CONTRAT=(SELECT MIN(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND DATE_EFF>v_dateEff) WHERE DATE_EFF_CONTRAT IS NULL AND EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=DIC_ADM_CONTRAT.PACMAT);
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', DATE_EFF_CONTRAT=(SELECT MAX(DATE_EFF) FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND DATE_EFF<v_dateEff) WHERE DATE_EFF_CONTRAT IS NULL AND EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=DIC_ADM_CONTRAT.PACMAT);
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', DATE_EFF_CONTRAT=DSDCN WHERE DATE_EFF_CONTRAT IS NULL AND EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=DIC_ADM_CONTRAT.PACMAT);
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', CURRENT_PAIEZAD=(SELECT PAIEZAD FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND DIC_ADM_CONTRAT_HISTO.DATE_EFF=DIC_ADM_CONTRAT.DATE_EFF_CONTRAT) WHERE EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND SECUPACMAT_TMP_CONTRAT.PACMAT=DIC_ADM_CONTRAT.PACMAT);

    -- On met à jour CURRENT_NUMPAC, CURRENT_PACMAT, CURRENT_NUMCNT et DATE_EFF_CONTRAT de DIC_ADM_PERSO
    UPDATE DIC_ADM_PERSO SET TYPE_WRITER='N', (CURRENT_NUMPAC, CURRENT_PACMAT, CURRENT_NUMCNT, DATE_EFF_CONTRAT)=(SELECT NUMPAC, PACMAT, CURRENT_NUMCNT_PACMAT, DATE_EFF_CONTRAT_PACMAT FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.MATRIC=DIC_ADM_PERSO.MATRIC AND SECUPACMAT_TMP_CONTRAT.PRIORITE_SITUATION=0) WHERE EXISTS (SELECT 1 FROM SECUPACMAT_TMP_CONTRAT WHERE SECUPACMAT_TMP_CONTRAT.MATRIC=DIC_ADM_PERSO.MATRIC);

    IF p_majDataContrat=1 THEN
      -- 7) On met à jour les données CONTRAT
      SECNAV_MAJ_DATA_CONTRAT(p_alimTmp);
    END IF;
    IF p_majDataContratHisto=1 THEN
      -- 8) On met à jour les données CONTRAT_HISTO
      SECNAV_MAJ_DATA_CONTRAT_HISTO(p_alimTmp);
    END IF;
  ELSE
    -- On insère dans la table temporaire les NUMPAC/PACMAT/MATRIC des enregistrements à mettre à jour
    IF p_matric IS NULL THEN
      IF p_alimTmp=0 THEN
        INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT    ;
      ELSE
        INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT_TMP;
      END IF;
    ELSE
      IF p_alimTmp=0 THEN
        INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT     WHERE MATRIC=p_matric;
      ELSE
        INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT_TMP WHERE MATRIC=p_matric;
      END IF;
    END IF;
    IF SQL%ROWCOUNT>0 THEN
      SECNAV_MAJ_CURRENT_CONTRAT('DO_MAJ', p_majDataContrat, p_majDataContratHisto, p_alimTmp);
      -- DIT 47820 : SECUPACMAT_TMP_CONTRAT is a temporary table 
      -- Truncate table instead of deleting 
      EXECUTE_IMMEDIATE_STRING( 'TRUNCATE  TABLE SECUPACMAT_TMP_CONTRAT',0);
    END IF;
  END IF;
END SECNAV_MAJ_CURRENT_CONTRAT;
##
SECNAV_MAJ_CURRENT_PERSO
=SQL=
CREATE OR REPLACE PROCEDURE SECNAV_MAJ_CURRENT_PERSO(p_matric VARCHAR2, p_majDataPerso NUMBER, p_majDataPersoHisto NUMBER, p_alimTmp NUMBER) AS
  v_dateEff DATE;
BEGIN
  IF p_matric='DO_MAJ' THEN
    -- On se met à minuit
    v_dateEff := TO_DATE(TO_CHAR(SYSDATE,'yyyymmdd'),'yyyymmdd');

    -- On met à jour DATE_EFF_PERSO dans la table temporaire
    UPDATE SECUPACMAT_TMP_PERSO SET DATE_EFF_PERSO=(SELECT MAX(DATE_EFF) FROM DIC_ADM_PERSO_HISTO WHERE DIC_ADM_PERSO_HISTO.MATRIC=SECUPACMAT_TMP_PERSO.MATRIC AND v_dateEff BETWEEN DATE_EFF AND DATE_FIN);
    UPDATE SECUPACMAT_TMP_PERSO SET DATE_EFF_PERSO=(SELECT MIN(DATE_EFF) FROM DIC_ADM_PERSO_HISTO WHERE DIC_ADM_PERSO_HISTO.MATRIC=SECUPACMAT_TMP_PERSO.MATRIC AND DATE_EFF>v_dateEff) WHERE DATE_EFF_PERSO IS NULL;
    UPDATE SECUPACMAT_TMP_PERSO SET DATE_EFF_PERSO=(SELECT MAX(DATE_EFF) FROM DIC_ADM_PERSO_HISTO WHERE DIC_ADM_PERSO_HISTO.MATRIC=SECUPACMAT_TMP_PERSO.MATRIC AND DATE_EFF<v_dateEff) WHERE DATE_EFF_PERSO IS NULL;
    UPDATE SECUPACMAT_TMP_PERSO SET DATE_EFF_PERSO=(SELECT DSNAI FROM DIC_ADM_PERSO WHERE DIC_ADM_PERSO.MATRIC=SECUPACMAT_TMP_PERSO.MATRIC) WHERE DATE_EFF_PERSO IS NULL;

    -- On met à jour DATE_EFF_PERSO de SECUPACMAT (ou SECUPACMAT_TMP)
    IF p_alimTmp=0 THEN
      UPDATE SECUPACMAT     SET DATE_EFF_PERSO=(SELECT DATE_EFF_PERSO FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=SECUPACMAT    .MATRIC) WHERE EXISTS (SELECT * FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=SECUPACMAT    .MATRIC);
    ELSE
      UPDATE SECUPACMAT_TMP SET DATE_EFF_PERSO=(SELECT DATE_EFF_PERSO FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=SECUPACMAT_TMP.MATRIC) WHERE EXISTS (SELECT * FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=SECUPACMAT_TMP.MATRIC);
    END IF;

    -- On met à jour DATE_EFF_PERSO de DIC_ADM_PERSO
    UPDATE DIC_ADM_PERSO SET TYPE_WRITER='N', DATE_EFF_PERSO=(SELECT DATE_EFF_PERSO FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=DIC_ADM_PERSO.MATRIC) WHERE EXISTS (SELECT * FROM SECUPACMAT_TMP_PERSO WHERE SECUPACMAT_TMP_PERSO.MATRIC=DIC_ADM_PERSO.MATRIC);

    IF p_majDataPerso=1 THEN
      -- 3) On met à jour les données PERSO
      SECNAV_MAJ_DATA_PERSO(p_alimTmp);
    END IF;
    IF p_majDataPersoHisto=1 THEN
      -- 4) On met à jour les données PERSO_HISTO
      SECNAV_MAJ_DATA_PERSO_HISTO(p_alimTmp);
    END IF;
  ELSE
    -- On insère dans la table temporaire le MATRIC à mettre à jour
    IF p_matric IS NULL THEN
      IF p_alimTmp=0 THEN
        INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT    ;
      ELSE
        INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT_TMP;
      END IF;
    ELSE
      INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT p_matric FROM DUAL;
    END IF;
    IF SQL%ROWCOUNT>0 THEN
      SECNAV_MAJ_CURRENT_PERSO('DO_MAJ', p_majDataPerso, p_majDataPersoHisto, p_alimTmp);
      IF p_matric IS NULL THEN
        DELETE FROM SECUPACMAT_TMP_PERSO;
      ELSE
        DELETE FROM SECUPACMAT_TMP_PERSO WHERE MATRIC=p_matric;
      END IF;
    END IF;
  END IF;
END SECNAV_MAJ_CURRENT_PERSO;
##
SYS_DYNAMICSAMPLING_STATS
=SQL=
CREATE OR REPLACE PROCEDURE SYS_DYNAMICSAMPLING_STATS 
(
  P_TABLE IN VARCHAR2 
) AS 
BEGIN
  DBMS_STATS.UNLOCK_TABLE_STATS(ownname => sys_context('USERENV','SESSION_SCHEMA'),TABNAME=> P_TABLE);
  DBMS_STATS.DELETE_TABLE_STATS(ownname => sys_context('USERENV','SESSION_SCHEMA'),TABNAME=>P_TABLE);
  DBMS_STATS.LOCK_TABLE_STATS(ownname => sys_context('USERENV','SESSION_SCHEMA'),TABNAME=>P_TABLE);
  
END SYS_DYNAMICSAMPLING_STATS;
##
SYS_MIGR_SECU_STRUCT_HRO
=SQL=
CREATE OR REPLACE
PROCEDURE SYS_MIGR_SECU_STRUCT_HRO
AS
TYPE tcur
IS
  REF
  CURSOR;
    requete CLOB;
    c_secu_pop_hro tcur;
    secu_pop_login sys_usr_config.login%type;
    secu_pop_nomrequete requetesimple.nomrequete%type;
  BEGIN
    OPEN c_secu_pop_hro FOR SELECT suc.login, rs.nomrequete FROM sys_usr_config suc, requetesimple rs WHERE suc.req_liste_mat=rs.nomrequete AND upper(rs.requete) LIKE '%HRORG_SECU%' AND NOT EXISTS
    (SELECT * FROM sys_sec_usr_struct ssus WHERE ssus.login=suc.login
    ) order by suc.login;
  LOOP
    FETCH c_secu_pop_hro INTO secu_pop_login, secu_pop_nomrequete;
    EXIT
  WHEN c_secu_pop_hro%NOTFOUND;
    requete:='INSERT INTO REQUETESIMPLE SELECT '''||secu_pop_nomrequete||''', UTILISATEUR, ''SEC_LOC_STR'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, EST_VISIBLE FROM REQUETESIMPLE WHERE NOMREQUETE='''||secu_pop_nomrequete||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC'' AND NOT EXISTS (SELECT * FROM REQUETESIMPLE WHERE NOMREQUETE='''||secu_pop_nomrequete||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR'')';
    EXECUTE_IMMEDIATE_STRING( requete,0);
    requete:='INSERT INTO SYS_SEC_USR_STRUCT VALUES ('''||secu_pop_login||''', '''||secu_pop_nomrequete||''')';
    EXECUTE_IMMEDIATE_STRING(requete,0);
  END LOOP;
  CLOSE c_secu_pop_hro;
  COMMIT;
END SYS_MIGR_SECU_STRUCT_HRO; 
##
SYS_MIGR_SECU_STRUCT_NIVSECU
=SQL=
CREATE OR REPLACE
PROCEDURE SYS_MIGR_SECU_STRUCT_NIVSECU
AS
TYPE tcur
IS
  REF
  CURSOR;
    requete CLOB;
    c_ tcur;
    c_secu_struct tcur;
    secu_struct_login std_nivsecu.login%type;
    secu_struct_codts std_nivsecu.codts%type;
    secu_struct_code_entite std_nivsecu.codniv1%type;
    secu_struct_type_entite VARCHAR2(15);
    secu_struct_libelle_structure std_struc_type.libelle%type;
    secu_struct_lib_type_entite std_struc_entite_type.libelle%type;
    req_liste_mat sys_usr_config.req_liste_mat%type;
    requete_complexe CLOB;
    requeteecr_gsi_complexe CLOB;
    requetesql_gsi_complexe CLOB;
    requete_simple CLOB;
    requeteecr_gsi_simple CLOB;
    requetesql_gsi_simple CLOB;
    clause_hrorg_secu_tmp VARCHAR2(300);
    secu_struct_nomcol_secumat std_struc_type.nomcol_secumatric%type;
    origine_affect VARCHAR2(200);
    cptcodts       NUMBER;
    cur_login std_nivsecu.login%type;
    cur_codts std_nivsecu.codts%type;
    cur_req_liste_mat sys_usr_config.req_liste_mat%type;
    cod_struc_non_def NUMBER;
    cod_struc_err_niv NUMBER;
  BEGIN
    SELECT MIN(CODTS)
    INTO cod_struc_non_def
    FROM STD_NIVSECU
    WHERE CODTS NOT IN
      (SELECT CODTS FROM STD_STRUC_TYPE
      );
  SELECT MIN(CODTS)
  INTO cod_struc_err_niv
  FROM
    (SELECT CODTS,
      MAX(NIV_MAX) AS NIV_MAX_NIVSECU,
      (SELECT MAX(NIVEAU)
      FROM STD_STRUC_NIV
      WHERE STD_STRUC_NIV.CODTS=Z.CODTS
      AND TO_CHAR(SYSDATE,'yyyymmdd') BETWEEN DATE_EFF AND DATE_FIN
      ) AS NIX_MAX_HRO
    FROM
      (SELECT CODTS,
        CASE
          WHEN CODNIV2 IS NULL
          THEN 1
          WHEN CODNIV3 IS NULL
          THEN 2
          WHEN CODNIV4 IS NULL
          THEN 3
          WHEN CODNIV5 IS NULL
          THEN 4
          WHEN CODNIV6 IS NULL
          THEN 5
          ELSE 6
        END AS NIV_MAX
      FROM STD_NIVSECU
      ) Z
    GROUP BY CODTS
    ) Y
  WHERE NIX_MAX_HRO IS NULL
  OR NIV_MAX_NIVSECU >NIX_MAX_HRO
  OR (SELECT COUNT(*)
    FROM STD_STRUC_ENTITE_TYPE
    WHERE STD_STRUC_ENTITE_TYPE.TYPE_ENTITE IN
      (SELECT TYPE_ENTITE
      FROM STD_STRUC_NIV
      WHERE STD_STRUC_NIV.CODTS=Y.CODTS
      AND TO_CHAR(SYSDATE,'yyyymmdd') BETWEEN DATE_EFF AND DATE_FIN
      AND NIVEAU       <=NIV_MAX_NIVSECU
      ))                <NIV_MAX_NIVSECU;
  IF cod_struc_non_def IS NOT NULL THEN
    RAISE_APPLICATION_ERROR(-20000,'Veuillez d''abord renseigner le référentiel HRO (définition des structures) pour les codes TS présents dans STD_NIVSECU (exemple : code TS '||cod_struc_non_def||')');
  END IF;
  IF cod_struc_err_niv IS NOT NULL THEN
    RAISE_APPLICATION_ERROR(-20001,'Veuillez d''abord renseigner correctement le référentiel HRO (types d''entité et organisation des niveaux) pour les codes TS présents dans STD_NIVSECU (exemple : code TS '||cod_struc_err_niv||')');
  END IF;
  cur_login        :=NULL;
  cur_codts        :=NULL;
  cur_req_liste_mat:=NULL;
  cptcodts         :=0;
  OPEN c_secu_struct FOR SELECT z.*,
  (SELECT req_liste_mat FROM sys_usr_config suc WHERE suc.login=z.login
  )
AS
  req_pop FROM
  (SELECT sns.login,
    sns.codts,
    sns.codniv1 AS code_entite,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =1
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1 IS NOT NULL
  AND sns.codniv2 IS NULL
  AND sns.codniv3 IS NULL
  AND sns.codniv4 IS NULL
  AND sns.codniv5 IS NULL
  AND sns.codniv6 IS NULL
  UNION ALL
  SELECT sns.login,
    sns.codts,
    sns.codniv2,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =2
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1 IS NOT NULL
  AND sns.codniv2 IS NOT NULL
  AND sns.codniv3 IS NULL
  AND sns.codniv4 IS NULL
  AND sns.codniv5 IS NULL
  AND sns.codniv6 IS NULL
  UNION ALL
  SELECT sns.login,
    sns.codts,
    sns.codniv3,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =3
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1 IS NOT NULL
  AND sns.codniv2 IS NOT NULL
  AND sns.codniv3 IS NOT NULL
  AND sns.codniv4 IS NULL
  AND sns.codniv5 IS NULL
  AND sns.codniv6 IS NULL
  UNION ALL
  SELECT sns.login,
    sns.codts,
    sns.codniv4,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =4
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1 IS NOT NULL
  AND sns.codniv2 IS NOT NULL
  AND sns.codniv3 IS NOT NULL
  AND sns.codniv4 IS NOT NULL
  AND sns.codniv5 IS NULL
  AND sns.codniv6 IS NULL
  UNION ALL
  SELECT sns.login,
    sns.codts,
    sns.codniv5,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =5
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1 IS NOT NULL
  AND sns.codniv2 IS NOT NULL
  AND sns.codniv3 IS NOT NULL
  AND sns.codniv4 IS NOT NULL
  AND sns.codniv5 IS NOT NULL
  AND sns.codniv6 IS NULL
  UNION ALL
  SELECT sns.login,
    sns.codts,
    sns.codniv6,
    ssn.type_entite,
    sst.libelle  AS libelle_structure,
    sset.libelle AS libelle_type_entite,
    sst.nomcol_secumatric
  FROM std_nivsecu sns,
    std_struc_type sst,
    std_struc_niv ssn,
    std_struc_entite_type sset
  WHERE sns.codts    =sst.codts
  AND sst.codts      =ssn.codts
  AND ssn.type_entite=sset.type_entite
  AND ssn.niveau     =6
  AND TO_CHAR(sysdate,'yyyymmdd') BETWEEN date_eff AND date_fin
  AND sns.codniv1     IS NOT NULL
  AND sns.codniv2     IS NOT NULL
  AND sns.codniv3     IS NOT NULL
  AND sns.codniv4     IS NOT NULL
  AND sns.codniv5     IS NOT NULL
  AND sns.codniv6     IS NOT NULL
  ) z WHERE login NOT IN
  (SELECT login FROM sys_sec_usr_struct
  ) order by login,
  codts,
  code_entite;
  LOOP
    FETCH c_secu_struct
    INTO secu_struct_login,
      secu_struct_codts,
      secu_struct_code_entite,
      secu_struct_type_entite,
      secu_struct_libelle_structure,
      secu_struct_lib_type_entite,
      secu_struct_nomcol_secumat,
      req_liste_mat;
    EXIT
  WHEN c_secu_struct%NOTFOUND;
    IF cur_login   IS NULL OR NOT cur_login=secu_struct_login THEN
      IF cur_login IS NOT NULL THEN
        requete    :='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||''', ''DBA'', ''SEC_LOC_STR'', ''( '||REPLACE(requete_complexe,'''','''''')||' )'', '''||REPLACE(requeteecr_gsi_complexe,'''','''''')||''', '''||REPLACE(requetesql_gsi_complexe,'''','''''')||''', 1, ''0'',''0'')';
        EXECUTE IMMEDIATE requete;
        IF requete_simple        IS NOT NULL THEN
          IF cptcodts             =0 THEN
            requeteecr_gsi_simple:=requeteecr_gsi_simple||'##';
            requetesql_gsi_simple:=requetesql_gsi_simple||'##';
            requete_simple       :=requete_simple||' AND ';
          ELSE
            requeteecr_gsi_simple:=requeteecr_gsi_simple||'@@';
            requetesql_gsi_simple:=requetesql_gsi_simple||'@@';
            requete_simple       :=requete_simple||' OR ';
          END IF;
        END IF;
        requeteecr_gsi_simple  :=requeteecr_gsi_simple||'  SOUS__REQUETE {{EQUAL{{ '||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||' ';
        requetesql_gsi_simple  :=requetesql_gsi_simple||'SOUS__REQUETE{{={{~~~'||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
        requete_simple         :=requete_simple||'SOUS__REQUETE=~~~'||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
        IF cptcodts             >0 THEN
          requeteecr_gsi_simple:=requeteecr_gsi_simple||')';
          requetesql_gsi_simple:=requetesql_gsi_simple||')';
          requete_simple       :=requete_simple||')';
        END IF;
        requeteecr_gsi_simple:=requeteecr_gsi_simple||' ';
        requete              :='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||''', ''DBA'', ''SEC_LOC_STR'', ''( '||REPLACE(requete_simple,'''','''''')||' )'', '''||REPLACE(requeteecr_gsi_simple,'''','''''')||''', '''||REPLACE(requetesql_gsi_simple,'''','''''')||''', 0, ''1'',''0'')';
        EXECUTE IMMEDIATE requete;
        requete:='INSERT INTO SYS_SEC_USR_STRUCT VALUES ('''||cur_login||''', ''SEC_'||cur_login||''')';
        EXECUTE IMMEDIATE requete;
        IF cur_req_liste_mat IS NULL THEN
          requete            :='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE, UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, EST_VISIBLE,''0'' FROM REQUETESIMPLE WHERE (NOMREQUETE=''SEC_'||cur_login||''' OR NOMREQUETE LIKE ''SEC_'||cur_login||'_CODTS_%'') AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
          EXECUTE IMMEDIATE requete;
        ELSE
          requete:='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE, UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, EST_VISIBLE,''0'' FROM REQUETESIMPLE WHERE NOMREQUETE LIKE ''SEC_'||cur_login||'_CODTS_%'' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
          EXECUTE IMMEDIATE requete;
          requete:='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE||''_STR'', UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, 1, ''0'',''0'' FROM REQUETESIMPLE WHERE NOMREQUETE=''SEC_'||cur_login||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
          EXECUTE IMMEDIATE requete;
          requete:='INSERT INTO REQUETESIMPLE SELECT ''SEC_'||cur_login||'_POP'', UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, 1, ''0'',''0'' FROM REQUETESIMPLE WHERE NOMREQUETE='''||cur_req_liste_mat||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC''';
          EXECUTE IMMEDIATE requete;
          requete:='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||''', ''DBA'', ''SEC_LOC'', ''( '||'SOUS__REQUETE=~~~SEC_'||cur_login||'_POP~~~ AND SOUS__REQUETE=~~~SEC_'||cur_login||'_STR~~~'||' )'', '''||'##  SOUS__REQUETE {{EQUAL{{ SEC_'||cur_login||'_POP  ##  SOUS__REQUETE {{EQUAL{{ SEC_'||cur_login||'_STR  '||''', '''||'##SOUS__REQUETE{{={{~~~SEC_'||cur_login||'_POP~~~##SOUS__REQUETE{{={{~~~SEC_'||cur_login||'_STR~~~'||''', 0, ''1'', ''0'')';
          EXECUTE IMMEDIATE requete;
        END IF;
        requete:='UPDATE SYS_USR_CONFIG SET REQ_LISTE_MAT=''SEC_'||cur_login||''' WHERE LOGIN='''||cur_login||'''';
        EXECUTE IMMEDIATE requete;
      END IF;
      requeteecr_gsi_simple  :='##';
      requetesql_gsi_simple  :='##';
      requete_simple         :=NULL;
      requeteecr_gsi_complexe:='##';
      requetesql_gsi_complexe:='##';
      requete_complexe       :=NULL;
      cptcodts               :=0;
    END IF;
    IF cur_login IS NOT NULL AND cur_login=secu_struct_login AND (NOT cur_codts=secu_struct_codts OR LENGTH(requete_complexe)>=3700 OR LENGTH(requeteecr_gsi_complexe)>=3700 OR LENGTH(requetesql_gsi_complexe)>=3700) THEN
      requete    :='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||secu_struct_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||''', ''DBA'', ''SEC_LOC_STR'', ''( '||REPLACE(requete_complexe,'''','''''')||' )'', '''||REPLACE(requeteecr_gsi_complexe,'''','''''')||''', '''||REPLACE(requetesql_gsi_complexe,'''','''''')||''', 1, ''0'', ''0'')';
      EXECUTE IMMEDIATE requete;
      IF requete_simple        IS NOT NULL THEN
        IF cptcodts             =0 THEN
          requeteecr_gsi_simple:=requeteecr_gsi_simple||'##';
          requetesql_gsi_simple:=requetesql_gsi_simple||'##';
          requete_simple       :=requete_simple||' AND ';
        ELSE
          requeteecr_gsi_simple:=requeteecr_gsi_simple||'@@';
          requetesql_gsi_simple:=requetesql_gsi_simple||'@@';
          requete_simple       :=requete_simple||' OR ';
        END IF;
      END IF;
      requeteecr_gsi_simple  :=requeteecr_gsi_simple||' ';
      IF cur_codts            =secu_struct_codts AND cptcodts=0 THEN
        requeteecr_gsi_simple:=requeteecr_gsi_simple||'(';
        requetesql_gsi_simple:=requetesql_gsi_simple||'(';
        requete_simple       :=requete_simple||'(';
      END IF;
      requeteecr_gsi_simple  :=requeteecr_gsi_simple||' SOUS__REQUETE {{EQUAL{{ '||'SEC_'||secu_struct_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||' ';
      requetesql_gsi_simple  :=requetesql_gsi_simple||'SOUS__REQUETE{{={{~~~'||'SEC_'||secu_struct_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
      requete_simple         :=requete_simple||'SOUS__REQUETE=~~~'||'SEC_'||secu_struct_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
      IF NOT cur_codts        =secu_struct_codts AND cptcodts>0 THEN
        requeteecr_gsi_simple:=requeteecr_gsi_simple||')';
        requetesql_gsi_simple:=requetesql_gsi_simple||')';
        requete_simple       :=requete_simple||')';
      END IF;
      requeteecr_gsi_simple  :=requeteecr_gsi_simple||' ';
      requeteecr_gsi_complexe:='##';
      requetesql_gsi_complexe:='##';
      requete_complexe       :=NULL;
      IF NOT cur_codts        =secu_struct_codts THEN
        cptcodts             :=0;
      ELSE
        cptcodts:=cptcodts+1;
      END IF;
    END IF;
    origine_affect    :=secu_struct_nomcol_secumat;
    IF origine_affect IS NULL THEN
      origine_affect  :='(SELECT CODE_ENTITE FROM STD_STRUC_AFFECTATION WHERE STD_STRUC_AFFECTATION.MATRIC=SECUMATRIC.MATRIC AND CODTS='||secu_struct_codts||' AND ''@DATE_DU_JOUR'' BETWEEN DATE_EFF AND DATE_FIN)';
    END IF;
    clause_hrorg_secu_tmp    :='HRORG_SECU('||secu_struct_codts||','''||secu_struct_type_entite||''' ,@POP_'||origine_affect||',@STRUCT_CODE_ENTITE, ''@DATE_DU_JOUR'' )§CODTS'||secu_struct_codts||'§';
    IF requete_complexe      IS NOT NULL THEN
      requeteecr_gsi_complexe:=requeteecr_gsi_complexe||'@@';
      requetesql_gsi_complexe:=requetesql_gsi_complexe||'@@';
      requete_complexe       :=requete_complexe||' OR ';
    END IF;
    requeteecr_gsi_complexe:=requeteecr_gsi_complexe||'  '||secu_struct_libelle_structure||' '||secu_struct_lib_type_entite||' {{EQUAL{{ '||secu_struct_code_entite||'  ';
    requetesql_gsi_complexe:=requetesql_gsi_complexe||clause_hrorg_secu_tmp||'{{={{'''||secu_struct_code_entite||'''';
    requete_complexe       :=requete_complexe||clause_hrorg_secu_tmp||'='''||secu_struct_code_entite||'''';
    cur_login              :=secu_struct_login;
    cur_codts              :=secu_struct_codts;
    cur_req_liste_mat      :=req_liste_mat;
  END LOOP;
  CLOSE c_secu_struct;
  IF cur_login IS NOT NULL THEN
    requete    :='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||''', ''DBA'', ''SEC_LOC_STR'', ''( '||REPLACE(requete_complexe,'''','''''')||' )'', '''||REPLACE(requeteecr_gsi_complexe,'''','''''')||''', '''||REPLACE(requetesql_gsi_complexe,'''','''''')||''', 1, ''0'', ''0'')';
    EXECUTE IMMEDIATE requete;
    IF requete_simple        IS NOT NULL THEN
      IF cptcodts             =0 THEN
        requeteecr_gsi_simple:=requeteecr_gsi_simple||'##';
        requetesql_gsi_simple:=requetesql_gsi_simple||'##';
        requete_simple       :=requete_simple||' AND ';
      ELSE
        requeteecr_gsi_simple:=requeteecr_gsi_simple||'@@';
        requetesql_gsi_simple:=requetesql_gsi_simple||'@@';
        requete_simple       :=requete_simple||' OR ';
      END IF;
    END IF;
    requeteecr_gsi_simple  :=requeteecr_gsi_simple||'  SOUS__REQUETE {{EQUAL{{ '||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||' ';
    requetesql_gsi_simple  :=requetesql_gsi_simple||'SOUS__REQUETE{{={{~~~'||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
    requete_simple         :=requete_simple||'SOUS__REQUETE=~~~'||'SEC_'||cur_login||'_CODTS_'||cur_codts||'_'||TO_CHAR(cptcodts)||'~~~';
    IF cptcodts             >0 THEN
      requeteecr_gsi_simple:=requeteecr_gsi_simple||')';
      requetesql_gsi_simple:=requetesql_gsi_simple||')';
      requete_simple       :=requete_simple||')';
    END IF;
    requeteecr_gsi_simple:=requeteecr_gsi_simple||' ';
    requete              :='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||''', ''DBA'', ''SEC_LOC_STR'', ''( '||REPLACE(requete_simple,'''','''''')||' )'', '''||REPLACE(requeteecr_gsi_simple,'''','''''')||''', '''||REPLACE(requetesql_gsi_simple,'''','''''')||''', 0, ''1'', ''0'')';
    EXECUTE IMMEDIATE requete;
    requete:='INSERT INTO SYS_SEC_USR_STRUCT VALUES ('''||cur_login||''', ''SEC_'||cur_login||''')';
    EXECUTE IMMEDIATE requete;
    IF cur_req_liste_mat IS NULL THEN
      requete            :='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE, UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, EST_VISIBLE,''0'' FROM REQUETESIMPLE WHERE (NOMREQUETE=''SEC_'||cur_login||''' OR NOMREQUETE LIKE ''SEC_'||cur_login||'_CODTS_%'') AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
      EXECUTE IMMEDIATE requete;
    ELSE
      requete:='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE, UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, EST_VISIBLE ,''0'' FROM REQUETESIMPLE WHERE NOMREQUETE LIKE ''SEC_'||cur_login||'_CODTS_%'' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
      EXECUTE IMMEDIATE requete;
      requete:='INSERT INTO REQUETESIMPLE SELECT NOMREQUETE||''_STR'', UTILISATEUR, ''SEC_LOC'', REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, 1, ''0'',''0'' FROM REQUETESIMPLE WHERE NOMREQUETE=''SEC_'||cur_login||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC_STR''';
      EXECUTE IMMEDIATE requete;
      requete:='INSERT INTO REQUETESIMPLE SELECT ''SEC_'||cur_login||'_POP'', UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, 1, ''0'',''0'' FROM REQUETESIMPLE WHERE NOMREQUETE='''||cur_req_liste_mat||''' AND UTILISATEUR=''DBA'' AND APPLICATION=''SEC_LOC''';
      EXECUTE IMMEDIATE requete;
      requete:='INSERT INTO REQUETESIMPLE VALUES (''SEC_'||cur_login||''', ''DBA'', ''SEC_LOC'', ''( '||'SOUS__REQUETE=~~~SEC_'||cur_login||'_POP~~~ AND SOUS__REQUETE=~~~SEC_'||cur_login||'_STR~~~'||' )'', '''||'##  SOUS__REQUETE {{EQUAL{{ SEC_'||cur_login||'_POP  ##  SOUS__REQUETE {{EQUAL{{ SEC_'||cur_login||'_STR  '||''', '''||'##SOUS__REQUETE{{={{~~~SEC_'||cur_login||'_POP~~~##SOUS__REQUETE{{={{~~~SEC_'||cur_login||'_STR~~~'||''', 0, ''1'',''0'')';
      EXECUTE IMMEDIATE requete;
    END IF;
    requete:='UPDATE SYS_USR_CONFIG SET REQ_LISTE_MAT=''SEC_'||cur_login||''' WHERE LOGIN='''||cur_login||'''';
    EXECUTE IMMEDIATE requete;
  END IF;
  COMMIT;
END SYS_MIGR_SECU_STRUCT_NIVSECU; 
##
SYS_RECALCUL_STATS
=SQL=
create or replace PROCEDURE SYS_RECALCUL_STATS(p_table in varchar2) AS 
 err_msg  VARCHAR(1000);
 err_code VARCHAR(200);
BEGIN
  if p_table is null then
 DBMS_STATS.gather_schema_stats( ownname => sys_context('USERENV','SESSION_SCHEMA') , cascade => true);
 else
 DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>p_table, cascade => true);
 end if;
 EXCEPTION
WHEN OTHERS THEN
 ERR_CODE := SQLCODE;
 ERR_MSG  := SQLERRM;
 INSERT INTO SYS_TRC_ERR VALUES (CURRENT_TIMESTAMP,ERR_CODE||'  MESSAGE='||ERR_MSG,'SYS_RECALCUL_STATS P_TABLE='||P_TABLE,'PL_SQL');
END SYS_RECALCUL_STATS;
##
SYS_TRACE_MODIF
=SQL=
CREATE OR REPLACE PROCEDURE SYS_TRACE_MODIF(
    P_LOGIN                     VARCHAR2,
    P_DATEMAJ                   SYS_TRC_MODIF.DATEMAJ%type,
    P_ROLE                      VARCHAR2,
    P_FUNCTIONNALITY            VARCHAR2,
    P_KEYS_VALUES               VARCHAR2,
    P_SHORT_NAME                VARCHAR2,
    P_ACTION                    VARCHAR2,
    P_NAMES_VALUES_HAVE_CHANGED VARCHAR2,
    P_BEFORE_CHANGE             VARCHAR2,
    P_AFTER_CHANGE              VARCHAR2,
    P_FILTRE                    VARCHAR2)
AS
BEGIN
  INSERT
  INTO SYS_TRC_MODIF
    (
      LOGIN ,
      DATEMAJ ,
      ROLE ,
      FUNCTIONNALITY,
      KEYS_VALUES ,
      SHORT_NAME ,
      ACTION ,
      NAMES_VALUES_HAVE_CHANGED ,
      BEFORE_CHANGE ,
      AFTER_CHANGE ,
      FILTRE
    )
    VALUES
    (
      P_LOGIN ,
      P_DATEMAJ ,
      P_ROLE ,
      P_FUNCTIONNALITY,
      P_KEYS_VALUES ,
      P_SHORT_NAME ,
      P_ACTION ,
      P_NAMES_VALUES_HAVE_CHANGED ,
      P_BEFORE_CHANGE ,
      P_AFTER_CHANGE ,
      P_FILTRE
    );
END SYS_TRACE_MODIF;
##
SYS_UNLOCK_STATS
=SQL=
CREATE OR REPLACE PROCEDURE SYS_UNLOCK_STATS 
(
  P_TABLE IN VARCHAR2 
) AS 
BEGIN
  DBMS_STATS.UNLOCK_TABLE_STATS(ownname => sys_context('USERENV','SESSION_SCHEMA'),TABNAME=> P_TABLE);
  
END SYS_UNLOCK_STATS;
##
TAG_CHARSET=@€éèç
##
TGE_ALIM_PERIODE_INDIV
=SQL=
CREATE OR REPLACE PROCEDURE TGE_ALIM_PERIODE_INDIV(
    p_id            IN NUMBER,
    p_numpac        IN VARCHAR2,
    p_periode_paie  IN VARCHAR2,
    p_paiezad       IN VARCHAR2,
    p_dosNumForSimu IN NUMBER DEFAULT NULL,
 	p_recueil_photo IN VARCHAR2 DEFAULT 'N'  )
IS
  id_trt                NUMBER;
  periode_deb_retro     VARCHAR2(6);
  periode_deb_histo_retro     VARCHAR2(6);
  periode_recalcul      VARCHAR2(6);
  periode_paie_en_cours VARCHAR2(6);
  periode_recalcul_deb  VARCHAR2(6);
  nb_mois_retro         NUMBER(2);
  recueil_photo         BOOLEAN;
  w_pacmat 				VARCHAR2(20);
  v_jobIdx 			   NUMBER;
  V_PERIODE_EN_COURS	   VARCHAR(6);
  V_DEB_RETRO           VARCHAR(6);
  req                   CLOB;
  
  --SELECT les changement pour la rétro
  type PERIODE IS RECORD
  ( 
  NUMPAC DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE,
  PACMAT DIC_ADM_CONTRAT_SITU.PACMAT%TYPE,
  PERIODE TGE_PERIODE_RECUEIL_PAIEZAD.MOIS_PAIE%TYPE,
  CODE_CHRONO DIC_ADM_CONTRAT_SITU.CODE_CHRONO%TYPE,
  PAIEZAD DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE);
  type PERIODE_TAB IS TABLE OF PERIODE INDEX BY BINARY_INTEGER;
  tab_retro PERIODE_TAB;
  type PERIODE2 IS RECORD
 (
  NUMPAC DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE,
  PACMAT DIC_ADM_CONTRAT_SITU.PACMAT%TYPE,
  PERIODE TGE_PERIODE_RECUEIL_PAIEZAD.MOIS_PAIE%TYPE,
  CODE_CHRONO DIC_ADM_CONTRAT_SITU.CODE_CHRONO%TYPE,
  PAIEZAD DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE,
  NUMCNT DIC_ADM_CONTRAT_SITU.NUMCNT%TYPE,
  DATE_SORTIE_SIT_BO DIC_ADM_CONTRAT_HISTO.DATE_SORTIE_SIT_BO%TYPE,
  DATE_EFF VARCHAR2(10) );
 type PERIODE_TAB2 IS TABLE OF PERIODE2 INDEX BY BINARY_INTEGER;
 tab_retro2 PERIODE_TAB2;
BEGIN
  TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV début (' || p_numpac || ',' || p_periode_paie || ',' || p_paiezad || ',' || p_recueil_photo || ')');
  --Alimentation id procédure
  IF p_id   = 0 OR p_id IS NULL THEN
    id_trt := IMP_TRT_SEQ_ID.nextval;
  ELSE
    id_trt := p_id;
  END IF;
  --Alimentation recueil_photo
  IF p_recueil_photo = 'O' THEN
    recueil_photo:=TRUE;
  ELSE
    recueil_photo:=FALSE;
  END IF;
  --Alimentation des informations sur le pac
  SELECT DEB_RETRO,
  	DEB_HISTO_RETRO,
    NB_MOIS_RETRO,
    PERIODEENCOURS
  INTO periode_deb_retro,
    periode_deb_histo_retro,
    nb_mois_retro,
    periode_paie_en_cours
  FROM TGE_REF_PAC
  WHERE NUMPAC = p_numpac;
  --Alimentation de la période de début de calcul
  -- Pour les simulations de départ, on autorise le calcul des périodes de recueil pour un mois dans le futur
  IF( p_periode_paie     <= periode_paie_en_cours OR p_dosNumForSimu IS NOT NULL) THEN
    IF p_dosNumForSimu IS NOT NULL THEN
      periode_recalcul   := p_periode_paie;
    ELSIF periode_deb_retro IS NOT NULL AND periode_deb_retro <= periode_paie_en_cours THEN
      periode_recalcul   := GREATEST(p_periode_paie, TO_CHAR(ADD_MONTHS(TO_DATE(periode_paie_en_cours, 'YYYYMM'), -nb_mois_retro), 'YYYYMM'));
      IF periode_recalcul < periode_deb_histo_retro THEN
        periode_recalcul := periode_deb_histo_retro;
      END IF;
      TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV calcul des périodes de recueil du ' || periode_recalcul || ' au ' || periode_paie_en_cours);
    ELSE
      periode_recalcul   := periode_paie_en_cours;
    END IF;
    periode_recalcul_deb := periode_recalcul;
       --Récupération du pacmat
	 IF p_paiezad IS NOT NULL THEN
		 BEGIN
			 SELECT PACMAT
			 INTO w_pacmat
			 FROM DIC_ADM_CONTRAT_SITU
			 WHERE NUMPAC = p_numpac
			 AND PAIEZAD  = p_paiezad
			 AND rownum   =1;
		 EXCEPTION
			 WHEN NO_DATA_FOUND THEN
				 req := 'DELETE FROM ';
				 IF p_dosNumForSimu IS NOT NULL THEN
					 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
					 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
				 ELSE
				 	req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
				 END IF;
				 req := req||' WHERE NUMPAC = '''||p_numpac||'''';
				 req := req||' AND MOIS_PAIE >= '''||periode_recalcul_deb||'''';
				 req := req||' AND PAIEZAD = '''||p_paiezad||'''';
				 IF p_dosNumForSimu IS NOT NULL THEN
				 	req := req||' AND DOS_NUM = '||p_dosNumForSimu;
				 END IF;
				 EXECUTE_IMMEDIATE_STRING (req,0);
				 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs dans DIC_ADM_CONTRAT_SITU AUCUN PACMAT trouvé pour le PAIEZAD = ''' || p_paiezad || '''');
			 raise;
		 END;
	 END IF;
    --Sauvegarde des période de recueil dans TGE_PERIODE_RECUEIL_PAIEZAD_R
	IF p_dosNumForSimu IS NULL THEN
		EXECUTE_IMMEDIATE_STRING  ('DELETE TGE_PERIODE_RECUEIL_PAIEZAD_R WHERE ID_TRT = ''' || id_trt || ''' OR ID_TRT + 1000 < ''' || id_trt || ''' ',0);
		req         := 'INSERT  INTO TGE_PERIODE_RECUEIL_PAIEZAD_R ';
		req         := req||'SELECT  '''||id_trt||'''  ,TGE_PERIODE_RECUEIL_PAIEZAD.* FROM TGE_PERIODE_RECUEIL_PAIEZAD ';
		req         := req||' WHERE NUMPAC = '''||p_numpac||'''';
		req         := req||' AND MOIS_PAIE >= '''||periode_recalcul||'''';
		IF w_pacmat IS NOT NULL THEN
		 	req       := req||' AND PACMAT = '''||w_pacmat||'''';
		END IF;
		EXECUTE_IMMEDIATE_STRING ( req,0);
	END IF;
    LOOP
      TGE_ALIM_PERIODE_INDIV_MAIN(id_trt, p_numpac, periode_recalcul, w_pacmat, p_dosNumForSimu, recueil_photo);
      --On passe au mois suivant
      periode_recalcul := TO_CHAR(ADD_MONTHS(TO_DATE(periode_recalcul, 'YYYYMM'), 1), 'YYYYMM');
      EXIT
    WHEN periode_deb_retro IS NULL OR periode_deb_retro > periode_paie_en_cours OR periode_recalcul > periode_paie_en_cours;
    END LOOP;
    --Mise à jour des incidents qui on changé période de paie plus inscription en rétro
	IF p_dosNumForSimu IS NULL THEN
	 	 -- Initialisations des variables pour tester la rétroactivité depuis la table TGE_REF_PAC. 
		 SELECT 
			 PERIODEENCOURS,
			 DEB_RETRO
		 INTO
			 V_PERIODE_EN_COURS,
			 V_DEB_RETRO
		 FROM TGE_REF_PAC
		 WHERE NUMPAC = p_numpac; 
	 	 -- Le recalcul de la période n'est fait que si le pac est rétro et que la rétro a démarré 
		 IF V_DEB_RETRO IS NOT NULL AND V_DEB_RETRO <= V_PERIODE_EN_COURS THEN
		 -- CALL TGE_RETRO_INSCRIPT_WITH_CHECK
		 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV -> Début CALL TGE_RETRO_INSCRIPT_WITH_CHECK');
		 
			req              := 'select S.NUMPAC, S.PACMAT, NVL(R.MOIS_PAIE, P.MOIS_PAIE) AS PERIODE, S.CODE_CHRONO, S.PAIEZAD from TGE_PERIODE_RECUEIL_PAIEZAD_R R  ';
			req              := req||'FULL JOIN TGE_PERIODE_RECUEIL_PAIEZAD P  ';
			req              := req||'ON R.NUMPAC = P.NUMPAC ';
			req              := req||'AND R.MOIS_PAIE = P.MOIS_PAIE ';
			req              := req||'AND R.PAIEZAD = P.PAIEZAD ';
			req              := req||'AND R.PACMAT = P.PACMAT ';
			req              := req||'INNER JOIN dic_adm_contrat_SITU S ';
			req              := req||'ON S.NUMPAC = NVL(R.NUMPAC, P.NUMPAC) ';
			req              := req||'AND S.PAIEZAD = NVL(R.PAIEZAD, P.PAIEZAD) ';
			req              := req||'WHERE  ';
			req              := req||'NVL(R.MOIS_PAIE, P.MOIS_PAIE) >= ''' || periode_recalcul_deb || ''' ';
 			req              := req||'AND NVL(R.NUMPAC, P.NUMPAC) = ''' || p_numpac || ''' ';
 		IF w_pacmat IS NOT NULL THEN
 			req              := req||'AND NVL(R.PACMAT, P.PACMAT) = '''||w_pacmat||'''';
 		END IF;
			req              := req||'AND (P.MOIS_PAIE IS NULL  ';
			req              := req||'OR R.MOIS_PAIE IS NULL ';
			req              := req||'OR P.DEBUT_PERIODE_RECUEIL != R.DEBUT_PERIODE_RECUEIL ';
			req              := req||'OR P.FIN_PERIODE_RECUEIL != R.FIN_PERIODE_RECUEIL) ';
			
			EXECUTE IMMEDIATE req BULK COLLECT INTO tab_retro;
			IF tab_retro.exists(1) THEN
			  FOR i IN tab_retro.first..tab_retro.last
			  LOOP
			  	BEGIN
			    	TGE_RETRO_INSCRIPT_WITH_CHECK(tab_retro(i).NUMPAC, tab_retro(i).PACMAT, tab_retro(i).PERIODE,  tab_retro(i).CODE_CHRONO,  tab_retro(i).PAIEZAD, 'TGE_PERIODE_RECUEIL_PAIEZAD');
			    EXCEPTION
			    WHEN OTHERS THEN
 					TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV KO : TGE_RETRO_INSCRIPT_WITH_CHECK('''||tab_retro(i).NUMPAC||''', '''||tab_retro(i).PACMAT||''', '''||tab_retro(i).PERIODE||''',  '''||tab_retro(i).CODE_CHRONO||''',  '''||tab_retro(i).PAIEZAD||''', ''TGE_PERIODE_RECUEIL_PAIEZAD'') '||SQLCODE||' '||SQLERRM);
			    END;
			  END LOOP;
			END IF;
			
		-- Le calcul des périodes de recueil doit lancer le calcul des HP, CALC_HP.principal, lorsqu'une modification est détectée sur la date de début ou de fin de génération HP. 
         TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV -> Début CALL CALC_HP.principal');
         req              := 'WITH TPRP2  AS ( select NVL(R.MOIS_PAIE, P.MOIS_PAIE) AS MOIS_PAIE , NVL(R.NUMPAC, P.NUMPAC) AS NUMPAC ,NVL(R.PACMAT, P.PACMAT) AS PACMAT,NVL(R.PAIEZAD, P.PAIEZAD) AS PAIEZAD ';
         req              := req||'from TGE_PERIODE_RECUEIL_PAIEZAD_R R  ';
         req              := req||'FULL JOIN TGE_PERIODE_RECUEIL_PAIEZAD P '; 
         req              := req||'ON R.NUMPAC = P.NUMPAC '; 
         req              := req||'AND R.MOIS_PAIE = P.MOIS_PAIE ';
         req              := req||'AND R.PAIEZAD = P.PAIEZAD '; 
         req              := req||'AND R.PACMAT = P.PACMAT ';
         req              := req||'WHERE (P.MOIS_PAIE IS NULL ';
         req              := req||'OR R.MOIS_PAIE IS NULL ';
         req              := req||'OR P.DEBUT_PER_GENERATION_HP != R.DEBUT_PER_GENERATION_HP '; 
         req              := req||'OR P.FIN_PER_GENERATION_HP  != R.FIN_PER_GENERATION_HP)) ';
         req              := req||'select S.NUMPAC, S.PACMAT, TPRP2.MOIS_PAIE AS PERIODE, S.CODE_CHRONO , S.PAIEZAD , S.NUMCNT , H.DATE_SORTIE_SIT_BO , TO_CHAR( TO_DATE(TPRP2.MOIS_PAIE,''YYYYMM''),''DD/MM/YYYY'') AS DATE_EFF FROM TPRP2 ';
         req              := req||'INNER JOIN dic_adm_contrat_SITU S ';
         req              := req||'ON S.NUMPAC = TPRP2.NUMPAC ';
         req              := req||'AND S.PAIEZAD = TPRP2.PAIEZAD ';
         req              := req||'AND S.PACMAT = TPRP2.PACMAT ';
         req              := req||'INNER JOIN ( SELECT DISTINCT ';
         req              := req||'TPRP2.MOIS_PAIE, ';
         req              := req||'dach_max_date_eff.numpac, ';
         req              := req||'dach_max_date_eff.paiezad, ';
         req              := req||'dach_max_date_eff.pacmat, ';
         req              := req||'MAX(dach_max_date_eff.date_eff) ';
         req              := req||'OVER(PARTITION BY dach_max_date_eff.numpac, dach_max_date_eff.paiezad, dach_max_date_eff.pacmat) AS date_eff ';
         req              := req||'FROM dic_adm_contrat_histo dach_max_date_eff ';
         req              := req||'INNER JOIN TPRP2  ON ';
         req              := req||'dach_max_date_eff.numpac = TPRP2.numpac ';
         req              := req||'AND dach_max_date_eff.paiezad = TPRP2.paiezad ';
         req              := req||'AND dach_max_date_eff.pacmat = TPRP2.pacmat ';
         req              := req||'WHERE dach_max_date_eff.date_eff <= last_day(to_date(TPRP2.MOIS_PAIE, ''YYYYMM'')) ';
         req              := req||') C on  ';
         req              := req||'C.NUMPAC = S.NUMPAC ';
         req              := req||'AND C.paiezad = S.paiezad ';
         req              := req||'AND C.PACMAT = S.PACMAT ';
         req              := req||'AND C.MOIS_PAIE = TPRP2.MOIS_PAIE ';
         req              := req||'INNER join DIC_ADM_CONTRAT_HISTO H  ';
         req              := req||'ON H.NUMPAC = S.NUMPAC ';
         req              := req||'AND H.PAIEZAD = S.PAIEZAD ';        
         req              := req||'AND H.PACMAT = S.PACMAT ';
         req              := req||'AND H.NUMCNT = S.NUMCNT ';
         req              := req||'AND H.DATE_EFF = C.date_eff ';
         req              := req||'AND H.ZA996 = ''Z'' ';
         req              := req||'WHERE  ';
         req              := req||'TPRP2.MOIS_PAIE >= ''' || periode_recalcul_deb || '''  ';
         req              := req||'AND TPRP2.NUMPAC = ''' || p_numpac || '''  ';
         IF w_pacmat IS NOT NULL THEN
           req              := req||'AND TPRP2.PACMAT = '''||w_pacmat||'''  ';
         END IF ;
         EXECUTE IMMEDIATE req BULK COLLECT INTO tab_retro2;
         IF tab_retro2.exists(1) THEN
           FOR i IN tab_retro2.first..tab_retro2.last  
           LOOP
             BEGIN
               TGE_RETRO_INSCRIPT_WITH_CHECK(tab_retro2(i).NUMPAC, tab_retro2(i).PACMAT, tab_retro2(i).PERIODE,  tab_retro2(i).CODE_CHRONO,  tab_retro2(i).PAIEZAD, 'TGE_PERIODE_RECUEIL_PAIEZAD');
             EXCEPTION
             WHEN OTHERS THEN
               TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV KO : TGE_RETRO_INSCRIPT_WITH_CHECK('''||tab_retro2(i).NUMPAC||''', '''||tab_retro2(i).PACMAT||''', '''||tab_retro2(i).PERIODE||''',  '''||tab_retro2(i).CODE_CHRONO||''',  '''||tab_retro2(i).PAIEZAD||''', ''TGE_PERIODE_RECUEIL_PAIEZAD'') '||SQLCODE||' '||SQLERRM);
             END;
             BEGIN
	           -- TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','CALC_HP.principal('''||tab_retro2(i).NUMPAC||''', '''||tab_retro2(i).PACMAT||''', '''||tab_retro2(i).PERIODE||''',  '''||tab_retro2(i).CODE_CHRONO||''',  '''||tab_retro2(i).PAIEZAD||''','''||tab_retro2(i).DATE_SORTIE_SIT_BO||''','''||tab_retro2(i).DATE_EFF||''','''||tab_retro2(i).NUMCNT||''', ''TGE_PERIODE_RECUEIL_PAIEZAD'') '||SQLCODE||' '||SQLERRM);
               CALC_HP.principal(tab_retro2(i).NUMPAC, tab_retro2(i).PACMAT, tab_retro2(i).PAIEZAD,  tab_retro2(i).NUMCNT,  tab_retro2(i).DATE_EFF,  tab_retro2(i).DATE_SORTIE_SIT_BO, 'proc_TGE_ALIM_PERIODE_INDIV',1);
             EXCEPTION
             WHEN OTHERS THEN
               TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV KO : CALC_HP.principal('''||tab_retro2(i).NUMPAC||''', '''||tab_retro2(i).PACMAT||''', '''||tab_retro2(i).PAIEZAD||''',  '''||tab_retro2(i).NUMCNT||''',  '''||tab_retro2(i).DATE_EFF||''', '''||tab_retro2(i).DATE_SORTIE_SIT_BO||''', ''proc_TGE_ALIM_PERIODE_INDIV'',1) '||SQLCODE||' '||SQLERRM);
             END;
           END LOOP;
         END IF;	
		 EXECUTE_IMMEDIATE_STRING  ('DELETE TGE_PERIODE_RECUEIL_PAIEZAD_R WHERE ID_TRT = ''' || id_trt || ''' ',0);		 
		 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV -> Début JOB.SUBMIT UPDATE TGE_INCIDENTS_PAIE');
		 -- UPDATE TGE_INCIDENTS_PAIE pour forcer le passage dans le trigger et le recalcul de la colonne PERIODE avec la bonne valeur
		 -- On cible les incidents dont la colonne PERIODE ne correspond pas à la valeur qu'elle devrait avoir (MOIS_PAIE de TGE_PERIODE_RECUEIL_PAIEZAD pour la période de recueil incluant la DATE_EFFET de l'incident)
			req              := 'UPDATE TGE_INCIDENTS_PAIE SET PERIODE = PERIODE, TYPE_WRITER=''''R'''' ';
			req              := req|| ' WHERE ID IN ( ';
			req            	 := req|| '   select I.ID from TGE_INCIDENTS_PAIE I  '; 
			req            	 := req|| '   INNER JOIN TGE_PERIODE_RECUEIL_PAIEZAD P  '; 
			req            	 := req|| '   ON I.NUMPAC = P.NUMPAC '; 
			req            	 := req|| '   AND I.PAIEZAD = P.PAIEZAD '; 
			req            	 := req|| '   AND I.DATE_EFFET BETWEEN P.DEBUT_PERIODE_RECUEIL AND P.FIN_PERIODE_RECUEIL '; 
			req            	 := req|| '   WHERE I.NUMPAC = ''''' || p_numpac || ''''' '; 
			req            	 := req|| '   AND TO_CHAR(I.PERIODE, ''''YYYYMM'''') != P.MOIS_PAIE '; 
			IF w_pacmat IS NOT NULL THEN
				req          := req|| '   AND P.PACMAT = '''''||w_pacmat||'''''  ';
			END IF;
			req            	 := req|| ' )  '; 
				 
		  DBMS_JOB.SUBMIT(v_jobIdx , 'BEGIN
			 TGE_IMPORT_AVANCEMENT_proc(''TGE_ALIM_PER'',''début CALCUL PERIODE INCIDENT '||id_trt||''');
			 EXECUTE_IMMEDIATE_STRING('''||req||''', 0);
			 TGE_IMPORT_AVANCEMENT_proc(''TGE_ALIM_PER'',''fin CALCUL PERIODE INCIDENT '||id_trt||' OK : ''||SQL%ROWCOUNT||'' ligne(s) mise(s) à jour'');
			 EXCEPTION
			 WHEN OTHERS THEN
			 TGE_IMPORT_AVANCEMENT_proc(''TGE_ALIM_PER'',''fin CALCUL PERIODE INCIDENT KO : ''|| SQLCODE||'' ''||SQLERRM);
		  END;', sysdate, null);
	 	END IF;
	 END IF;
  ELSE
    TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV -> Date de periode_recalcul ('||p_periode_paie||') > à la période du pac en cours ('||periode_paie_en_cours||')');
  END IF;
  TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV OK');
EXCEPTION
WHEN OTHERS THEN
  TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV KO : TGE_ALIM_PERIODE_INDIV '||SQLCODE||' '||SQLERRM);
END TGE_ALIM_PERIODE_INDIV;
##
TAG_CHARSET=@€éèç
##
TGE_ALIM_PERIODE_INDIV_MAIN
=SQL=
create or replace PROCEDURE TGE_ALIM_PERIODE_INDIV_MAIN( p_id            IN NUMBER, p_numpac        IN VARCHAR2, p_periode_paie  IN VARCHAR2,
 p_pacmat       IN VARCHAR2,
 p_dosNumForSimu IN NUMBER DEFAULT NULL,
 recueil_photo IN BOOLEAN DEFAULT FALSE )
 IS
 w_err    VARCHAR2(2000);
 w_audit_alim_periode_tab AUDIT_ALIM_PERIODE_TAB;
 w_debut_recueil_retro DATE;
 w_fin_recueil_retro   DATE;
 id_trt                NUMBER;
 reqTempInfo		   CLOB;
 req                   CLOB;

 BEGIN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN début (' || p_numpac || ',' || p_periode_paie || ',' || p_pacmat || ')');
 --Alimentation id procédure
 IF p_id   = 0 OR p_id IS NULL THEN
 id_trt := IMP_TRT_SEQ_ID.nextval;
 ELSE
 id_trt := p_id;
 END IF;

 
 --Vérification des données à traiter
 w_audit_alim_periode_tab := AUDIT_ALIM_PERIODE_INDIV(id_trt, p_numpac, p_periode_paie, p_pacmat);
 IF w_audit_alim_periode_tab.exists(1) THEN
 FOR i IN w_audit_alim_periode_tab.first..w_audit_alim_periode_tab.last
 LOOP
 w_err := w_err || '(' || w_audit_alim_periode_tab(i).paiezad || ',' || w_audit_alim_periode_tab(i).debut_recueil_force || ',' || w_audit_alim_periode_tab(i).fin_recueil_force || ')';
 END LOOP;
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs de configuration des periodes de recueil pour les paiezad suivant (paiezad,debut_recueil_force,fin_recueil_force) : ' || w_err);
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN KO');
 RETURN;
 END IF;
 --Récupération de la période de recueil retro issu de la table LTP (TGE_REF_LTP)
 BEGIN
 SELECT DEBUT_PERIODE,
 FIN_PERIODE
 INTO w_debut_recueil_retro,
 w_fin_recueil_retro
 FROM TGE_REF_LTP
 WHERE NUMPAC  = p_numpac
 AND MOIS_PAIE = TO_CHAR(ADD_MONTHS(TO_DATE(p_periode_paie,'yyyymm'),-1),'YYYYMM');
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs de configuration des periodes de recueil M-1 dans TGE_REF_LTP : NUMPAC = ''' || p_numpac || ''' AND MOIS_PAIE = ' || TO_CHAR(ADD_MONTHS(TO_DATE(p_periode_paie,'yyyymm'),-1),'YYYYMM'));
 raise;
 END;

 --Récupération requête des informations
 TGE_ALIM_PERIODE_INDIV_TEMP(id_trt, p_numpac, p_pacmat, p_periode_paie, reqTempInfo, recueil_photo);
 
 --Nettoyage avant d'insérer dans TGE_PERIODE_RECUEIL_PAIEZAD
 req := 'DELETE FROM ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
 ELSE
 req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
 END IF;
 req := req||' WHERE NUMPAC = '''||p_numpac||'''';
 req := req||' AND MOIS_PAIE >= '''||p_periode_paie||'''';
 IF p_pacmat IS NOT NULL THEN
 req := req||' AND PACMAT = '''||p_pacmat||'''';
 END IF;
 IF p_dosNumForSimu IS NOT NULL THEN
 req := req||' AND DOS_NUM = '||p_dosNumForSimu;
 END IF;
 EXECUTE_IMMEDIATE_STRING ( req,0);
 
 --Insertion des données dans TGE_PERIODE_RECUEIL_PAIEZAD
 req := 'INSERT INTO ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
 ELSE
 req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
 END IF;
 req := req||' (';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, il faut alimenter la colonne DOS_NUM
 req := req||'    DOS_NUM,';
 END IF;
 req := req||'    NUMPAC, 
 			      MOIS_PAIE, 
 			      PAIEZAD, 
 			      PACMAT, 
 			      RETRO_GC, 
 			      DEBUT_PERIODE_PAIE, 
 			      FIN_PERIODE_PAIE, 
 			      DEBUT_PERIODE_RECUEIL, 
 			      FIN_PERIODE_RECUEIL, 
 			      ENTREE, 
 			      SORTIE, 
 			      DEBUT_PER_RECUEIL_RETRO, 
 			      FIN_PER_RECUEIL_RETRO, 
 			      DEPART_SUSPENSION, 
 			      RETOUR_SUSPENSION, 
 			      DEBUT_PER_GENERATION_HP, 
 			      FIN_PER_GENERATION_HP,
 				  DEBUT_PERIODE_RECUEIL_LTP,
 				  FIN_PERIODE_RECUEIL_LTP
 			    ) 
 			  SELECT * FROM ( SELECT  /*+ opt_param(''_optimizer_push_pred_cost_based'',''false'') */ ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, il faut alimenter la colonne DOS_NUM
 req := req||p_dosNumForSimu||',';
 END IF;
 req := req||'  NUMPAC, 
 			    MOIS_PAIE, 
 			    PAIEZAD, 
 			    PACMAT, 
 			    RETRO_GC, 
 			    DATE_DEB_PERIODE, 
 			    DATE_FIN_PERIODE, 
 			    debut_recueil, 
 			    fin_recueil, 
 			    debut_situ, 
 			    CASE 
 			      WHEN fin_situ > DATE_FIN_PERIODE 
 			        THEN TO_DATE(''31.12.2099'',''dd.mm.yyyy'') 
 			      ELSE fin_situ 
 			    END AS fin_situation, 
 			    TO_DATE('||TO_CHAR(w_debut_recueil_retro,'yyyymmdd')||',''yyyymmdd''), 
 			    TO_DATE('||TO_CHAR(w_fin_recueil_retro,'yyyymmdd')||',''yyyymmdd''), 
 			    DEPART_SUSP, 
 			    RETOUR_SUSP, 
 			    CASE 
 			      WHEN SORTIE_PRECEDENTE BETWEEN DATE_DEB_PERIODE AND DATE_FIN_PERIODE 
 			      	OR debut_recueil IS NOT NULL 
 			        THEN TRUNC(TRUNC(GREATEST(DSDCN, dt_recueil_deb),''MONTH''),''DAY'') 
 			      WHEN debut_recueil IS NULL 
 			        AND entree       IS NOT NULL 
 			        AND entree         <= DATE_FIN_PERIODE 
 			        AND sortie        IS NOT NULL 
 			        AND sortie         >= dt_recueil_deb 
 			        THEN DATE_DEB_PERIODE 
 			      WHEN debut_recueil IS NULL
                  AND ((entree       IS NOT NULL
                  AND entree          > DATE_FIN_PERIODE)
                  OR (sortie         IS NOT NULL
                  AND sortie          < dt_recueil_deb))
                  THEN NULL 
 			    END AS debut_HP , 
 			    CASE 
 			        WHEN fin_recueil IS NOT NULL
 			          AND ENTREE_SUIVANTE IS NULL
 			          THEN TRUNC(LAST_DAY(DATE_FIN_PERIODE),''DAY'')+6
 			        WHEN fin_recueil IS NOT NULL
 			          THEN LEAST(TRUNC(LAST_DAY(DATE_FIN_PERIODE),''DAY'')+6,NVL(DSFCN,TRUNC(LAST_DAY(DATE_FIN_PERIODE),''DAY'')+6)) 
 			        WHEN fin_recueil IS NULL 
 			          AND entree     IS NOT NULL 
 			          AND entree       <= DATE_FIN_PERIODE 
 			          AND sortie      IS NOT NULL 
 			          AND sortie       >= dt_recueil_deb 
 			          THEN DATE_FIN_PERIODE
 			           WHEN fin_recueil IS NULL
                    AND ((entree     IS NOT NULL
                    AND entree        > DATE_FIN_PERIODE)
                    OR (sortie       IS NOT NULL
                    AND sortie        < dt_recueil_deb))
                    THEN NULL 
 			      END AS fin_HP,
 			      DT_RECUEIL_DEB,
 				  DT_RECUEIL_FIN 
 			    FROM 
 			      (SELECT lead(ENTREE,1) over(partition BY NUMPAC,PACMAT order by ENTREE)-1 ENTREE_SUIVANTE, 
 			        lag(SORTIE,1) over(partition BY NUMPAC,PACMAT order by SORTIE) SORTIE_PRECEDENTE, 
 			        NUMPAC, 
 			        PACMAT, 
 			        PAIEZAD, 
 			        RETRO_GC, 
 			        MOIS_PAIE,
 			        DATE_DEB_PERIODE,
 			        DATE_FIN_PERIODE,
 			        DEBUT_FORCEE, 
 			        FIN_FORCEE, 
 			        ENTREE, 
 			        SORTIE, 
 			        DSFCN, 
 			        DSDCN,
 			        RETOUR_SUSP, 
 			        DEPART_SUSP, 
 			        DEBUT_SITU, 
 			        FIN_SITU, 
 			        debut_recueil, 
 			        DT_RECUEIL_DEB, 
 			        DT_RECUEIL_FIN, 
 			        CASE 
 			          WHEN fin_forcee IS NOT NULL 
 			            THEN fin_forcee 
 			          WHEN debut_recueil IS NULL 
 			            THEN NULL 
 			          WHEN sortie      IS NULL 
 			            OR sortie      > DATE_FIN_PERIODE 
 			            THEN dt_recueil_fin 
 			          WHEN sortie      >= dt_recueil_deb 
 			            THEN sortie  
 			          ELSE TO_DATE(''01/01/1900'',''dd/mm/yyyy'')  
 			        END AS fin_recueil 
 			      FROM 
 			        (SELECT NUMPAC, 
 			          PACMAT, 
 			          PAIEZAD, 
 			          RETRO_GC, 
 			          MOIS_PAIE,
 			          DATE_DEB_PERIODE,
 			          DATE_FIN_PERIODE,
 			          DEBUT_FORCEE, 
 			          FIN_FORCEE, 
 			          ENTREE, 
 			          SORTIE, 
 			          DSFCN, 
 			          DSDCN,
 			          RETOUR_SUSP, 
 			          DEPART_SUSP, 
 			          DEBUT_SITU, 
 			          FIN_SITU, 
 			          DT_RECUEIL_DEB, 
 			          DT_RECUEIL_FIN, 
 			          CASE 
 			            WHEN debut_forcee IS NOT NULL 
 			              THEN debut_forcee 
 			            WHEN entree IS NULL  
 			              THEN null 
 			            WHEN entree        <= dt_recueil_fin 
 			              AND (sortie IS NULL 
 			              OR (sortie        >= dt_recueil_deb 
 			              AND (sortie > DATE_FIN_PERIODE  
 			              	OR NOT EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD rec_ind WHERE rec_ind.NUMPAC = rec_temp.numpac AND rec_ind.PAIEZAD = rec_temp.paiezad AND rec_ind.FIN_PERIODE_RECUEIL >= rec_temp.sortie) ) ))  
 
 			              THEN GREATEST(entree, NVL(dt_recueil_deb, entree)) 
 			            WHEN entree        <= dt_recueil_fin	
						AND (sortie        < dt_recueil_deb  
							OR ( sortie        >= dt_recueil_deb AND (sortie < DATE_FIN_PERIODE 
								AND EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD rec_ind WHERE rec_ind.NUMPAC = rec_temp.numpac AND rec_ind.PAIEZAD = rec_temp.paiezad AND rec_ind.FIN_PERIODE_RECUEIL >= rec_temp.sortie))))
						THEN TO_DATE(''01/01/1900'',''dd/mm/yyyy'')
						WHEN (sortie        IS NOT NULL
                          AND entree         > dt_recueil_fin
                          AND sortie        <= DATE_FIN_PERIODE)
                          THEN entree						
                        ELSE NULL
 			          END AS debut_recueil 
 			        FROM (' || reqTempInfo || ') rec_temp 
 			        ) 
 			      ) ) WHERE (debut_recueil IS NULL OR TO_CHAR(debut_recueil,''dd/mm/yyyy'') != ''01/01/1900'') AND (fin_recueil IS NULL OR  TO_CHAR(fin_recueil,''dd/mm/yyyy'')  != ''01/01/1900'') AND debut_HP IS NOT NULL AND fin_HP IS NOT NULL';
 			      
 --DBMS_OUTPUT.PUT_LINE(req);
 EXECUTE_IMMEDIATE_STRING  (req,0);

 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN OK');
 EXCEPTION
 WHEN OTHERS THEN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN KO : TGE_ALIM_PERIODE_INDIV_MAIN '||SQLCODE||' '||SQLERRM);
 END TGE_ALIM_PERIODE_INDIV_MAIN;
##
TAG_CHARSET=@€éèç
##
TGE_ALIM_PERIODE_INDIV_TEMP
=SQL=
create or replace PROCEDURE TGE_ALIM_PERIODE_INDIV_TEMP( p_id           IN NUMBER, p_numpac       IN VARCHAR2, p_pacmat       IN VARCHAR2,
 p_periode_paie IN VARCHAR2,
 out_req OUT CLOB,
 recueil_photo IN BOOLEAN DEFAULT TRUE)
 AS
 w_Y326                 VARCHAR2(4000 BYTE);
 w_Y327                 VARCHAR2(4000 BYTE);
 w_A302                 VARCHAR2(4000 BYTE);
 w_A301                 VARCHAR2(4000 BYTE);
 w_A520                 VARCHAR2(4000 BYTE);
 w_A521                 VARCHAR2(4000 BYTE);
 w_A523                 VARCHAR2(4000 BYTE);
 w_AB43                 VARCHAR2(4000 BYTE);
 w_AB44                 VARCHAR2(4000 BYTE);
 periode_paie_en_cours  VARCHAR2(6);
 periode_deb_retro      VARCHAR2(6);
 optionEcp      VARCHAR2(1);
 
 A01_NOM_ELT    VARCHAR2(20);
 A02_NOM_ELT    VARCHAR2(20);
 A03_NOM_ELT    VARCHAR2(20);
 requeteMappingPivot  VARCHAR2(3000);
 
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_TEMP début (' || p_id || ',' || p_numpac || ',' || p_pacmat || ',' || p_periode_paie || ')');
 BEGIN
 --Alimentation des informations sur le pac
 SELECT PERIODEENCOURS, DEB_RETRO, OPTION_ECP
 INTO periode_paie_en_cours, periode_deb_retro, optionEcp
 FROM TGE_REF_PAC
 WHERE NUMPAC = p_numpac;
 --- Calcul des noms d'elements depuis tge_map_arg_elt
 select A01_NOM_ELT, A02_NOM_ELT, A03_NOM_ELT
 into   A01_NOM_ELT, A02_NOM_ELT, A03_NOM_ELT
 from (
 SELECT NOM_ARG,NOM_ELT FROM TABLE(GET_TGE_MAP_ARG_ELT_BY_NUMPAC(p_numpac))
 )
 pivot (MAX(NOM_ELT) AS NOM_ELT FOR (NOM_ARG) in ('A01' AS A01,'A02' AS A02,'A03' AS A03));
 
 
 --Alimentation des informations sur le mapping des données
 requeteMappingPivot :='SELECT
 Y326_DONNEE ,
 Y327_DONNEE ,
 A302_DONNEE ,
 A301_DONNEE ,
 A520_DONNEE ,
 A521_DONNEE ,
 A523_DONNEE ,
 AB43_DONNEE ,
 AB44_DONNEE
 FROM (
 SELECT DISTINCT c.element,
 NVL(REPLACE(REPLACE(c.trtparticulier, ''$DONNEEGXP'', ''$TABLE.'' || c.donneegxp), ''$TABLE'', c.tablegxp), c.tablegxp || ''.'' || c.donneegxp) AS DONNEEGXP
 FROM tge_ref_mapdo c
 WHERE C.numpac = '''|| p_numpac ||'''
 AND c.element IN (''Y326'',''Y327'',''A302'',''A301'','''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''',''BA50'',''BA51'')
 UNION ALL
 SELECT DISTINCT c.element,
 NVL(REPLACE(REPLACE(c.trtparticulier, ''$DONNEEGXP'', ''$TABLE.'' || c.donneegxp), ''$TABLE'', c.tablegxp), c.tablegxp || ''.'' || c.donneegxp) AS DONNEEGXP
 FROM tge_ref_mapdo c
 WHERE C.numpac = ''*''
 AND c.element IN (''Y326'',''Y327'',''A302'',''A301'','''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''',''BA50'',''BA51'')
 AND (c.ELEMENT) NOT IN
 (
 SELECT a.element
 FROM tge_ref_mapdo a
 WHERE a.numpac = '''|| p_numpac ||'''
 AND A.ELEMENT IN (''Y326'',''Y327'',''A302'',''A301'','''||A01_NOM_ELT||''','''||A02_NOM_ELT||''','''|| A03_NOM_ELT||''',''BA50'',''BA51'')
 )
 ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element)
 IN(''Y326'' AS Y326 ,''Y327'' AS Y327 ,''A302'' AS A302 ,''A301'' AS A301 ,'''||A01_NOM_ELT||''' AS A520 ,'''||A02_NOM_ELT||''' AS A521,'''||A03_NOM_ELT||''' AS A523,''BA50'' AS AB43,''BA51'' AS AB44))
 ';
 EXECUTE IMMEDIATE
 requeteMappingPivot
 INTO w_Y326,
 w_Y327,
 w_A302,
 w_A301,
 w_A520,
 w_A521,
 w_A523,
 w_AB43,
 w_AB44;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_TEMP ERR : Erreurs de configuration de TGE_REF_MAPDO : NUMPAC = ''' || p_numpac || ''' AND ELEMENT in (''Y326'',''Y327'',''A302'',''A301'',''A520'',''A521'',''A523'')');
 raise;
 END;
 
 out_req := 'SELECT l.numpac, l.pacmat, l.PAIEZAD, l.debut_forcee, l.fin_forcee, l.entree, l.sortie, l.retour_susp, l.depart_susp, l.debut_situ, l.fin_situ, l.DT_RECUEIL_DEB, l.DT_RECUEIL_FIN, l.retro_gc, l.MOIS_PAIE, l.DATE_DEB_PERIODE, l.DATE_FIN_PERIODE, l.DSFCN, l.DSDCN from (
 SELECT
 dach_tmp_sus.numpac,
 dach_tmp_sus.pacmat,
 dach_tmp_sus.PAIEZAD,
 dach_tmp_sus.debut_forcee,
 dach_tmp_sus.fin_forcee,
 dach_tmp_sus.debut_situ as entree,
 dach_tmp_sus.fin_situ as sortie ,'
 || w_A302 || '+1 as retour_susp,  ' --pseudo date de retour de suspension / réembaucher
 || w_A301 || '-1 as depart_susp,  ' --pseudo date de départ en suspension
 || '
 dach_tmp_sus.debut_situ,
 dach_tmp_sus.fin_situ,
 dach_tmp_sus.DT_RECUEIL_DEB,
 dach_tmp_sus.DT_RECUEIL_FIN,
 dach_tmp_sus.retro_gc,
 dach_tmp_sus.NUMCNT,
 dach_tmp_sus.DATE_EFF,
 dach_tmp_sus.DSFCN,
 dach_tmp_sus.DSDCN,
 ' || w_A301 || ' AS sous_DSA301,
 ' || w_A302 || ' AS sous_DSA302,
 MOIS_PAIE,DATE_DEB_PERIODE,DATE_FIN_PERIODE
 FROM (
 select VR.numpac,VR.pacmat,VR.PAIEZAD,VR.NUMCNT,VR.DATE_EFF,VR.DSFCN,VR.DSDCN,VR.debut_forcee,VR.fin_forcee,VR.debut_situ,VR.fin_situ,VR.MOIS_PAIE,VR.DATE_DEB_PERIODE,VR.DATE_FIN_PERIODE,
 CASE
 WHEN TO_CHAR(VR.debut_forcee,''YYYYMMDD'') IS NOT NULL
 THEN VR.debut_forcee
 ELSE to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 29, 8), ''DDMMYYYY'')
 END AS DT_RECUEIL_DEB,
 CASE
 WHEN TO_CHAR(VR.fin_forcee,''YYYYMMDD'') IS NOT NULL
 THEN VR.fin_forcee
 ELSE to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 37, 8), ''DDMMYYYY'')
 END AS DT_RECUEIL_FIN,  ';
 IF periode_deb_retro IS NULL OR periode_deb_retro > periode_paie_en_cours THEN
 out_req := out_req || ' TGE_PERIODE_RECUEIL_PAIEZAD_R.retro_gc,  ';
 ELSE
 out_req := out_req || ' null as retro_gc, ';
 END IF;
 out_req := out_req || '(
 select max(dach_tmp.date_eff) from ';
 IF recueil_photo THEN
 out_req := out_req || ' PHOTO_DIC_ADM_CONTRAT_HISTO ';
 ELSE
 out_req := out_req || ' dic_adm_contrat_histo ';
 END IF;
 out_req := out_req || ' dach_tmp
 where dach_tmp.za962 is not null
 and dach_tmp.dsa301-1 <= last_day(to_date(''' || p_periode_paie || '''||''01'',''YYYYMMDD''))
 and nvl(dach_tmp.dsa302, dach_tmp.dsfsus)+1 >= to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 29, 8), ''DDMMYYYY'')
 and dach_tmp.date_eff <= last_day(to_date(''' || p_periode_paie || '''||''01'',''YYYYMMDD'')) + 1
 and dach_tmp.numpac = VR.NUMPAC
 and dach_tmp.pacmat = VR.PACMAT
 and dach_tmp.paiezad = VR.PAIEZAD
 ) as date_eff_sus
 
 from (
 select numpac,pacmat,PAIEZAD,NUMCNT,DATE_EFF,DSFCN,DSDCN,debut_forcee,fin_forcee,debut_situ,fin_situ,NUMERO_DE_PAC,CODE_TABLE,MOIS_PAIE,DATE_DEB_PERIODE,DATE_FIN_PERIODE,MIN(NUMERO_DE_LIGNE) as min_NUMERO_DE_LIGNE from
 (SELECT CO.* FROM (select
 DIC_ADM_CONTRAT_SITU.numpac as numpac,
 DIC_ADM_CONTRAT_SITU.pacmat as pacmat,
 DIC_ADM_CONTRAT_SITU.PAIEZAD as paiezad,
 DIC_ADM_CONTRAT.DSDCN                 AS DSDCN,
 DIC_ADM_CONTRAT.DSFCN                 AS DSFCN,
 DIC_ADM_CONTRAT_HISTO.NUMCNT          AS NUMCNT,
 DIC_ADM_CONTRAT_HISTO.DATE_EFF        AS DATE_EFF, 
 ' || w_Y326 || ' as debut_forcee,
 ' || w_Y327 || ' as fin_forcee,
 ' || w_AB43 || ' as debut_situ,
 NVL(' || w_AB44 || ', TO_DATE(''20991231'',''YYYYMMDD'')) as fin_situ,
 ' || w_A520 || ' as activite,
 ' || w_A521 || ' as etablissement,
 ' || w_A523 || ' as categorie,
 DIC_ADM_CONTRAT_HISTO.MOIS_PAIE,
 DIC_ADM_CONTRAT_HISTO.DATE_DEB_PERIODE,
 DIC_ADM_CONTRAT_HISTO.DATE_FIN_PERIODE
 FROM  ';
 IF recueil_photo THEN
 out_req := out_req || ' (SELECT NUMPAC, PACMAT, NUMCNT, CURRENT_PAIEZAD as PAIEZAD, DSDCN as DSDSC, NVL(DSFCN,TO_DATE(''20991231'',''yyyymmdd'')) as DSFSC
 FROM PHOTO_DIC_ADM_CONTRAT WHERE paiezad IS NOT NULL) DIC_ADM_CONTRAT_SITU ';
 ELSE
 out_req := out_req || ' DIC_ADM_CONTRAT_SITU ';
 END IF;
 out_req := out_req || '
 left join DIC_PERIODES_RECUEIL_HIS
 on DIC_PERIODES_RECUEIL_HIS.numpac = DIC_ADM_CONTRAT_SITU.numpac
 AND DIC_PERIODES_RECUEIL_HIS.paiezad = DIC_ADM_CONTRAT_SITU.paiezad
 AND DIC_PERIODES_RECUEIL_HIS.PRH_MOIS_PAIE = ''' || p_periode_paie || '''
 inner join  ';
 IF recueil_photo THEN
 out_req := out_req || ' PHOTO_DIC_ADM_CONTRAT DIC_ADM_CONTRAT ';
 ELSE
 out_req := out_req || ' DIC_ADM_CONTRAT ';
 END IF;
 out_req := out_req || '
 on DIC_ADM_CONTRAT.NUMPAC=DIC_ADM_CONTRAT_SITU.NUMPAC
 AND DIC_ADM_CONTRAT.PACMAT=DIC_ADM_CONTRAT_SITU.PACMAT
 AND DIC_ADM_CONTRAT.NUMCNT=DIC_ADM_CONTRAT_SITU.NUMCNT
 left join ( SELECT  DIC_ADM_CONTRAT_HISTO.*,C.MOIS_PAIE, C.DATE_DEB_PERIODE_PREC, C.DATE_DEB_PERIODE, C.DATE_FIN_PERIODE
 FROM (
 SELECT distinct DACH_MAX_DATE_EFF.NUMPAC,
 DACH_MAX_DATE_EFF.PAIEZAD,
 DACH_MAX_DATE_EFF.PACMAT,
 ''' || p_periode_paie || ''' MOIS_PAIE,
 TO_DATE(TO_CHAR(ADD_MONTHS(TO_DATE(''' || p_periode_paie || ''',''yyyymm''),-1),''YYYYMM'')||''01'',''yyyymmdd'') DATE_DEB_PERIODE_PREC,
 TO_DATE(''' || p_periode_paie || '''||''01'',''yyyymmdd'') DATE_DEB_PERIODE,
 last_day(to_date(''' || p_periode_paie || '''||''01'',''yyyymmdd'')) DATE_FIN_PERIODE,
 MAX(DACH_MAX_DATE_EFF.DATE_EFF)  over (partition BY DACH_MAX_DATE_EFF.NUMPAC, DACH_MAX_DATE_EFF.PAIEZAD, DACH_MAX_DATE_EFF.PACMAT) AS max_date_eff
 FROM ';
 IF recueil_photo THEN
 out_req := out_req || ' PHOTO_DIC_ADM_CONTRAT_HISTO ';
 ELSE
 out_req := out_req || ' DIC_ADM_CONTRAT_HISTO ';
 END IF;
 out_req := out_req || ' DACH_MAX_DATE_EFF
 WHERE DACH_MAX_DATE_EFF.NUMPAC = ''' || p_numpac || ''' ';
 IF p_pacmat IS NOT NULL THEN
 out_req := out_req || ' AND PACMAT = ''' || p_pacmat || ''' ';
 END IF;
 out_req := out_req || '  AND DACH_MAX_DATE_EFF.DATE_EFF <= last_day(TO_DATE( ''' || p_periode_paie || '''||''01'',''yyyymmdd''))
 ) C
 inner join ';
 IF recueil_photo THEN
 out_req := out_req || ' PHOTO_DIC_ADM_CONTRAT_HISTO DIC_ADM_CONTRAT_HISTO ';
 ELSE
 out_req := out_req || ' DIC_ADM_CONTRAT_HISTO ';
 END IF;
 out_req := out_req || ' on
 DIC_ADM_CONTRAT_HISTO.NUMPAC = C.NUMPAC
 AND DIC_ADM_CONTRAT_HISTO.paiezad = C.paiezad
 AND DIC_ADM_CONTRAT_HISTO.PACMAT = C.PACMAT
 AND DIC_ADM_CONTRAT_HISTO.DATE_EFF = C.max_date_eff
 ) DIC_ADM_CONTRAT_HISTO
 on DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT_SITU.NUMCNT
 AND DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT_SITU.NUMPAC
 AND DIC_ADM_CONTRAT_HISTO.paiezad = DIC_ADM_CONTRAT_SITU.paiezad
 AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT_SITU.PACMAT
 WHERE (DIC_ADM_CONTRAT_HISTO.ZA750 IS NULL OR DIC_ADM_CONTRAT_HISTO.DRPAI2 != ''B'')
 AND (DIC_ADM_CONTRAT.NATCOL IS NULL OR DIC_ADM_CONTRAT.NATCOL in (''SAL'',''STA''))
 AND NVL(' || w_AB44 || ', TO_DATE(''20991231'',''YYYYMMDD'')) >= DIC_ADM_CONTRAT_HISTO.DATE_DEB_PERIODE_PREC
 AND NVL(DIC_ADM_CONTRAT_HISTO.DATE_EFF, ' || w_AB43 || ') <= DIC_ADM_CONTRAT_HISTO.DATE_FIN_PERIODE
 ) CO
 ) COM,TGE_REF_VRVAL
 WHERE TGE_REF_VRVAL.CODE_TABLE = ''LTP''
 AND TGE_REF_VRVAL.NUMERO_DE_PAC = COM.NUMPAC
 AND SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 19 , 6 ) = SUBSTR(COM.MOIS_PAIE,5, 2)||SUBSTR(COM.MOIS_PAIE,1, 4) ';
 
 IF optionEcp IS NOT NULL AND optionEcp = 'P' THEN
 out_req := out_req || '
 AND TRIM(LPAD(COM.activite,2)) BETWEEN LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,1 ,2),2) AND LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,3,2),2)
 AND TRIM(LPAD(COM.etablissement,5)) BETWEEN LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,5 ,5),5) AND LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,10,5),5)
 AND TRIM(LPAD(COM.categorie,2)) BETWEEN LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,15,2),2) AND LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,17,2),2)
 ';
 ELSE
 out_req := out_req || '
 AND IS_BETWEEN_NLS_FRENCH(TRIM(LPAD(COM.activite,2)),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,1 ,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,3,2),2) )  = ''TRUE''
 AND IS_BETWEEN_NLS_FRENCH(TRIM(LPAD(COM.etablissement,5)),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,5 ,5),5), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,10,5),5))  = ''TRUE''
 AND IS_BETWEEN_NLS_FRENCH(TRIM(LPAD(COM.categorie,2)),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,15,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,17,2),2) )  = ''TRUE''
 ';
 END IF;
 
 out_req := out_req || '
 GROUP BY numpac,pacmat,PAIEZAD,NUMCNT,DATE_EFF,DSFCN,DSDCN,debut_forcee,fin_forcee,debut_situ,fin_situ,NUMERO_DE_PAC,CODE_TABLE,COM.MOIS_PAIE,COM.DATE_DEB_PERIODE,COM.DATE_FIN_PERIODE
 ) VR inner join TGE_REF_VRVAL on TGE_REF_VRVAL.NUMERO_DE_PAC = VR.NUMERO_DE_PAC AND TGE_REF_VRVAL.CODE_TABLE = VR.CODE_TABLE AND TGE_REF_VRVAL.NUMERO_DE_LIGNE = VR.min_NUMERO_DE_LIGNE
 LEFT JOIN TGE_PERIODE_RECUEIL_PAIEZAD_R
 ON TGE_PERIODE_RECUEIL_PAIEZAD_R.NUMPAC      = VR.NUMPAC
 AND TGE_PERIODE_RECUEIL_PAIEZAD_R.PACMAT     = VR.PACMAT
 AND TGE_PERIODE_RECUEIL_PAIEZAD_R.PAIEZAD    = VR.PAIEZAD
 AND TGE_PERIODE_RECUEIL_PAIEZAD_R.MOIS_PAIE  = VR.MOIS_PAIE
 AND TGE_PERIODE_RECUEIL_PAIEZAD_R.ID_TRT     = ''' || p_id || '''
 ) dach_tmp_sus
 LEFT JOIN  ';
 IF recueil_photo THEN
 out_req := out_req || ' PHOTO_DIC_ADM_CONTRAT_HISTO DIC_ADM_CONTRAT_HISTO ';
 ELSE
 out_req := out_req || ' DIC_ADM_CONTRAT_HISTO ';
 END IF;
 out_req := out_req || ' ON
 DIC_ADM_CONTRAT_HISTO.numpac = dach_tmp_sus.NUMPAC
 AND DIC_ADM_CONTRAT_HISTO.pacmat = dach_tmp_sus.PACMAT
 AND DIC_ADM_CONTRAT_HISTO.paiezad = dach_tmp_sus.PAIEZAD
 AND DIC_ADM_CONTRAT_HISTO.date_eff = dach_tmp_sus.date_eff_sus
 ) l ';
 IF not recueil_photo THEN
 out_req := out_req || ' LEFT JOIN PHOTO_DIC_ADM_CONTRAT P
 ON l.NUMPAC = P.NUMPAC
 AND l.PACMAT = P.PACMAT
 AND l.NUMCNT = P.NUMCNT
 LEFT JOIN PHOTO_DIC_ADM_CONTRAT_HISTO PH
 ON l.NUMPAC = PH.NUMPAC
 AND l.PACMAT = PH.PACMAT
 AND l.NUMCNT = PH.NUMCNT
 AND l.DATE_EFF = PH.DATE_EFF
 AND l.PAIEZAD = PH.PAIEZAD
 WHERE P.PACMAT IS NULL
 OR l.DSFCN IS NULL
 OR l.DSFCN >  l.DATE_FIN_PERIODE
 OR NVL(P.DSDCN, TO_DATE(''01.01.1900'', ''dd.MM.yyyy'')) != NVL(l.DSDCN, TO_DATE(''01.01.1900'', ''dd.MM.yyyy''))
 OR NVL(P.DSFCN, TO_DATE(''01.01.1900'', ''dd.MM.yyyy'')) != NVL(l.DSFCN, TO_DATE(''01.01.1900'', ''dd.MM.yyyy''))
 OR PH.PACMAT IS NULL
 OR l.sous_DSA301 IS NULL
 OR l.sous_DSA301 > l.DATE_FIN_PERIODE
 OR NVL(PH.DSA302, TO_DATE(''01.01.1900'', ''dd.MM.yyyy'')) != NVL(l.sous_DSA302, TO_DATE(''01.01.1900'', ''dd.MM.yyyy''))
 OR NVL(PH.DSA301, TO_DATE(''01.01.1900'', ''dd.MM.yyyy'')) != NVL(l.sous_DSA301, TO_DATE(''01.01.1900'', ''dd.MM.yyyy''))
 OR l.DATE_DEB_PERIODE BETWEEN l.ENTREE AND l.SORTIE
 OR l.ENTREE BETWEEN l.DATE_DEB_PERIODE AND  l.DATE_FIN_PERIODE ';
 END IF;
 
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_TEMP OK');
 EXCEPTION
 WHEN OTHERS THEN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_TEMP KO : TGE_ALIM_PERIODE_INDIV_TEMP '||SQLCODE||' '||SQLERRM);
 raise;
 END TGE_ALIM_PERIODE_INDIV_TEMP;
##
TAG_CHARSET=@€éèç
##
TGE_CLOTURE
=SQL=
create or replace PROCEDURE TGE_CLOTURE ( p_id in number, P_NUMPAC IN VARCHAR2 ) AS 
/********************************************************************************
Version     : V5.05.000
 *********************************************************************************/
 P_PERIODEENCOURS TGE_REF_PAC.PERIODEENCOURS%type;
 p_dtdebMois varchar2(8);
 p_finMois varchar2(8);
 p_histoIP varchar2(1);
 
 P_DEB_RETRO TGE_REF_PAC.DEB_RETRO%type;
 P_DEB_HISTO_RETRO TGE_REF_PAC.DEB_HISTO_RETRO%type;
 P_NB_MOIS_RETRO TGE_REF_PAC.NB_MOIS_RETRO%type;
 P_PERIDOE_HISTO_LIMITE TGE_REF_PAC.PERIODEENCOURS%type;
 w_per   VARCHAR2(6);
 w_req   CLOB;
 isRetro number :=0;
 BEGIN
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin)','Début de la clôture du numpac  '||P_NUMPAC);
 
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Recup Periode + infos Rétro)','Récupération de la période en cours,date début Rétro, date début historisation Rétro et nombre de mois Rétro à partir de TGE_REF_PAC pour le numpac : '||P_NUMPAC);
 select PERIODEENCOURS ,DEB_RETRO,DEB_HISTO_RETRO,NB_MOIS_RETRO ,to_char( add_months(to_date(PERIODEENCOURS,'yyyymm'),(-1*nvl(NB_MOIS_RETRO,1))+1),'YYYYMM') PERIDOE_HISTO_LIMITE
 into P_PERIODEENCOURS,P_DEB_RETRO,P_DEB_HISTO_RETRO,P_NB_MOIS_RETRO ,P_PERIDOE_HISTO_LIMITE
 from TGE_REF_PAC where numpac=p_numpac;
 
 IF P_DEB_RETRO is not null  AND to_date(P_PERIODEENCOURS,'YYYYMM')>=to_date(P_DEB_HISTO_RETRO,'YYYYMM') THEN
 w_per := P_PERIDOE_HISTO_LIMITE;
 isRetro :=1;
 ELSE
 w_per := P_PERIODEENCOURS;
 isRetro:=0;
 END IF;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge GAP_TRT_MAL_RECYCLES)','Purge de la table GAP_TRT_MAL_RECYCLES pour le numpac : '||P_NUMPAC);
 
 DELETE FROM  GAP_TRT_MAL_RECYCLES  WHERE NUMPAC = P_NUMPAC;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge GAP_TRT_DERNIER_ENVOI)','Purge de la table GAP_TRT_DERNIER_ENVOI pour le numpac : '||P_NUMPAC);
 
 DELETE FROM  GAP_TRT_DERNIER_ENVOI  WHERE NUMPAC = P_NUMPAC;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant lecture REF PER)','Récupération de la date de début et de fin du mois pour le numpac '||P_NUMPAC || '  et la periode '|| p_PERIODEENCOURS );
 select DATE_DEBUT_MOIS,DATE_FIN_MOIS into p_dtdebMois,p_finMois from TGE_REF_PER where numpac=p_numpac and periodeencours=p_PERIODEENCOURS;
 
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Insert GAP_TRT_MAL_RECYCLES)','Remplissage de la table GAP_TRT_MAL_RECYCLES pour le numpac : '||P_NUMPAC);
 
 insert into GAP_TRT_MAL_RECYCLES select ID_TRT,NUMPAC  ,PACMAT ,PAIEZAD,DATE_TRT  from
 (SELECT d.numpac,d.pacmat,max(b.id_trt)as ID_TRT,d.paiezad,nvl(max(b.DATE_DEBUT_TRT),to_date('01/01/1901','dd/mm/yyyy'))as DATE_TRT
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )
 AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 group by d.numpac,d.pacmat,d.paiezad);
 
 DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'GAP_TRT_MAL_RECYCLES',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Insert GAP_TRT_DERNIER_ENVOI)','Remplissage de la table GAP_TRT_DERNIER_ENVOI pour le numpac : '||P_NUMPAC);
 
 insert into GAP_TRT_DERNIER_ENVOI select ID_TRT,NUMPAC  ,PACMAT ,PAIEZAD,DATE_TRT  from
 (SELECT d.numpac,d.pacmat,max(b.id_trt)as ID_TRT,d.paiezad,nvl(max(b.DATE_DEBUT_TRT),to_date('01/01/1901','dd/mm/yyyy'))as DATE_TRT
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 group by d.numpac,d.pacmat,d.paiezad);
 
 DBMS_STATS.GATHER_TABLE_STATS( ownname => sys_context('USERENV','SESSION_SCHEMA') ,TABNAME=>'GAP_TRT_DERNIER_ENVOI',METHOD_OPT => 'FOR ALL COLUMNS SIZE 254',estimate_percent => 100, cascade => true , DEGREE=>4);
 --Purge et Historisation de dif_FSED
 
 BEGIN
 w_req :='Create TABLE DIF_FSED_HISTO_'||P_PERIODEENCOURS||' as select * from DIF_FSED_HISTO '  ;
 execute_immediate_string (w_req,0);
 EXCEPTION
 WHEN OTHERS THEN
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV DIF_FSED_HISTO) ','la table DIF_FSED_HISTO_'||P_PERIODEENCOURS||' existe déja ' );
 END ;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Deb PURGE_HISTO_DIF_FSED)','Début PURGE_HISTO_DIF_FSED pour le numpac  '||P_NUMPAC );
 
 PURGE_HISTO_DIF_FSED ( p_id, P_NUMPAC,P_PERIODEENCOURS,P_DEB_RETRO,P_DEB_HISTO_RETRO,P_NB_MOIS_RETRO,P_PERIDOE_HISTO_LIMITE);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Fin PURGE_HISTO_DIF_FSED)','Fin PURGE_HISTO_DIF_FSED pour le numpac  '||P_NUMPAC );
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV DIF_FSED) ',' début sauvegarde DIF_FSED'  );
 BEGIN
 w_req :='Create TABLE DIF_FSED_'||P_PERIODEENCOURS||' as select * from DIF_FSED '  ;
 execute_immediate_string (w_req,0);
 EXCEPTION
 WHEN OTHERS THEN
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV DIF_FSED) ','la table DIF_FSED_'||P_PERIODEENCOURS||' existe déja ' );
 END ;
 
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (DEBUT Supp DIF_FSED)','DEBUT Purge de la table DIF_FSED ');
 FOR C IN
 (SELECT DISTINCT to_char(id_trt) as trt FROM DIF_FSED WHERE NUMPAC =p_numpac
 )
 LOOP
 w_req :='ALTER TABLE DIF_FSED DROP PARTITION ID_'||C.trt ;
 BEGIN
 execute_immediate_string (w_req,0);
 EXCEPTION
 when others then
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE ( Supp partition DIF_FSED)','ERREUR lors de la suppresstion partition ID_'||C.trt||' de DIF_FSED '||SQLCODE||'-'||SQLERRM);
 end ;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE ( Supp partition DIF_FSED)','suppression partition ID_'||C.trt||' de DIF_FSED ');
 END LOOP;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (FIN Supp DIF_FSED)','FIN Purge de la table DIF_FSED');
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant insert GAP TRT)','Préparation du traitement GAP_TRT pour le  '||P_NUMPAC);
 --Ajout  dans GAP_TRT
 insert into GAP_TRT (ID_TRT,NUMPAC,PERIODE_PAIE,NUMERO_ECHANGE,MODELE,NATURE,DATE_DEBUT_PAIE,DATE_FIN_PAIE,WORKFLOW_ID,DATE_PREVUE_TRT,DATE_PLANIF_TRT,DATE_DEBUT_TRT,INFO)
 values
 (p_id,P_NUMPAC,p_PERIODEENCOURS,'0000','ALP','CLOTURE',p_dtdebMois,p_finMois,'TGEPAY'||P_NUMPAC||'PACGXP'||p_PERIODEENCOURS||'0000',sysdate,sysdate,sysdate,'CLOTURE');
 
 --GAP_TRT_SUIVI
 FSED.insert_gap_trt_suivi(p_id,'PREPA_CLOTURE',null,'BATCH','CL');
 --BEGIN DIT 37805
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin Supp RELIQ)',' Début de la purge des tables  TGE_RELIQ_INCIDENTS_PAIE, TGE_RELIQ_DONNEES_PAIE, TGE_RELIQ_ELEMENTS_PAIE, TGE_RELIQ_IMPUTATIONS,TGE_RELIQ_PACMAT_TORESEND pour le numpac  '||P_NUMPAC);
 -- les tables TGE_RELIQ_* sont vidées pour le pac en question
 DELETE FROM TGE_RELIQ_INCIDENTS_PAIE  WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_DONNEES_PAIE    WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_ELEMENTS_PAIE   WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_IMPUTATIONS     WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_PACMAT_TORESEND WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_PACMAT_TORESEND_RETRO WHERE NUMPAC = P_NUMPAC;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (End Supp RELIQ)','Fin de de la purge des tables RELIQ pour le  numpac : '||P_NUMPAC);
 --FIN  DIT 37805
 
 -- Mise à jour secupacmat
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Update SECUPACMAT)','Deuxième période de recyclage : Mise à jour de la table SECUPACMAT pour le numpac : '||p_numpac);
 -- MCN : PERIODE_RECYCLAGE passe à 99 en début de Cloture et repasse à 0 à la fin, toute valeur entre 1 ( déclenché par le controle ) et 99 indicque que le matricule est en cours de traitement paie)
 update SECUPACMAT set PERIODE_RECYCLAGE=99 where numpac=p_numpac;
 FSED.insert_gap_trt_suivi(p_id,'PERIODE_RECYCLAGE_2',null,'BATCH','CL');
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant insert LISTE MAT)','Préparation de la liste des matricules');
 -- RSI  Le 20/02/2015 DIT 41197:EVOL: Ajout du type de paie 'GAPSELMA'
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,null from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_PERIODEENCOURS  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and not exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 -- Le 25/04/2015 ajout des mal recyclés (colonne "TRAITE"='R')
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,'R' from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_PERIODEENCOURS  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 -- photos
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant génération photo)','Début de la génération de la photo pour le numpac '||P_NUMPAC||'  à la date '||p_dtdebMois);
 tge_generation_photo(p_id,p_numpac,p_dtdebMois);
 FSED.insert_gap_trt_suivi(p_id,'PHOTO',null,'BATCH','CL');
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après génération photo)','Fin de la génération de la photo pour le numpac '||P_NUMPAC||'  à la date '||p_dtdebMois);
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après génération photo)','Ajout photo_dic_adm_perso pour les mals recyclés '||P_NUMPAC);
 
 --SEUNA2-16226 : Ajout d'une PHOTO_ADM_PERSO pour les mals recyclés déjà envoyés en paie pour eviter d'envoyer une carte 29
 INSERT INTO PHOTO_DIC_ADM_PERSO (NUMPAC,PACMAT,MATRIC)
 SELECT DISTINCT M.NUMPAC,M.PACMAT,DAC.MATRIC 
 FROM TGE_SCHEMA_PRODUCTION A, GAP_TRT B, GAP_TRT_SUIVI C,
 GAP_TRT_LISTE_MAT M, DIC_ADM_CONTRAT DAC, GAP_RECYCL_MATRIC RM , DIC_ADM_CONTRAT_SITU DACS
 WHERE A.NUMPAC       =p_numpac
 AND A.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND A.NUMPAC         =B.NUMPAC
 AND A.MODELE         =B.MODELE
 AND A.NATURE         =B.NATURE
 AND B.ID_TRT         =C.ID_TRT
 AND C.STATUT        IN ('PA','EX','DEMSEA')
 AND NVL(C.CODE_RETOUR_ZPP,'00')='00'
 AND B.NUMERO_ECHANGE<>'0000'
 AND M.ID_TRT=B.ID_TRT
 AND M.NUMPAC=A.NUMPAC
 -- jointure sur dac pour récupérer le matric
 AND DAC.NUMPAC=M.NUMPAC
 AND DAC.PACMAT=M.PACMAT
 -- selectionne les mal recylcés 
 AND RM.NUMPAC=M.NUMPAC
 AND RM.PACMAT=M.PACMAT
 -- jointure avec DACS pour récupére le paiezad
 AND DAC.NUMPAC = DACS.NUMPAC
 AND DAC.PACMAT = DACS.PACMAT
 AND DAC.NUMCNT = DACS.NUMCNT
 -- qui n'ont pas de photo de dic_adm_perso
 AND DAC.MATRIC NOT IN (SELECT MATRIC FROM PHOTO_DIC_ADM_PERSO)
 -- Zadig n'a pas supprimé element A310 alimenté par le retour de paie correspondant a PRFPAI=A 
 AND NOT EXISTS( SELECT 1 FROM DIC_TGE_RESPAIE_UNIQUE DTRU WHERE DTRU.NUMPAC=DACS.NUMPAC AND DTRU.PAIEZAD=DACS.PAIEZAD 
 AND DTFPAI is not null and PRFPAI='A');
 
 insert into bypass_trg_recycl_on_session(date_event, message) values (sysdate, 'Cloture en cours pour le NUMPAC : ' || p_numpac);
 
 -- lecture de la valeur de HISTO_IP dans TGE_REF_PAC
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant lecture REF PER)','Récupération de la valeur de HISTO_IP dans TGE_REF_PAC pour le numpac '||P_NUMPAC );
 select nvl(HISTO_IP,'N') into p_histoIP from TGE_REF_PAC where NUMPAC = p_numpac;
 
 -- purge saisies quai
 FSED.insert_gap_trt_suivi(p_id,'PURGE_QUAIS',null,'BATCH','CL');
 delete from TGE_IMPUTATIONS where numpac=p_numpac and to_date(PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'YYYYMM') and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt=p_id
 and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null );
 
 IF p_histoIP = 'N' THEN
 
 w_req :='DELETE FROM TGE_INCIDENTS_PAIE z WHERE z.numpac='''||p_numpac||''' AND  ';
 if isRetro=1 then
 w_req := w_req || ' ( z.PERIODE <greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req || ' ( z.PERIODE           <=to_date('''||w_per||''',''yyyymm'')';
 end if;
 w_req := w_req||')'||' AND (z.numpac,z.paiezad) IN (SELECT DISTINCT b.numpac,
 d.paiezad FROM GAP_TRT_LISTE_MAT b INNER JOIN DIC_ADM_CONTRAT_SITU d ON d.numpac =b.numpac AND d.pacmat =b.pacmat INNER JOIN TGE_PERIODE_RECUEIL_PAIEZAD t ON d.numpac  =t.numpac AND d.pacmat  =t.pacmat AND d.paiezad   =t.paiezad
 LEFT JOIN SECUPACMAT s ON t.NUMPAC = s.NUMPAC AND s.pacmat  =t.pacmat
 WHERE b.id_trt ='||p_id||' AND ';
 if isRetro=1 then
 w_req := w_req || ' to_date(t.MOIS_PAIE,''YYYYMM'') <= greatest(to_date(NVL( S.PREMIERE_PAIE, ''190101''),''YYYYMM''),to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req ||' to_date(t.MOIS_PAIE,''YYYYMM'') = to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||' AND (z.date_effet <= t.FIN_PERIODE_RECUEIL OR z.TYPE_IP       = ''T'')AND b.traite      IS NULL)';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge incidents )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 --R046
 update TGE_INCIDENTS_PAIE z
 set    z.ACTION_RETRO='H',z.ACTION_RETRO_DATE=null
 WHERE  z.numpac           =p_numpac
 AND z.PERIODE >=greatest(to_date(P_PERIDOE_HISTO_LIMITE,'YYYYMM'),to_date(nvl(P_DEB_HISTO_RETRO,'209912'),'YYYYMM'))
 AND z.PERIODE<=to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.numpac,z.paiezad) IN
 (SELECT DISTINCT b.numpac,
 d.paiezad
 FROM GAP_TRT_LISTE_MAT b,
 DIC_ADM_CONTRAT_SITU d,
 TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE b.id_trt     =p_id
 AND d.numpac       =b.numpac
 AND d.pacmat       =b.pacmat
 AND d.numpac       =t.numpac
 AND d.pacmat       =t.pacmat
 AND d.paiezad      =t.paiezad
 AND to_date(t.MOIS_PAIE,'yyyymm') = to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.date_effet <= t.FIN_PERIODE_RECUEIL
 OR z.TYPE_IP       = 'T')
 --THN
 --AND b.traite      IS NULL
 )
 AND z.date_maj<
 (
 SELECT DATE_TRT from GAP_TRT_DERNIER_ENVOI  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 update TGE_INCIDENTS_PAIE z
 set    ACTION_RETRO='C',
 ACTION_RETRO_DATE =z.date_maj
 WHERE  z.numpac           =p_numpac
 AND z.PERIODE=to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.numpac,z.paiezad) IN
 (SELECT DISTINCT b.numpac,
 d.paiezad
 FROM GAP_TRT_LISTE_MAT b,
 DIC_ADM_CONTRAT_SITU d,
 TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE b.id_trt     =p_id
 AND d.numpac       =b.numpac
 AND d.pacmat       =b.pacmat
 AND d.numpac       =t.numpac
 AND d.pacmat       =t.pacmat
 AND d.paiezad      =t.paiezad
 AND to_date(t.MOIS_PAIE,'yyyymm') = to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.date_effet <= t.FIN_PERIODE_RECUEIL
 OR z.TYPE_IP       = 'T')
 --THN
 --AND b.traite      IS NULL
 )--- Pour les periodes<periodeencours on laisse l'action retro existante
 AND z.date_maj>=
 (
 SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 end if;
 END IF;
 
 w_req :='delete from TGE_DONNEES_PAIE where numpac='''||p_numpac||''' and ' ;
 if isRetro=1 then
 w_req := w_req || '( to_date(PERIODE,''YYYYMM'') < greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req ||' (  to_date(PERIODE,''YYYYMM'') <= to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||') and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt='||p_id||
 ' and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null)';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge donnes )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 ---R046
 update TGE_DONNEES_PAIE z
 set    z.ACTION_RETRO ='H',
 z.ACTION_RETRO_DATE =null
 where z.numpac=p_numpac
 and to_date(z.PERIODE,'YYYYMM')>=greatest(to_date(P_PERIDOE_HISTO_LIMITE,'YYYYMM'),to_date(nvl(P_DEB_HISTO_RETRO,'209912'),'YYYYMM'))
 AND to_date(z.PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'yyyymm')
 AND to_date(z.date_maj,'yyyymmddHH24MI')<
 (
 SELECT DATE_TRT from GAP_TRT_DERNIER_ENVOI  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 ---R046
 update TGE_DONNEES_PAIE z
 set    z.ACTION_RETRO ='C',
 z.ACTION_RETRO_DATE =to_date(z.date_maj,'yyyymmddHH24MI')
 where z.numpac=p_numpac
 AND to_date(z.PERIODE,'YYYYMM')=to_date(p_PERIODEENCOURS,'yyyymm')
 --- Pour les periodes<periodeencours on laisse l'action retro existante
 AND to_date(z.date_maj,'yyyymmddHH24MI')>=
 (
 SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 end if;
 w_req :='delete from TGE_ELEMENTS_PAIE where numpac='''||p_numpac||''' and  ' ;
 if isRetro=1 then
 w_req := w_req || '( to_date(PERIODE,''YYYYMM'') < greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req ||' (  to_date(PERIODE,''YYYYMM'') <= to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||')  and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt='||p_id||
 ' and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null )';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge elements )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 update TGE_ELEMENTS_PAIE z
 set    z.ACTION_RETRO ='H',
 z.ACTION_RETRO_DATE =null
 where z.numpac=p_numpac
 and to_date(z.PERIODE,'YYYYMM')>=greatest(to_date(P_PERIDOE_HISTO_LIMITE,'YYYYMM'),to_date(nvl(P_DEB_HISTO_RETRO,'209912'),'YYYYMM'))
 AND to_date(z.PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'yyyymm')
 AND to_date(z.date_maj,'yyyymmddHH24MI')<
 (
 SELECT DATE_TRT from GAP_TRT_DERNIER_ENVOI  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 
 update TGE_ELEMENTS_PAIE z
 set    z.ACTION_RETRO ='C',
 z.ACTION_RETRO_DATE =to_date(z.date_maj,'yyyymmddHH24MI')
 where z.numpac=p_numpac
 AND to_date(z.PERIODE,'YYYYMM')=to_date(p_PERIODEENCOURS,'yyyymm')
 AND to_date(z.date_maj,'yyyymmddHH24MI')>=
 (
 SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 WHERE e.numpac       =z.numpac
 AND e.PAIEZAD      =z.paiezad
 );
 END IF;
 
 --Nettoyage des annulations de périodes d'emploi si la suppression a été faite avant le dernier passage de paie 
 
 delete from DELETED_PAIEZAD z where numpac=p_numpac AND DATE_SUPPRESSION<
 ( SELECT max (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 ) ;
 
 
 -- purge saisies quai des matricules mal recyclés
 FSED.insert_gap_trt_suivi(p_id,'PURGE_QUAIS_RECY',null,'BATCH','CL');
 
 delete from TGE_IMPUTATIONS z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 
 (  SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 WHERE z.numpac       =e.numpac
 AND z.PAIEZAD      =e.paiezad
 )  and PERIODE<=p_PERIODEENCOURS ;
 
 
 
 IF p_histoIP='N' AND isRetro=0 THEN
 DELETE
 FROM TGE_INCIDENTS_PAIE z
 WHERE z.numpac            =p_numpac
 AND (z.numpac,z.paiezad) IN
 (SELECT DISTINCT t.numpac,
 t.paiezad
 FROM TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE z.numpac     =t.numpac
 AND z.paiezad      =t.paiezad
 AND t.MOIS_PAIE = p_PERIODEENCOURS
 AND (z.date_effet <= t.FIN_PERIODE_RECUEIL
 OR z.TYPE_IP       = 'T')
 )
 AND z.date_maj<(SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 where z.numpac  =e.numpac
 AND   z.PAIEZAD =e.paiezad)
 AND to_date(z.PERIODE)<=to_date(p_PERIODEENCOURS,'YYYYMM');
 
 END IF;
 
 IF isRetro=0 THEN
 delete from TGE_DONNEES_PAIE z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 (
 SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 WHERE z.numpac       =e.numpac
 AND z.PAIEZAD      =e.paiezad
 ) and PERIODE<=p_PERIODEENCOURS ;
 
 delete from TGE_ELEMENTS_PAIE z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 
 (SELECT DATE_TRT from GAP_TRT_MAL_RECYCLES  e
 
 WHERE z.numpac       =e.numpac
 AND  z.PAIEZAD      =e.paiezad
 )  and PERIODE<=p_PERIODEENCOURS ;
 END IF;
 
 if P_DEB_RETRO is null OR to_date(p_PERIODEENCOURS,'YYYYMM') < to_date(P_DEB_RETRO,'YYYYMM') then
 --Recalcul des période de recueil avec les photos de dach et dac avant de changer de mois, pour corriger les saisies tardives
 TGE_ALIM_PERIODE_INDIV(p_id, p_numpac, p_PERIODEENCOURS, NULL, NULL, 'O');
 END IF;
 
 -- M+1 sur TGE_REF_PAC
 update TGE_REF_PAC set periodeencours=to_char(add_months(to_date(periodeencours,'yyyymm'), 1),'yyyymm') where numpac=p_numpac;
 
 merge into TGE_REF_PER a using (select p_numpac as numpac,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'), 1),'yyyymm') as periodeencours from dual) b on (a.numpac=b.numpac and a.periodeencours=b.periodeencours)
 when matched then
 update set a.DATE_DEBUT_MOIS=b.periodeencours||'01',a.DATE_FIN_MOIS= to_char(last_day(to_date(b.periodeencours,'yyyymm')),'yyyymmdd'),a.DERNIER_NUM_ECHANGE=nvl(a.DERNIER_NUM_ECHANGE,'0000')
 when not matched then
 insert (a.numpac,a.periodeencours,a.DATE_DEBUT_MOIS,a.DATE_FIN_MOIS,a.DERNIER_NUM_ECHANGE) values (b.numpac,b.periodeencours,b.periodeencours||'01', to_char(last_day(to_date(b.periodeencours,'yyyymm')),'yyyymmdd') ,'0000'      )
 ;
 -- purge histo technique
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant purge histo)','Début de la purge pour le numpac : '||P_NUMPAC);
 tge_purge_histo(p_numpac,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'), 1),'yyyymm'));
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après purge histo)','Fin de la purge pour le numpac : '||P_NUMPAC);
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin Insert RELIQ)','Début d insertion dans les tables RELIQ_  pour le numpac : '||P_NUMPAC);
 
 -- les tables TGE_RELIQ_* sont vidées pour le pac en question
 tge_insert_reliq (p_id,p_numpac,p_PERIODEENCOURS,isRetro);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (End Insert RELIQ)','Fin d insertion dans les tables RELIQ_  pour le numpac : '||P_NUMPAC);
 
 -- Mise à jour secupacmat
 update SECUPACMAT set PERIODE_RECYCLAGE=0 where numpac=p_numpac;
 FSED.insert_gap_trt_suivi(p_id,'PERIODE_RECYCLAGE_0',null,'BATCH','CL');
 -- purger table matricules en recyclage
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge RECYCL)','Purger table matricules en recyclage  pour le numpac : '||P_NUMPAC);
 DELETE from GAP_RECYCL_MATRIC where numpac=p_numpac ;
 DELETE from TGE_MODIF_PACMAT_TORESEND where numpac=p_numpac ;
 DELETE from GAP_SELECTION_PACMAT where nomtraitement='RECYCLAG' and numpac=p_numpac;
 
 --Historiser les periodes rétro max par pacmat
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Histo Periode RETRO MAX)','Historiser les periodes rétro max par pacmat pour le numpac : '||P_NUMPAC);
 
 MERGE INTO GAP_TRT_LISTE_MAT_HISTO T USING
 (select numpac,pacmat,min(periode_retro) as periode_retro from
 (select numpac,pacmat,periode_retro from gap_retro_matric where numpac =p_numpac
 union all
 select numpac,pacmat,periode_retro from gap_selection_retro where numpac =p_numpac
 )group by numpac,pacmat)i ON (i.NUMPAC=t.numpac and  i.PACMAT=t.pacmat and  t.PERIODE_PAIE = p_PERIODEENCOURS)
 when matched then update
 set RETRO_MAX =i.periode_retro ;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge RETRO)','Purger table matricules Rétro  pour le numpac : '||P_NUMPAC);
 -- purger table matricules  RETRO
 if isRetro=1 then
 
 BEGIN
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV TGE_MODIF_PACMAT_RETRO) ','Sauvegarde de la table TGE_MODIF_PACMAT_RETRO avant purge' );
 
 w_req :='Create TABLE TGE_MODIF_PACMAT_RETRO_'||P_PERIODEENCOURS||' as select * from TGE_MODIF_PACMAT_RETRO '  ;
 execute_immediate_string (w_req,0);
 EXCEPTION
 WHEN OTHERS THEN
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV TGE_MODIF_PACMAT_RETRO) ','la table TGE_MODIF_PACMAT_RETRO_'||P_PERIODEENCOURS||' existe déja ' );
 END ;
 --R046 THN
 DELETE from TGE_MODIF_PACMAT_RETRO z where z.numpac=p_numpac and not exists(select 1 from GAP_TRT_MAL_RECYCLES e  WHERE z.numpac =e.numpac AND z.pacmat=e.pacmat and z.DATE_MAJ>e.DATE_TRT) ;
 DELETE from GAP_RETRO_MATRIC z where z.numpac=p_numpac and not exists (select 1 from TGE_MODIF_PACMAT_RETRO e  WHERE z.numpac =e.numpac AND z.pacmat=e.pacmat);
 DELETE from GAP_RETRO_MATRIC_TRAITE where numpac=p_numpac ;
 DELETE from GAP_SELECTION_RETRO z where  z.numpac=p_numpac   and not exists(select 1 from GAP_TRT_MAL_RECYCLES e  WHERE z.numpac =e.numpac AND z.pacmat=e.pacmat);
 --Fin R046
 --- Maj de la période pour les lignes non supprimée et mal recyclés
 --on duplique les lignes qui ont dépassé la limite rétro si c'est possible
 INSERT INTO TGE_MODIF_PACMAT_RETRO z select numpac,pacmat,GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat),table_maj,sysdate from TGE_MODIF_PACMAT_RETRO y where y.numpac=p_numpac and periode_retro < GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat)  and (numpac,pacmat,GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat),table_maj) not in (select x.numpac,x.pacmat,x.periode_retro,x.table_maj from TGE_MODIF_PACMAT_RETRO x where x.numpac= p_numpac );
 INSERT into GAP_RETRO_MATRIC (numpac,pacmat,periode_retro,min_code_chrono,paiezad_retro ) select numpac,pacmat,GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat),min_code_chrono ,paiezad_retro from gap_retro_matric y where y.numpac=p_numpac and periode_retro < GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat) and (numpac,pacmat,GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat),min_code_chrono ) not in (select numpac,pacmat,GET_DEB_HISTO_PACMAT(y.numpac,y.pacmat),min_code_chrono from gap_retro_matric x where x.numpac=p_numpac);
 INSERT INTO GAP_SELECTION_RETRO     (numpac,periode_paie,periode_retro,aoid,pacmat,date_maj) SELECT numpac,periode_paie,get_deb_histo_pacmat(y.numpac, y.pacmat),aoid,pacmat,sysdate FROM GAP_SELECTION_RETRO y WHERE y.numpac = p_numpac AND periode_retro < get_deb_histo_pacmat(y.numpac, y.pacmat) AND ( numpac,periode_paie,get_deb_histo_pacmat(y.numpac, y.pacmat),aoid,pacmat ) NOT IN ( SELECT numpac,periode_paie,periode_retro,aoid,pacmat FROM GAP_SELECTION_RETRO x WHERE x.numpac = p_numpac );
 
 --on supprime ensuite ce qui est hors période.
 DELETE TGE_MODIF_PACMAT_RETRO z where z.numpac=p_numpac and z.periode_retro < GET_DEB_HISTO_PACMAT(z.numpac,Z.pacmat) ;
 DELETE GAP_RETRO_MATRIC z where z.numpac=p_numpac and z.periode_retro < GET_DEB_HISTO_PACMAT(z.numpac,Z.pacmat) ;
 DELETE GAP_SELECTION_RETRO z where z.numpac=p_numpac and z.periode_retro < GET_DEB_HISTO_PACMAT(z.numpac,Z.pacmat) ;

 DELETE FROM GAP_TRT_MOIS_RETRO where  numpac=p_numpac;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin Insc Retro RELIQ)','Début d inscription retro des tables RELIQ_  pour le numpac : '||P_NUMPAC);
 tge_retro_inscription_reliq (p_id,p_numpac,p_PERIODEENCOURS);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (End Insc Retro RELIQ)','Fin d inscription retro des tables RELIQ_ pour le numpac : '||P_NUMPAC);
 END IF;
 -- RSI Le 20/02/2015 DIT 41197 : Supprimer pour le pac en cours des matricules
 -- sélectionnés dans GAP_SELECTION_PACMAT pour les natures de traitements associés à GAPSELMA dans TGE_SCHEMA_PRODUCTION
 DELETE from GAP_SELECTION_PACMAT
 where numpac= p_numpac
 and nomtraitement in (select distinct NATURE from TGE_SCHEMA_PRODUCTION where type_paie =  'GAPSELMA' and date_fin is null and numpac=p_numpac);
 
 --On réactive les triggers pour que la colonne période de paie des incidents soit recalculée
 delete bypass_trg_recycl_on_session;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant alimentation période recueil)','Début de la procédure d''alimentation des périodes de recueil pour le numpac '||P_NUMPAC);
 IF to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'), 1),'yyyymm') = P_DEB_RETRO THEN
 TGE_ALIM_PERIODE_INDIV(p_id, p_numpac, greatest(P_PERIDOE_HISTO_LIMITE,P_DEB_HISTO_RETRO), NULL);
 ELSE
 TGE_ALIM_PERIODE_INDIV(p_id, p_numpac, TO_CHAR(ADD_MONTHS(TO_DATE(p_periodeencours,'yyyymm'), 1),'YYYYMM'), NULL);
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après alimentation période recueil)','Fin de la procédure d''alimentation des périodes de recueil pour le numpac '||P_NUMPAC);
 
 --On désactive à nouveau les triggers
 insert into bypass_trg_recycl_on_session(date_event, message) values (sysdate, 'Cloture en cours pour le NUMPAC : ' || p_numpac);
 
 -- recalcul du flag SECUPACMAT.PRESENT_FICHIER_PAIE
 R_PRESENT_FICHIER_PAIE( p_numpac , null );
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (end)','Fin de la clôture pour le numpac '||P_NUMPAC);
 FSED.insert_gap_trt_suivi(p_id,'CLOTURE_OK',null,'BATCH','CL');
 
 exception
 when others then
 FSED.FSED_ERREUR(p_id,'TGE_CLOTURE (raise)',P_NUMPAC,SQLCODE||'-'||SQLERRM);
 update SECUPACMAT set PERIODE_RECYCLAGE=1 where numpac=p_numpac;
 raise;
 END TGE_CLOTURE;##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_30
=SQL=
create or replace PROCEDURE TGE_CONTROLE_30 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 -- Valeurs attendues : EC/ECS -> écran création (S en mode SimuPaie),  EM/EMS -> écran modification (S en mode SimuPaie), GAP -> création en sous-marin,
 -- I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch, MP -> création depuis la Market Place
 , P_TYPE_ACTION IN VARCHAR2
 ) AS
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 clWhere varchar2(1000);
 -- Pour les merge, la clause where ne doit pas inclure la colonne ERREURS, on gère des clauses spécifiques
 clWhereMerge varchar2(1000);
 clWhereMergeErreur varchar2(250);
 
 req varchar2(2000);
 w_exist_element NUMBER ;
 w_err VARCHAR2(2000);
 w_param_longueur VARCHAR2(10);
 w_id_natcol varchar2(4000);
 
 BEGIN
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||''' and EI.code_element not in (''B690'',''B691'') ';
 
 if p_numligne is not null then
 	clwhere:=clwhere||' AND EI.NUMLIGNE='||p_numligne;
 end if;

 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controlées 
 clwhere:=clwhere || ' AND (EI.STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR EI.STATUT = ''TRANS'') ';
  
 clWhereMerge := clwhere;
 clWhereMergeErreur := '';
 
 IF p_type_action = 'VI' and p_login <> 'BATCH' then
   -- A la validation d'import Web, on ne va passer que sur les lignes qui ne sont pas déjà en erreur.
   -- Certaines lignes sont déjà en erreur et on ne veut pas les retraiter (sinon double message)
   clwhere := clwhere || ' and EI.ERREURS is null';
   clWhereMergeErreur := ' where EI.ERREURS is null';
 END IF;
 
 IF p_login ='BATCH' THEN 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées. Seulement pour le BATCH, car dans les autres cas il y a des contrôles
 -- qui sont fait en amont des contrôles PL/SQL (côté Java)
 	req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS = '''' WHERE '||clwhere;
 	EXECUTE_IMMEDIATE_STRING( req,0);
 	
 -- Contrôle que le collaborateur est cohérent : date effet / paiezad. En Batch, on n'utilise pas IdentifiantCollab pour récupérer les informations
 -- du collaborateur, on prend juste ce qui est dans le fichier. On doit donc contrôler que le collab existe
  	req:= 'update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS, '''||replace(get_message_erreur('STD', 'STD00046', p_codlang),'''','''''')||''',EI.MATRICULE||''|''||EI.NUMPAC||''|''||EI.PACMAT||''|''||EI.PAIEZAD||''|''||EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere;
  	req:= req || ' and EI.NUMPAC is not null and EI.PAIEZAD is not null';
  	req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=EI.NUMPAC and DACS.PAIEZAD=EI.PAIEZAD';
  	req:= req || ' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
  	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Met une erreur sur les lignes en doublon dans le fichier d'import
 IF p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00032',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' and  P.LOGIN='''||p_login||''' and P.ERREURS is null';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*'') )in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*'') from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' and t.ERREURS is null group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- On conserve la ligne dont le numLigne est le max dans la liste des doublons (on enlève le message d'erreur)
 IF p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=null WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' AND  P.LOGIN='''||p_login||''' ';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*''),numligne) in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*''),max(numligne) as numligne from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 IF p_type_action = 'EC' or p_type_action = 'ECS' or p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
   -- Non existe EZ (seulement en création ou import. Les tests d'existence en modification sont exécutés en Java)
   -- Si l'élément existant a comme DERNIER_CODE_OPE = 'S', alors message ZEZ00040
   -- sinon ZEZ00030
   req :='merge into TGE_IMPORT_ELEMENTS EI using TGE_ELEMENTS_PAIE E on (';
   req := req || clwhereMerge;
   req := req ||' and E.NUMPAC = EI.NUMPAC and E.PAIEZAD = EI.PAIEZAD and E.PERIODE = EI.PERIODE';
   --req := req ||' and E.TYPE_TRAITEMENT = EI.TYPE_TRAITEMENT and E.CODE_ELEMENT = EI.CODE_ELEMENT and E.INDICATIF = EI.INDICATIF AND E.CODE_REMPLACEMENT=NVL(EI.CODE_REMPLACEMENT,''*''))';
   req := req ||' and E.TYPE_TRAITEMENT = EI.TYPE_TRAITEMENT and E.CODE_ELEMENT = EI.CODE_ELEMENT and E.INDICATIF = EI.INDICATIF AND E.CODE_REMPLACEMENT=NVL(EI.CODE_REMPLACEMENT,''*'')';
   -- On rajoute une clause sur la table TGE_IMPORT_ANNULATION car avant l'insertion il peut y avoir eu des cartes d'annulation (FSED) et donc l'élément sera supprimé
   req := req ||' and not exists (select 1 from  TGE_IMPORT_ANNULATION A where A.LOGIN = '''||P_LOGIN||''' and A.DATE_IMPORT = '''||P_DATE_IMPORT||''' and A.NUMPAC = E.NUMPAC';
   req := req ||' and A.PAIEZAD = E.PAIEZAD and A.PERIODE = E.PERIODE and A.ORIGINE = E.ORIGINE';
   -- Lors de l'annulation, on ne supprime pas les EZ de remplacement si MODE_3060 est différent de 'F'
   req := req ||' and ((exists (select 1 from TGE_REF_ORIGINE_GTA where NUMPAC = E.NUMPAC and CODE_ORIGINE = E.ORIGINE';
   req := req ||' and MODE_3060 != ''F'' ) and E.CODE_REMPLACEMENT = ''R'') or E.CODE_REMPLACEMENT = ''*'' ))';
   req := req ||' )';
   req := req ||' when matched then update set ERREURS ='; 
   req := req ||' case';
   req := req ||' when E.DERNIER_CODE_OPE = ''S'' then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00040',p_codlang),'''','''''')||''',EI.CODE_ELEMENT||''|''||TGE_IMPORT_FORMATE_DATE(EI.PERIODE, EI.LOGIN, ''YYYYMM'', ''MM.YYYY'')||''|''||EI.INDICATIF,'''||p_codlang||''')';
   req := req ||' else TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00030',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF||''|''||TGE_IMPORT_FORMATE_DATE(PERIODE, LOGIN, ''YYYYMM'', ''MM.YYYY''),'''||p_codlang||''')';
   req := req ||' end';
   req:= req || clWhereMergeErreur;
   EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Numpac non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PaieZad non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Periode non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Type Traitement non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Code_element non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00016',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_ELEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Date d'effet non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00314',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_EFFET is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Longueur Matricule
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00089',p_codlang),'''','''''')||''',MATRICULE,'''||p_codlang||''') where '||clwhere||' AND MATRICULE is NOT null AND LENGTH (MATRICULE)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Origine
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',ORIGINE,'''||p_codlang||''') where '||clwhere||' AND ORIGINE is NOT null AND LENGTH (ORIGINE)>1 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --
 -- Longueur LOGIN (sauf pour le Batch)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00107',p_codlang),'''','''''')||''',LOGIN,'''||p_codlang||''') where '||clwhere||' AND LOGIN!=''BATCH'' AND LENGTH (LOGIN)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie TGE00310
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00310',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 -- permet de gérer les cas où DATE_EFFET ou PERIODE ne sont pas des dates valides
 req:= req ||' and (select case when to_date(EI.DATE_EFFET,''YYYYMMDD'') > last_day(to_date(EI.PERIODE,''YYYYMM'')) then ''O'' else ''N'' end from dual where is_date(EI.DATE_EFFET, ''YYYYMMDD'')=1 and is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_type_action = 'ECS' or p_type_action = 'EMS' then
	-- En SimuPaie, on contrôle seulement l'interdiction de la saisie dans la passé : TGE00311 (il n'y a pas de passé, rétro) 
	req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	req:= req ||' where '||clwhere || ' ';
	-- permet de gérer les cas où PERIODE n'est pas une date valide 
	req:= req ||' and (select case when to_date(EI.PERIODE,''YYYYMM'') < (select to_date(P.PERIODEENCOURS,''YYYYMM'') from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC) then ''O'' else ''N'' end from dual where is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
	EXECUTE_IMMEDIATE_STRING( req,0);
 ELSE
	 -- période de paie pour les EZ : TGE00311 / ZEZ00037 / TGE00336 / TGE00337
	 req:='merge into TGE_IMPORT_ELEMENTS EI using';
	 req:= req ||' (select P1.NUMPAC, P1.PERIODEENCOURS, P1.DEB_RETRO, GREATEST(P1.DEB_HISTO_RETRO,NVL( S.PREMIERE_PAIE, ''190101'')) AS DEB_HISTO_RETRO, P1.NB_MOIS_RETRO, S.PACMAT,';
	 -- Pour le calcul de la limite rétro, on ne tient pas compte du max entre DEB_HISTO_RETRO et PERIODEENCOURS - NB_MOIS
	 -- car c'est le test sur la DEB_HISTO_RETRO et le message TGE00336 qui sera pris en compte
	 req:= req ||' TO_CHAR(ADD_MONTHS(TO_DATE(P1.PERIODEENCOURS, ''YYYYMM''), - P1.NB_MOIS_RETRO), ''YYYYMM'') AS LIMITE_RETRO '; 
	 req:= req ||' from TGE_REF_PAC P1 LEFT JOIN SECUPACMAT S ON P1.NUMPAC = S.NUMPAC ) P';
	 req:= req ||' on (';
	 req:= req || clwhereMerge;
	 req:= req ||' and EI.PERIODE < P.PERIODEENCOURS';
	 req:= req ||' and ( P.DEB_RETRO IS NULL or P.PERIODEENCOURS < P.DEB_RETRO';
	 IF not p_type_action = 'GAP' then
	   -- Pour les éléments créés en sous-marin depuis la GAP, on ne teste pas le caractère CALCUL_RETRO de l'élément, ni la cohérence entre la période et la date d'effet
	   req:= req ||' or EI.PERIODE <> substr(EI.DATE_EFFET, 0, 6)';
	 END IF;
	 req:= req ||' or EI.PERIODE < P.DEB_HISTO_RETRO or EI.PERIODE < P.LIMITE_RETRO)';
	 req:= req ||' AND ( EI.PACMAT is  null or EI.PACMAT = P.PACMAT )'; 
	 req:= req ||' and EI.NUMPAC = P.NUMPAC)'; 
	 req:= req ||' when matched then update set EI.ERREURS = case';
	 req:= req ||' when P.DEB_RETRO is null or P.PERIODEENCOURS < P.DEB_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 req:= req ||' when EI.PERIODE < P.DEB_HISTO_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',to_char(to_date(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' when EI.PERIODE < P.LIMITE_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.LIMITE_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' end';
	 req:= req || clWhereMergeErreur;
	 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Format date d'effet TGE00315
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00315',p_codlang),'''','''''')||''',EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere||' AND EI.DATE_EFFET is not null and IS_DATE(EI.DATE_EFFET,''YYYYMMDD'')=0';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- IdPacMat non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00102',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND (RPAD(NUMPAC,6) || PACMAT) is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur NumPac
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',numpac,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(NUMPAC),0)>6 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur PaieZad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',NULL,PAIEZAD) where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format Periode
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00328',p_codlang),'''','''''')||''',PERIODE,'''||p_codlang||''') WHERE '||clwhere||' AND PERIODE is NOT null AND IS_DATE(PERIODE,''YYYYMM'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Cle_import
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00099',p_codlang),'''','''''')||''',LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE,'''||p_codlang||''') WHERE '||clwhere||' AND LOGIN IS NOT NULL AND DATE_IMPORT IS NOT NULL AND NUMLIGNE IS NOT NULL AND  LENGTH(LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE) >70 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur IdPacMat
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00103',p_codlang),'''','''''')||''',RPAD(NUMPAC,6) || PACMAT,'''||p_codlang||''') WHERE '||clwhere||' AND NUMPAC   IS NOT NULL AND PACMAT IS NOT NULL AND  LENGTH(RPAD(NUMPAC,6) || PACMAT) >14 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle NATCOL doit avoir la valeur SAL ou STA TGE00027
 select VALVAR into w_id_natcol from sys_varsys where module='STD' and codvar='ID_NATCOL';
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00027',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req := req ||' and (select DAC.'||w_id_natcol||' from DIC_ADM_CONTRAT DAC inner join DIC_ADM_CONTRAT_SITU DACS on (DACS.NUMPAC = DAC.NUMPAC and DACS.PACMAT = DAC.PACMAT and DACS.NUMCNT = DAC.NUMCNT) where DACS.PAIEZAD = EI.PAIEZAD and DAC.NUMPAC = EI.NUMPAC';
-- Si le PAC n'est pas MPE, le couple NUMPAC/PAIEZAD ne suffit pas à déterminer un contrat, on utilise la date d'effet
 req := req ||' and case when ((select MPE from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC) = ''N'' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DAC.DSDCN and nvl(DAC.DSFCN, to_date(''20991231'', ''YYYYMMDD'')))';
 req := req ||' or (select MPE from TGE_REF_PAC P2 where P2.NUMPAC = EI.NUMPAC) <> ''N'' then 1 else 0 end = 1) not in (''SAL'', ''STA'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_login = 'BATCH' THEN
 -- Autorisation paiezad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.paiezad IS NOT NULL AND EI.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Il ne doit pas y avoir de pac * dans la table TGE_REF_DICOZ
 -- Existe code_element
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00017',p_codlang),'''','''''')||''',code_element,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND EI.code_element is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT= EI.CODE_ELEMENT)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Existe type_traitement
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND  EI.type_traitement is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_TYPETRT TT where TT.CODETYPTRT = EI.TYPE_TRAITEMENT';
 req:= req || ' and (';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT = EI.TYPE_TRAITEMENT) > 0 and TT.NUMPAC = EI.NUMPAC)';
 req:= req ||   ' or';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT= EI.TYPE_TRAITEMENT) = 0 and TT.NUMPAC=''*'')';
 req:= req || ' ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format sens
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00038',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND sens IS NOT NULL AND sens NOT IN (''+'',''-'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Autorisation sens (Valeur 'Aucun' attendue pour les TYPE = 'A')
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00015',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' and EI.SENS is not null and EI.SENS in (''+'',''-'') ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT= EI.CODE_ELEMENT and DZ.TYPE = ''A'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 /** Début des tests sur l'INDICATIF */
 -- On fait les tests sur l'indicatif qu'en création ou import. En modification, l'indicatif ne change pas.
 IF p_type_action = 'EC' or p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null AND EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''COT'',''CZR'',''CTM'',''CRA''))';
 req:= req || ' and not exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = EI.INDICATIF)';
 EXECUTE_IMMEDIATE_STRING( req,0);

  -- OCC1 > 0 et GROUPE = TXR : Existe code_rubrique
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00334',p_codlang),'''','''''')||''',EI.INDICATIF,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null AND EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''TXR''))';
 req:= req || ' and not exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = EI.NUMPAC and R.CODERUB = EI.INDICATIF)';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Caisse référence interdite si on est NewCot (TGE_REF_PAC.OLDCOT = 'N')
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null and EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''COT'',''CZR'',''CTM'',''CRA''))';
 req:= req || ' and exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = EI.INDICATIF and RC.CODEGROUP = ''R'')';
 req:= req || ' and nvl((select P.OLDCOT from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC), ''N'') != ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - longueur attendue 6
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''MM:CCC'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null  and length(EI.INDICATIF) != 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - MM doit correspondre à un mois
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00011',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null AND EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and (IS_NUMBER(substr(EI.INDICATIF, 0, 2)) is null or IS_DATE(substr(EI.INDICATIF,0, 2),''MM'') !=1)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null and EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 req:= req || ' and not exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = substr(EI.INDICATIF, 4))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Caisse référence interdite
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null and EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''HCO''))';
 req:= req || ' and exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = substr(EI.INDICATIF, 4) and RC.CODEGROUP = ''R'')';
 req:= req || ' and nvl((select P.OLDCOT from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC), ''N'') != ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) != 7 or IS_NUMBER(substr(EI.INDICATIF,7,1)) is null or IS_DATE(substr(EI.INDICATIF, 0, 6),''YYYYMM'') !=1 )';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 = 0 and DZ.GROUPE = ''HIS'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere;
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 = 0 and DZ.GROUPE = ''HIS'')';
 -- On gère avec un "exist/from dual" pour effectuer les tests > 1 et < 9 sans que ça plante si la valeur de "N" n'est pas un nombre valide
 req:= req || ' and exists (select 1 from dual where length(EI.INDICATIF) = 7 and (IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or to_number(substr(EI.INDICATIF, 7, 1)) < 1 or to_number(substr(EI.INDICATIF, 7, 1)) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN:XX'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) != 10 or IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or IS_DATE(substr(EI.INDICATIF, 0, 6),''YYYYMM'') !=1 ';
 req:= req || ' or substr(EI.INDICATIF,8,1) != '':'' or IS_NUMBER(substr(EI.INDICATIF,9,2)) is null)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere;
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'')';
 -- On gère avec un "exist/from dual" pour effectuer les tests > 1 et < 9 sans que ça plante si la valeur de "N" n'est pas un nombre valide
 req:= req || ' and exists (select 1 from dual where length(EI.INDICATIF) = 10 and (IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or to_number(substr(EI.INDICATIF, 7, 1)) < 1 or to_number(substr(EI.INDICATIF, 7, 1)) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - XX doit être compris entre 01 et TGE_REF_DICOZ.OCC2
 -- Utilisation d'un merge afin de pouvoir utiliser DZ.OCC2 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 AND DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'' ';
 req:= req || ' and (length(EI.INDICATIF)) = 10 and IS_NUMBER(substr(EI.INDICATIF,7,1)) is not null and IS_DATE(substr(EI.INDICATIF,0,6),''YYYYMM'') !=0 and (IS_NUMBER(substr(EI.INDICATIF,9,2)) is null ';
 req:= req || ' or to_number(substr(EI.INDICATIF,9,2)) < 1 or to_number(substr(EI.INDICATIF,9,2)) > DZ.OCC2 )) ';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00013',p_codlang),'''','''''')||''',DZ.OCC2,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur; 
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''AAMM+Code Chrono'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) !=10 ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, partie AAMM non valide
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00035',p_codlang),'''','''''')||''',''AAMM+Code Chrono|AAMM'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) = 10 and IS_DATE(substr(EI.INDICATIF, 0, 4),''YYMM'') != 1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, Code chrono n'existe pas pour le collaborateur
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00034',p_codlang),'''','''''')||''',substr(Ei.indicatif,5),'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) = 10 and IS_DATE(substr(EI.INDICATIF, 0, 4),''YYMM'') = 1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 req:= req || ' and not exists (select 1 from DIC_ADM_CONTRAT_SITU where NUMPAC = EI.NUMPAC and PACMAT = EI.PACMAT and CODE_CHRONO  = substr(EI.INDICATIF, 5))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu SSAAMM
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMM'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and IS_DATE(EI.INDICATIF,''YYYYMM'') !=1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC2 = 0 and DZ.OCC1 = 13 and DZ.GROUPE not in (''COT'',''CZR'',''CTM'',''CRA'',''HCO'',''HIS'',''HCP'',''HC2'',''TXR'',''CRF'',''CAA'',''CPP''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_ELEMENT commence par 'R' et OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR /CRF / CAA / CPP: Format indicatif attendu compris entre (PERIODE -12 mois) et (PERIODE - 1 mois)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00035',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.CODE_ELEMENT is not null and length(EI.CODE_ELEMENT) = 4 and EI.CODE_ELEMENT like ''R%'' ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC2 = 0 and DZ.OCC1 = 13 and DZ.GROUPE not in (''COT'',''CZR'',''CTM'',''CRA'',''HCO'',''HIS'',''HCP'',''HC2'',''TXR'',''CRF'',''CAA'',''CPP''))';
 -- permet de gérer les cas où INDICATIF n'est pas une date valide
 req:= req || ' and (select case when (to_date(EI.INDICATIF,''YYYYMM'') > add_months(to_date(EI.PERIODE,''YYYYMM''),-1) or to_date(EI.INDICATIF,''YYYYMM'') < add_months(to_date(EI.PERIODE,''YYYYMM''),-12)) then ''O'' else ''N'' end from dual where IS_DATE(EI.INDICATIF, ''YYYYMM'')=1) = ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et OCC1 <> 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu entre 1 et OCC1 
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.OCC1 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC1 <> 13';
 req:= req || ' and DZ.GROUPE not in (''HIS'',''HCO'',''COT'',''CZR'',''CTM'',''CRA'',''DFR'', ''HCP'', ''HC2'', ''TXR'',''CRF'',''CAA'',''CPP'')';
 req:= req || ' and (is_number(EI.INDICATIF) is null or to_number(EI.INDICATIF) < 1 or to_number(EI.INDICATIF) > DZ.OCC1))';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00014',p_codlang),'''','''''')||''',DZ.OCC1,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- GROUPE in CRF / CAA / CPP : Format indicatif attendu alphanumerique <= 2 Caractères
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00343',p_codlang),'''','''''')||''',''XX=alphanumérique'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) > 2 or not regexp_like(EI.INDICATIF, ''^[a-zA-Z0-9]+$''))';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.GROUPE in (''CRF'',''CAA'',''CPP''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 -- Fin tests sur l'indicatif
 
 -- Format valeur : longueur valide (TYPE = A ou N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00006',p_codlang),'''','''''')||''',(select distinct(oz.longueur) from tge_ref_dicoz oz where oz.element = ei.code_element and ei.numpac =oz.numpac and oz.type in (''A'',''N'',''B'')),'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req ||   ' and (';
 req:= req ||   ' ((DZ.TYPE = ''A'' or DZ.TYPE = ''B'') and length(EI.VALEUR) > DZ.LONGUEUR)';
 req:= req ||   ' or (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16) and length(EI.VALEUR) > DZ.LONGUEUR)';
 req:= req ||   ')';
 req:= req || ' )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : nombre signé(TYPE = N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR04',p_codlang),'''','''''')||''',EI.VALEUR,'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req ||   ' and ( (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16)) or (DZ.TYPE = ''B'')) ';
 req:= req ||   ' and (regexp_like(EI.VALEUR, ''^[-+]+.*''))';
 req:= req || ' )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : partie entière <= TGE_REF_DICOZ.LONGUEUR (TYPE =P)
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC ';
 req:= req || ' and (DZ.TYPE = ''P'' and is_number(EI.VALEUR) is not null and (((INSTR(replace(EI.VALEUR,''.'','',''),'','')-1)> DZ.LONGUEUR) or (INSTR(replace(EI.VALEUR,''.'','',''),'','')= 0 and length(EI.VALEUR) > DZ.LONGUEUR))  ) ';
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR02',p_codlang),'''','''''')||''', EI.VALEUR||''|''||DZ.LONGUEUR,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : partie décimale <= TGE_REF_DICOZ.NBDECI (TYPE =P)
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC ';
 req:= req || ' and (DZ.TYPE = ''P'' and INSTR(replace(EI.VALEUR,''.'','',''),'','') > 0 and length(EI.VALEUR)-INSTR(replace(EI.VALEUR,''.'','',''),'','')> DZ.NBDECI)'; 
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR01',p_codlang),'''','''''')||''', EI.VALEUR||''|''||(DZ.NBDECI),'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- Format valeur : nombre non décimal (TYPE = N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00007',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null and (is_number(EI.VALEUR) is null or instr(EI.VALEUR, '','') > 0 or instr(EI.VALEUR, ''.'') > 0)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC'; 
 req:= req ||   ' and (DZ.TYPE = ''B'' or (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : date ne respectant pas la longueur (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.LONGUEUR dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req || ' and EI.VALEUR is not null and DZ.TYPE = ''N'' and DZ.MASQUE>=1 AND DZ.MASQUE<=16';
 req:= req || ' and length(EI.VALEUR) != DZ.LONGUEUR';
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00008',p_codlang),'''','''''')||''',DZ.LONGUEUR,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : date pas dans bon format (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.MASQUE dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC'; 
 req:= req || ' and DZ.TYPE = ''N'' AND DZ.MASQUE >= 1 AND DZ.MASQUE <= 16';
 req:= req || ' and length(EI.VALEUR) = DZ.LONGUEUR and (';
 req:= req || ' (DZ.MASQUE =1 AND (IS_DATE(EI.VALEUR,''DDMMYYYY'')!=1 AND EI.VALEUR<>''00000000'')) OR';
 req:= req || ' (DZ.MASQUE =2 AND (IS_DATE(EI.VALEUR,''MMYYYY'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =3 AND (IS_DATE(EI.VALEUR,''YYYYMM'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =4 AND (IS_DATE(EI.VALEUR,''DD'')!=1 AND EI.VALEUR<>''00'' ) ) OR';
 req:= req || ' (DZ.MASQUE =5 AND (IS_DATE(EI.VALEUR,''MM'')!=1 AND EI.VALEUR<>''00'')) OR';
 req:= req || ' (DZ.MASQUE =6 AND (IS_DATE(EI.VALEUR,''YYYY'')!=1 AND EI.VALEUR<>''0000'' )) OR';
 req:= req || ' (DZ.MASQUE =7 AND (IS_DATE(EI.VALEUR,''YYYYMMDD'')!=1 AND EI.VALEUR<>''00000000'')) OR';
 req:= req || ' (DZ.MASQUE =8 AND (IS_DATE(EI.VALEUR,''DDMMYY'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =9 AND (IS_DATE(EI.VALEUR,''MMYY'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =10 AND (IS_DATE(EI.VALEUR,''YYMM'')!=1 AND EI.VALEUR<>''0000'' )) OR';
 req:= req || ' (DZ.MASQUE =11 AND (IS_DATE(EI.VALEUR,''YY'')!=1 AND EI.VALEUR<>''00'')) OR';
 req:= req || ' (DZ.MASQUE =12 AND (IS_DATE(EI.VALEUR,''YYMMDD'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =13 AND( IS_DATE(EI.VALEUR,''DDYY'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =14 AND (IS_DATE(EI.VALEUR,''DDMM'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =15 AND (IS_DATE(EI.VALEUR,''MMDD'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =16 AND (IS_DATE(EI.VALEUR,''MMDDYYYY'')!=1 AND EI.VALEUR<>''00000000''))';
 req:= req || '))';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00024',p_codlang),'''','''''')||''',TGE_VALEUR_FORMAT_DATE(DZ.MASQUE),'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : nombre attendu (TYPE = P)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00009',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.VALEUR is not null and is_number(EI.VALEUR) is null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.TYPE = ''P'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Controle Origine et mode_3060 : TGE00317
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00317',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and EI.CODE_REMPLACEMENT = ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''R'' and G.MODE_3060 <> ''F'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF P_TYPE_ACTION = 'EM' or p_type_action = 'EMS' THEN
 -- Ce test n'est à faire qu'en modification (EM), mais pas à la création (EC ou I)
 -- Controle Origine et mode_3060 : TGE00318
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00318',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and nvl(EI.CODE_REMPLACEMENT, ''*'') <> ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''W'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Mise à jour de l'élément autorisée ZEZ00005 seulement si on n'est pas en simulation
 /*      
  	 	 - Si on est en simulation
  	 	 - Si l'élément a une ORIGINE = '&'
         - sinon CODEMODIF doit être égale à 2 et :
            - soit l'élément n'est pas présent dans MAPDO
            - soit il est présent dans TGE_REF_MAPDO et il doit avoir TGE_REF_MAPDO.OCCURRENCE like '%!%' ou TGE_REF_MAPTA.ALLERRETOUR = 'R'
 */
 IF p_type_action <> 'ECS' and p_type_action <> 'EMS' then
 	req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00005',p_codlang),'''','''''')||''',EI.CODE_ELEMENT ,'''||p_codlang||''') where '||clwhere;
 	req:= req || ' and EI.CODE_ELEMENT is not null and (EI.ORIGINE is null or EI.ORIGINE <> ''&'') and not exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.CODEMODIF =''2'' ';
 	req:= req || ' and EI.NUMPAC = DZ.NUMPAC ';
 	-- L'élément n'est pas présent dans MAPDO (pour le numpac ou le pac *)
 	req:= req || ' and (DZ.ELEMENT not in (select ELEMENT from TGE_REF_MAPDO DO2 where (((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO2.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO2.NUMPAC = ''*''))) ';
 	-- Si l'élément est présent dans MAPDO alors TGE_REF_MAPDO.OCCURENCE doit contenir '!'
 	-- ou TGE_REF_MAPTA.ALLERRETOUR = 'R' pour être modifiable
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO DO left outer join TGE_REF_MAPTA TA on DO.TABLEGXP = TA.TABLEPARAM where DO.ELEMENT = DZ.ELEMENT ';
 	req:= req || ' and (((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO.NUMPAC = ''*'')) ';
 	req:= req || ' and (((select count(*) from TGE_REF_MAPTA where NUMPAC = DZ.NUMPAC and TABLEPARAM = DO.TABLEGXP ) > 0 and TA.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPTA where NUMPAC = DZ.NUMPAC and TABLEPARAM = DO.TABLEGXP ) = 0 and TA.NUMPAC = ''*'')) ';
 	req:= req || ' and (DO.OCCURENCE like ''%!%'' or TA.ALLERRETOUR = ''R'')) > 0 )) ';
 	req:= req || ' )';
 	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Contrôle Origine existe pour le numPac TGE00331
 -- Ce test devra être supprimé lorsque celui associé au message TGE00321(origine est cohérente avec la GTA du collaborateur)
 -- sera intégré au contrôle PL/SQL (pour le moment fait en Java pour les saisies écrans et imports Web)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00331',p_codlang),'''','''''')||''',EI.ORIGINE||''|''||EI.NUMPAC ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC)';
 EXECUTE_IMMEDIATE_STRING( req,0);
  
 -- Ecrasement de la clause Where
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||'''';
 -- Controles pour les éléments B691 et B690
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00195',p_codlang),'''','''''')||''',ei.valeur,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element=''B690'' and not exists(select * from   TGE_REF_IMPUTATION
 Ei2 where ei2.numpac in (Ei.numpac,''*'') and ei2.codeimp=ei.valeur )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00193',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element=''B691'' and exists(select * from
 (select date_import,login,numpac,paiezad, code_element, sum(to_number(replace(valeur,''.'','',''))) as somme from TGE_IMPORT_ELEMENTS Ei2 where code_element=''B691'' AND IS_NUMBER(VALEUR) is not null  group by  date_import,login,numpac,paiezad, code_element) tmp where   ei.date_import  =tmp.date_import  AND ei.login =tmp.login and somme<>100 and ei.numpac =tmp.numpac
 AND ei.paiezad  =tmp.paiezad)  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00194',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element in (''B690'',''B691'') and not exists(select * from TGE_REF_MAPDO d where code_element=ELEMENT and indicatif=occurence and (d.numpac=Ei.numpac or d.numpac=''*''))  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
    	-- On remonte l'erreur à l'application
 		raise;
	END IF;
 END TGE_CONTROLE_30;
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_40
=SQL=
create or replace PROCEDURE TGE_CONTROLE_40 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 , P_ISFSED in NUMBER
 ) AS
/********************************************************************************
Version     : V5.05.000
*********************************************************************************/
 cNumeric_Characters varchar2(40);
 cNLS_NUMERIC_CHARACTERS varchar2(40);
 clWhere varchar2(1000);
 req varchar2(2000);
 w_exist_incident VARCHAR2(2000);
 w_err VARCHAR2(2000);
 
 /* Objets utilisés pour le contrôle sur la somme des heures réalisées */
 -- Objet contenant un tableau des lignes par collaborateur par jour avec les sommes des heures réalisées déjà créées (TGE_INCIDENTS_PAIE) et des heures réalisées ajoutées par l'import
 TYPE T_REC IS RECORD (
 numpac varchar2(6),
 paiezad varchar2(8),
 date_effet date,
 somme_heures number,
 somme_heures_trav_import number);
 TYPE typ_tab IS table of T_REC;
 tab typ_tab ;
 -- Plus petite et plus grande date de l'import
 v_dateMinImport varchar2(8);
 v_dateMaxImport varchar2(8);
 varsys varchar2(100);
 
 BEGIN
 
 SELECT substr(TRIM(VALUE),length(TRIM(VALUE)))  INTO cNLS_NUMERIC_CHARACTERS FROM nls_session_parameters where PARAMETER = 'NLS_NUMERIC_CHARACTERS';
 
 clwhere:='login='''||p_login||''' and date_import='''||p_date_import||'''';
 if p_numligne is not null then
 clwhere:=clwhere||' AND NUMLIGNE='||p_numligne;
 end if;
 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controler
 clwhere:=clwhere || ' AND (STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR STATUT = ''TRANS'')';
 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées
 IF p_login='BATCH' THEN
 req:='update TGE_IMPORT_INCIDENTS I SET ERREURS = '''' WHERE '||clwhere;
EXECUTE_IMMEDIATE_STRING (req,0);
 END IF;
 
 -- Numpac non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PAIEZAD non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PERIODE non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- TYPE_TRAITEMENT non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_DEBUT non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00108',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_DEBUT is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_FIN non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00109',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_FIN is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- NUMPAC controle format
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',NUMPAC,'''||p_codlang||''') where '||clwhere||' AND  NVL(LENGTH(NUMPAC),0)>6 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 ---controleLigneImportIncidentVide(TGE_IMPORT_INCIDENTS_sgbd p_importIncident, ArrayList<GxpErreurWithParams> p_arrErreurs)INCI0025
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','INCI0025',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_IP is null AND HEURES_IP IS NULL AND HEURES_TRAV IS NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
  ---controleLigneImportIncidentWhenHeuresIncNonVide(TGE_IMPORT_INCIDENTS_sgbd p_importIncident, ArrayList<GxpErreurWithParams> p_arrErreurs)INCI0035
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','INCI0035',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_IP is null AND HEURES_IP IS not NULL ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PAIEZAD >8 cara
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',PAIEZAD,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PERIODE format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00083',p_codlang),'''','''''')||''',PERIODE||''|yyyyMM'','''||p_codlang||''') WHERE '||clwhere||' AND (IS_DATE(PERIODE ,''yyyyMM'') =0)' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_DEBUT format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00110',p_codlang),'''','''''')||''',DATE_DEBUT||''|yyyyMMdd'','''||p_codlang||''') WHERE '||clwhere||' AND (IS_DATE(DATE_DEBUT ,''yyyyMMdd'') =0) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_FIN format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00111',p_codlang),'''','''''')||''',DATE_FIN||''|yyyyMMdd'','''||p_codlang||''') WHERE '||clwhere||' AND IS_DATE(DATE_FIN ,''yyyyMMdd'') =0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- HEURES_TRAV controle 1 numerique
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00112',p_codlang),'''','''''')||''',HEURES_TRAV,'''||p_codlang||''') WHERE '||clwhere||' AND TGE_CONTROLE_HEURE_TRAV ( HEURES_TRAV, 3, 2,'''||cNLS_NUMERIC_CHARACTERS||''')=0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- HEURES_IP controle 1 numerique
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00113',p_codlang),'''','''''')||''',HEURES_IP,'''||p_codlang||''') WHERE '||clwhere||' AND TGE_CONTROLE_HEURE_TRAV ( HEURES_IP, 3, 2,'''||cNLS_NUMERIC_CHARACTERS||''')=0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ORIGINE
 req:='update TGE_IMPORT_INCIDENTS INC SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00331',p_codlang),'''','''''')||''',INC.ORIGINE||''|''||INC.NUMPAC ,'''||p_codlang||''') WHERE '||clwhere;
 req:= req || ' and INC.ORIGINE is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = INC.ORIGINE and G.NUMPAC = INC.NUMPAC)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ORIGINE (lig 1968)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND (ORIGINE IS NOT NULL AND LENGTH(ORIGINE) >1) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ORIGINE
  IF P_LOGIN ='BATCH' THEN 
  req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00225',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND ((ORIGINE IS NOT NULL AND ORIGINE = ''T'') OR (ORIGINE is null)) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
  else if P_ISFSED=1 then
  req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00225',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND ((ORIGINE IS NOT NULL AND ORIGINE = ''T'') OR (ORIGINE is null)) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
  END IF;
  END IF;
 
 -- CONTROLES EXISTENCES
 -- TYPE_TRAITEMENT (Lig 1971)
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND ii.TYPE_TRAITEMENT IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   '( exists  (SELECT RT.CODETYPTRT FROM TGE_REF_TYPETRT RT WHERE rt.numpac=ii.numpac and ii.type_traitement =RT.CODETYPTRT) )';
 req:= req || ' OR ';
 req:= req ||   '( exists (SELECT RT.CODETYPTRT FROM TGE_REF_TYPETRT RT WHERE rt.numpac=''*'' AND RT.codetyptrt= ii.type_traitement and ii.type_traitement =RT.CODETYPTRT AND NOT EXISTS (SELECT 1 FROM TGE_REF_TYPETRT RT2 WHERE RT2.NUMPAC=ii.numpac)))';
 req:= req || ')  ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_IMPUTATION (Lig 1972)
 
 select valvar into varsys from sys_varsys where module='TGE' and CODVAR='CTRL_CODE_IMPUTATION_EXISTE';
 if upper(varsys)<>'FALSE' then
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00012',p_codlang),'''','''''')||''',ii.code_imputation||''|''||ii.numPac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' and ii.code_imputation<>''*'' AND  ii.code_imputation IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   '( exists (SELECT ri.codeimp FROM TGE_REF_IMPUTATION ri WHERE ri.numpac = ii.numpac and ri.codeimp=ii.code_imputation))';
 req:= req || ' OR ';
 req:= req ||   '(exists  (SELECT ri.codeimp FROM TGE_REF_IMPUTATION ri WHERE ri.numpac=''*'' AND  ri.codeimp=ii.code_imputation and ri.codeimp= ii.code_imputation AND NOT EXISTS (SELECT 1 FROM TGE_REF_IMPUTATION rt2 WHERE rt2.numpac=ii.numpac and rt2.codeimp= ii.code_imputation)))';
 req:= req || ')  ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 end if;
 
 -- CODE_IP (Lig 1973)INCI0012
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','INCI0012',p_codlang),'''','''''')||''',code_ip,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND ii.code_ip IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac ) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac=''*'' AND rp.code_incident=ii.code_ip AND NOT EXISTS (SELECT 1 FROM TGE_REF_PRE rp2 WHERE rp2.numpac=ii.numpac and ii.code_ip=rp2.code_incident)))';
 req:= req || ') ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Contrôles spécifiques
 -- Date_Debut Date_Fin (lig 1977)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00118',p_codlang),'''','''''')||''',to_char(to_date(date_debut, ''yyyymmdd''), ''dd.mm.yyyy'')||''|''||to_char(to_date(date_fin, ''yyyymmdd''), ''dd.mm.yyyy''),'''||p_codlang||''') WHERE '||clwhere||' AND  date_debut > date_fin ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- HEURES_TRAV TYPE_HEURE (lig 1978)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00114',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') WHERE '||clwhere||' AND heures_trav IS NOT NULL AND type_heure NOT IN (''T'',''R'') ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00115',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') WHERE '||clwhere||' AND heures_trav IS NULL AND type_heure IS NOT NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_IP HEURE_IP (lig 1979)
 /*req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00138',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_ip IS NOT NULL AND heures_ip IS NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);*/
 
 -- DOMAINE_IMP ligne 1980
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00119',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND (DOMAINE_IMP IS NOT NULL AND CODE_IMPUTATION IS NULL) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00120',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NOT NULL AND heures_ip IS NOT NULL AND domaine_imp != ''H'' AND domaine_imp !=''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00121',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NOT NULL AND heures_ip IS NULL AND domaine_imp != ''H'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00122',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_ip IS NOT NULL AND heures_trav IS NULL AND domaine_imp != ''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00136',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NULL AND heures_ip IS NULL AND domaine_imp != ''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
  
 -- controle date début incident avec les dates de bébut et fin contrat 
req:='update TGE_IMPORT_INCIDENTS ii  SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00358',p_codlang),'''','''''')||''',date_debut,'''||p_codlang||''')';
req:= req || ' where '||clwhere||'' ; 
req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=ii.NUMPAC and DACS.PAIEZAD=ii.PAIEZAD';
req:= req || ' and TO_DATE(ii.DATE_DEBUT, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ctrl if heure contenuHeures(String p_heures, String p_type_ip, ArrayList<GxpErreurWithParams> p_arrErreurs) INCI0024
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0024',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND (((Ii.heures_ip IS NOT NULL OR Ii.code_ip is not null ) AND Ii.code_ip = ''HP'' AND II.heures_ip is null)
     OR (ii.HEURES_TRAV is null  AND ii.type_heure  in (''T'',''R''))
     ) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ToolsTge_controles.controleAutorisationPaieZad(p_loginUserOrDelegator, p_unIncident.numPac, p_unIncident.paieZad, arrErreurs);STD00049
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND ii.paiezad IS NOT NULL AND ii.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =ii.numpac and C.CURRENT_PAIEZAD =ii.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =ii.numpac and C.CURRENT_PAIEZAD =ii.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleHoraireTheorique(p_unIncident, arrErreurs, p_transac); INCI0020 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0020',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.code_IP =''HP'' AND ii.code_imputation IS NOT NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleDateDebutFin(p_code_ip,p_date_debut,p_date_fin,p_arrErreurs); TGE00226 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','TGE00226',p_codlang),'''','''''')||''',to_char(to_date(date_debut, ''yyyymmdd''), ''dd.mm.yyyy'')||''|''||to_char(to_date(date_fin, ''yyyymmdd''), ''dd.mm.yyyy''),'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.code_IP =''HP'' AND ii.DATE_FIN !=  ii.DATE_DEBUT ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleCode_ip; INCI0027 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0027',p_codlang),'''','''''')||''',code_ip,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.type_heure != ''T'' AND  ii.type_heure != ''R''  AND (ii.CODE_IP =''HP'' OR ii.CODE_IP =''HT'') ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- controle saisie en demi journée DIT 42237
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00264',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND ii.CODE_IP  IS NOT NULL AND ii.CODE_IP != ''HP'' AND ii.DATE_DEBUT is not null and ii.DATE_FIN is not null  and ii.DATE_DEBUT!=ii.DATE_FIN ';
 req := req || 'AND ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac AND rp.OPTION_CONSERV_HISTO =''A'' AND rp.UNITE=''J'') ) AND is_number(ii.HEURES_IP)=0.5 ';
 
  EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- controle saisie du volume different de 0 ou 1 DIT 42237
 req:='update TGE_IMPORT_INCIDENTS ii  SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00265',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')'; 
 req:= req || ' where '||clwhere||' AND ii.CODE_IP  IS NOT NULL AND ii.CODE_IP != ''HP'' ';
 req := req || 'AND ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac AND rp.OPTION_CONSERV_HISTO =''A'' AND rp.UNITE=''J'') ) AND is_number(ii.HEURES_IP)!=0 AND is_number(ii.HEURES_IP)!=1  AND is_number(ii.HEURES_IP)!=0.5 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Bloquer les imports carte 40 sur des périodes antérieures à la date de limite de rétro
 req:='MERGE INTO TGE_IMPORT_INCIDENTS II USING ';
 req:= req ||' (SELECT P1.NUMPAC, P1.PERIODEENCOURS, P1.DEB_RETRO,GREATEST(P1.DEB_HISTO_RETRO,NVL( S.PREMIERE_PAIE, ''190101''))  AS DEB_HISTO_RETRO , P1.NB_MOIS_RETRO,  S.PACMAT,';
 req:= req ||'  GREATEST(NVL( S.PREMIERE_PAIE, ''190101''),NVL(P1.DEB_HISTO_RETRO, ''190001''), (TO_CHAR(ADD_MONTHS(TO_DATE(P1.PERIODEENCOURS, ''YYYYMM''), -P1.NB_MOIS_RETRO), ''YYYYMM''))) AS LIMITE_RETRO ';
 req:= req ||' FROM TGE_REF_PAC P1 LEFT JOIN SECUPACMAT S ON P1.NUMPAC = S.NUMPAC ) P';
 req:= req ||' ON (';
 req:= req || clwhere;
 req:= req ||' AND II.NUMPAC = P.NUMPAC';
 req:= req ||' AND  ( II.PACMAT is  null or II.PACMAT = P.PACMAT )'; 
 req:= req ||' AND II.PERIODE < P.PERIODEENCOURS';
 req:= req ||' AND ( P.DEB_RETRO IS NOT NULL AND P.DEB_RETRO <= P.PERIODEENCOURS';
 req:= req ||' ) ) WHEN MATCHED THEN UPDATE SET II.ERREURS = CASE';
 req:= req ||' WHEN II.PERIODE < P.DEB_HISTO_RETRO THEN TGE_GET_MESSAGE_ERREUR(II.ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' WHEN II.PERIODE < P.LIMITE_RETRO THEN TGE_GET_MESSAGE_ERREUR(II.ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.LIMITE_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' END WHERE II.ERREURS IS NULL';
 EXECUTE_IMMEDIATE_STRING(req, 0);
 
 -- Bloquer en mode non rétro les imports carte 40 sur des périodes antérieures à la période en cours
 req := 'MERGE INTO TGE_IMPORT_INCIDENTS II USING TGE_REF_PAC P ON( '|| clwhere;
 req := req || ' AND II.NUMPAC = P.NUMPAC';
 req := req || ' AND P.PERIODEENCOURS IS NOT NULL ';
 req := req || ' AND (P.DEB_RETRO > P.PERIODEENCOURS OR P.DEB_RETRO IS NULL) ';
 req := req || ' AND II.PERIODE < P.PERIODEENCOURS) ';
 req := req || ' WHEN MATCHED THEN UPDATE ';
 req := req || ' SET II.ERREURS = TGE_GET_MESSAGE_ERREUR(II.ERREURS, ''' || replace(get_message_erreur('TGE', 'TGE00351', p_codlang), '''', '''''') || ''', NULL, ''' || p_codlang || ''')';
 req := req || ' WHERE II.ERREURS IS NULL';
 EXECUTE_IMMEDIATE_STRING(req, 0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
 		-- On remonte l'erreur à l'application
  		raise;
  	END IF;
 END TGE_CONTROLE_40;
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_40_CHEVAUCHEMENT
=SQL=
create or replace PROCEDURE TGE_CONTROLE_40_CHEVAUCHEMENT (P_LOGIN IN VARCHAR2, P_DATE_IMPORT IN VARCHAR2, P_NUMLIGNE IN VARCHAR2, P_CODLANG IN VARCHAR2) AS 
 /********************************************************************************
 Version     : V5.05.003
 *********************************************************************************/
 
 dateDebutSQL  VARCHAR2(20);                      --date fin import_absence
 dateFinSQL    VARCHAR2(20);                      --date fin import_absence
 cod_erreur    VARCHAR2(10);                      --code anomalie
 msg           VARCHAR(1000);                     --Message d'ano namlie
 typ_msg       VARCHAR2(10);                      --type de message ERROR ou WARNING
 varsys        VARCHAR2(100);                     --boolean varsys CTRL_ABS_CHEVAUCH
 ctrlWhere     VARCHAR2(2000) ;                   --requet SELECT pour controler le chevauchement
 updatesql     VARCHAR2(2000);                    --requete d'insertion de ERROR/WARNING
 C_FORMAT_DATE CONSTANT VARCHAR(10) :='YYYYMMDD'; --format date
 iterChev      NUMBER               :=0;          --compteur iteration absence chevauchante
 haveJ         NUMBER               :=0;          --boolean verifier si une absence type J a été traité
 firstMsg      NUMBER               :=0;
 haveMsg2demiJr NUMBER              :=0;
 accepte_2_demi_journee boolean:=false;
 type_demi_journee_meme_motif boolean:=false;
 
 ------- variable temporaire info abs. chevauché -------
 v_DATE_DEBUT TGE_ABSENCES.DATE_DEBUT%TYPE ;
 v_DATE_FIN TGE_ABSENCES.DATE_FIN%TYPE;
 v_FIN_MA TGE_ABSENCES.FIN_MA%TYPE;
 v_DEBUT_MA TGE_ABSENCES.DEBUT_MA%TYPE;
 v_MOTIF TGE_ABSENCES.MOTIF%TYPE;
 v_DEMI_JOURNEE TGE_REF_PRE.DEMI_JOURNEE%TYPE;
 v_duree VARCHAR2(100);
 --------------------------------------
 TYPE TGE_CTRL40_type_map_msg_error
 IS
 TABLE OF VARCHAR2(200) INDEX BY VARCHAR2(10);-- typer table temporère pour optimiser la recupération des erreurs */
 abs_chevauch SYS_REFCURSOR;                  -- cursor + variable absence chevauché
 prop_abs_encour TGE_CTRL40_prop_absence;     -- contient statut absence
 map_msg TGE_CTRL40_type_map_msg_error;       -- for optimization error
 inf_abs TGE_CTRL40_info_absence;             -- Objet de sauvegarde des propriété absence calculable
 tmp_record_cursor TGE_CTRL40_abs_row_cursor  :=TGE_CTRL40_abs_row_cursor(NULL,NULL,NULL,NULL,NULL,NULL);
 C_SQL_NON_DEMI_JOURNEE CONSTANT VARCHAR(200) :='and not exists (select 1 from tge_ref_pre pre  where absence.numpac=pre.numpac and absence.motif=pre.code_incident and pre.demi_journee =1 )';
 /************ CURSORS ************/
 -- Curseur des absence à contrôler
 CURSOR ABS_IMPORT
 IS
 SELECT absence.LOGIN,
 absence.DATE_IMPORT,
 absence.NUMLIGNE,
 absence.MATRICULE,
 absence.NUMPAC,
 absence.PACMAT,
 absence.PAIEZAD,
 absence.PERIODE,
 absence.TYPE_TRAITEMENT,
 absence.DATE_DEBUT,
 absence.DATE_FIN,
 absence.HEURES_TRAV,
 absence.TYPE_HEURE,
 absence.HEURES_IP,
 absence.CODE_IP,
 absence.CODE_IMPUTATION,
 absence.DOMAINE_IMP,
 absence.ORIGINE,
 absence.ERREURS,
 absence.STATUT,
 absence.WARNINGS,
 absence.DATE_EFFET,
 absence.FSED_PAIEZAD,
 MOT.DEMI_JOURNEE,
 mot.RUB_ECHANGE,
 mot.UNITE
 FROM TGE_IMPORT_INCIDENTS absence LEFT JOIN TGE_REF_PRE mot
 ON absence.CODE_IP=mot.CODE_INCIDENT AND mot.NUMPAC    =absence.NUMPAC WHERE LOGIN =P_LOGIN  AND DATE_IMPORT   =P_DATE_IMPORT AND mot.OPTION_CONSERV_HISTO='A';
 
 --Curseur des messages d'erreurs
 CURSOR error_msg_cursor
 IS SELECT coderr, liberr FROM sys_def_erreurs WHERE codlang=P_CODLANG AND CODMOD   ='TGE'
 AND coderr  IN ('TGE00172','TGE00184','TGE00187','TGE00188','TGE00198','TGE00185','TGE00186','TGE00197','TGE00295','TGE00296','TGE00297','TGE00298','TGE00344','TGE00345');
 
 BEGIN
 /**********DEBUT TRAITEMENT ***********/
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'CTRL_CHEVAUCHEMENT_40 DEBUT '||TO_CHAR(SYSTIMESTAMP, 'DD.MM.YYYY HH24:MI:SSxFF'));
 
 /** Alimentation des erreur en memoir **/
 FOR row_err IN error_msg_cursor LOOP
 map_msg(row_err.coderr):=row_err.liberr;
 END LOOP;
 
 --get varsys CTRL_ABS_CHEVAUCH
 --IF true inserer dans Erreur ELSE inserer dans Warning
 SELECT valvar INTO varsys FROM sys_varsys WHERE module ='TGE' AND CODVAR      ='CTRL_ABS_CHEVAUCH';
 IF upper(varsys)='TRUE' THEN  typ_msg :='erreurs'; ELSE typ_msg:='warnings'; END IF;
 
 /**************************************/
 /****  LOOP sur TGE_IMPORT_ABSENCES****/
 /**************************************/
 FOR absence IN ABS_IMPORT
 LOOP
 
 dateDebutSQL                  :='';
 dateFinSQL                    :='';
 iterChev                      :=0;
 tmp_record_cursor.DATE_DEBUT  :=absence.DATE_DEBUT;
 tmp_record_cursor.DATE_FIN    :=absence.DATE_FIN;
 tmp_record_cursor.UNITE       :=absence.UNITE;
 tmp_record_cursor.HEURES_IP   :=absence.HEURES_IP;
 tmp_record_cursor.DEMI_JOURNEE:=absence.DEMI_JOURNEE;
 tmp_record_cursor.RUB_ECHANGE :=absence.RUB_ECHANGE;
 
 -- get info absence
 inf_abs  := TGE_CTRL40_GET_INFO_ABSENCE(tmp_record_cursor,dateDebutSQL , dateFinSQL);
 
 -- calculer les états de l'absence
 prop_abs_encour :=TGE_CTRL40_GET_ETATS_ABSENCE(absence.HEURES_IP, absence.DEMI_JOURNEE, inf_abs, dateDebutSQL, dateFinSQL);
 
 /* verification date absence */
 IF dateDebutSQL IS NULL THEN dateDebutSQL := '19000102'; END IF;
 IF dateFinSQL   IS NULL THEN dateFinSQL   := '20990101'; END IF;
 
 /********************************************************/
 /* Construction de la requete controle chevauchement !! */
 /********************************************************/
 ctrlWhere :='SELECT DATE_DEBUT, DATE_FIN, FIN_MA, DEBUT_MA,MOTIF , TO_CHAR(NVL(DUREE,0)) as DUREE, DEMI_JOURNEE FROM TGE_ABSENCES absence LEFT JOIN TGE_REF_PRE mot ON absence.MOTIF=mot.CODE_INCIDENT AND mot.NUMPAC=absence.NUMPAC  WHERE MATRIC='''||absence.MATRICULE||''' AND STATUT IN (select CODE from TGE_GTA_ABS_STATUTS  where EST_ABS_ACTIVE = 1) ' ;
 ctrlWhere := ctrlWhere|| 'AND ( ( TO_DATE( ' || dateDebutSQL ||','''|| C_FORMAT_DATE ||''') between DATE_DEBUT AND DATE_FIN OR TO_DATE('||dateFinSQL||','''|| C_FORMAT_DATE ||''') between DATE_DEBUT AND DATE_FIN OR DATE_DEBUT between TO_DATE('||dateDebutSql||','''|| C_FORMAT_DATE ||''') AND TO_DATE('||dateFinSql||','''|| C_FORMAT_DATE ||''') OR  DATE_FIN  between TO_DATE('||dateDebutSql ||','''|| C_FORMAT_DATE ||''') AND TO_DATE('||dateDebutSql||','''|| C_FORMAT_DATE ||''') ) AND ';
 IF prop_abs_encour.isJourneeCompleteSurUnSeulJour   =1 OR prop_abs_encour.isEnDureeSurUnSeulJour=1 OR prop_abs_encour.isJourneCompletSurPlusieurJour=1 OR prop_abs_encour.isEnDureeSurPlusieursJour=1 THEN
 ctrlWhere :=ctrlWhere||' 1=1 ';
 ELSIF prop_abs_encour.isDemiJourneeSurUnSeulJour=1  OR prop_abs_encour.estDemiJournee=1 THEN
 ctrlWhere :=ctrlWhere||' ((DEBUT_MA=''J'' AND ( ('''|| NVL(absence.heures_ip,'0') ||'''=''0.50'' AND TO_CHAR(NVL(DUREE,0))=''14400'') OR  ''0'' = NVL(DUREE,''0'')) ) OR (DEBUT_MA in (''M'',''D'',''A'')) OR (FIN_MA in (''M'',''D'',''A'')) OR DEMI_JOURNEE = ''1'')';
 ELSIF prop_abs_encour.isMatinSurUnSeulJour =1 OR prop_abs_encour.isMatinSurPlusieursJour=1 THEN --
 ctrlWhere :=ctrlWhere||' ( (DEBUT_MA IN (''D'',''J'',''M'') AND DEBUT_MA =FIN_MA '||C_SQL_NON_DEMI_JOURNEE||' ) OR (DEBUT_MA=''A'' AND FIN_MA in (''M'',''J'') AND TO_DATE('||dateFinSql||','''|| C_FORMAT_DATE ||''') <> DATE_DEBUT ) OR (DEBUT_MA=''J'' AND FIN_MA=''M'') )';
 ELSIF prop_abs_encour.isApresMidiSurUnSeulJour      =1 OR prop_abs_encour.isApresMidiSurPlusieursJour=1 THEN--
 ctrlWhere :=ctrlWhere||' (  (DEBUT_MA in (''D'',''J'',''A'') AND DEBUT_MA= FIN_MA '||C_SQL_NON_DEMI_JOURNEE||' ) OR (DEBUT_MA=''A'' AND FIN_MA=''J'') OR ( DEBUT_MA IN (''A'',''J'') and FIN_MA=''M'' and TO_DATE('||dateDebutSql||','''|| C_FORMAT_DATE ||''') <> DATE_FIN ) ) ';
 ELSIF prop_abs_encour.isStatApremdAndFinitToutJourne=1 THEN
 ctrlWhere :=ctrlWhere||' ( (DEBUT_MA in(''J'',''D'',''A'') AND DEBUT_MA= FIN_MA '||C_SQL_NON_DEMI_JOURNEE||' ) OR (DEBUT_MA=''A'' and FIN_MA=''J'') OR ( DEBUT_MA in (''A'',''J'') AND FIN_MA=''M'' AND TO_DATE('||dateDebutSql ||','''|| C_FORMAT_DATE ||''') <> DATE_FIN ) OR ( DEBUT_MA=''M'' and FIN_MA=''M'' AND DATE_FIN >  TO_DATE( '|| dateDebutSQL||' ,'''|| C_FORMAT_DATE ||''') ) )';
 ELSIF prop_abs_encour.isStartApremidiAndFinitMatin  =1 THEN
 ctrlWhere :=ctrlWhere||' ( (DEBUT_MA IN (''J'',''D'') AND DEBUT_MA=FIN_MA '||C_SQL_NON_DEMI_JOURNEE||' ) OR ( DEBUT_MA=''M'' AND FIN_MA=''M'' AND DATE_FIN> TO_DATE('||dateDebutSql ||','''|| C_FORMAT_DATE ||''') ) OR ( DEBUT_MA=''A'' AND FIN_MA=''A'' AND DATE_DEBUT > TO_DATE( '||dateFinSql||','''|| C_FORMAT_DATE ||''') ) OR ( DEBUT_MA=''A'' AND FIN_MA=''M'' AND DATE_DEBUT <> TO_DATE('||dateFinSql||','''|| C_FORMAT_DATE ||''') and DATE_FIN <> TO_DATE('||dateDebutSql ||','''|| C_FORMAT_DATE ||''') ) OR ( DEBUT_MA=''J'' AND FIN_MA=''M'' AND DATE_FIN <> TO_DATE('||dateDebutSql||','''|| C_FORMAT_DATE ||''') ) )';
 ELSIF prop_abs_encour.isStartToutJourneAndFinitMatin=1 THEN
 ctrlWhere :=ctrlWhere||' ( ( DEBUT_MA IN (''J'',''D'',''M'') AND DEBUT_MA=FIN_MA '||C_SQL_NON_DEMI_JOURNEE||' ) OR ( DEBUT_MA =''A'' AND FIN_MA =''A''  AND DATE_DEBUT < TO_DATE('||dateFinSql||','''|| C_FORMAT_DATE ||''') ) OR ( DEBUT_MA =''A'' AND FIN_MA IN (''J'',''M'') AND DATE_DEBUT <> TO_DATE('||dateFinSQL||','''|| C_FORMAT_DATE ||''') ) OR ( DEBUT_MA=''J'' AND FIN_MA=''M'' ) )';
 END IF;
 ctrlWhere :=ctrlWhere||')  ORDER BY DEBUT_MA desc';
 
 
 IF NOT prop_abs_encour.erreur=1 THEN
 --parcourir les absences en cheuvauchement pour inserer les erreurs/warnings
 OPEN abs_chevauch FOR ctrlWhere;
 LOOP
 FETCH abs_chevauch INTO v_DATE_DEBUT, v_DATE_FIN, v_FIN_MA, v_DEBUT_MA, v_MOTIF, v_duree, v_DEMI_JOURNEE;
 EXIT WHEN abs_chevauch%NOTFOUND;
 

 
 IF v_DEBUT_MA='J' OR v_FIN_MA='J' THEN haveJ:=1; END IF;
 
 iterChev :=iterChev+1;
 
 -- condition qui accepte 2 demi journée
 accepte_2_demi_journee:= iterchev<2 AND (prop_abs_encour.isDemiJourneeSurUnSeulJour=1 OR prop_abs_encour.estDemiJournee=1) AND ( ((v_duree ='14400') AND v_DEBUT_MA = 'J' AND v_DEMI_JOURNEE <> 1) OR  v_DEBUT_MA IN ('M','A') OR v_FIN_MA IN ('M','A') OR (v_DEMI_JOURNEE=1 AND v_MOTIF != absence.CODE_IP));
 -- condition qui bloque la 2éme absence typé demi_journée si même motif d'absence
 type_demi_journee_meme_motif:=prop_abs_encour.estDemiJournee=1 AND v_DEMI_JOURNEE=1 AND v_MOTIF=absence.CODE_IP;
 
 -- contrôle pour ne pas dépasser 2 demi journée dans la même journée (sauf pour la durée) et qui bloque l'import d'une 2eme absnece typée demi-journée avec le même motif.
 IF firstMsg = 0 AND (not(accepte_2_demi_journee) OR type_demi_journee_meme_motif ) THEN
 msg:=map_msg('TGE00172');
 updatesql:=' update TGE_IMPORT_INCIDENTS set '|| ( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' = '|| ( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' || '''||REPLACE(msg,'''','''''')||'''  WHERE login='''||absence.login||''' and date_import='''||absence.date_import||''' and numligne='|| absence.numligne||'';
 EXECUTE_IMMEDIATE_STRING(updatesql,0);
 firstMsg:=1;
 END IF;
 IF accepte_2_demi_journee THEN
 CONTINUE;
 ELSIF haveMsg2demiJr=0 AND prop_abs_encour.isDemiJourneeSurUnSeulJour=1 AND (v_DEBUT_MA  <> 'D' OR haveJ = 1)  AND iterchev>=2 THEN
 msg:=map_msg('TGE00344');
 msg:=regexp_replace(msg,'#',v_DATE_DEBUT,1,1);
 haveMsg2demiJr:=1;
 GOTO MAJ_TBL_IMPORT;
 ELSIF haveMsg2demiJr=1 AND prop_abs_encour.isDemiJourneeSurUnSeulJour=1 AND iterchev>=2 THEN
 CONTINUE;
 END IF;
 IF type_demi_journee_meme_motif THEN
 msg:=map_msg('TGE00345');
 msg:=regexp_replace(msg,'#',v_MOTIF,1,1);
 msg:=regexp_replace(msg,'#',v_DATE_DEBUT,1,1);
 GOTO MAJ_TBL_IMPORT;
 END IF;
 
 --get code erreur adéquat
 IF v_DATE_DEBUT   =v_DATE_FIN THEN
 IF    v_DEBUT_MA='D' THEN cod_erreur   :='TGE00184';
 ELSIF v_DEBUT_MA='M' THEN cod_erreur   :='TGE00187';
 ELSIF v_DEBUT_MA='A' THEN cod_erreur   :='TGE00188';
 ELSIF v_DEBUT_MA='J' THEN cod_erreur   :='TGE00198';
 END IF;
 ELSE
 IF v_DEBUT_MA   ='M' THEN
 cod_erreur   :='TGE00185';
 ELSIF v_DEBUT_MA='A' AND v_FIN_MA!='M' AND v_FIN_MA!='J' THEN cod_erreur   :='TGE00186';
 ELSIF v_DEBUT_MA='J' AND v_FIN_MA!='M' THEN cod_erreur   :='TGE00197';
 ELSIF v_DEBUT_MA='A' AND v_FIN_MA='J' THEN cod_erreur   :='TGE00295';
 ELSIF v_DEBUT_MA='A' AND v_FIN_MA='M' THEN cod_erreur   :='TGE00296';
 ELSIF v_DEBUT_MA='J' AND v_FIN_MA='M' THEN cod_erreur   :='TGE00297';
 ELSIF v_DEBUT_MA='D' THEN cod_erreur   :='TGE00298';
 END IF;
 END IF;
 
 --récupèrer message d'erreur et remplacer les paramétres
 msg:=map_msg(cod_erreur);
 msg:=regexp_replace(msg,'#',v_MOTIF,1,1);
 msg:=regexp_replace(msg,'#',v_DATE_DEBUT,1,1);
 msg:=regexp_replace(msg,'#',v_DATE_FIN,1,1);
 
 <<MAJ_TBL_IMPORT>>
 --MAJ de l'anomalie import_absence / WARNINGS si MA=Durée
 updatesql:=' UPDATE TGE_IMPORT_INCIDENTS SET '|| ( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' = '|| ( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' || '''||REPLACE(msg,'''','''''')||'''  WHERE login='''||absence.login||''' AND date_import='''||absence.date_import||''' AND numligne='|| absence.numligne||'';
 EXECUTE_IMMEDIATE_STRING(updatesql,0);
 
 END LOOP; --FIN LOOP absence chevauché
 iterChev:=0; firstMsg:=0;haveJ:=0;haveMsg2demiJr:=0;
 CLOSE abs_chevauch;
 
 ELSE
 msg :='Problem de controle de chevauchement. ';
 updatesql:=' UPDATE TGE_IMPORT_ABSENCES SET '||( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' = '|| ( CASE WHEN v_DEBUT_MA='D' AND haveJ=0 THEN 'warnings' ELSE typ_msg END) ||' || '''||REPLACE(msg,'''','''''')||'''  WHERE login='''||absence.login||''' AND date_import='''||absence.date_import||''' AND numligne='|| absence.numligne||'';
 EXECUTE_IMMEDIATE_STRING(updatesql,0);
 END IF;
 END LOOP;--FIN LOOP import_absence
 
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'CTRL_CHEVAUCHEMENT_40 FIN '||TO_CHAR(SYSTIMESTAMP, 'DD.MM.YYYY HH24:MI:SSxFF'));
 
 EXCEPTION
 WHEN OTHERS THEN
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END TGE_CONTROLE_40_CHEVAUCHEMENT;
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_50
=SQL=
create or replace PROCEDURE TGE_CONTROLE_50 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
  -- Valeurs attendues : EC/ECS -> écran création (S en mode SimuPaie),  EM/EMS -> écran modification (S en mode SimuPaie), GAP -> création en sous-marin,
 -- I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch, MP -> création depuis la Market Place
 , P_TYPE_ACTION IN VARCHAR2
 ) AS
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 clWhere varchar2(1000);
 -- Pour les merge, la clause where ne doit pas inclure la colonne ERREURS, on gère des clauses spécifiques
 clWhereMerge varchar2(1000);
 clWhereMergeErreur varchar2(250);
 
 req varchar2(2000);
 w_exist_element NUMBER ;
 w_err VARCHAR2(2000);
 w_param_longueur VARCHAR2(10);
 w_id_natcol varchar2(4000);
 
 BEGIN
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||'''';
 
 if p_numligne is not null then
 	clwhere:=clwhere||' AND EI.NUMLIGNE='||p_numligne;
 end if;

 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controlées 
 clwhere:=clwhere || ' AND (EI.STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR EI.STATUT = ''TRANS'') ';
  
 clWhereMerge := clwhere;
 clWhereMergeErreur := '';
  IF p_type_action = 'VI' and p_login <> 'BATCH' then
   -- A la validation d'import Web, on ne va passer que sur les lignes qui ne sont pas déjà en erreur.
   -- Certaines lignes sont déjà en erreur et on ne veut pas les retraiter (sinon double message)
   clwhere := clwhere || ' and EI.ERREURS is null';
   clWhereMergeErreur := ' where EI.ERREURS is null';
 END IF;
 
 IF p_login ='BATCH' THEN 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées. Seulement pour le BATCH, car dans les autres cas il y a des contrôles
 -- qui sont fait en amont des contrôles PL/SQL (côté Java)
 	req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS = '''' WHERE '||clwhere;
 	EXECUTE_IMMEDIATE_STRING( req,0);
 	
 -- Contrôle que le collaborateur est cohérent : date effet / paiezad. En Batch, on n'utilise pas IdentifiantCollab pour récupérer les informations
 -- du collaborateur, on prend juste ce qui est dans le fichier. On doit donc contrôler que le collab existe
  	req:= 'update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS, '''||replace(get_message_erreur('STD', 'STD00046', p_codlang),'''','''''')||''',EI.MATRICULE||''|''||EI.NUMPAC||''|''||EI.PACMAT||''|''||EI.PAIEZAD||''|''||EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere;
  	req:= req || ' and EI.NUMPAC is not null and EI.PAIEZAD is not null';
  	req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=EI.NUMPAC and DACS.PAIEZAD=EI.PAIEZAD';
  	req:= req || ' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
  	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
   -- Numpac non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PaieZad non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Periode non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Type Traitement non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Date d'effet non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00314',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_EFFET is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- Code imputation non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00009',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_IMPUTATION is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
   -- Nombre unité non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZIM00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NOMBRE_UNITE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- Longueur Origine
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',ORIGINE,'''||p_codlang||''') where '||clwhere||' AND ORIGINE is NOT null AND LENGTH (ORIGINE)>1 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --
 -- Longueur LOGIN (sauf pour le Batch)
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00107',p_codlang),'''','''''')||''',LOGIN,'''||p_codlang||''') where '||clwhere||' AND LOGIN!=''BATCH'' AND LENGTH (LOGIN)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie TGE00310
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00310',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 -- permet de gérer les cas où DATE_EFFET ou PERIODE ne sont pas des dates valides
 req:= req ||' and (select case when to_date(EI.DATE_EFFET,''YYYYMMDD'') > last_day(to_date(EI.PERIODE,''YYYYMM'')) then ''O'' else ''N'' end from dual where is_date(EI.DATE_EFFET, ''YYYYMMDD'')=1 and is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
 EXECUTE_IMMEDIATE_STRING( req,0);
  
 -- Format date d'effet TGE00315
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00315',p_codlang),'''','''''')||''',EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere||' AND EI.DATE_EFFET is not null and IS_DATE(EI.DATE_EFFET,''YYYYMMDD'')=0';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- IdPacMat non vide
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00102',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND (RPAD(NUMPAC,6) || PACMAT) is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur NumPac
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',numpac,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(NUMPAC),0)>6 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur PaieZad
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',NULL,PAIEZAD) where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format PERIODE_PAIE
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00328',p_codlang),'''','''''')||''',PERIODE,'''||p_codlang||''') WHERE '||clwhere||' AND PERIODE is NOT null AND IS_DATE(PERIODE,''YYYYMM'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- Longueur IdPacMat
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00103',p_codlang),'''','''''')||''',RPAD(NUMPAC,6) || PACMAT,'''||p_codlang||''') WHERE '||clwhere||' AND NUMPAC   IS NOT NULL AND PACMAT IS NOT NULL AND  LENGTH(RPAD(NUMPAC,6) || PACMAT) >14 ';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- Format nombre_unité
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZIM000NU',p_codlang),'''','''''')||''',NOMBRE_UNITE,'''||p_codlang||''') WHERE '||clwhere||' AND NOMBRE_UNITE   IS NOT NULL AND IS_NUMBER(NOMBRE_UNITE) IS  NULL   ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format nombre_unité Partie décimale/Partie entiere
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZIM00015',p_codlang),'''','''''')||''',NOMBRE_UNITE,'''||p_codlang||''') where '||clwhere||' AND NOMBRE_UNITE is not null ';
 req := req ||' and ((is_number(NOMBRE_UNITE) is not null and (length(trunc(is_number(NOMBRE_UNITE))) > 11';
 req := req ||' or (mod(is_number(NOMBRE_UNITE), 1) > 0 and length(substr(mod(is_number(NOMBRE_UNITE),1), instr(mod(is_number(NOMBRE_UNITE), 1),'','')+1)) > 4))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle NATCOL doit avoir la valeur SAL ou STA TGE00027
 select VALVAR into w_id_natcol from sys_varsys where module='STD' and codvar='ID_NATCOL';
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00027',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req := req ||' and (select DAC.'||w_id_natcol||' from DIC_ADM_CONTRAT DAC inner join DIC_ADM_CONTRAT_SITU DACS on (DACS.NUMPAC = DAC.NUMPAC and DACS.PACMAT = DAC.PACMAT and DACS.NUMCNT = DAC.NUMCNT) where DACS.PAIEZAD = EI.PAIEZAD and DAC.NUMPAC = EI.NUMPAC';
-- Si le PAC n'est pas MPE, le couple NUMPAC/PAIEZAD ne suffit pas à déterminer un contrat, on utilise la date d'effet
 req := req ||' and case when ((select MPE from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC) = ''N'' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DAC.DSDCN and nvl(DAC.DSFCN, to_date(''20991231'', ''YYYYMMDD'')))';
 req := req ||' or (select MPE from TGE_REF_PAC P2 where P2.NUMPAC = EI.NUMPAC) <> ''N'' then 1 else 0 end = 1) not in (''SAL'', ''STA'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_login = 'BATCH' THEN
 -- Autorisation paiezad
 req:='update TGE_IMPORT_IMPUTATIONS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.paiezad IS NOT NULL AND EI.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Il ne doit pas y avoir de pac * dans la table TGE_REF_DICOZ
 
 -- Existe type_traitement
 req:='update TGE_IMPORT_IMPUTATIONS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND  EI.type_traitement is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_TYPETRT TT where TT.CODETYPTRT = EI.TYPE_TRAITEMENT';
 req:= req || ' and (';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT = EI.TYPE_TRAITEMENT) > 0 and TT.NUMPAC = EI.NUMPAC)';
 req:= req ||   ' or';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT= EI.TYPE_TRAITEMENT) = 0 and TT.NUMPAC=''*'')';
 req:= req || ' ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- Existe code_imputation
 req:='update TGE_IMPORT_IMPUTATIONS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE003CI',p_codlang),'''','''''')||''',CODE_IMPUTATION,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND  EI.CODE_IMPUTATION is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_IMPUTATION I where I.CODEIMP = EI.CODE_IMPUTATION';
 req:= req || ' and (';
 req:= req ||   ' ((select count(*) from TGE_REF_IMPUTATION I2 where I2.NUMPAC = EI.NUMPAC and I2.CODEIMP = EI.CODE_IMPUTATION) > 0 and I.NUMPAC = EI.NUMPAC)';
 req:= req ||   ' or';
 req:= req ||   ' ((select count(*) from TGE_REF_IMPUTATION I2 where I2.NUMPAC = EI.NUMPAC and I2.CODEIMP= EI.CODE_IMPUTATION) = 0 and I.NUMPAC=''*'')';
 req:= req || ' ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
    	-- On remonte l'erreur à l'application
 		raise;
	END IF;
 END TGE_CONTROLE_50; ##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_ABSENCES
=SQL=
create or replace PROCEDURE TGE_CONTROLE_ABSENCES ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 ) AS
 /********************************************************************************
Version     : V5.05.000
*********************************************************************************/
 cNumeric_Characters varchar2(40);
 cNLS_NUMERIC_CHARACTERS varchar2(40);
 clWhereLoginDate varchar2(1000);
 clWhere varchar2(1000);
 req varchar2(2000);
 w_err VARCHAR2(2000);
 BEGIN
 SELECT TRIM(VALUE) INTO cNLS_NUMERIC_CHARACTERS FROM nls_session_parameters where PARAMETER = 'NLS_NUMERIC_CHARACTERS';
 
 clwhereLoginDate:='login='''||p_login||''' and date_import='''||P_DATE_IMPORT||'''';
 --Ajout clause incident
 clwhere:=clWhereLoginDate||' and ( exists ( (SELECT ri.CODE_INCIDENT FROM TGE_REF_PRE ri WHERE ri.numpac = ii.numpac AND  ri.OPTION_CONSERV_HISTO = ''A'' and CODE_IP=ri.CODE_INCIDENT) )OR ';
 clwhere:=clwhere||' exists (SELECT ri.CODE_INCIDENT FROM TGE_REF_PRE ri WHERE ri.numpac=''*''  and CODE_IP=ri.CODE_INCIDENT AND ri.OPTION_CONSERV_HISTO = ''A'' ';
 clwhere:=clwhere||' AND NOT EXISTS (SELECT 1 FROM TGE_REF_PRE rt2 WHERE rt2.numpac=ii.numpac and  CODE_IP=rt2.CODE_INCIDENT ))) ';
 if p_numligne is not null then
 clwhere:=clwhere||' AND NUMLIGNE='||p_numligne;
 end if;
 /*Champs obligatoires*/
 --contenuMotif(p_absence.motif, arrErreurs);ToolsTge_controles.contenu(p_motif, "TGE00142", p_arrErreurs);CODE_IP
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00142',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_IP is null';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --contenuDate_debut(p_absence.date_debut, arrErreurs);p_arrErreurs.add(new GxpErreurWithParams("TGE00108", new String[] {}));
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00108',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_DEBUT is null';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --contenuDate_fin(p_absence.date_fin, arrErreurs);p_arrErreurs.add(new GxpErreurWithParams("TGE00109", new String[] {}));
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00109',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where  '||clwhere||' AND DATE_FIN is null';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --contenu numpac  ToolsTge_controles.contenuNumPac(p_absence.numPac, arrErreurs); TGE00077
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 /* Contrôles format */
 --controleFormatMatricule(p_absence.matric, arrErreurs);p_arrErreurs.add(new GxpErreurWithParams("TGE00089", new String[] {}));--MATRIC
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00089',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND MATRICULE is NOT NULL AND LENGTH(MATRICULE)>32';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --controleFormatMotif(p_absence.motif, arrErreurs);p_arrErreurs.add(new GxpErreurWithParams("TGE00143", new String[] {}));MOTIF
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00143',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND (CODE_IP IS NOT NULL AND LENGTH(CODE_IP) > 2)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ToolsTge_controles.controleFormatNumPac(p_absence.numPac, arrErreurs);TGE00072
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',NUMPAC,'''||p_codlang||''') where '||clwhere||' AND NUMPAC IS NOT NULL AND LENGTH(NUMPAC)>6';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 /* Contrôles métier */
 --Format date fin et date
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00118',p_codlang),'''','''''')||''',date_debut||''|''||date_fin,'''||p_codlang||''') where '||clwhere||' AND DATE_DEBUT IS NOT NULL AND DATE_FIN IS NOT NULL '||
 ' AND  (IS_DATE(date_debut, ''YYYYMMdd'')=0 OR IS_DATE(date_fin, ''YYYYMMdd'')=0)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --date_debut> date_fin
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00118',p_codlang),'''','''''')||''',date_debut||''|''||date_fin,'''||p_codlang||''') where '||clwhere||' AND DATE_DEBUT IS NOT NULL AND DATE_FIN IS NOT NULL '||
 ' AND  DATE_DEBUT>DATE_FIN  AND IS_DATE(date_debut, ''YYYYMMdd'')=1 AND  IS_DATE(date_fin, ''YYYYMMdd'')=1 AND  '||clwhere;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controlePlageSiDuree: n'est pas valable puisque debut_ma ='D' et fin_ma tjrs

 --controleAbsenceInPeriodeActivite(p_absence, arrErreurs); verification de la négation "TGE00148"
 req:='update TGE_IMPORT_INCIDENTS  ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00148',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')where '||clwhere;
 req:= req || ' AND EXISTS ( SELECT 1
 FROM DIC_ADM_CONTRAT dac, dic_adm_contrat_histo dach
 WHERE dac.numpac=dach.numpac and dac.numpac=ii.numpac
 AND dac.pacmat=dach.pacmat and dac.pacmat=ii.pacmat
 AND dac.numcnt=dach.numcnt 
 AND ii.date_debut <=TO_CHAR(dach.date_sortie_sit_bo,''yyyymmdd'')
 AND ii.date_fin  > TO_CHAR(dac.dsfcn,''yyyymmdd'')
 AND dac.DSFCN<dach.DATE_SORTIE_SIT_BO)';
 EXECUTE_IMMEDIATE_STRING( req,0);

 ---controleExistenceMotif TGE00161
 req:='update TGE_IMPORT_INCIDENTS  ii  SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00161',p_codlang),'''','''''')||''',CODE_IP||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clWhereLoginDate||' AND II.CODE_IP IS NOT NULL ';
 req:= req || ' AND NOT (';
 req:= req ||   '(exists(SELECT p.CODE_INCIDENT FROM TGE_REF_PRE P WHERE p.numpac=II.numpac AND p.CODE_INCIDENT=II.CODE_IP  and II.CODE_IP= p.CODE_INCIDENT))';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT p.CODE_INCIDENT FROM TGE_REF_PRE P WHERE p.numpac=''*'' and II.CODE_IP= p.CODE_INCIDENT AND p.CODE_INCIDENT=II.CODE_IP AND NOT EXISTS (SELECT 1 FROM TGE_REF_PRE rt2 WHERE rt2.numpac=II.numpac)))';
 req:= req || ')  ' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 --ToolsTge_controles.controleAutorisationMatric(p_loginOrLoginDelegator, p_absence.matric, arrErreurs);STD00014
 req:='update TGE_IMPORT_INCIDENTS  ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00014',p_codlang),'''','''''')||''',MATRICULE,'''||p_codlang||''') where '||clwhere||
 'AND MATRICULE IS NOT NULL and NOT exists (select S.MATRIC  from SECUPACMAT S, DIC_ADM_CONTRAT C where  C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT and S.MATRIC =ii.MATRICULE)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controlerMotifInAllNumPac TGE00161
 req:='update TGE_IMPORT_INCIDENTS  ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00161',p_codlang),'''','''''')||''',CODE_IP||''|''||NUMPAC,'''||p_codlang||''')';
 req:= req || ' where '||clwhereLoginDate|| ' AND MATRICULE IS NOT NULL AND NUMPAC IS NOT NULL AND (DATE_DEBUT IS NOT NULL OR DATE_FIN IS NOT NULL)';
 req:= req || ' and II.CODE_IP IS NOT NULL and exists ';
 -- Récupération de la liste des numPac pour lesquels le code incident n'existe pas
 req:= req || ' (select NUMPAC from TGE_REF_PAC where ( NUMPAC not in (select NUMPAC from TGE_REF_PRE where code_incident = ii.code_IP) and not exists (select * from TGE_REF_PRE where code_incident = ii.code_IP  and NUMPAC = ''*''))';
 req:= req || ' and NUMPAC in (select distinct C.NUMPAC from   DIC_ADM_CONTRAT C where  C.MATRIC = ii.matricule and  C.DSDCN  <= to_DATE(ii.date_debut,''YYYYMMDD'') and (C.DSFCN >= TO_DATE(ii.date_fin,''YYYYMMDD'')  or C.DSFCN is null ))'||
 ')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Période de recueil
 END TGE_CONTROLE_ABSENCES;
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_DONNEE_PAIE
=SQL=
create or replace PROCEDURE TGE_CONTROLE_DONNEE_PAIE ( 
   P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG IN VARCHAR2
 -- Valeurs attendues : EC/ECS -> écran création (S en mode SimuPaie),  EM/EMS -> écran modification (S en mode SimuPaie), 
 -- I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch, MP -> création depuis la Market Place
 , P_TYPE_ACTION IN VARCHAR2
 ) AS
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 clWhere varchar2(1000);
  -- Pour les merge, la clause where ne doit pas inclure la colonne ERREURS, on gère des clauses spécifiques
 clWhereMerge varchar2(1000);
 clWhereMergeErreur varchar2(250);
 
 req varchar2(2000);
 w_length_matricule number;
 w_id_natcol varchar2(4000);
 w_err VARCHAR2(2000);
 v_start NUMBER;
 v_stop  Number;
 varsys varchar2(100);
 BEGIN
 v_start := DBMS_UTILITY.GET_TIME;
 
 
 select VALVAR into w_length_matricule from sys_varsys where module='SYS' and codvar='LONGUEUR_MATRIC';
 
 clwhere:='DI.login='''||p_login||''' and DI.date_import='''||p_date_import||'''';
 if p_numligne is not null then
 	clwhere:=clwhere||' AND DI.NUMLIGNE='||p_numligne;
 end if;
 
 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controler
 clwhere:=clwhere || ' AND (DI.STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR DI.STATUT = ''TRANS'') ';
 
 clWhereMerge := clwhere;
 clWhereMergeErreur := '';
 
 IF p_type_action = 'VI' and p_login <> 'BATCH' then
   -- A la validation d'import Web, on ne va passer que sur les lignes qui ne sont pas déjà en erreur.
   -- Certaines lignes sont déjà en erreur et on ne veut pas les retraiter (sinon double message)
   clwhere := clwhere || ' and DI.ERREURS is null';
   clWhereMergeErreur := ' where DI.ERREURS is null';
 END IF;
 
 IF p_login ='BATCH' THEN 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées. Seulement pour le BATCH, car dans les autres cas il y a des contrôles
 -- qui sont fait en amont des contrôles PL/SQL (côté Java)
 	req:='update TGE_IMPORT_DONNEES DI SET ERREURS = '''' WHERE '||clwhere;
 	EXECUTE_IMMEDIATE_STRING( req,0);
 	
 -- Contrôle que le collaborateur est cohérent : date effet / paiezad. En Batch, on n'utilise pas IdentifiantCollab pour récupérer les informations
 -- du collaborateur, on prend juste ce qui est dans le fichier. On doit donc contrôler que le collab existe
 	req:= 'update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS, '''||replace(get_message_erreur('STD', 'STD00046', p_codlang),'''','''''')||''',DI.MATRICULE||''|''||DI.NUMPAC||''|''||DI.PACMAT||''|''||DI.PAIEZAD||''|''||DI.DATE_EFFET,'''||p_codlang||''') where '||clwhere;
  	req:= req || ' and DI.NUMPAC is not null and DI.PAIEZAD is not null';
  	req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=DI.NUMPAC and DACS.PAIEZAD=DI.PAIEZAD';
  	req:= req || ' and TO_DATE(DI.DATE_EFFET, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
  	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 --contenu NumPac TGE00077
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- format MATRICULE TGE00089
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00089',p_codlang),'''','''''')||''',MATRICULE,'''||p_codlang||''') where '||clwhere||' AND MATRICULE is NOT null AND LENGTH (MATRICULE)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --contenu PaieZad TGE00078
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --contenu Periode TGE00010
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie ZDV00060 (seulement pour les DR/DR cotis date_effet doit être < periode)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00060',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_EFFET is not null';
 req := req ||' and TYPE_DONNEE in (''2'',''3'') and DATE_EFF_PER_AFFECT in (''D'', ''2'') and IS_DATE(DATE_EFFET, ''YYYYMMDD'') = 1 and IS_DATE(PERIODE, ''YYYYMM'') = 1 and DATE_EFFET >= PERIODE' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie TGE00310 (seulement pour les DV car pour les DR/DR cotis c'est le message ZDV00060 qui devra s'afficher)
 req:='update TGE_IMPORT_DONNEES DI  SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00310',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req:= req ||' and TYPE_DONNEE in (''1'')';
 -- permet de gérer les cas où DATE_EFFET ou PERIODE ne sont pas des dates valides 
 req:= req ||' and (select case when to_date(DI.DATE_EFFET,''YYYYMMDD'') > last_day(to_date(DI.PERIODE,''YYYYMM'')) then ''O'' else ''N'' end from dual where is_date(DI.DATE_EFFET, ''YYYYMMDD'')=1 and is_date(DI.PERIODE, ''YYYYMM'')=1 ) = ''O'''; 
 EXECUTE_IMMEDIATE_STRING( req,0);
  
 IF p_type_action = 'ECS' or p_type_action = 'EMS' then
	-- En SimuPaie, on contrôle seulement l'interdiction de la saisie dans la passé : TGE00311 (il n'y a pas de passé, rétro) 
	req:='update TGE_IMPORT_DONNEES DI  set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	req:= req ||' where '||clwhere || ' ';
	-- permet de gérer les cas où PERIODE n'est pas une date valide 
	req:= req ||' and (select case when to_date(DI.PERIODE,''YYYYMM'') < (select to_date(P.PERIODEENCOURS,''YYYYMM'') from TGE_REF_PAC P where P.NUMPAC = DI.NUMPAC) then ''O'' else ''N'' end from dual where is_date(DI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
	EXECUTE_IMMEDIATE_STRING( req,0); ELSE
	 -- période de paie pour les DV : TGE00311 / ZDV00066 / TGE00336 / TGE00337
	 req:='merge into TGE_IMPORT_DONNEES DI using';
	 req:= req ||' (select P1.NUMPAC, P1.PERIODEENCOURS, P1.DEB_RETRO,GREATEST(P1.DEB_HISTO_RETRO,NVL( S.PREMIERE_PAIE, ''190101''))  AS DEB_HISTO_RETRO ,S.PACMAT, P1.NB_MOIS_RETRO, ';
	 req:= req ||' R.OPTION_RETRO, R.CODERUB, ';
	 -- Pour le calcul de la limite rétro, on ne tient pas compte du max entre DEB_HISTO_RETRO et PERIODEENCOURS - NB_MOIS
	 -- car c'est le test sur la DEB_HISTO_RETRO et le message TGE00336 qui sera pris en compte
	 req:= req ||' TO_CHAR(ADD_MONTHS(TO_DATE(P1.PERIODEENCOURS, ''YYYYMM''), -P1.NB_MOIS_RETRO), ''YYYYMM'') AS LIMITE_RETRO '; 
	 req:= req ||' from TGE_REF_PAC P1 INNER JOIN TGE_REF_RUBRIQUE R ON  P1.NUMPAC = R.NUMPAC LEFT JOIN SECUPACMAT s ON P1.NUMPAC = s.NUMPAC ) P';
	 req:= req ||' on (';
	 req:= req || clwhereMerge;
	 req:= req ||' and DI.PERIODE < P.PERIODEENCOURS and DI.TYPE_DONNEE =''1''';
	 req:= req ||' and ( P.DEB_RETRO IS NULL or P.PERIODEENCOURS < P.DEB_RETRO or P.OPTION_RETRO = ''N'' or DI.PERIODE < P.DEB_HISTO_RETRO';
	 req:= req ||' or DI.PERIODE < P.LIMITE_RETRO or DI.PERIODE <> substr(DI.DATE_EFFET, 0, 6))';
	 req:= req ||' and DI.CODE_RUBRIQUE = P.CODERUB'; 
	 req:= req ||' and  ( DI.PACMAT is  null or DI.PACMAT = P.PACMAT )'; 
	 req:= req ||' and P.NUMPAC=DI.NUMPAC)';
	 req:= req ||' when matched then update set DI.ERREURS = case';
	 req:= req ||' when P.DEB_RETRO is null or P.PERIODEENCOURS < P.DEB_RETRO then TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 req:= req ||' when P.OPTION_RETRO = ''N'' then TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00066',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 req:= req ||' when DI.PERIODE < P.DEB_HISTO_RETRO then TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',to_char(to_date(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' when DI.PERIODE < P.LIMITE_RETRO then TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.LIMITE_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' else '''' end';
	 req:= req || clWhereMergeErreur;
	 EXECUTE_IMMEDIATE_STRING( req,0);
 
	 -- période de paie pour les DR/DR Cotis : TGE00311 / ZDV00067
	 req:='merge into TGE_IMPORT_DONNEES DI using TGE_REF_PAC P';
	 req:= req ||' on (';
	 req:= req || clwhereMerge;
	 req:= req ||' and DI.PERIODE < P.PERIODEENCOURS and DI.TYPE_DONNEE in(''2'', ''3'')';
	 req:= req ||' and DI.NUMPAC = P.NUMPAC)';
	 req:= req ||' when matched then update set DI.ERREURS = case';
	 req:= req ||' when P.DEB_RETRO is null then TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 req:= req ||' else TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00067',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 req:= req ||' end';
	 req:= req || clWhereMergeErreur;
	 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- contenu Type_traitement TGE00079
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- contenu Code_rubrique ZDV00027
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00027',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_RUBRIQUE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- contenu IdPacMat TGE00102
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00102',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null AND PACMAT IS NULL ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 /**Controle format**/
 -- controle Format NumPac TGE00072
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',NUMPAC,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is not null AND LENGTH(NUMPAC)>6 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format PaieZad TGE00073
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',PAIEZAD,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is not null AND LENGTH(PAIEZAD)>8 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- format date_effet TGE00315
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00315',p_codlang),'''','''''')||''',DATE_EFFET,'''||p_codlang||''') where '||clwhere||' and DATE_EFFET is not null and is_date(DATE_EFFET,''YYYYMMDD'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format Periode TGE00328
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00328',p_codlang),'''','''''')||''',PERIODE,'''||p_codlang||''') where '||clwhere||' AND PERIODE is NOT null AND IS_DATE(PERIODE,''YYYYMM'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format Origine TGE00100
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',ORIGINE,'''||p_codlang||''') where '||clwhere||' AND ORIGINE is not null AND LENGTH(ORIGINE)>1 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle NATCOL doit avoir la valeur SAL ou STA TGE00027
 select VALVAR into w_id_natcol from sys_varsys where module='STD' and codvar='ID_NATCOL';
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00027',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req := req ||' and (select max(DAC.'||w_id_natcol||') from DIC_ADM_CONTRAT DAC inner join DIC_ADM_CONTRAT_SITU DACS on (DACS.NUMPAC = DAC.NUMPAC and DACS.PACMAT = DAC.PACMAT and DACS.NUMCNT = DAC.NUMCNT) where DACS.PAIEZAD = DI.PAIEZAD and DAC.NUMPAC = DI.NUMPAC';
-- Si le PAC n'est pas MPE, le couple NUMPAC/PAIEZAD ne suffit pas à déterminer un contrat, on utilise la date d'effet
 req := req ||' and case when ((select MPE from TGE_REF_PAC P where P.NUMPAC = DI.NUMPAC) = ''N'' and TO_DATE(DI.DATE_EFFET, ''YYYYMMDD'') between DAC.DSDCN and nvl(DAC.DSFCN, to_date(''20991231'', ''YYYYMMDD'')))';
 req := req ||' or (select MPE from TGE_REF_PAC P2 where P2.NUMPAC = DI.NUMPAC) <> ''N'' then 1 else 0 end = 1) not in (''SAL'', ''STA'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle CODE_REMPLACEMENT TGE00320
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00320',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_REMPLACEMENT is not null AND CODE_REMPLACEMENT <> ''R''';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle CODE_REMPLACEMENT et ORIGINE TGE00322
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00322',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_REMPLACEMENT is not null AND (ORIGINE is null or ORIGINE = '''')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --  controle Format Nombre ZDV00032
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00032',p_codlang),'''','''''')||''',NOMBRE,'''||p_codlang||''') where '||clwhere||' AND NOMBRE is not null ';
 req := req ||' and (is_number(NOMBRE) is null or (is_number(NOMBRE) is not null and (length(trunc(is_number(NOMBRE))) > 11'; 
 req := req ||' or (mod(is_number(NOMBRE), 1) > 0 and length(substr(mod(is_number(NOMBRE),1), instr(mod(is_number(NOMBRE), 1),'','')+1)) > 4))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle  Format Taux ZDV00033
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00033',p_codlang),'''','''''')||''',TAUX,'''||p_codlang||''') where '||clwhere||' AND TAUX is not null ';
 req := req ||' and (is_number(TAUX) is null or (is_number(TAUX) is not null and (length(trunc(is_number(TAUX))) > 11'; 
 req := req ||' or (mod(is_number(TAUX), 1) > 0 and length(substr(mod(is_number(TAUX),1), instr(mod(is_number(TAUX), 1),'','')+1)) > 4))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --controle Format Montant ZDV00034
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00034',p_codlang),'''','''''')||''',MONTANT,'''||p_codlang||''') where '||clwhere||' AND MONTANT is not null ';
 req := req ||' and (is_number(MONTANT) is null or (is_number(MONTANT) is not null and (length(trunc(is_number(MONTANT))) > 11'; 
 req := req ||' or (mod(is_number(MONTANT), 1) > 0 and length(substr(mod(is_number(MONTANT),1), instr(mod(is_number(MONTANT), 1),'','')+1)) > 2))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format Pourcentage ZDV00035
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00035',p_codlang),'''','''''')||''',POURCENTAGE,'''||p_codlang||''') where '||clwhere||' AND POURCENTAGE is not null ';
 req := req ||' and (is_number(POURCENTAGE) is null or ( is_number(POURCENTAGE) is not null and (length(trunc(is_number(POURCENTAGE))) > 3'; 
 req := req ||' or (mod(is_number(POURCENTAGE), 1) > 0 and length(substr(mod(is_number(POURCENTAGE),1), instr(mod(is_number(POURCENTAGE), 1),'','')+1)) > 3))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format Domaine_prcte ZDV00036
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00036',p_codlang),'''','''''')||''',DOMAINE_PRCTE,'''||p_codlang||''') where '||clwhere||' AND DOMAINE_PRCTE is not null AND LENGTH(DOMAINE_PRCTE)>1';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format Cle_import  TGE00099
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00099',p_codlang),'''','''''')||''','''||p_login||'#';
 req := req ||p_date_import||'#'||p_numligne||''','''||p_codlang||''') where '||clwhere||' AND (:login||''#''||:dateimp||''#''||:numligne) is not null AND LENGTH(:login||''#''||:dateimp||''#''||:numligne)>70';
 execute immediate req using p_login,p_date_import,p_numligne,p_login,p_date_import,p_numligne;
 --  controle Format IdPacMat TGE00103
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00103',p_codlang),'''','''''')||''',numpac||PACMAT,'''||p_codlang||''') where '||clwhere||' AND numpac is not null AND pacmat is not null ';
 req:=req ||' AND  LENGTH(RPAD(NUMPAC,6) || PACMAT) >14  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- existe Type Traitement TGE00101
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',DI.TYPE_TRAITEMENT,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is not null  ';
 req:= req || ' and not exists (select 1 from TGE_REF_TYPETRT TT where TT.CODETYPTRT = DI.TYPE_TRAITEMENT';
 req:= req || ' and (';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = DI.NUMPAC and TT2.CODETYPTRT = DI.TYPE_TRAITEMENT) > 0 and TT.NUMPAC = DI.NUMPAC)';
 req:= req ||   ' or';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = DI.NUMPAC and TT2.CODETYPTRT= DI.TYPE_TRAITEMENT) = 0 and TT.NUMPAC=''*'')';
 req:= req || ' ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- existe Caisse  TGE00013
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',DI.CODE_CAISSE,'''||p_codlang||''') where '||clwhere||' AND DI.CODE_CAISSE is not null AND DI.CODE_CAISSE !=''*'' ';
 req:= req || ' and not exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = DI.NUMPAC and RC.CODECAISSE= DI.CODE_CAISSE)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- existe Imputation FctVarsys TGE00012
 select valvar into varsys from sys_varsys where module='TGE' and CODVAR='CTRL_CODE_IMPUTATION_EXISTE';
 if upper(varsys)<>'FALSE' then
 	req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00012',p_codlang),'''','''''')||''',DI.code_imputation||''|''||DI.numPac,'''||p_codlang||''') ';
	req:= req || ' where '||clwhere||' and DI.CODE_IMPUTATION <> ''*'' and DI.CODE_IMPUTATION is not null';
	req:= req || ' and not exists (select 1 from TGE_REF_IMPUTATION RI where RI.CODEIMP = DI.CODE_IMPUTATION';
	req:= req || ' and (';
	req:= req ||   ' ((select count(*) from TGE_REF_IMPUTATION RI2 where RI2.NUMPAC = DI.NUMPAC and RI2.CODEIMP = DI.CODE_IMPUTATION) > 0 and RI.NUMPAC = DI.NUMPAC)';
	req:= req ||   ' or';
	req:= req ||   ' ((select count(*) from TGE_REF_IMPUTATION RI2 where RI2.NUMPAC = DI.NUMPAC and RI2.CODEIMP= DI.CODE_IMPUTATION) = 0 and RI.NUMPAC=''*'')';
	req:= req || ' ))';
 	EXECUTE_IMMEDIATE_STRING( req,0);
 end if;
 
 /***Controle format des colonnes DSN **/
 -- controle Format PERIODE_RATTACH_DEB
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00325',p_codlang),'''','''''')||''',PERIODE_RATTACH_DEB,'''||p_codlang||''') where '||clwhere||' AND PERIODE_RATTACH_DEB is NOT null AND IS_DATE(PERIODE_RATTACH_DEB, ''YYYYMMDD'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Format PERIODE_RATTACH_FIN
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00326',p_codlang),'''','''''')||''',PERIODE_RATTACH_FIN,'''||p_codlang||''') where '||clwhere||' AND PERIODE_RATTACH_FIN is NOT null AND IS_DATE(PERIODE_RATTACH_FIN, ''YYYYMMDD'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Format DATE_DEB_ARRET
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00327',p_codlang),'''','''''')||''',DATE_DEB_ARRET,'''||p_codlang||''') where '||clwhere||' AND DATE_DEB_ARRET is NOT null AND IS_DATE(DATE_DEB_ARRET, ''YYYYMMDD'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Format PERIODE_AFFECTATION
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00221',p_codlang),'''','''''')||''',PERIODE_AFFECTATION,'''||p_codlang||''') where '||clwhere||' AND PERIODE_AFFECTATION is NOT null AND IS_DATE(PERIODE_AFFECTATION, ''YYYYMMDD'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle periode de rattachement TGE00223
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00223',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE_RATTACH_FIN is NOT null AND PERIODE_RATTACH_DEB IS NOT NULL';
 req:=req ||' and IS_DATE(PERIODE_RATTACH_DEB, ''YYYYMMDD'') = 1 and IS_DATE(PERIODE_RATTACH_FIN, ''YYYYMMDD'') = 1  AND PERIODE_RATTACH_FIN < PERIODE_RATTACH_DEB';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
   -- controle periode affectation ZDV00061 (pour les DR/DR cotis periode_affectation < periode)
   req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00061',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE_AFFECTATION is not null';
   req := req ||' and TYPE_DONNEE in (''2'',''3'') and DATE_EFF_PER_AFFECT in (''A'', ''2'') and IS_DATE(PERIODE_AFFECTATION, ''YYYYMMDD'') = 1 ';
   req := req ||' and IS_DATE(PERIODE, ''YYYYMM'') = 1 and PERIODE_AFFECTATION >= PERIODE' ;
   EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 --LOGIN different de batch TGE00107
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00107',p_codlang),'''','''''')||''',LOGIN,'''||p_codlang||''') where '||clwhere||' AND LOGIN!=''BATCH'' AND LENGTH (LOGIN)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- DR/DR cotis : date_effet et periode_affectation sont obligatoires
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00324',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE_AFFECTATION IS  NULL   ';
 req := req ||' AND  DATE_EFFET IS NULL  AND  NVL(TYPE_DONNEE,99)!=1' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 --controle Signe Nombre
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00046',p_codlang),'''','''''')||''',NOMBRE,'''||p_codlang||''') where '||clwhere||' AND NOMBRE IS NOT NULL   AND  substr(NOMBRE,1,1) in (''+'',''-'',''*'',''^'',''['','']'',''.'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --controle Signe Taux
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00047',p_codlang),'''','''''')||''',TAUX,'''||p_codlang||''') where '||clwhere||' AND  TAUX IS NOT NULL  AND  substr(TAUX,1,1) in (''+'',''-'',''*'',''^'',''['','']'',''.'')  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --controle Signe Montant
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00048',p_codlang),'''','''''')||''',MONTANT,'''||p_codlang||''') where '||clwhere||' AND  MONTANT IS NOT NULL AND  substr(MONTANT,1,1) in (''+'',''-'',''*'',''^'',''['','']'',''.'')    ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Signe Pourcentage
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00049',p_codlang),'''','''''')||''',POURCENTAGE,'''||p_codlang||''') where '||clwhere||' AND  POURCENTAGE IS NOT NULL AND substr(POURCENTAGE,1,1) in (''+'',''-'',''*'',''^'',''['','']'',''.'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controle Pourcentage Domaine Pourcentage
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00017',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND  POURCENTAGE IS  NULL AND DOMAINE_PRCTE IS NOT NULL ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Domaine autorisé : M, N, T ZDV00065
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00065',p_codlang),'''','''''')||''',DOMAINE_PRCTE,'''||p_codlang||''') where '||clwhere||' and DOMAINE_PRCTE is not null and DOMAINE_PRCTE not in (''M'', ''N'', ''T'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- contenu Sens TGE00007 (DR/DR Cotis)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00007',p_codlang),'''','''''')||''',SENS,'''||p_codlang||''') where '||clwhere||' AND SENS IS  NULL AND TYPE_DONNEE IN (''2'',''3'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- controle Sens TGE00038 (DR/DR Cotis)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00038',p_codlang),'''','''''')||''',SENS,'''||p_codlang||''') where '||clwhere||' AND SENS IS NOT NULL AND SENS NOT IN (''+'',''-'') AND TYPE_DONNEE IN (''2'',''3'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- contenu Code caisse ZDV00028 (DR Cotis)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00028',p_codlang),'''','''''')||''',CODE_CAISSE,'''||p_codlang||''') where '||clwhere||' AND (CODE_CAISSE is null or CODE_CAISSE = ''*'') AND TYPE_DONNEE =''3'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controle Flag DVDR
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00002',p_codlang),'''','''''')||''',CODE_RUBRIQUE,'''||p_codlang||''') where '||clwhere||' AND CODE_RUBRIQUE IS NOT NULL AND TYPE_DONNEE =''1'' ';
 req:= req || 'and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB= DI.CODE_RUBRIQUE and NVL(R.FLAGDVDR,''N'') in(''O'',''V''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZDV00003',p_codlang),'''','''''')||''',CODE_RUBRIQUE,'''||p_codlang||''') where '||clwhere||' AND  CODE_RUBRIQUE IS NOT NULL AND TYPE_DONNEE in (''2'',''3'') ';
 req:= req || 'and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB= DI.CODE_RUBRIQUE and NVL(R.FLAGDVDR,''N'') in(''O'',''R''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Il ne doit pas y avoir de pac * dans la table TGE_REF_RUBRIQUE
 --Existance code rubrique pour les type de donnees !=3 (DV et DR)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00359',p_codlang),'''','''''')||''',CODE_RUBRIQUE,'''||p_codlang||''') where '||clwhere||' AND CODE_RUBRIQUE IS NOT NULL AND TYPE_DONNEE !=''3'' ';
 req:= req || ' and not exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB= DI.CODE_RUBRIQUE)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --Existance code rubrique pour les type de donnees =3 (DR cotis)
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00359',p_codlang),'''','''''')||''',CODE_RUBRIQUE,'''||p_codlang||''') where '||clwhere||' AND CODE_RUBRIQUE IS NOT NULL AND TYPE_DONNEE =''3'' ';
 req:= req || ' and not exists (select 1 from TGE_REF_RUBRIQUE R ,TGE_REF_LIBRUB_COTIS L where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.CODERUB = L.CODERUB)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Montant Rubrique ZDV00018 ou ZDV00019
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00018',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.MONTANT is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGMONTANT = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00019',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.MONTANT is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGMONTANT = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controle Flag Nombre Rubrique ZDV00038 ou ZDV00039
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00038',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.NOMBRE is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGNB = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00039',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.NOMBRE is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGNB = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Taux Rubrique ZDV00040 ou ZDV00041
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00040',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.TAUX is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGTAUX = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00041',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.TAUX is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGTAUX = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Pourcentage ZDV00042 ou ZDV00043
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00042',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.POURCENTAGE is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGPCTG = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00043',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.POURCENTAGE is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGPCTG = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controle qu'au moins 1 valeur a été saisie si aucun FLAG (nombre, montant, taux, pourcentage) n'est obligatoire TGE00022
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00022',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and DI.NOMBRE is null and DI.TAUX is null and DI.MONTANT is null and DI.POURCENTAGE is null';
 req:= req || ' and exists  (';
 req:= req ||   ' select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and (R.FLAGNB is null or R.FLAGMONTANT is null or R.FLAGTAUX is null or R.FLAGPCTG is null)';
 req:= req || ')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Imputation Rubrique ZDV00044 ou ZDV00045
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00044',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.CODE_IMPUTATION is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGIMP = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00045',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.CODE_IMPUTATION is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGIMP = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Rattachement Rubrique
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00054',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and (DI.PERIODE_RATTACH_DEB is null or DI.PERIODE_RATTACH_FIN is null)';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGRATTACH = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00053',p_codlang),'''','''''')||''',NULL ,'''||p_codlang||''') where '||clwhere||' and (DI.PERIODE_RATTACH_DEB is not null or DI.PERIODE_RATTACH_FIN is not null) ';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGRATTACH = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle Flag Arret Rubrique
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00055',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' and DI.DATE_DEB_ARRET is null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGARRET = ''O'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_DONNEES DI set DI.ERREURS=TGE_GET_MESSAGE_ERREUR(DI.ERREURS,'''||replace(get_message_erreur('TGE','ZDV00056',p_codlang),'''','''''')||''',NULL ,'''||p_codlang||''') where '||clwhere||' and DI.DATE_DEB_ARRET is not null';
 req:= req || ' and exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = DI.NUMPAC and R.CODERUB = DI.CODE_RUBRIQUE and R.FLAGARRET = ''I'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Controle Origine et mode_3060 : TGE00317
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00317',p_codlang),'''','''''')||''',DI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and DI.ORIGINE is not null and DI.CODE_REMPLACEMENT = ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = DI.ORIGINE and G.NUMPAC = DI.NUMPAC and G.MODE_3060 <> ''R'' and G.MODE_3060 <> ''F'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_type_action = 'EM' or p_type_action = 'EMS' THEN
   -- Ce test n'est à faire qu'en modification (EM), mais pas à la création (EC ou I)
   -- Controle Origine et mode_3060 : TGE00318
   req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00318',p_codlang),'''','''''')||''',DI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
   req:= req || ' and DI.ORIGINE is not null and nvl(DI.CODE_REMPLACEMENT, ''*'') <> ''R''';
   req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = DI.ORIGINE and G.NUMPAC = DI.NUMPAC and G.MODE_3060 <> ''W'')';
   EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Contrôle Origine existe pour le numPac TGE00331
 -- Ce test devra être supprimé lorsque celui associé au message TGE00321(origine est cohérente avec la GTA du collaborateur)
 -- sera intégré au contrôle PL/SQL (pour le moment fait en Java pour les saisies écrans et imports Web) 
 req:='update TGE_IMPORT_DONNEES DI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00331',p_codlang),'''','''''')||''',DI.ORIGINE||''|''||DI.NUMPAC ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and DI.ORIGINE is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = DI.ORIGINE and G.NUMPAC = DI.NUMPAC)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
 		-- On remonte l'erreur à l'application
  		raise;
  	END IF;
 END TGE_CONTROLE_DONNEE_PAIE;
##
TAG_CHARSET=@€éèç
##
TGE_CREATE_TRIGGER
=SQL=
CREATE OR REPLACE PROCEDURE TGE_CREATE_TRIGGER(NOM_TABLE IN VARCHAR2)
AS
  PROC CLOB;
  PROC_MP_NOTIF CLOB;
  populateLigOld CLOB;
  populateLigNew CLOB;
  v_typeTable VARCHAR(1);
  is_aller_ou_allerretour_mapta NUMBER;
  table_exist                   NUMBER;
  type_writer_exists            NUMBER;
BEGIN

  -- Exclusion de DACS, le trigger est en dur.
  IF upper(NOM_TABLE) = 'DIC_ADM_CONTRAT_SITU' THEN
    RETURN;
  END IF;
  
  -- On teste si la table existe bien
  SELECT COUNT(*)
  INTO table_exist
  FROM user_tables
  WHERE table_name = nom_table;
  IF table_exist = 0 THEN
    RETURN;
  END IF;

  SELECT COUNT(*)
  INTO is_aller_ou_allerretour_mapta
  FROM tge_ref_mapta
  WHERE 
    tablephy = nom_table
      --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_REF_MAPDO
      --Ajout du type 'I'
    AND allerretour                                   IN ('A', '2','I');

  PROC_MP_NOTIF := TGE_CREATE_TRIGGER_MP_NOTIF(NOM_TABLE);

  -- Si on n'est ni sur une table qui part en paie, ni sur une table qui génère des notifications Marketplace, ni sur DIC_ADM_PERSO, DIC_ADM_PERSO_HISTO, DIC_ADM_CONTRAT ou DIC_ADM_CONTRAT_HISTO, on ne génère pas de trigger
  IF is_aller_ou_allerretour_mapta = 0 AND nom_table NOT IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') AND PROC_MP_NOTIF IS NULL THEN
    RETURN;
  END IF;

  -- Si la colonne TYPE_WRITER n'existe pas, on la crée
  SELECT COUNT(*)
  INTO type_writer_exists
  FROM user_tab_cols
  WHERE column_name     = 'TYPE_WRITER'
  AND table_name        = NOM_TABLE;
  IF type_writer_exists = 0 THEN
     EXECUTE_IMMEDIATE_STRING(  'ALTER TABLE ' || NOM_TABLE || ' ADD (TYPE_WRITER VARCHAR2(1 BYTE))',0);
  END IF;

  v_typeTable := fsed.getTypeTable(NOM_TABLE);

  PROC        := 'CREATE OR REPLACE TRIGGER TRG_' || NOM_TABLE || ' FOR INSERT OR UPDATE OR DELETE ON '||NOM_TABLE||' COMPOUND TRIGGER 
v_matric varchar2(32);
v_numpac varchar2(6); 
v_pacmat varchar2(8); 
v_paiezad varchar2(8);
v_type_writer varchar2(1); 
v_bypass_trigger number; 
v_bypass_DACH number; 
v1_bypass_DACH number;
TYPE periodeTabType is  table of TGE_REF_PAC.PERIODEENCOURS%TYPE ; 
periodeTab periodeTabType := periodeTabType();    
idxPeriodesIndiv NUMBER;
v_ligOld '||nom_table||'%ROWTYPE;
v_ligNew '||nom_table||'%ROWTYPE;
v_periode varchar2(6);
tabRefPacByNumpac ALIM_IDX.T_REF_PAC_BY_NUMPAC; 
';
  IF nom_table='DIC_PERIODES_RECUEIL_HIS' OR nom_table='DIC_ADM_CONTRAT_HISTO' THEN
    PROC :=PROC||'
listJobMasseAsync varchar2(4000);
listJobMasseAsyncTab TAB_VARCHAR:=TAB_VARCHAR();
v_jobAsyncMasseIdx NUMBER;
';
  END IF;

  IF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
    PROC :=PROC||'
TYPE paiezadPacPeriodModifedType IS  TABLE OF TGE_PAC_PAIEZAD_PERIOD_RETRO  INDEX BY VARCHAR2(15);
paiezadPacPeriodModifed paiezadPacPeriodModifedType ;
idx  VARCHAR2(15);
';
  ELSE 
    PROC :=PROC||'
idx NUMBER;
';
  END IF;

  IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
    PROC          :=PROC||' 
v_listMatricToUpdate CLOB := NULL; 
v_nbMatricToUpdate NUMBER := 0;
v_countSecNav NUMBER := -1;
';
    IF nom_table   ='DIC_ADM_PERSO' THEN
      PROC        :=PROC||'
v_listMatricToDelete CLOB := NULL; 
v_nbMatricToDelete NUMBER := 0;
';
    ELSIF nom_table='DIC_ADM_CONTRAT' THEN
      PROC        :=PROC||'
v_date_debut_periode_paie DATE :=NULL; 
v_nbLig NUMBER; 
v_doMajPerso NUMBER := 0; 
TYPE NUMPAC_PACMAT_TO_DELETE IS RECORD (MATRIC DIC_ADM_CONTRAT.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT.PACMAT%TYPE); 
TYPE TAB_NUMPAC_PACMAT_TO_DELETE IS TABLE OF NUMPAC_PACMAT_TO_DELETE; 
v_NUMPAC_PACMAT NUMPAC_PACMAT_TO_DELETE; 
v_TAB_NUMPAC_PACMAT TAB_NUMPAC_PACMAT_TO_DELETE; 
v_listNumpacPacmatToDelete CLOB := '',''; 
';
    ELSIF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
      PROC        :=PROC||'
v_dsdcn DIC_ADM_CONTRAT.DSDCN%TYPE; 
v_date_eff DIC_ADM_CONTRAT_HISTO.DATE_EFF%TYPE;
v_natcol DIC_ADM_CONTRAT.NATCOL%TYPE; 

TYPE paiezadTabType is table of DIC_ADM_CONTRAT_HISTO.PAIEZAD%TYPE ; 
TYPE numpacTabType is  table of DIC_ADM_CONTRAT_HISTO.NUMPAC%TYPE ; 
paiezadTab paiezadTabType := paiezadTabType(); 
numpacTab numpacTabType := numpacTabType(); 

TYPE T_TRAITEMENT_PERIODES_INDIV IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(100);
-- Ce tableau indexé contient plusieurs chose :
-- + Une entrée avec un code PAC + un PAIEZAD --> Un flag permettant de savoir si le couple NUMPAC/PAIEZAD a déjà été traité
-- + Une entrée avec un code PAC --> La période en cours du PAC
tabTrtPeriodesIndividuelles T_TRAITEMENT_PERIODES_INDIV;
in_calc_hp T_TRAITEMENT_PERIODES_INDIV;
TYPE calcHpTabType is  table of T_TRAITEMENT_PERIODES_INDIV ; 
calcHpTab calcHpTabType := calcHpTabType();
 
TYPE T_COMPARAISON_VAL_OLD_NEW IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(20);
tabValToCompare T_COMPARAISON_VAL_OLD_NEW;
TYPE PRESENTDIC_PACMAT IS RECORD 
(NUMPAC  varchar2(6),PACMAT DIC_ADM_CONTRAT_HISTO.PACMAT%TYPE);
TYPE TAB_PRESENTDIC_PACMAT IS TABLE OF PRESENTDIC_PACMAT INDEX BY VARCHAR2(14);
indexTabPresFicPacmat varchar2(14);
tabPresenceFichierPacmat TAB_PRESENTDIC_PACMAT;
alimPeriodesIndiv boolean;
';
    END IF;

    IF nom_table='DIC_ADM_CONTRAT' OR nom_table='DIC_ADM_CONTRAT_HISTO' THEN
      PROC     :=PROC||'
v_actionIdx VARCHAR2(1);
v_lanceRecalculHp boolean;
v_isDeleting  NUMBER ;
v_jobIdx NUMBER;
v_cle_idx_contrat T_CLE_IDX_CONTRAT_HISTO; 
v_cles_idx_contrat T_CLES_IDX_CONTRAT_HISTO := T_CLES_IDX_CONTRAT_HISTO();
';
    END IF;

    IF nom_table='DIC_ADM_PERSO' OR nom_table='DIC_ADM_CONTRAT' THEN
      PROC     :=PROC||'
v_matricForPacmat VARCHAR2(32); 
TYPE T_LOCKED_MATRIC IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(32);
tabLockedMatric T_LOCKED_MATRIC;
';
    END IF;
  END IF;

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    PROC      :=PROC||' 
BEFORE STATEMENT IS BEGIN
 select count(*) into v_bypass_DACH from bypass_trg_DACH_on_session;
END BEFORE STATEMENT;
';
  END IF;

  PROC        := PROC || '  
BEFORE EACH ROW IS BEGIN
' ;

  populateLigOld := NULL;
  populateLigNew := NULL;
  FOR liste_cols_table IN (SELECT COLUMN_NAME FROM USER_TAB_COLS WHERE TABLE_NAME=NOM_TABLE AND COLUMN_ID IS NOT NULL ORDER BY COLUMN_NAME) 
  LOOP
    populateLigOld := populateLigOld||'
v_ligOld.'||liste_cols_table.COLUMN_NAME||' := :OLD.'||liste_cols_table.COLUMN_NAME||';';

        populateLigNew := populateLigNew||'
v_ligNew.'||liste_cols_table.COLUMN_NAME||' := :NEW.'||liste_cols_table.COLUMN_NAME||';';
  END LOOP;

  PROC      := PROC || '
IF INSERTING THEN 
 -- On initialise le ''OLD'' (car :OLD n''existe pas, en insertion)
 v_ligOld := ';
  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- En insertion dans DIC_ADM_CONTRAT_HISTO, on considère que le 'OLD' c'est l'histo précédent (celui qui est en train d'être splitté)
    PROC      := PROC || 'GET_CONTRAT_HISTO_HORS_TRANSAC(:NEW.NUMPAC, :NEW.PACMAT, :NEW.NUMCNT, :NEW.DATE_EFF-1, TRUE); ';
  ELSE
    PROC      := PROC || 'NULL; ';
  END IF;
  PROC      := PROC || '
ELSE' || populateLigOld || '
END IF;
IF DELETING THEN 
 -- On initialise le ''NEW'' (car :NEW n''existe pas, en suppression)
 v_ligNew := ';
  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- En suppression dans DIC_ADM_CONTRAT_HISTO, on considère que le 'NEW' c'est l'histo précédent (dont les données vont remplacer celles de l'histo qui est supprimée)
    PROC      := PROC || 'GET_CONTRAT_HISTO_HORS_TRANSAC(:OLD.NUMPAC, :OLD.PACMAT, :OLD.NUMCNT, :OLD.DATE_EFF-1, TRUE); ';
  ELSE
    PROC      := PROC || 'NULL; ';
  END IF;
  PROC      := PROC || '
ELSE' || populateLigNew || '
END IF;
';

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    PROC      := PROC || ' IF (v_bypass_DACH > 0) THEN null; else ';
  END IF;

  PROC          := PROC || ' 
if (v_bypass_trigger > 0) then 
 v_type_writer := ''N''; 
else 
 IF DELETING THEN 
  v_type_writer :=NVL(v_ligOld.type_writer,''O''); 
 ELSE 
  v_type_writer :=NVL(v_ligNew.type_writer,''O''); 
  -- On remet TYPE_WRITER à NULL pour qu''il ne soit pas considéré comme ''N'' lors des futurs update n''incluant pas cette colonne 
  :NEW.type_writer := NULL; 
  v_ligNew.type_writer := :NEW.type_writer; 
 END IF; 
END IF; 
v_matric := NVL(v_ligNew.MATRIC,v_ligOld.MATRIC);
';

  IF v_typeTable = 'z' THEN
    PROC := PROC||' 
v_numpac := nvl(v_ligNew.numpac,v_ligOld.numpac);
IF DELETING THEN
 v_paiezad := v_ligOld.paiezad;
ELSE
 v_paiezad := v_ligNew.paiezad;
END IF; ';
  ELSIF v_typeTable='p' THEN
    PROC := PROC||' 
v_numpac := nvl(v_ligNew.numpac,v_ligOld.numpac);
v_pacmat := nvl(v_ligNew.pacmat,v_ligOld.pacmat); ';
  END IF;

  IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
    PROC      := PROC || '
IF v_type_writer<>''N'' AND v_type_writer<>''M'' AND v_countSecNav=-1 THEN
 SELECT COUNT(*) INTO v_countSecNav FROM SECUPACMAT_TMP WHERE MATRIC=''SECNAV'';
 IF v_countSecNav>0 THEN
  RAISE_APPLICATION_ERROR(-20000,''CODERR=GENREC03'');
 END IF;
END IF;
';
  END IF;

  IF nom_table ='DIC_ADM_PERSO' OR nom_table ='DIC_ADM_CONTRAT' THEN
    -- On récupère le MATRIC et on teste si on l'a déjà traité
    PROC      := PROC || ' 
IF v_type_writer<>''N'' AND v_type_writer<>''M'' AND NOT tabLockedMatric.exists(v_matric) THEN';

    -- En cas de modification de DAP, on lock les tables qui la mette à jour par trigger (DAPH, DAC, DACS et DACH)
    -- En cas de modification de DAC, on lock les tables qui la mette à jour par trigger (DACS et DACH)
    IF nom_table ='DIC_ADM_PERSO' THEN
      -- DAPH et DAC uniquement pour DAP
      PROC      := PROC || ' 
BEGIN
UPDATE DIC_ADM_PERSO_HISTO SET MATRIC=MATRIC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matric;
EXCEPTION WHEN OTHERS THEN NULL; END;
BEGIN
UPDATE DIC_ADM_CONTRAT SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matric;
EXCEPTION WHEN OTHERS THEN NULL; END;';
    END IF;

    -- DACs et DACH uniquement pour les 2 (DAP et DAC)
    PROC      := PROC || ' 
BEGIN
UPDATE DIC_ADM_CONTRAT_SITU SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd'') WHERE MATRIC=v_matric;
EXCEPTION WHEN OTHERS THEN NULL; END;
BEGIN
UPDATE DIC_ADM_CONTRAT_HISTO SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matric;
EXCEPTION WHEN OTHERS THEN NULL; END;';
        

    -- On stocke le MATRIC pour indiquer qu'on l'a déjà traité
    PROC      := PROC || ' 
tabLockedMatric(v_matric) := ''O'';
END IF;';

  END IF;

  IF nom_table   ='DIC_ADM_PERSO' THEN
    PROC        :=PROC||TRG_PERSO_BEFORE_ROW();
  ELSIF nom_table='DIC_ADM_PERSO_HISTO' THEN
    PROC        :=PROC||TRG_PERSO_HISTO_BEFORE_ROW();
  ELSIF nom_table='DIC_ADM_CONTRAT' THEN
    PROC        :=PROC||TRG_CONTRAT_BEFORE_ROW();
  ELSIF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
    PROC        :=PROC||TRG_CONTRAT_HISTO_BEFORE_ROW();
  END IF;

  IF is_aller_ou_allerretour_mapta > 0 THEN
    PROC := PROC||TGE_CREATE_TRIGGER_RECYCLAGE(NOM_TABLE);
  END IF;

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    PROC      := PROC || '
END IF ;
';
  END IF;

  PROC := PROC||PROC_MP_NOTIF;

  PROC :=PROC||' 
END BEFORE EACH ROW;';

  IF nom_table IN ('DIC_ADM_CONTRAT_HISTO','DIC_PERIODES_RECUEIL_HIS') THEN
    PROC      :=PROC||' AFTER EACH ROW IS BEGIN ';
    IF nom_table   = 'DIC_ADM_CONTRAT_HISTO' THEN
      PROC      := PROC|| TRG_CONTRAT_HISTO_AFTER_ROW();
    ELSIF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
      PROC      := PROC|| DIC_PERIOD_REC_HISTO_AFTER_ROW();
    END IF;
    PROC      :=PROC||' END AFTER EACH ROW;';
  END IF;

  IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_PERIODES_RECUEIL_HIS') THEN
    PROC          :=PROC||' AFTER STATEMENT IS BEGIN';
    IF nom_table   ='DIC_ADM_PERSO' THEN
      PROC        :=PROC||TRG_PERSO_AFTER_STMNT();
    ELSIF nom_table='DIC_ADM_PERSO_HISTO' THEN
      PROC        :=PROC||TRG_PERSO_HISTO_AFTER_STMNT();
    ELSIF nom_table='DIC_ADM_CONTRAT' THEN
      PROC        :=PROC||TRG_CONTRAT_AFTER_STMNT();
    ELSIF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
      PROC        :=PROC||TRG_CONTRAT_HISTO_AFTER_STMNT();
    ELSIF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
      PROC        :=PROC||DIC_PERIODES_REC_H_AFTER_STMNT();
    END IF;
    PROC:=PROC||'END AFTER STATEMENT;';
  END IF;

  PROC :=PROC||' END TRG_'||NOM_TABLE||';';
  
  EXECUTE_IMMEDIATE_STRING( PROC,0);
END TGE_CREATE_TRIGGER;
##
TGE_DROP_PHOTO_A310
=SQL=
create or replace PROCEDURE TGE_DROP_PHOTO_A310 
(
  P_ID IN NUMBER 
, P_NUMPAC IN VARCHAR2 
, P_PERIODEPAIE IN VARCHAR2 
) AS 
/********************************************************************************
 Version     : V5.05.000
 Historique  : - RSI DIT  50818 : Impacts évolution MDD table DACS
*********************************************************************************/
CURSOR cur_mapta
  IS
    SELECT a.*
    FROM tge_ref_mapta a,
      (SELECT * FROM user_tables
      ) b
  WHERE a.numpac     =p_numpac
  AND b.table_name   =a.tablephy
  AND a.allerretour IN ('A','2')
  UNION ALL
  SELECT a.*
  FROM tge_ref_mapta a,
    (SELECT * FROM user_tables
    ) b
  WHERE a.numpac        ='*'
  AND b.table_name      =a.tablephy
  AND a.allerretour    IN ('A','2')
  AND (tableparam) NOT IN
    (SELECT tableparam
    FROM tge_ref_mapta a,
      (SELECT * FROM user_tables
      ) b
    WHERE a.numpac  =p_numpac
    AND b.table_name=a.tablephy
    ) ;
    
 CURSOR cur_element 
 IS
  select * from (
  SELECT distinct c.element,c.tablegxp,c.DONNEEGXP
    FROM 
      (SELECT * FROM user_tables
      ) b,tge_ref_mapdo c
  WHERE C.numpac     =p_numpac
  AND b.table_name   =c.TABLEGXP 
  AND c.element in ('A310','X500')
  UNION ALL
  SELECT distinct c.element,c.tablegxp,c.DONNEEGXP
  FROM 
    (SELECT * FROM user_tables
    ) b,tge_ref_mapdo c
  WHERE C.numpac        ='*'
  AND b.table_name      =c.TABLEGXP
  AND c.element in ('A310','X500')

  AND (TABLEGXP,ELEMENT) NOT IN
    (SELECT a.TABLEGXP,a.element
    FROM tge_ref_mapdo a,
      (SELECT * FROM user_tables
      ) b
    WHERE a.numpac  =p_numpac
    AND b.table_name=a.TABLEGXP
    AND a.ELEMENT IN ('A310','X500')
    ) )  pivot ( max(DONNEEGXP) AS DONNEE FOR (element) IN('A310'as A310 ,'X500' as X500));
    
  lig_mapta cur_mapta%rowtype;
  clWhere CLOB;
BEGIN

For C in cur_element LOOP 
   
   clWhere := '(select distinct numpac,pacmat from dic_adm_contrat_situ where numpac = '''||p_numpac||''' AND paiezad IN (select distinct paiezad from '||c.tablegxp||' WHERE ';
   clWhere := clWhere ||c.X500_DONNEE||' = ''A'' AND '||c.A310_DONNEE||'<=last_day(ADD_MONTHS(to_date('''||P_PERIODEPAIE||''',''YYYYMM''),1)) AND numpac = '''||p_numpac||'''))';
 
OPEN cur_mapta;
  LOOP
    FETCH cur_mapta
    INTO lig_mapta ;
    EXIT
  WHEN cur_mapta%NOTFOUND ;  
  
 EXECUTE_IMMEDIATE_STRING( 'delete FROM PHOTO_'||lig_mapta.tablephy||'  where  (numpac,pacmat) in '||clWhere,0);    
  END LOOP;
  CLOSE cur_mapta;
END LOOP; 
EXCEPTION
WHEN OTHERS THEN
  FSED.FSED_ERREUR(p_id,'TGE_DROP_PHOTO_A310',P_NUMPAC,SQLCODE||'-'||SQLERRM);
  raise;
END TGE_DROP_PHOTO_A310;
##
TGE_GAP_DO_PRE_CONTROLE
=SQL=
CREATE OR REPLACE PROCEDURE TGE_GAP_DO_PRE_CONTROLE(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2 ,
    P_REQUETES    IN VARCHAR2 )
AS
  v_temp_Request VARCHAR2(4000);
  CURSOR v_lignes_gap_data
  IS
    /* Toutes les lignes à controler */
    SELECT *
    FROM TGE_IMPORT_GAP_RETRO_DATA
    WHERE login     = P_LOGIN
    AND date_import = P_DATE_IMPORT
    AND statut     IS NULL;
  v_ligne_gap_data v_lignes_gap_data%ROWTYPE;
  v_ligne_en_erreur_msg VARCHAR2(1000);
  v_nb_all_occs         NUMBER;
BEGIN
  OPEN v_lignes_gap_data;
  LOOP
    FETCH v_lignes_gap_data INTO v_ligne_gap_data;
    EXIT
  WHEN v_lignes_gap_data%NOTFOUND;
    v_ligne_en_erreur_msg := '';
    v_temp_Request        := 'select count(*) from ('||P_REQUETES||')';
    v_temp_Request        := REPLACE(v_temp_Request,'##MATRICULE##',''''||v_ligne_gap_data.matricule||'''');
    v_temp_Request        := REPLACE(v_temp_Request,'##NUMPAC##',''''||v_ligne_gap_data.NUMPAC||'''');
    v_temp_Request        := REPLACE(v_temp_Request,'##PACMAT##',''''||v_ligne_gap_data.PACMAT||'''');
    v_temp_Request        := REPLACE(v_temp_Request,'##NUMCNT##',''''||v_ligne_gap_data.NUMCNT||'''');
    v_temp_Request        := REPLACE(v_temp_Request,'##DATE_PROPAGATION##',''''||v_ligne_gap_data.DATE_PROPAGATION||'''');
    BEGIN
      EXECUTE immediate v_temp_Request INTO v_nb_all_occs;
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
        v_ligne_en_erreur_msg := GET_MESSAGE_ERREUR('TGE','IMPGR036','fr_fr');
        v_nb_all_occs         := -1;
      END;
    END;
    IF v_nb_all_occs      > 1 THEN
      v_ligne_en_erreur_msg := GET_MESSAGE_ERREUR('TGE','IMPGR043','fr_fr');
    END IF;
    IF LENGTH(v_ligne_en_erreur_msg) > 0 THEN
      /*** Si le le nombre de lignes dans la requete simple est different de celui dans la requete avec group by c'est qu'il y au moins une rupture **/
      UPDATE TGE_IMPORT_GAP_RETRO_DATA D
      SET D.statut        = 'KO'
      WHERE D.date_import = v_ligne_gap_data.date_import
      AND D.login         = v_ligne_gap_data.login
      AND d.numligne      = v_ligne_gap_data.numligne;
      INSERT
      INTO TGE_IMPORT_GAP_ERREURS VALUES
        (
          v_ligne_gap_data.login,
          v_ligne_gap_data.date_import,
          v_ligne_gap_data.NUMLIGNE,
          (SELECT NVL(MAX(occerr),0)
          FROM TGE_IMPORT_GAP_ERREURS Err
          WHERE Err.login     = v_ligne_gap_data.login
          AND err.date_import = v_ligne_gap_data.DATE_IMPORT
          AND err.NUMLIGNE    = v_ligne_gap_data.NUMLIGNE
          ) + 1,
          v_ligne_gap_data.MATRICULE,
          v_ligne_gap_data.NUMPAC,
          v_ligne_gap_data.PACMAT,
          v_ligne_gap_data.PAIEZAD,
          v_ligne_gap_data.NUMCNT,
          v_ligne_gap_data.DATE_EFFET,
          NULL ,
          NULL,
          'P',
          v_ligne_en_erreur_msg,
          NULL
        );
    END IF;
  END LOOP;
  CLOSE v_lignes_gap_data;
END TGE_GAP_DO_PRE_CONTROLE;
##
TGE_GENERATION_PHOTO
=SQL=
create or replace PROCEDURE TGE_GENERATION_PHOTO(
    p_id          IN NUMBER,
    p_numpac      IN VARCHAR2,
    p_periodepaie IN VARCHAR2)
/********************************************************************************
Version     : V5.05.000
*********************************************************************************/
AS
  CURSOR cur_mapta
  IS
    SELECT a.*
    FROM tge_ref_mapta a,
      (SELECT * FROM user_tables
      ) b
  WHERE a.numpac     =p_numpac
  AND b.table_name   =a.tablephy
  AND a.allerretour IN ('A','2')
  UNION ALL
  SELECT a.*
  FROM tge_ref_mapta a,
    (SELECT * FROM user_tables
    ) b
  WHERE a.numpac        ='*'
  AND b.table_name      =a.tablephy
  AND a.allerretour    IN ('A','2')
  AND (tableparam) NOT IN
    (SELECT tableparam
    FROM tge_ref_mapta a,
      (SELECT * FROM user_tables
      ) b
    WHERE a.numpac  =p_numpac
    AND b.table_name=a.tablephy
    ) ;
  lig_mapta cur_mapta%rowtype;
  v_typeTable VARCHAR(1);
  clinsert CLOB;
  clinsertsel CLOB;
  clinsertcols CLOB;
  requete CLOB;
  nbpart NUMBER;
  cldate VARCHAR2(500):='';
  p_nb_mois_paie_init number;
BEGIN
   
BEGIN
      SELECT TO_NUMBER(NVL(VALVAR,'0'))
      INTO p_nb_mois_paie_init
      FROM SYS_VARSYS
      WHERE MODULE = 'GAP'
      AND CODVAR   = 'NB_MOIS_PAIE_INIT';
EXCEPTION
  WHEN NO_DATA_FOUND THEN
      p_nb_mois_paie_init :=1;
END ;
p_nb_mois_paie_init := p_nb_mois_paie_init-1;


  OPEN cur_mapta;
  LOOP
  BEGIN
    FETCH cur_mapta
    INTO lig_mapta ;
    EXIT
  WHEN cur_mapta%NOTFOUND ;
    -- on regarde les clés pour savoir si table datée
    cldate:='';
    FOR colonne IN
    (SELECT a.column_name,
      b.data_type
    FROM user_cons_columns a,
      USER_TAB_COLUMNS b
    WHERE a.table_name   =lig_mapta.tablephy
    AND a.table_name     =b.table_name
    AND a.column_name    =b.column_name
    AND constraint_name IN
      (SELECT c.constraint_name
      FROM user_constraints c
      WHERE c.table_name =a.table_name
      AND CONSTRAINT_TYPE='P'
      )
    )
    LOOP
    IF colonne.data_type='DATE'  THEN
       cldate  :=' AND  a.'||colonne.column_name||'<=last_day(to_date('''||p_periodepaie||''',''yyyymmdd''))';
    END IF;
    END LOOP;
    IF lig_mapta.tablephy='DIC_ADM_CONTRAT' THEN
    cldate  :=' AND  a.DSDCN <=last_day(to_date('''||p_periodepaie||''',''yyyymmdd''))';
    END IF;
    -- requête de sélection des données à faire selon le type de table
    v_typeTable   :=fsed.getTypeTable(lig_mapta.tablephy);
    IF v_typeTable ='z' THEN
      clinsertsel :='';
      clinsertcols:='NUMPAC,PACMAT';
      FOR colonne IN
      (SELECT a.column_name
      FROM user_tab_columns a,
        user_tab_columns b
      WHERE a.table_name = lig_mapta.tablephy
      AND b.table_name   ='PHOTO_'
        ||a.table_name
      AND a.column_name=b.column_name
      AND a.column_name NOT LIKE '%IDPACMAT%'
      ORDER BY a.column_id
      )
      LOOP
        IF colonne.column_name <>'NUMPAC' AND colonne.column_name<>'PACMAT' THEN
          clinsertsel          :=clinsertsel||',a.'||colonne.column_name;
          clinsertcols         :=clinsertcols||','||colonne.column_name;
        END IF;
      END LOOP;

      clinsert      :='select distinct '''||p_numpac;
      clinsert      := clinsert||''',b.pacmat'||clinsertsel;
      clinsert      := clinsert||' from '||lig_mapta.tablephy;
      clinsert:= clinsert||' a,DIC_ADM_CONTRAT_SITU b where b.paiezad=a.paiezad and a.numpac=b.numpac and a.numpac= '''||p_numpac;
      clinsert:= clinsert||'''  and a.pacmat in (select c.pacmat from GAP_TRT_LISTE_MAT c where c.id_trt='||p_id||')';     
      clinsert:= clinsert||' and a.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where b.numpac=f.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
    elsif v_typeTable='p' THEN
      clinsertsel   :='';
      clinsertcols  :='';
      FOR colonne IN
      (SELECT a.column_name
      FROM user_tab_columns a,
        user_tab_columns b
      WHERE a.table_name = lig_mapta.tablephy
      AND b.table_name   ='PHOTO_'
        ||a.table_name
      AND a.column_name=b.column_name
      AND a.column_name NOT LIKE '%IDPACMAT%'
      ORDER BY a.column_id
      )
      LOOP
        IF clinsertsel IS NOT NULL THEN
          clinsertsel  :=clinsertsel||',';
        END IF;
        clinsertsel     :=clinsertsel||'a.'||colonne.column_name;
        IF clinsertcols IS NOT NULL THEN
          clinsertcols  :=clinsertcols||',';
        END IF;
        clinsertcols:=clinsertcols||colonne.column_name;
      END LOOP;

      clinsert      :='select distinct '||clinsertsel;
      clinsert      := clinsert||' from '||lig_mapta.tablephy;
      clinsert      := clinsert||' a  where  a.numpac= '''||p_numpac||''' AND    a.pacmat in (select c.pacmat from GAP_TRT_LISTE_MAT c where c.id_trt='||p_id||')';
      clinsert      := clinsert||' and a.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where f.numpac=a.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
    elsif v_typeTable='m' THEN
      clinsertsel   :='';
      clinsertcols  :='NUMPAC,PACMAT';
      FOR colonne IN
      (SELECT a.column_name
      FROM user_tab_columns a,
        user_tab_columns b
      WHERE a.table_name = lig_mapta.tablephy
      AND b.table_name   ='PHOTO_'
        ||a.table_name
      AND a.column_name=b.column_name
      AND a.column_name NOT LIKE '%IDPACMAT%'
      ORDER BY a.column_id
      )
      LOOP
        IF colonne.column_name <>'NUMPAC' AND colonne.column_name<>'PACMAT' THEN
          clinsertsel          :=clinsertsel||',a.'||colonne.column_name;
          clinsertcols         :=clinsertcols||','||colonne.column_name;
        END IF;
      END LOOP;

      clinsert:='select distinct '''||p_numpac;
      clinsert:= clinsert||''',b.pacmat'||clinsertsel;
      clinsert:= clinsert||' from '||lig_mapta.tablephy;
      clinsert:= clinsert||' a,SECUPACMAT b, GAP_TRT_LISTE_MAT c where b.matric=a.matric and b.numpac= '''||p_numpac;
      clinsert:= clinsert||'''  and b.pacmat=c.pacmat and c.numpac='''||p_numpac||''' and c.id_trt='||p_id;
      clinsert:= clinsert||' and b.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where b.numpac=f.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
    END IF;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO *** '||p_numpac||' *** Begin *** '||lig_mapta.tablephy||' (type='||v_typeTable||')',null);

    -- 1)	Sauvegarde de PHOTO dans PH_PH des mal recyclés non déjà présents dans PH_PH
    IF instr(clinsertsel,'a.PACMAT')>0 THEN
      requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select '||clinsertsel ||' from PHOTO_'||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''' AND  b.pacmat not in (select c.pacmat from PH_PH_'||lig_mapta.tablephy||' c where c.numpac='''||p_numpac||'''))';
    ELSE    
      requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select a.numpac,a.pacmat'||clinsertsel ||' from PHOTO_'||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''' AND  b.pacmat not in (select c.pacmat from PH_PH_'||lig_mapta.tablephy||' c where c.numpac='''||p_numpac||'''))';
    END IF;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de PHOTO vers PH_PH des Toresend (mal recyclés) non présents dans PH_PH',requete);
    EXECUTE_IMMEDIATE_STRING( requete,0);
    
    -- 2)	On efface la PHOTO
    -- Contrôle de l'existence de partitionnement (son nom sera aussi une garantie de mode LIST)
    SELECT COUNT(*)
    INTO nbpart
    FROM user_tab_partitions
    WHERE table_name = 'PHOTO_'||lig_mapta.tablephy and partition_name = 'P_'||p_numpac;
    IF nbpart >0 THEN
      BEGIN
      -- Suppression de la partition
      requete:= 'ALTER TABLE PHOTO_'||lig_mapta.tablephy||' TRUNCATE PARTITION P_'||p_numpac||' DROP STORAGE UPDATE GLOBAL INDEXES';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partition PHOTO détectée : suppression',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
      -- Création de la partition
      EXCEPTION
        WHEN OTHERS THEN
         BEGIN
      requete:= 'ALTER TABLE PHOTO_'||lig_mapta.tablephy||' ADD PARTITION P_'||p_numpac||' values ('''||p_numpac||''')';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Création de partition PHOTO',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
         EXCEPTION 
             WHEN OTHERS THEN 
                requete:= 'delete from  PHOTO_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
                FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PHOTO',requete);
                EXECUTE_IMMEDIATE_STRING( requete,0);
        END;
      END;
    ELSE
      -- Cas des tables non partitionnées ou partitionnées en mode HASH
      requete:= 'delete from PHOTO_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PHOTO',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
    END IF;
    
    -- 3)	On met à jour la PHOTO avec la table DIC sauf pour les mal recyclés de ce dictionnaire
    requete:= 'insert into PHOTO_'||lig_mapta.tablephy||'('||clinsertcols||') '||clinsert; 
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de DIC vers PHOTO sauf les mal recyclés',requete);
    EXECUTE_IMMEDIATE_STRING( requete,0);
    
    -- 4)	On copie PH_PH dans PHOTO uniquement pour les mal recyclés
    requete:= 'insert into PHOTO_'||lig_mapta.tablephy||'('||clinsertcols||')  (select '||clinsertcols||' from PH_PH_'||lig_mapta.tablephy||'  where numpac='''||p_numpac||''' and pacmat in (select pacmat from TGE_MODIF_PACMAT_TORESEND where numpac='''||p_numpac||''' and table_to_send='''||lig_mapta.tablephy||''' ) )';
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de PH_PH dans PHOTO pour les mal recyclés',requete);
    EXECUTE_IMMEDIATE_STRING( requete,0);
    
    -- 5)	On efface PH_PH
    -- Contrôle de l'existence de partitionnement (son nom sera aussi une garantie de mode LIST)
    SELECT COUNT(*)
    INTO nbpart
    FROM user_tab_partitions
    WHERE table_name = 'PH_PH_'||lig_mapta.tablephy and partition_name = 'P_'||p_numpac;
    IF nbpart >0 THEN
     BEGIN
      requete:= 'ALTER TABLE PH_PH_'||lig_mapta.tablephy||' TRUNCATE PARTITION P_'||p_numpac||' DROP STORAGE UPDATE GLOBAL INDEXES';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partition PH_PH détectée : suppression',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
      EXCEPTION
      WHEN OTHERS THEN
        BEGIN   
      -- Création de la partition
      requete:= 'ALTER TABLE PH_PH_'||lig_mapta.tablephy||' ADD PARTITION P_'||p_numpac||' values ('''||p_numpac||''')';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Création de partition PH_PH',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
     EXCEPTION 
         WHEN OTHERS THEN 
      requete:= 'delete from PH_PH_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PH_PH',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);        END;
      END;
    ELSE
      -- Cas des tables non partitionnées ou partitionnées en mode HASH
      requete:= 'delete from PH_PH_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PH_PH',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);
    END IF;

    -- 6)	On copie dans PH_PH la table DIC des matricules mal recyclés
    IF instr(clinsertsel,'a.PACMAT')>0 THEN
      requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select '||clinsertsel ||' from '||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''')';
    ELSE
      requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select b.numpac,b.pacmat'||clinsertsel ||' from '||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b ,SECUPACMAT s where s.numpac=b.numpac  and s.pacmat=b.pacmat and s.MATRIC = a.MATRIC and b.table_to_send='''||lig_mapta.tablephy||''' and b.numpac='''||p_numpac||''')';
    END IF;
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de DIC vers PH_PH des Toresend (mal recyclés)',requete);
    EXECUTE_IMMEDIATE_STRING( requete,0);

      -- 7)	On supprime les DRPAIE2='B' de la photo DIT 82467
      
      IF v_typeTable ='z' THEN
         requete:= 'DELETE from PHOTO_'||lig_mapta.tablephy||' PH where PH.numpac='''||p_numpac||''' AND EXISTS ( select 1 from ( ';
         requete:=requete||' SELECT DISTINCT DACH2.NUMPAC,DACH2.paiezad, DACH2.NUMCNT ,DACH2.DRPAI2, MAX(DATE_EFF) OVER (PARTITION BY DACH2.paiezad, DACH2.NUMCNT) FROM DIC_ADM_CONTRAT_HISTO DACH2 ';
         requete:=requete||' WHERE DACH2.NUMPAC = '''||p_numpac||''' and DACH2.DATE_EFF <= LAST_DAY(TO_DATE('''||p_periodepaie||''',''yyyymmdd'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS(TO_DATE('''||p_periodepaie||''',''yyyymmdd''),-'||p_nb_mois_paie_init||') ';         
         if lig_mapta.tablephy in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_ADM_CONTRAT_SITU') THEN 
            requete:=requete||' ) DACH   where  PH.paiezad=DACH.paiezad and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC AND PH.NUMCNT = DACH.NUMCNT) ' ;
         ELSE
            requete:=requete||' ) DACH   where  PH.paiezad=DACH.paiezad and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC ) ' ;
         END IF;
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Suppression des DRPAIE2=''B'' de la PHOTO',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);  
      ELSIF v_typeTable='p' THEN
         requete:= 'DELETE from PHOTO_'||lig_mapta.tablephy||' PH where PH.numpac='''||p_numpac||''' AND EXISTS ( select 1 from ( ';
         requete:=requete||' SELECT DISTINCT DACH2.NUMPAC,DACH2.pacmat, DACH2.NUMCNT ,DACH2.DRPAI2, MAX(DATE_EFF) OVER (PARTITION BY DACH2.pacmat, DACH2.NUMCNT) FROM DIC_ADM_CONTRAT_HISTO DACH2 ';
         requete:=requete||' WHERE DACH2.NUMPAC = '''||p_numpac||''' and DACH2.DATE_EFF <= LAST_DAY(TO_DATE('''||p_periodepaie||''',''yyyymmdd'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS(TO_DATE('''||p_periodepaie||''',''yyyymmdd''),-'||p_nb_mois_paie_init||') ';         
         if lig_mapta.tablephy in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_ADM_CONTRAT_SITU') THEN 
           requete:=requete||' ) DACH   where PH.pacmat=DACH.pacmat and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC AND PH.NUMCNT=DACH.NUMCNT ) ' ;
         ELSE
           requete:=requete||' ) DACH   where PH.pacmat=DACH.pacmat and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC ) ' ;
         END IF;
      FSED.FSED_AVANCEMENT_PLSQL(p_id,'Suppression des DRPAIE2=''B'' de la PHOTO',requete);
      EXECUTE_IMMEDIATE_STRING( requete,0);  
      END IF;      
    -- Fin
    FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO *** '||p_numpac||' *** End *** '||lig_mapta.tablephy,null);

 EXCEPTION
 WHEN OTHERS THEN
  	FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO : '||lig_mapta.tablephy ||' )' , 'Une erreur est survenue lors de la génération photo de la table '||lig_mapta.tablephy||'. Veuillez consulter la table TGE_FSED_ERREUR.');
    FSED.FSED_ERREUR(p_id,'TGE_GENERATION_PHOTO:'||lig_mapta.tablephy,P_NUMPAC,SQLCODE||'-'||SQLERRM);
    -- pour pouvoir suivre le traitement de génération photo sur le reste des tables après le catch de l'exception
    -- il suffit de commenter le 'raise'
    raise;
  END ;  
  END LOOP;
  CLOSE cur_mapta;

END TGE_GENERATION_PHOTO;
##
TGE_GENERATION_PHOTO_DACS
=SQL=
create or replace PROCEDURE TGE_GENERATION_PHOTO_DACS( 
 p_numpac      IN VARCHAR2,
 p_periodepaie IN VARCHAR2,
 p_encours     IN VARCHAR2)
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 AS
 CURSOR cur_mapta
 IS
 SELECT a.*
 FROM tge_ref_mapta a,
 (SELECT * FROM user_tables
 ) b
 WHERE a.numpac     =p_numpac
 AND b.table_name   =a.tablephy
 and a.tablephy ='DIC_ADM_CONTRAT_SITU'
 AND a.allerretour IN ('A','2')
 UNION ALL
 SELECT a.*
 FROM tge_ref_mapta a,
 (SELECT * FROM user_tables
 ) b
 WHERE a.numpac        ='*'
 AND b.table_name      =a.tablephy
 and a.tablephy ='DIC_ADM_CONTRAT_SITU'
 AND a.allerretour    IN ('A','2')
 AND (tableparam) NOT IN
 (SELECT tableparam
 FROM tge_ref_mapta a,
 (SELECT * FROM user_tables
 ) b
 WHERE a.numpac  =p_numpac
 AND b.table_name=a.tablephy
 ) ;
 lig_mapta cur_mapta%rowtype;
 v_typeTable VARCHAR(1);
 clinsert CLOB;
 clinsertsel CLOB;
 clinsertcols CLOB;
 requete CLOB;
 nbpart NUMBER;
 cldate VARCHAR2(500):='';
 p_nb_mois_paie_init number;
 p_id           NUMBER;
 w_count_trt number ;
 v_periode varchar2(6);
 BEGIN
 
 BEGIN
 SELECT TO_NUMBER(NVL(VALVAR,'0'))
 INTO p_nb_mois_paie_init
 FROM SYS_VARSYS
 WHERE MODULE = 'GAP'
 AND CODVAR   = 'NB_MOIS_PAIE_INIT';
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 p_nb_mois_paie_init :=1;
 END ;
 p_nb_mois_paie_init := p_nb_mois_paie_init-1;
 
 select GAP_TRT_SEQ_ID.nextval into p_id from dual;
 
 
 select count(*) 
 INTO w_count_trt 
 from  (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature
 and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_encours  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and not exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 
 if w_count_trt=0 then

 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,null from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature
 and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = to_char(add_months(to_date(p_encours,'YYYYMM'),-1),'YYYMM')  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and not exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 
 else
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,null from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature
 and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_encours  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and not exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 
 end if;
 
 -- Le 25/04/2015 ajout des mal recyclés (colonne "TRAITE"='R')
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,'R' from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_encours  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 
 OPEN cur_mapta;
 LOOP
 BEGIN
 FETCH cur_mapta
 INTO lig_mapta ;
 EXIT
 WHEN cur_mapta%NOTFOUND ;
 
 
 -- on regarde les clés pour savoir si table datée
 cldate:='';
 FOR colonne IN
 (SELECT a.column_name,
 b.data_type
 FROM user_cons_columns a,
 USER_TAB_COLUMNS b
 WHERE a.table_name   =lig_mapta.tablephy
 AND a.table_name     =b.table_name
 AND a.column_name    =b.column_name
 AND constraint_name IN
 (SELECT c.constraint_name
 FROM user_constraints c
 WHERE c.table_name =a.table_name
 AND CONSTRAINT_TYPE='P'
 )
 )
 LOOP
 IF colonne.data_type='DATE'  THEN
 cldate  :=' AND  a.'||colonne.column_name||'<=last_day(to_date('''||p_periodepaie||''',''yyyymmdd''))';
 END IF;
 END LOOP;
 IF lig_mapta.tablephy='DIC_ADM_CONTRAT' THEN
 cldate  :=' AND  a.DSDCN <=last_day(to_date('''||p_periodepaie||''',''yyyymmdd''))';
 END IF;
 -- requête de sélection des données à faire selon le type de table
 v_typeTable   :=fsed.getTypeTable(lig_mapta.tablephy);
 IF v_typeTable ='z' THEN
 clinsertsel :='';
 clinsertcols:='NUMPAC,PACMAT';
 FOR colonne IN
 (SELECT a.column_name
 FROM user_tab_columns a,
 user_tab_columns b
 WHERE a.table_name = lig_mapta.tablephy
 AND b.table_name   ='PHOTO_'
 ||a.table_name
 AND a.column_name=b.column_name
 AND a.column_name NOT LIKE '%IDPACMAT%'
 ORDER BY a.column_id
 )
 LOOP
 IF colonne.column_name <>'NUMPAC' AND colonne.column_name<>'PACMAT' THEN
 clinsertsel          :=clinsertsel||',a.'||colonne.column_name;
 clinsertcols         :=clinsertcols||','||colonne.column_name;
 END IF;
 END LOOP;
 
 clinsert      :='select distinct '''||p_numpac;
 clinsert      := clinsert||''',b.pacmat'||clinsertsel;
 clinsert      := clinsert||' from '||lig_mapta.tablephy;
 clinsert:= clinsert||' a,DIC_ADM_CONTRAT_SITU b where b.paiezad=a.paiezad and a.numpac=b.numpac and a.numpac= '''||p_numpac;
 clinsert:= clinsert||'''  and a.pacmat in (select c.pacmat from GAP_TRT_LISTE_MAT c where c.id_trt='||p_id||')';
 clinsert:= clinsert||' and a.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where b.numpac=f.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
 elsif v_typeTable='p' THEN
 clinsertsel   :='';
 clinsertcols  :='';
 FOR colonne IN
 (SELECT a.column_name
 FROM user_tab_columns a,
 user_tab_columns b
 WHERE a.table_name = lig_mapta.tablephy
 AND b.table_name   ='PHOTO_'
 ||a.table_name
 AND a.column_name=b.column_name
 AND a.column_name NOT LIKE '%IDPACMAT%'
 ORDER BY a.column_id
 )
 LOOP
 IF clinsertsel IS NOT NULL THEN
 clinsertsel  :=clinsertsel||',';
 END IF;
 clinsertsel     :=clinsertsel||'a.'||colonne.column_name;
 IF clinsertcols IS NOT NULL THEN
 clinsertcols  :=clinsertcols||',';
 END IF;
 clinsertcols:=clinsertcols||colonne.column_name;
 END LOOP;
 
 clinsert      :='select distinct '||clinsertsel;
 clinsert      := clinsert||' from '||lig_mapta.tablephy;
 clinsert      := clinsert||' a  where  a.numpac= '''||p_numpac||''' AND    a.pacmat in (select c.pacmat from GAP_TRT_LISTE_MAT c where c.id_trt='||p_id||')';
 clinsert      := clinsert||' and a.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where f.numpac=a.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
 elsif v_typeTable='m' THEN
 clinsertsel   :='';
 clinsertcols  :='NUMPAC,PACMAT';
 FOR colonne IN
 (SELECT a.column_name
 FROM user_tab_columns a,
 user_tab_columns b
 WHERE a.table_name = lig_mapta.tablephy
 AND b.table_name   ='PHOTO_'
 ||a.table_name
 AND a.column_name=b.column_name
 AND a.column_name NOT LIKE '%IDPACMAT%'
 ORDER BY a.column_id
 )
 LOOP
 IF colonne.column_name <>'NUMPAC' AND colonne.column_name<>'PACMAT' THEN
 clinsertsel          :=clinsertsel||',a.'||colonne.column_name;
 clinsertcols         :=clinsertcols||','||colonne.column_name;
 END IF;
 END LOOP;
 
 clinsert:='select distinct '''||p_numpac;
 clinsert:= clinsert||''',b.pacmat'||clinsertsel;
 clinsert:= clinsert||' from '||lig_mapta.tablephy;
 clinsert:= clinsert||' a,SECUPACMAT b, GAP_TRT_LISTE_MAT c where b.matric=a.matric and b.numpac= '''||p_numpac;
 clinsert:= clinsert||'''  and b.pacmat=c.pacmat and c.numpac='''||p_numpac||''' and c.id_trt='||p_id;
 clinsert:= clinsert||' and b.pacmat not in (select f.pacmat from TGE_MODIF_PACMAT_TORESEND f where b.numpac=f.numpac and f.numpac='''||p_numpac||''' and  f.table_to_send='''||lig_mapta.tablephy||''')'||cldate;
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO_DACS *** '||p_numpac||' *** Begin *** '||lig_mapta.tablephy||' (type='||v_typeTable||')',null);
 
 -- 1)	Sauvegarde de PHOTO dans PH_PH des mal recyclés non déjà présents dans PH_PH
 IF instr(clinsertsel,'a.PACMAT')>0 THEN
 requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select '||clinsertsel ||' from PHOTO_'||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''' AND  b.pacmat not in (select c.pacmat from PH_PH_'||lig_mapta.tablephy||' c where c.numpac='''||p_numpac||'''))';
 ELSE
 requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select a.numpac,a.pacmat'||clinsertsel ||' from PHOTO_'||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''' AND  b.pacmat not in (select c.pacmat from PH_PH_'||lig_mapta.tablephy||' c where c.numpac='''||p_numpac||'''))';
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de PHOTO vers PH_PH des Toresend (mal recyclés) non présents dans PH_PH',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 
 -- 2)	On efface la PHOTO
 -- Contrôle de l'existence de partitionnement (son nom sera aussi une garantie de mode LIST)
 SELECT COUNT(*)
 INTO nbpart
 FROM user_tab_partitions
 WHERE table_name = 'PHOTO_'||lig_mapta.tablephy and partition_name = 'P_'||p_numpac;
 IF nbpart >0 THEN
 BEGIN
 -- Suppression de la partition
 requete:= 'ALTER TABLE PHOTO_'||lig_mapta.tablephy||' TRUNCATE PARTITION P_'||p_numpac||' DROP STORAGE UPDATE GLOBAL INDEXES';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partition PHOTO détectée : suppression',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 -- Création de la partition
 EXCEPTION
 WHEN OTHERS THEN
 BEGIN
 requete:= 'ALTER TABLE PHOTO_'||lig_mapta.tablephy||' ADD PARTITION P_'||p_numpac||' values ('''||p_numpac||''')';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Création de partition PHOTO',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 EXCEPTION
 WHEN OTHERS THEN
 requete:= 'delete from  PHOTO_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PHOTO',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 END;
 END;
 ELSE
 -- Cas des tables non partitionnées ou partitionnées en mode HASH
 requete:= 'delete from PHOTO_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PHOTO',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 END IF;
 
 -- 3)	On met à jour la PHOTO avec la table DIC sauf pour les mal recyclés de ce dictionnaire
 requete:= 'insert into PHOTO_'||lig_mapta.tablephy||'('||clinsertcols||') '||clinsert;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de DIC vers PHOTO sauf les mal recyclés',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 
 -- 4)	On copie PH_PH dans PHOTO uniquement pour les mal recyclés
 requete:= 'insert into PHOTO_'||lig_mapta.tablephy||'('||clinsertcols||')  (select '||clinsertcols||' from PH_PH_'||lig_mapta.tablephy||'  where numpac='''||p_numpac||''' and pacmat in (select pacmat from TGE_MODIF_PACMAT_TORESEND where numpac='''||p_numpac||''' and table_to_send='''||lig_mapta.tablephy||''' ) )';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de PH_PH dans PHOTO pour les mal recyclés',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 
 -- 5)	On efface PH_PH
 -- Contrôle de l'existence de partitionnement (son nom sera aussi une garantie de mode LIST)
 SELECT COUNT(*)
 INTO nbpart
 FROM user_tab_partitions
 WHERE table_name = 'PH_PH_'||lig_mapta.tablephy and partition_name = 'P_'||p_numpac;
 IF nbpart >0 THEN
 BEGIN
 requete:= 'ALTER TABLE PH_PH_'||lig_mapta.tablephy||' TRUNCATE PARTITION P_'||p_numpac||' DROP STORAGE UPDATE GLOBAL INDEXES';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Partition PH_PH détectée : suppression',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 EXCEPTION
 WHEN OTHERS THEN
 BEGIN
 -- Création de la partition
 requete:= 'ALTER TABLE PH_PH_'||lig_mapta.tablephy||' ADD PARTITION P_'||p_numpac||' values ('''||p_numpac||''')';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Création de partition PH_PH',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 EXCEPTION
 WHEN OTHERS THEN
 requete:= 'delete from PH_PH_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PH_PH',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);        END;
 END;
 ELSE
 -- Cas des tables non partitionnées ou partitionnées en mode HASH
 requete:= 'delete from PH_PH_'||lig_mapta.tablephy||' where numpac='''||p_numpac||'''';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Effacement de PH_PH',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 END IF;
 
 -- 6)	On copie dans PH_PH la table DIC des matricules mal recyclés
 IF instr(clinsertsel,'a.PACMAT')>0 THEN
 requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select '||clinsertsel ||' from '||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b where a.numpac=b.numpac and a.pacmat=b.pacmat and b.table_to_send='''||lig_mapta.tablephy||''' and a.numpac='''||p_numpac||''')';
 ELSE
 requete:= 'insert into PH_PH_'||lig_mapta.tablephy||'('||clinsertcols||') (select b.numpac,b.pacmat'||clinsertsel ||' from '||lig_mapta.tablephy||' a, TGE_MODIF_PACMAT_TORESEND b ,SECUPACMAT s where s.numpac=b.numpac  and s.pacmat=b.pacmat and s.MATRIC = a.MATRIC and b.table_to_send='''||lig_mapta.tablephy||''' and b.numpac='''||p_numpac||''')';
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Copie de DIC vers PH_PH des Toresend (mal recyclés)',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 
 -- 7)	On supprime les DRPAIE2='B' de la photo DIT 82467
 
 IF v_typeTable ='z' THEN
 requete:= 'DELETE from PHOTO_'||lig_mapta.tablephy||' PH where PH.numpac='''||p_numpac||''' AND EXISTS ( select 1 from ( ';
 requete:=requete||' SELECT DISTINCT DACH2.NUMPAC,DACH2.paiezad, DACH2.NUMCNT ,DACH2.DRPAI2, MAX(DATE_EFF) OVER (PARTITION BY DACH2.paiezad, DACH2.NUMCNT) FROM DIC_ADM_CONTRAT_HISTO DACH2 ';
 requete:=requete||' WHERE DACH2.NUMPAC = '''||p_numpac||''' and DACH2.DATE_EFF <= LAST_DAY(TO_DATE('''||p_periodepaie||''',''yyyymmdd'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS(TO_DATE('''||p_periodepaie||''',''yyyymmdd''),-'||p_nb_mois_paie_init||') ';
 if lig_mapta.tablephy in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_ADM_CONTRAT_SITU') THEN
 requete:=requete||' ) DACH   where  PH.paiezad=DACH.paiezad and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC AND PH.NUMCNT = DACH.NUMCNT) ' ;
 ELSE
 requete:=requete||' ) DACH   where  PH.paiezad=DACH.paiezad and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC ) ' ;
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Suppression des DRPAIE2=''B'' de la PHOTO',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 ELSIF v_typeTable='p' THEN
 requete:= 'DELETE from PHOTO_'||lig_mapta.tablephy||' PH where PH.numpac='''||p_numpac||''' AND EXISTS ( select 1 from ( ';
 requete:=requete||' SELECT DISTINCT DACH2.NUMPAC,DACH2.pacmat, DACH2.NUMCNT ,DACH2.DRPAI2, MAX(DATE_EFF) OVER (PARTITION BY DACH2.pacmat, DACH2.NUMCNT) FROM DIC_ADM_CONTRAT_HISTO DACH2 ';
 requete:=requete||' WHERE DACH2.NUMPAC = '''||p_numpac||''' and DACH2.DATE_EFF <= LAST_DAY(TO_DATE('''||p_periodepaie||''',''yyyymmdd'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS(TO_DATE('''||p_periodepaie||''',''yyyymmdd''),-'||p_nb_mois_paie_init||') ';
 if lig_mapta.tablephy in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_ADM_CONTRAT_SITU') THEN
 requete:=requete||' ) DACH   where PH.pacmat=DACH.pacmat and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC AND PH.NUMCNT=DACH.NUMCNT ) ' ;
 ELSE
 requete:=requete||' ) DACH   where PH.pacmat=DACH.pacmat and NVL(DACH.DRPAI2,''B'')=''B'' AND PH.NUMPAC=DACH.NUMPAC ) ' ;
 END IF;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'Suppression des DRPAIE2=''B'' de la PHOTO',requete);
 EXECUTE_IMMEDIATE_STRING( requete,0);
 END IF;
 -- Fin
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO_DACS *** '||p_numpac||' *** End *** '||lig_mapta.tablephy,null);
 
 
 EXCEPTION
 WHEN OTHERS THEN
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_GENERATION_PHOTO_DACS : '||lig_mapta.tablephy ||' )' , 'Une erreur est survenue lors de la génération photo de la table '||lig_mapta.tablephy||'. Veuillez consulter la table TGE_FSED_ERREUR.');
 FSED.FSED_ERREUR(p_id,'TGE_GENERATION_PHOTO_DACS:'||lig_mapta.tablephy,P_NUMPAC,SQLCODE||'-'||SQLERRM);
 -- pour pouvoir suivre le traitement de génération photo sur le reste des tables après le catch de l'exception
 -- il suffit de commenter le 'raise'
 raise;
 END ;
 
 END LOOP;
 
 CLOSE cur_mapta;
 
 END TGE_GENERATION_PHOTO_DACS;
 ##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_30
=SQL=
create or replace PROCEDURE TGE_IMPORT_30
(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2 ,
    P_ROLE        IN VARCHAR2 ,
    -- Origine écran
    P_ORIGINE     IN VARCHAR2 ,
    P_VALIDATION  IN VARCHAR2 ,
    P_WITH30      IN VARCHAR2 ,
    P_CODLANG     IN VARCHAR2,
    -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
    P_TYPE_ACTION IN VARCHAR2 ,
    P_DATE_MAJ    IN SYS_TRC_MODIF.DATEMAJ%type)
AS
  w_err   VARCHAR2(2000);
  v_start NUMBER;
  v_stop  NUMBER;
  req CLOB;
  reqvalues CLOB;
  reqInsert CLOB;
  dateMaj SYS_TRC_MODIF.datemaj%type;
  functionnalityTrace VARCHAR2(250);
BEGIN
  v_start       := DBMS_UTILITY.GET_TIME;
  IF P_DATE_MAJ IS NULL THEN
    SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
  ELSE
    dateMaj:= P_DATE_MAJ;
  END IF;
  IF ( P_WITH30 =1) THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 30');
      TGE_CONTROLE_30 (p_login, p_date_import, NULL, p_codlang, P_TYPE_ACTION);
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  '||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_30 - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
  END IF;
  IF p_validation = 1 THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion TGE_ELEMENTS_PAIE');
      INSERT
      INTO TGE_ELEMENTS_PAIE
        (
          NUMPAC ,
          PAIEZAD ,
          PERIODE ,
          TYPE_TRAITEMENT ,
          CODE_ELEMENT ,
          INDICATIF ,
          ORIGINE ,
          SENS ,
          VALEUR ,
          DERNIER_CODE_OPE ,
          LOGIN_MAJ ,
          DATE_MAJ ,
          CLE_IMPORT ,
          IDPACMAT,
          type_writer,
          CODE_REMPLACEMENT,
          DATE_EFFET,
         ACTION_RETRO,
         ACTION_RETRO_DATE
        )
      SELECT E.NUMPAC ,
        PAIEZAD ,
        PERIODE ,
        TYPE_TRAITEMENT ,
        CODE_ELEMENT ,
        UPPER (NVL(INDICATIF,'*')) AS INDICATIF,
        ORIGINE ,
        SENS ,
        VALEUR ,
        'C' ,
        p_login ,
        TO_CHAR (sysdate, 'YYYYMMDDHH24MI') ,
        CASE
          WHEN 'VI' = P_TYPE_ACTION or 'MP' = P_TYPE_ACTION
          -- Pour les EZ, on va stocker une clé d'import en import et en MP
		  -- afin de pouvoir retrouver la ligne créée pour les traces
          THEN P_LOGIN
            ||'#'
            ||P_DATE_IMPORT
            ||'#'
            ||NUMLIGNE
          ELSE NULL
        END AS CLE_IMPORT,
        CASE
          WHEN E.NUMPAC IS NOT NULL
          AND PACMAT    IS NOT NULL
          THEN RPAD(E.NUMPAC,6)
            || PACMAT
          ELSE ' '
        END AS IDPACMAT,
        CASE
          WHEN (SELECT O.MODE_T2
              ||'#'
              ||O.ENVOI_MODE_R
            FROM TGE_REF_ORIGINE_GTA O
            WHERE O.NUMPAC     = E.NUMPAC
            AND O.CODE_ORIGINE = E.ORIGINE) = 'R#N'
          THEN 'N'
          ELSE NULL
        END AS TYPE_WRITER,
        NVL(E.CODE_REMPLACEMENT,'*') AS CODE_REMPLACEMENT,
        TO_DATE(E.DATE_EFFET,'YYYYMMDD') AS DATE_EFFET,
        -- Gestion Action Retro : pour ne pas bousiller les perfs, on va positionner une valeur '*' dans actionRetro et null dans actionRetroDate
        -- et ensuite avec une requête d'update mettre à jour la valeur de actionRetro et actionRetroDate.
        -- On évite ainsi de faire 2 sous-select sur TGE_REF_PAC ou une jointure globale pour récupérer TGE_REF_PAC.PERIODEENCOURS
        case
        	when  E.PERIODE < (select PAC.PERIODEENCOURS from TGE_REF_PAC PAC where PAC.NUMPAC = E.NUMPAC)
         	then '*'
         	else NULL
        end as ACTION_RETRO,
        NULL as ACTION_RETRO_DATE
                             
      FROM TGE_IMPORT_ELEMENTS E
      WHERE LOGIN           =P_LOGIN
      AND CODE_ELEMENT NOT IN ('B690','B691')
      AND DATE_IMPORT       = p_date_import
      AND ((ERREURS        IS NULL
      AND STATUT            = 'TRAIT')
      OR (ERREURS          IS NOT NULL
      AND STATUT            = 'TRANS'));
      
      -- Gestion Action Retro : si création d'une ligne rétro, on sauvegarde qu'il s'agit d'une création comme première action et la date à laquelle elle a eu lieu
      update TGE_ELEMENTS_PAIE set 
      	ACTION_RETRO = 'C',
      	ACTION_RETRO_DATE = DATE_MAJ
      where ACTION_RETRO = '*';
      
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  ' ||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidElement - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH' or SQLCODE=-20001) THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
        
    --- Gestion de la trace pour les imports ou la MarketPlace : on enregistre une trace pour chaque ligne de l'import qui n'est pas en erreur
    IF P_TYPE_ACTION = 'VI' or P_TYPE_ACTION = 'MP' THEN
    	functionnalityTrace := 'IMPORT_ELEMENT_PAIE';
    	IF P_TYPE_ACTION = 'MP' THEN
    		functionnalityTrace := 'IMPORT_ELEMENT_PAIE_MP';
    	END IF;
    	
      	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début SYS_TRC_MODIF pour insertion EZ');
      	
		insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
	  		NAMES_VALUES_HAVE_CHANGED, AFTER_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
			select EI.LOGIN, SYSDATE, '3', functionnalityTrace, 
			-- KEY_VALUES
			'numPac='||E.NUMPAC||'&paieZad='||E.PAIEZAD||'&periode='||E.PERIODE||'&type_traitement='||E.TYPE_TRAITEMENT||'&code_element='||E.CODE_ELEMENT||'&indicatif='||E.INDICATIF||'&'||'code_remplacement='||E.CODE_REMPLACEMENT,
			-- SHORT_NAME : on gère si c'est un élément de remplacement ou non
			'Ajout d''un EZ' || decode(E.CODE_REMPLACEMENT, '*', '', ' rempl.'), 
			-- ACTION
			'C',
			-- NAMES_VALUES_HAVE_CHANGED 
			'numPac^paieZad^periode^type_traitement^code_element^indicatif^valeur^origine^dernier_code_ope^login_maj^date_maj^idPacMat^code_remplacement^date_effet^cle_import',
			-- AFTER_CHANGE
			E.NUMPAC||'^'||E.PAIEZAD||'^'||E.PERIODE||'^'||E.TYPE_TRAITEMENT||'^'||E.CODE_ELEMENT||'^'||E.INDICATIF||'^'||E.VALEUR
			||'^'||E.ORIGINE||'^'||E.DERNIER_CODE_OPE||'^'||E.LOGIN_MAJ||'^'||E.DATE_MAJ||'^'||E.IDPACMAT||'^'||E.CODE_REMPLACEMENT
			||'^'||E.DATE_EFFET||'^'||E.CLE_IMPORT,
			-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
			E.NUMPAC, EI.PACMAT, E.PAIEZAD, EI.MATRICULE, E.DATE_EFFET
		from TGE_ELEMENTS_PAIE E inner join TGE_IMPORT_ELEMENTS EI on E.CLE_IMPORT = EI.LOGIN||'#'||EI.DATE_IMPORT||'#'||EI.NUMLIGNE
		where EI.LOGIN = P_LOGIN and EI.DATE_IMPORT = P_DATE_IMPORT;
    END IF;
    
    -- Mise à jour de la column RETRO_GC de la table TGE_PERIODE_RECUEIL_PAIEZAD
    -- si la "full" rétroactivité n'est pas activé sur le pac
    UPDATE TGE_PERIODE_RECUEIL_PAIEZAD R
    SET R.RETRO_GC =
      (SELECT E.VALEUR
      FROM TGE_ELEMENTS_PAIE E
      WHERE R.NUMPAC     = E.NUMPAC
      AND R.PAIEZAD      = E.PAIEZAD
      AND R.MOIS_PAIE    = E.PERIODE
      AND E.CODE_ELEMENT = 'WG96'
      )
    WHERE (R.NUMPAC, R.PAIEZAD, R.MOIS_PAIE) IN
      (SELECT e2.numpac,
        e2.paiezad,
        e2.periode
      FROM TGE_IMPORT_ELEMENTS E2
      WHERE e2.login     = P_LOGIN
      AND e2.date_import = p_date_import
      AND ((e2.ERREURS  IS NULL
      AND e2.STATUT     IN ('TRAIT','FIN'))
      OR (e2.ERREURS    IS NOT NULL
      AND e2.STATUT      = 'TRANS'))
      AND EXISTS (SELECT 'ACTIVE_RETRO_GC'
	 	FROM TGE_REF_PAC
	 	WHERE NUMPAC = e2.NUMPAC
	 		AND (DEB_RETRO IS NULL OR DEB_RETRO > e2.periode)
	 	)
      );
    ----------------------------------------------------------------------------
    
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPORT_ELEMENTS');
    -- Mise à jour des lignes d'import qui sont encore en erreur après validation, statut prend TRANS
   	UPDATE TGE_IMPORT_ELEMENTS
   	SET STATUT ='TRANS'
   	WHERE LOGIN = P_LOGIN
   	AND DATE_IMPORT = p_date_import
   	AND (ERREURS IS NOT NULL
   	AND STATUT = 'TRAIT')
   	AND CODE_ELEMENT NOT IN ('B690','B691');
	
   	-- Mise à jour des lignes d'import qui ne sont plus en erreur après validation, statut prend FIN
    UPDATE TGE_IMPORT_ELEMENTS
    SET STATUT ='FIN'
    WHERE LOGIN = P_LOGIN
    AND DATE_IMPORT = p_date_import
    AND ERREURS IS NULL
    AND CODE_ELEMENT NOT IN ('B690','B691');
       
    -- Suppression des lignes dans dans DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début DELETE FROM dic_tge_imputations_perm');
    DELETE
    FROM DIC_TGE_IMPUTATIONS_PERM A
    WHERE (A.NUMPAC,A.PAIEZAD) IN
      (SELECT B.NUMPAC,
        B.paiezad
      FROM TGE_IMPORT_ELEMENTS B
      WHERE B.CODE_ELEMENT >='B690'
      AND B.CODE_ELEMENT   <='B691'
      AND B.CODE_ELEMENT   IS NOT NULL
      AND B.ERREURS        IS NULL
      AND B.DATE_IMPORT     = p_date_import
      AND B.LOGIN           = P_LOGIN
      GROUP BY LOGIN,
        NUMPAC,
        PAIEZAD,
        DATE_IMPORT,
        INDICATIF
      HAVING COUNT(DISTINCT B.CODE_ELEMENT ) >1
      ) ;
    -- Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE');
    FOR b_numpac IN
    (SELECT DISTINCT numpac
    FROM TGE_IMPORT_ELEMENTS
    WHERE LOGIN       = P_LOGIN
    AND DATE_IMPORT   = p_date_import
    AND ERREURS      IS NULL
    AND code_ELEMENT IN ('B690','B691')
    )
    LOOP
      req      :='insert into DIC_TGE_IMPUTATIONS_PERM p(numpac,paiezad,MATRIC,pacmat';
      reqInsert:='select numpac,paiezad,MATRICULE,pacmat,';
      reqvalues:= ' from (select numpac,paiezad,MATRICULE,pacmat,code_element||''#''||indicatif as el, valeur';
      reqvalues:= reqvalues|| ' from TGE_IMPORT_ELEMENTS b where login='''||p_login||''' and date_import='''||P_DATE_IMPORT||''' and code_element in (''B690'',''B691'')  )';


      reqvalues:= reqvalues|| '  pivot (max(valeur)   for(el) in (';
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion DIC_TGE_IMPUTATIONS_PERM');
      FOR cur IN
      (SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     =b_numpac.numpac
      UNION
      SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     ='*'
      )
      LOOP
        req           :=req||','||cur.DONNEEGXP;
        reqvalues     := reqvalues||''''||cur.element||'#'||cur.occurence ||''' as '|| cur.DONNEEGXP||',';
        IF cur.element ='B690' THEN
          reqInsert   := reqInsert||cur.DONNEEGXP ||',';
        ELSE
          reqInsert:= reqInsert||' IS_NUMBER(replace('||cur.DONNEEGXP ||','','',''.'')) as '||cur.DONNEEGXP ||' ,';
        END IF;
        IF P_LOGIN = 'BATCH' THEN
          SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPUTATION_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE||'&ELEMENT='||cur.element||'&DONNEEGXP='||cur.DONNEEGXP, 'Import Batch 30 B690/B691','C',NULL,NULL,NULL,NULL);
        END IF;
      END LOOP;
      reqvalues:= SUBSTR(reqvalues,1,LENGTH(reqvalues)-1)||'))  ';
      reqvalues:= reqvalues|| ' b where   exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||'''  and c.date_import='''||P_DATE_IMPORT||'''  and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B690''   and ERREURs is  null)
      and  exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||''' and c.date_import='''||P_DATE_IMPORT||''' and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B691''  and ERREURs is  null) ';
      reqInsert:= SUBSTR(reqInsert,1,LENGTH(reqInsert)-1);
      req      :=req||')  ';
      req      :=req||reqInsert|| reqvalues;
       EXECUTE_IMMEDIATE_STRING( req,0);
    END LOOP;
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début UPDATE TGE_IMPORT_LISTE');
    UPDATE TGE_IMPORT_LISTE
    SET NBLIGNES_ERR =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NOT NULL
      ),
      NBLIGNES_IMP =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      ),
      STATUT        ='TRANS'
    WHERE LOGIN     = P_LOGIN
    AND DATE_IMPORT = p_date_import
    AND TYPE        = '2';
    -- Inscription en recyclage
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Inscription en recyclage');
  END IF;
END TGE_IMPORT_30;
##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_3040
=SQL=
create or replace PROCEDURE TGE_IMPORT_3040( P_LOGIN       IN VARCHAR2 , P_DATE_IMPORT IN VARCHAR2 , P_ROLE        IN VARCHAR2 ,
 P_ORIGINE     IN VARCHAR2 ,
 P_VALIDATION  IN NUMBER ,
 P_WITH30      IN NUMBER ,
 P_WITH40      IN NUMBER ,
 P_WITH60      IN NUMBER ,
 P_WITH70      IN NUMBER ,
 P_WITH50      IN NUMBER ,
 P_ISFSED      IN NUMBER ,
 P_CODLANG     IN VARCHAR2,
 -- Valeurs attendues : VI -> pour la validation des imports Web ou Batch, MP -> pour la validation depuis le Market Place
 P_TYPE_ACTION IN VARCHAR2)
 AS
 /********************************************************************************
 Version     : V5.05.004
 *********************************************************************************/
 w_err   VARCHAR2(2000);
 v_start NUMBER;
 v_stop  NUMBER;
 id_trt number ;
 dateMaj SYS_TRC_MODIF.datemaj%type;
 doRollback boolean;
 desactiveTraitements   VARCHAR2(1000);

 BEGIN
 doRollback:=false;
 v_start := DBMS_UTILITY.GET_TIME;
 id_trt := IMP_TRT_SEQ_ID.nextval;
 -- FVI on peut lire le pac une seule fois
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'TGE_IMPORT_3040 début ' || P_LOGIN || '-' || P_DATE_IMPORT || '-' || P_ROLE || '-' || P_ORIGINE || '-' || P_VALIDATION || '-' || P_WITH30 || '-' || P_WITH40|| '-' || P_WITH60|| '-' || P_WITH70|| '-' || P_WITH50|| '-' || P_ISFSED || '-' || P_CODLANG || '-' || P_TYPE_ACTION);
 -- Mise à jour des donnees ID collab
 select CURRENT_TIMESTAMP into dateMaj from dual;
 -- Cartes d'annulation
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début delete pour gérer annulation  ');
 
 -- Suppression dans TGE_ABSENCES
 DELETE
 FROM TGE_ABSENCES ABS
 WHERE EXISTS
 (SELECT 1
 FROM TGE_INCIDENTS_PAIE  P,
 TGE_REF_TYPES_GTA   GTA,
 TGE_REF_ORIGINE_GTA  ori,
 TGE_IMPORT_ANNULATION A,DIC_ADM_CONTRAT_SITU C
 WHERE ABS.NUMPAC = A.NUMPAC
 AND   P.NUMPAC   = C.NUMPAC
 AND   C.NUMPAC   = A.NUMPAC
 AND   GTA.NUMPAC = A.NUMPAC
 AND   ori.NUMPAC = A.NUMPAC
 AND A.LOGIN       =P_LOGIN
 AND A.DATE_IMPORT =P_DATE_IMPORT
 and A.ERREURS is null
 AND NVL(GTA.MATRIC_GTA,'PAIEZAD')='PACMAT'
 AND GTA.CODE_GTA    = ori.CODE_GTA
 AND ori.CODE_ORIGINE =P.ORIGINE
 AND ABS.MATRIC                  =A.MATRICULE
 AND C.PACMAT   = A.PACMAT
 AND C.MATRIC = A.MATRICULE
 AND P.PAIEZAD = C.PAIEZAD
 AND A.ORIGINE                    =P.ORIGINE
 AND TO_DATE(A.PERIODE,'yyyymm')  =P.PERIODE
 AND P.CLE_ABSENCE               IS NOT NULL
 AND ABS.ID = P.CLE_ABSENCE
 );
 
 DELETE
 FROM TGE_ABSENCES ABS
 WHERE EXISTS
 (SELECT 1
 FROM TGE_INCIDENTS_PAIE p,TGE_REF_TYPES_GTA gta
 WHERE p.numpac = abs.numpac
 AND p.cle_absence IS NOT NULL
 AND p.cle_absence = abs.id
 and p.numpac = gta.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =p.numpac and code_origine =p.origine )
 AND EXISTS
 (SELECT *
 FROM TGE_IMPORT_ANNULATION a
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 AND a.matricule                 = abs.matric
 and a.erreurs is null
 AND ( NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD' AND a.paiezad = p.paiezad )
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 )
 );
 
 -- Suppression dans TGE_INCIDENTS_PAIE sur la colonne PERIODE
 DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 );
 
 DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND   NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD'
 AND a.paiezad = p.paiezad
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 );
 
-- Suppression dans TGE_INCIDENTS_PAIE sur la colonne PERIODE_INIT
DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode_init
 );

DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND   NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD'
 AND a.paiezad = p.paiezad
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode_init
 );
 
 -- Gestion de l'annulation pour les éléments de paie et les données variables (on pourra rajouter les autres types si on veut)
 TGE_IMPORT_CARTE_ANNULATION(P_LOGIN, P_DATE_IMPORT);
 
  -- Suppression dans TGE_IMPUTATIONS
  
 DELETE
 FROM TGE_IMPUTATIONS p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')));
 
 DELETE
 FROM TGE_IMPUTATIONS p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and a.erreurs is null
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD' AND a.paiezad = p.paiezad
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')));
 
 IF P_WITH30 =1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début carte 30');
 TGE_IMPORT_30 (P_LOGIN , P_DATE_IMPORT , P_ROLE , P_ORIGINE , P_VALIDATION , P_WITH30 , P_CODLANG, P_TYPE_ACTION, datemaj );
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 FSED.FSED_ERREUR( id_trt , ' imp:TGE_IMPORT_30 ' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30, w_err );
--UN TRAITEMENT DE PAIE EST EN COURS
 if(SQLCODE='-20001') then 
  doRollback:=true;
  GOTO end_proc;
 end if ; 
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 IF P_WITH50 =1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début carte 50');
 TGE_IMPORT_50 (P_LOGIN , P_DATE_IMPORT , P_ROLE , P_ORIGINE , P_VALIDATION , P_WITH50 , P_CODLANG, P_TYPE_ACTION, datemaj );
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 FSED.FSED_ERREUR( id_trt , ' imp:TGE_IMPORT_50 ' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH50, w_err );
 --UN TRAITEMENT DE PAIE EST EN COURS
 if(SQLCODE='-20001') then
 doRollback:=true;
 GOTO end_proc;
 end if ;
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 IF P_WITH60 =1 OR P_WITH70 =1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début carte 60');
 TGE_IMPORT_6070 (P_LOGIN , P_DATE_IMPORT , P_ROLE , P_ORIGINE , P_VALIDATION , P_WITH60 , P_WITH70 , P_CODLANG, P_TYPE_ACTION );
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 FSED.FSED_ERREUR( id_trt , ' imp:TGE_IMPORT_6070 ' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH60 ||','|| P_WITH70 , w_err );
 if(SQLCODE='-20001') then 
   doRollback:=true;
   GOTO end_proc;
  end if ;
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 
 IF P_WITH40 =1 THEN
 
 
 --Supprimer les absences sur le mois de paie M-1 si le flag Retro GC = 'O'
 DELETE from
 TGE_ABSENCES A
 WHERE exists
 (
 SELECT ABS.ID FROM TGE_ABSENCES ABS
 INNER JOIN TGE_IMPORT_INCIDENTS t on ( ABS.MATRIC = T.MATRICULE and T.numpac=ABS.NUMPAC)
 INNER JOIN TGE_INCIDENTS_PAIE INC ON ABS.ID = INC.CLE_ABSENCE
 INNER JOIN TGE_REF_PAC PAC ON INC.NUMPAC = PAC.NUMPAC
 INNER JOIN TGE_REF_PER PER ON PER.NUMPAC = INC.NUMPAC AND PER.PERIODEENCOURS = TO_CHAR(ADD_MONTHS(TO_DATE(PAC.PERIODEENCOURS,'yyyymm'),-1),'YYYYMM')
 INNER JOIN TGE_PERIODE_RECUEIL_PAIEZAD REC ON INC.NUMPAC = REC.NUMPAC AND INC.PAIEZAD = REC.PAIEZAD AND REC.MOIS_PAIE = PAC.PERIODEENCOURS
 WHERE INC.DATE_EFFET BETWEEN DEBUT_PER_RECUEIL_RETRO AND FIN_PER_RECUEIL_RETRO
 AND REC.RETRO_GC = '1'
 AND A.ID=ABS.ID
 AND T.LOGIN=P_LOGIN
 AND T.DATE_IMPORT=P_DATE_IMPORT
 );
 
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début controle carte 40');
 TGE_CONTROLE_40 (p_login,p_date_import,NULL,p_codlang , P_ISFSED);
 
 -- activer ou non les nouveaux traitements de l'import 3040
 select NVL(upper(VALVAR), ' ') into desactiveTraitements from sys_varsys where module='STD' and codvar='DESACTIVE_TRAITEMENTS_IMPORT_3040';
 IF INSTR(desactiveTraitements, 'TGE_CONTROLE_40_CHEVAUCHEMENT') < 1 THEN
	 --controle chevauchement
	 TGE_CONTROLE_40_CHEVAUCHEMENT(P_LOGIN, P_DATE_IMPORT ,null , P_CODLANG );
 END IF;
 
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'imp:TGE_CONTROLE_40' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 BEGIN
 --Controle Abscence
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Controle Abscence');
 
 TGE_CONTROLE_ABSENCES (p_login,p_date_import,NULL,p_codlang);
 EXCEPTION
 WHEN OTHERS THEN
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'imp:TGE_CONTROLE_ABSENCES' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 IF P_VALIDATION = 1 THEN
 --Creation Abscence
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : Creation Abscence');
 
 INSERT
 INTO TGE_ABSENCES
 (
 ID,
 MATRIC ,
 MOTIF ,
 NUMPAC ,
 DATE_DEBUT ,
 DEBUT_MA ,
 DATE_FIN ,
 FIN_MA ,
 DUREE ,
 DATE_IJEDI ,
 LOGIN_CREATE ,
 DATE_CREATE ,
 ROLE_CREATE ,
 ORIGINE_CREATE ,
 LOGIN_MAJ ,
 DATE_MAJ ,
 ROLE_MAJ ,
 ORIGINE_MAJ ,
 CLE_IMPORT,
 STATUT,
 ORIGINE,
 CODE_IMPUTATION
 )
 SELECT SEQ_TGE_ABSENCES.NEXTVAL ,
 ABSENCES.MATRIC ,
 ABSENCES.MOTIF ,
 ABSENCES.NUMPAC ,
 ABSENCES.DATE_DEBUT ,
 ABSENCES.DEBUT_MA ,
 ABSENCES.DATE_FIN ,
 ABSENCES.FIN_MA ,
 ABSENCES.DUREE ,
 ABSENCES.DATE_IJEDI ,
 ABSENCES.LOGIN_CREATE ,
 ABSENCES.DATE_CREATE ,
 ABSENCES.ROLE_CREATE ,
 ABSENCES.ORIGINE_CREATE ,
 ABSENCES.LOGIN_MAJ ,
 ABSENCES.DATE_MAJ ,
 ABSENCES.ROLE_MAJ ,
 ABSENCES.ORIGINE_MAJ ,
 ABSENCES.CLE_IMPORT,
 ABSENCES.STATUT,
 ABSENCES.ORIGINE,
 ABSENCES.CODE_IMPUTATION
 FROM
 (SELECT
 (SELECT C.MATRIC
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC = INCI.NUMPAC
 AND C.PAIEZAD  =INCI.PAIEZAD
 AND rownum     = 1
 )                                   AS MATRIC,--matricule
 INCI.CODE_IP                        AS MOTIF, --motif
 INCI.NUMPAC                         AS NUMPAC,
 to_date(INCI.DATE_DEBUT,'yyyyMMdd') AS DATE_DEBUT, --date debut
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 THEN DECODE (INCI.HEURES_IP,'1.00','J',DECODE(IS_NUMBER(INCI.HEURES_IP),0.5,'M','J'))
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
 THEN DECODE (INCI.HEURES_IP ,NULL,'J','D')
 END                               AS DEBUT_MA , --debutma
 to_date(INCI.DATE_FIN,'yyyyMMdd') AS DATE_FIN,  --date fin
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 THEN DECODE (INCI.HEURES_IP,'1.00','J',DECODE(IS_NUMBER(INCI.HEURES_IP),0.5,'M','J'))
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
 THEN DECODE (INCI.HEURES_IP ,NULL,'J','D')
 END AS FIN_MA, --Fin ma
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 AND ((SELECT pre.demi_journee
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 )                       = 1 
 OR IS_NUMBER(INCI.HEURES_IP) = 0.5
)
 THEN NVL(is_number(REPLACE(INCI.HEURES_IP,'.',',')) *8*3600,NULL) 
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
THEN NVL(is_number(REPLACE(INCI.HEURES_IP,'.',',')) *3600,NULL) 
ELSE NULL
 END        AS DUREE,        --duree
 NULL       AS DATE_IJEDI,   --date_ijedi
 INCI.LOGIN AS LOGIN_CREATE, --login create
 sysdate    AS DATE_CREATE,  --date_create
 P_ROLE     AS ROLE_CREATE,
 P_ORIGINE  AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create :ToolsTge.ORI_ECRAN_IMPORT_INCIDENT
 INCI.LOGIN AS LOGIN_MAJ,      --login maj
 sysdate    AS DATE_MAJ,       -- date_maj
 P_ROLE     AS ROLE_MAJ,
 P_ORIGINE  AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj   :ToolsTge.ORI_ECRAN_IMPORT_INCIDENT
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 'Q' AS STATUT,
  INCI.origine AS ORIGINE,     --origine 
  CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.code_ip     IS NOT NULL
 AND INCI.domaine_imp ='1'
 THEN INCI.code_imputation
 WHEN INCI.type_heure IN ('T','R')
 AND INCI.domaine_imp  ='H'
 THEN INCI.code_imputation
 END AS code_imputation-- code_imputation
 FROM TGE_IMPORT_INCIDENTS INCI
 WHERE EXISTS (
 (SELECT ri.CODE_INCIDENT
 FROM TGE_REF_PRE ri
 WHERE ri.numpac             = INCI.numpac
 AND ri.code_incident        =inci.code_ip
 AND ri.OPTION_CONSERV_HISTO = 'A'
 )
 UNION
 (SELECT ri.CODE_INCIDENT
 FROM TGE_REF_PRE ri
 WHERE ri.numpac             ='*'
 AND ri.code_incident        =inci.code_ip
 AND ri.OPTION_CONSERV_HISTO = 'A'
 AND NOT EXISTS
 (SELECT *
 FROM TGE_REF_PRE rt2
 WHERE rt2.numpac      =iNCI.numpac
 AND rt2.code_incident =ri.code_incident
 )
 ))
 AND INCI.LOGIN       = P_LOGIN
 AND INCI.DATE_IMPORT = P_DATE_IMPORT
 AND ((INCI.ERREURS  IS NULL
 AND INCI.STATUT      = 'TRAIT')
 OR (INCI.ERREURS    IS NOT NULL
 AND INCI.STATUT      = 'TRANS'))
 ) ABSENCES ,
 TGE_REF_ORIGINE_GTA
 WHERE ABSENCES.numpac=TGE_REF_ORIGINE_GTA.numpac
 AND ABSENCES.ORIGINE =TGE_REF_ORIGINE_GTA.CODE_ORIGINE;
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'ValidAbsences' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 --insertion des incidents
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion des incidents');
 
 INSERT
 INTO TGE_INCIDENTS_PAIE
 (
 ID ,
 NUMPAC,
 PAIEZAD,
 PERIODE,
 TYPE_TRAITEMENT,
 TYPE_IP,
 CODE_IP,
 DATE_EFFET,
 CODE_IMPUTATION,
 HEURES,
 ORIGINE,
 LOGIN_CREATE,
 DATE_CREATE,
 ROLE_CREATE,
 ORIGINE_CREATE,
 LOGIN_MAJ,
 DATE_MAJ,
 ROLE_MAJ,
 ORIGINE_MAJ,
 CLE_IMPORT,
 CLE_ABSENCE,
 IDPACMAT,
 ENVOYE,
 type_writer,
 ACTION_RETRO,
 ACTION_RETRO_DATE,
 DERNIER_CODE_OPE 
 )
 SELECT SEQ_TGE_INCIDENTS_PAIE.NEXTVAL ,
 INCIDENTS.NUMPAC,
 INCIDENTS.PAIEZAD,
 INCIDENTS.PERIODE,
 INCIDENTS.TYPE_TRAITEMENT,
 INCIDENTS.TYPE_IP,
 INCIDENTS.CODE_IP,
 INCIDENTS.DATE_EFFET,
 INCIDENTS.CODE_IMPUTATION,
 INCIDENTS.HEURES,
 INCIDENTS.ORIGINE,
 INCIDENTS.LOGIN_CREATE,
 INCIDENTS.DATE_CREATE,
 INCIDENTS.ROLE_CREATE,
 INCIDENTS.ORIGINE_CREATE,
 INCIDENTS.LOGIN_MAJ,
 INCIDENTS.DATE_MAJ,
 INCIDENTS.ROLE_MAJ,
 INCIDENTS.ORIGINE_MAJ,
 INCIDENTS.CLE_IMPORT,
 INCIDENTS.CLE_ABSENCE,
 INCIDENTS.IDPACMAT,
 INCIDENTS.ENVOYE,
 CASE
 WHEN TGE_REF_ORIGINE_GTA.MODE_T2    ='R'
 AND TGE_REF_ORIGINE_GTA.ENVOI_MODE_R='N'
 THEN 'N'
 ELSE NULL
 END AS TYPE_writer,
  CASE WHEN pac.DEB_RETRO IS NOT NULL AND TO_char(incidents.periode,'YYYYMM') < pac.PERIODEENCOURS
 THEN 'C' ELSE NULL
 END as ACTION_RETRO,
 CASE WHEN pac.DEB_RETRO IS NOT NULL AND TO_char(incidents.periode,'YYYYMM') < pac.PERIODEENCOURS
 THEN sysdate ELSE NULL
 END as ACTION_RETRO_DATE,
 'C' as DERNIER_CODE_OPE
 FROM
 (SELECT INCI.numpac              AS NUMPAC,          --numpac
 INCI.paiezad                   AS PAIEZAD,         --paiezad
 to_date(INCI.periode,'YYYYMM') AS PERIODE,         --periode
 INCI.type_traitement           AS TYPE_TRAITEMENT, --type_traitement
 CASE
 WHEN (INCI.heures_ip IS NOT NULL
 OR INCI.code_ip      IS NOT NULL )
 THEN DECODE (INCI.code_ip,'HP','T',
 (SELECT p.option_conserv_histo
 FROM TGE_REF_PRE p
 WHERE p.numpac     =inci.numpac
 AND p.code_incident=inci.code_ip
 ))
 WHEN INCI.type_heure IN ('T','R')
 THEN INCI.type_heure
 END AS type_ip ,--DIT 37186 type_ip
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN INCI.CODE_IP
 WHEN INCI.type_heure IN ('T','R')
 THEN DECODE ( INCI.TYPE_HEURE,'R','HT','HP')
 END                                           AS CODE_IP,  ---code_ip DIT 37186
 to_date(INCI.date_debut,'yyyymmdd')-1 +a.jour AS DATE_EFFET,--date effet
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.code_ip     IS NOT NULL
 AND INCI.domaine_imp ='1'
 THEN INCI.code_imputation
 WHEN INCI.type_heure IN ('T','R')
 AND INCI.domaine_imp  ='H'
 THEN INCI.code_imputation
 END AS code_imputation,-- code_imputation DIT 37186
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN is_number(INCI.heures_ip)
 WHEN INCI.type_heure IN ('T','R')
 THEN is_number(INCI.heures_trav)
 END          AS heures,       -- heures DIT 37186
 INCI.origine AS ORIGINE,      --origine
 INCI.LOGIN   AS LOGIN_CREATE, --login create
 sysdate      AS DATE_CREATE,  --date_create
 P_ROLE       AS ROLE_CREATE,
 P_ORIGINE    AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create
 INCI.LOGIN   AS LOGIN_MAJ,      --login maj
 sysdate      AS DATE_MAJ,       -- date_maj
 P_ROLE       AS ROLE_MAJ,
 P_ORIGINE    AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN
 (SELECT id
 FROM tge_absences
 WHERE cle_import =P_LOGIN
 ||'#'
 ||INCI.DATE_IMPORT
 ||'#'
 ||INCI.NUMLIGNE
 )
 WHEN INCI.type_heure IN ('T','R')
 THEN NULL
 END AS CLE_ABSENCE ,--cleAbsence
 CASE
 WHEN INCI.NUMPAC IS NOT NULL
 AND INCI.PACMAT  IS NOT NULL
 THEN RPAD(INCI.NUMPAC,6)
 || INCI.PACMAT
 ELSE ' '
 END  AS IDPACMAT, --idpacmat
 NULL AS ENVOYE    --envoye
 FROM TGE_IMPORT_INCIDENTS INCI,
 -- FVI modif GTA_PAR_ANNEE
 (
 SELECT LEVEL "JOUR" FROM dual CONNECT BY LEVEL <=
 (SELECT MAX(to_number(to_date(date_fin,'YYYYMMDD') - to_date(date_debut,'YYYYMMDD') )) + 1
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN    =P_LOGIN
 AND DATE_IMPORT=P_DATE_IMPORT
 AND ((ERREURS IS NULL
 AND STATUT     = 'TRAIT')
 OR (ERREURS   IS NULL
 AND STATUT     = 'TRANS'))
 )
 ) a
 WHERE INCI.LOGIN                                      =P_LOGIN
 AND INCI.DATE_IMPORT                                  =P_DATE_IMPORT
 AND IS_DATE(INCI.date_debut,'yyyymmdd')               =1
 AND IS_DATE(INCI.date_fin,'yyyymmdd')                 =1
 AND (to_date(INCI.date_debut,'yyyymmdd')-1 + a.jour )<=to_date(INCI.date_fin,'yyyymmdd')
 AND ((INCI.ERREURS                                   IS NULL
 AND INCI.STATUT                                       = 'TRAIT')
 OR (INCI.ERREURS                                     IS NULL
 AND INCI.STATUT                                       = 'TRANS'))
 UNION ALL
 SELECT INCI.numpac               AS NUMPAC,          --numpac
 INCI.paiezad                   AS PAIEZAD,         --paiezad
 to_date(INCI.periode,'YYYYMM') AS PERIODE,         --periode
 INCI.type_traitement           AS TYPE_TRAITEMENT, --type_traitement
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN INCI.type_heure
 WHEN (INCI.heures_ip IS NOT NULL
 OR INCI.code_ip      IS NOT NULL )
 THEN DECODE (INCI.code_ip,'HP','T',
 (SELECT p.option_conserv_histo
 FROM TGE_REF_PRE p
 WHERE p.numpac     =inci.numpac
 AND p.code_incident=inci.code_ip
 ))
 END AS type_ip ,--DIT 37186 type_ip
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN DECODE ( INCI.TYPE_HEURE,'R','HT','HP')
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN INCI.CODE_IP
 END                                           AS CODE_IP,  ---code_ip DIT 37186
 to_date(INCI.date_debut,'yyyymmdd')-1 +a.jour AS DATE_EFFET,--date effet
 CASE
 WHEN INCI.type_heure IN ('T','R')
 AND INCI.domaine_imp  ='H'
 THEN INCI.code_imputation
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.code_ip     IS NOT NULL
 AND INCI.domaine_imp ='1'
 THEN INCI.code_imputation
 END AS code_imputation,-- code_imputation DIT 37186
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN is_number(INCI.heures_trav)
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN is_number(INCI.heures_ip)
 END          AS heures,       -- heures DIT 37186
 INCI.origine AS ORIGINE,      --origine
 INCI.LOGIN   AS LOGIN_CREATE, --login create
 sysdate      AS DATE_CREATE,  --date_create
 P_ROLE       AS ROLE_CREATE,
 P_ORIGINE    AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create
 INCI.LOGIN   AS LOGIN_MAJ,      --login maj
 sysdate      AS DATE_MAJ,       -- date_maj
 P_ROLE       AS ROLE_MAJ,
 P_ORIGINE    AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN NULL
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN
 (SELECT id
 FROM tge_absences
 WHERE cle_import =P_LOGIN
 ||'#'
 ||INCI.DATE_IMPORT
 ||'#'
 ||INCI.NUMLIGNE
 )
 END AS CLE_ABSENCE ,--cleAbsence
 CASE
 WHEN INCI.NUMPAC IS NOT NULL
 AND INCI.PACMAT  IS NOT NULL
 THEN RPAD(INCI.NUMPAC,6)
 || INCI.PACMAT
 ELSE ' '
 END  AS IDPACMAT, --idpacmat
 NULL AS ENVOYE    --envoye
 FROM TGE_IMPORT_INCIDENTS INCI,
 -- FVI modif GTA_PAR_ANNEE
 (
 SELECT LEVEL "JOUR" FROM dual CONNECT BY LEVEL <=
 (SELECT MAX(to_number(to_date(date_fin,'YYYYMMDD') - to_date(date_debut,'YYYYMMDD') )) + 1
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN    =P_LOGIN
 AND DATE_IMPORT=P_DATE_IMPORT
 AND ((ERREURS IS NULL
 AND STATUT     = 'TRAIT')
 OR (ERREURS   IS NULL
 AND STATUT     = 'TRANS'))
 )
 ) a
 WHERE INCI.LOGIN                                      =P_LOGIN
 AND INCI.DATE_IMPORT                                  =P_DATE_IMPORT
 AND IS_DATE(INCI.date_debut,'yyyymmdd')               =1
 AND IS_DATE(INCI.date_fin,'yyyymmdd')                 =1
 AND (to_date(INCI.date_debut,'yyyymmdd')-1 + a.jour )<=to_date(INCI.date_fin,'yyyymmdd')
 AND ( (INCI.heures_ip                                IS NOT NULL
 OR INCI.code_ip                                      IS NOT NULL)
 AND INCI.type_heure                                  IS NOT NULL)
 AND ((INCI.ERREURS                                   IS NULL
 AND INCI.STATUT                                       = 'TRAIT')
 OR (INCI.ERREURS                                     IS NULL
 AND INCI.STATUT                                       = 'TRANS'))
 )INCIDENTS,
 TGE_REF_PAC pac,
 TGE_REF_ORIGINE_GTA
 WHERE INCIDENTS.numpac=TGE_REF_ORIGINE_GTA.numpac
 AND INCIDENTS.ORIGINE =TGE_REF_ORIGINE_GTA.CODE_ORIGINE
 AND pac.numpac = incidents.numpac;
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'ValidIncidents' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
--UN TRAITEMENT DE PAIE EST EN COURS
 if(SQLCODE='-20000') then 
  doRollback:=true;
  GOTO end_proc;
 end if ;
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_INCIDENTS_PAIE');
 SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','SAISIE_IND_INCIDENT',
 'CARTE=40&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE,
 'Import Batch 40','C',null,null,null,null);
 -- Mise à jour des lignes d'import qui sont encore en erreur après validation, statut prend TRANS
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,' UPDATE TGE_IMPORT_INCIDENTS');
 UPDATE TGE_IMPORT_INCIDENTS
 SET STATUT      ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND (ERREURS   IS NOT NULL
 AND STATUT      = 'TRAIT');
 
 IF INSTR(desactiveTraitements, 'TGE_REGROUPE_ABS') < 1 THEN
 	-- Regroupement des absences importé
 	TGE_REGROUPE_ABS(P_LOGIN||'#'||P_DATE_IMPORT);
 END IF;
 
 -- Mise à jour des lignes d'import qui ne sont plus en erreur après validation, statut prend FIN
 UPDATE TGE_IMPORT_INCIDENTS
 SET STATUT        ='FIN'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ERREURS  IS NULL;
 
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,' UPDATE TGE_IMPORT_LISTE');
 UPDATE TGE_IMPORT_LISTE
 SET NBLIGNES_ERR =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ERREURS    IS NOT NULL
 ),
 NBLIGNES_IMP =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 ),
 STATUT        ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND TYPE        = '5';
 
 -- Mise à jour des lignes d'import qui sont encore en erreur après validation, statut prend TRANS
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,' UPDATE TGE_IMPORT_ANNULATION');
 UPDATE TGE_IMPORT_ANNULATION
 SET STATUT      ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND (ERREURS   IS NOT NULL
 AND STATUT      = 'TRAIT');
 
 -- Mise à jour des lignes d'import qui ne sont plus en erreur après validation, statut prend FIN
 UPDATE TGE_IMPORT_ANNULATION
 SET STATUT        ='FIN'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ERREURS  IS NULL;
 
 UPDATE TGE_IMPORT_LISTE
 SET NBLIGNES_ERR =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_ANNULATION
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ERREURS    IS NOT NULL
 ),
 NBLIGNES_IMP =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_ANNULATION
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 ),
 STATUT        ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND TYPE        = '0';
 
 
 
 END IF;
 END IF ;

 v_stop := DBMS_UTILITY.GET_TIME;
 --DBMS_OUTPUT.PUT_LINE(((v_stop-v_start)*10) || ' ms');
 --FIXME utiliser la procédure trace_dbms_output()
 <<end_proc>> 
 if(doRollback) then
  ROLLBACK;
  if(P_WITH30=1) then
    UPDATE TGE_IMPORT_ELEMENTS
    SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
    WHERE LOGIN      = P_LOGIN
    AND DATE_IMPORT  = p_date_import ;
    end if;
  if(P_WITH40=1) then
    UPDATE TGE_IMPORT_INCIDENTS
    SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
    WHERE LOGIN      = P_LOGIN
    AND DATE_IMPORT  = p_date_import ;
  end if;
  if(P_WITH50=1) then
 UPDATE TGE_IMPORT_IMPUTATIONS
 SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
 WHERE LOGIN      = P_LOGIN
 AND DATE_IMPORT  = p_date_import ;
 end if;
  if(P_WITH60=1 or P_WITH70=1) then
  UPDATE TGE_IMPORT_DONNEES
  SET ERREURS =TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
  WHERE LOGIN      = P_LOGIN
  AND DATE_IMPORT  = p_date_import ;
  
  end if;
  TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Rollback de l''import suite à une détection d''un traitement de paie en cours.');
  FSED.FSED_ERREUR( id_trt , 'TGE3040' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , 'Une paie est en cours d''exécution.' );
 
  end if;

 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'fin TGE_IMPORT_3040 OK');
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := 'TGE3040 '||w_err|| sqlerrm;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'fin TGE_IMPORT_3040 KO : '||w_err);
 FSED.FSED_ERREUR( id_trt , 'TGE3040' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 raise;
 END TGE_IMPORT_3040;
##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_50
=SQL=
create or replace PROCEDURE TGE_IMPORT_50 (
 P_LOGIN       IN VARCHAR2 ,
 P_DATE_IMPORT IN VARCHAR2 ,
 P_ROLE        IN VARCHAR2 ,
 -- Origine écran
 P_ORIGINE     IN VARCHAR2 ,
 P_VALIDATION  IN VARCHAR2 ,
 P_WITH50      IN VARCHAR2 ,
 P_CODLANG     IN VARCHAR2,
 -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
 P_TYPE_ACTION IN VARCHAR2 ,
 P_DATE_MAJ    IN SYS_TRC_MODIF.DATEMAJ%type )
 AS
 w_err   VARCHAR2(2000);
 v_start NUMBER;
 v_stop  NUMBER;
 req CLOB;
 reqvalues CLOB;
 reqInsert CLOB;
 dateMaj SYS_TRC_MODIF.datemaj%type;
 BEGIN
 v_start       := DBMS_UTILITY.GET_TIME;
 IF P_DATE_MAJ IS NULL THEN
 SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
 ELSE
 dateMaj:= P_DATE_MAJ;
 END IF;
 IF ( P_WITH50 =1) THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 50');
 TGE_CONTROLE_50 (p_login, p_date_import, NULL, p_codlang, P_TYPE_ACTION);
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_50 - Erreur : ' || w_err);
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 IF p_validation = 1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion TGE_IMPUTATIONS');
 INSERT
 INTO TGE_IMPUTATIONS
 (
 NUMPAC,
PAIEZAD,
PERIODE,
TYPE_TRAITEMENT,
IMPUTATION,
NO_SEQUENCE,
ORIGINE,
NB_UNITE,
DERNIER_CODE_OPE,
LOGIN_MAJ,
DATE_MAJ,
IDPACMAT,
TYPE_WRITER,
DATE_EFFET,
CLE_IMPORT
 )
 select 
 IMPU.NUMPAC,
 IMPU.PAIEZAD,
 IMPU.PERIODE,
 IMPU.TYPE_TRAITEMENT,
 IMPU.CODE_IMPUTATION,
 is_number(IMPU.NO_SEQUENCE+IMPU.CMPT),
 IMPU.ORIGINE,
 IS_NUMBER(IMPU.NOMBRE_UNITE),
 IMPU.DERNIER_CODE_OPE,
 IMPU.LOGIN_MAJ,
 IMPU.DATE_MAJ,
 IMPU.IDPACMAT,
 IMPU.TYPE_WRITER,
 IMPU.DATE_EFFET,
 IMPU.CLE_IMPORT
 from (SELECT             dense_rank() over (partition by NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,CODE_IMPUTATION  order by NUMLIGNE desc)  as CMPT,
 NUMPAC ,
 PAIEZAD ,
 PERIODE ,
 TYPE_TRAITEMENT ,
 CODE_IMPUTATION ,
 (SELECT NVL(MAX(NO_SEQUENCE),0)
 FROM TGE_IMPUTATIONS
 WHERE NUMPAC = I.NUMPAC
 AND PAIEZAD =I.PAIEZAD
 AND PERIODE = I.PERIODE
 AND TYPE_TRAITEMENT = I.TYPE_TRAITEMENT
 AND IMPUTATION = I.CODE_IMPUTATION ) as NO_SEQUENCE,
 ORIGINE,
 NOMBRE_UNITE,
 'C' as DERNIER_CODE_OPE,
 P_LOGIN as LOGIN_MAJ,
 TO_CHAR (sysdate, 'YYYYMMDDHH24MI') as DATE_MAJ,
 CASE
 WHEN I.NUMPAC IS NOT NULL
 AND PACMAT    IS NOT NULL
 THEN RPAD(I.NUMPAC,6)
 || PACMAT
 ELSE ' '
 END AS IDPACMAT,
 CASE
 WHEN (SELECT O.MODE_T2
 ||'#'
 ||O.ENVOI_MODE_R
 FROM TGE_REF_ORIGINE_GTA O
 WHERE O.NUMPAC     = I.NUMPAC
 AND O.CODE_ORIGINE = I.ORIGINE) = 'R#N'
 THEN 'N'
 ELSE NULL
 END AS TYPE_WRITER,
 TO_DATE(I.DATE_EFFET,'YYYYMMDD') AS DATE_EFFET,
  CASE
          WHEN 'VI' = P_TYPE_ACTION
          THEN P_LOGIN
            ||'#'
            ||P_DATE_IMPORT
            ||'#'
            ||NUMLIGNE
          ELSE NULL
        END AS CLE_IMPORT
 FROM TGE_IMPORT_IMPUTATIONS I
 WHERE LOGIN           =P_LOGIN
 AND DATE_IMPORT       = p_date_import
 AND ((ERREURS        IS NULL
 AND STATUT            = 'TRAIT')
 OR (ERREURS          IS NOT NULL
 AND STATUT            = 'TRANS')))IMPU;
 
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidImputation - Erreur : ' || w_err);
 IF (P_LOGIN != 'BATCH' or SQLCODE=-20001) THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END;
 
 IF P_TYPE_ACTION = 'VI' THEN
 --- Gestion de la trace : on enregistre une trace généréale lors d'un import car on ne peut pas gérer de trace individuelle
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_IMPUTATIONS');
 SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','TGE_IMPUTATIONS', 'CARTE=50&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Batch/Web 50','C',NULL,NULL,NULL,NULL);
 END IF;
 
 ----------------------------------------------------------------------------
 
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPUTATIONS');
 UPDATE TGE_IMPORT_IMPUTATIONS
 SET ERREURS           ='',
 STATUT              ='FIN'
 WHERE LOGIN           = P_LOGIN
 AND DATE_IMPORT       = p_date_import
 AND ((ERREURS        IS NULL
 AND STATUT            = 'TRAIT')
 OR (ERREURS          IS NOT NULL
 AND STATUT            = 'TRANS'));
 END IF ;
 END TGE_IMPORT_50;
##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_6070
=SQL=
create or replace PROCEDURE TGE_IMPORT_6070 
(
  P_LOGIN IN VARCHAR2 
, P_DATE_IMPORT IN VARCHAR2 
, P_ROLE IN VARCHAR2 -- pour les traces
  -- Origine écran
, P_ORIGINE IN VARCHAR2  -- pour les traces
, P_VALIDATION IN VARCHAR2 
, P_WITH60 IN VARCHAR2 
, P_WITH70 IN VARCHAR2 
, P_CODLANG IN VARCHAR2 
-- Valeurs attendues : EC -> écran création, EM -> écran modification, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
, P_TYPE_ACTION IN VARCHAR2
) AS 

  w_err   VARCHAR2(2000);
  v_start NUMBER;
  v_stop  NUMBER;
  dateMaj SYS_TRC_MODIF.datemaj%type;
  functionnalityTrace VARCHAR2(250);
BEGIN
  v_start := DBMS_UTILITY.GET_TIME;
  SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
 IF  ( P_WITH60 =1  OR P_WITH70 = 1) THEN
    BEGIN
      TGE_CONTROLE_DONNEE_PAIE (p_login,p_date_import,NULL, p_codlang, P_TYPE_ACTION);
    EXCEPTION
    WHEN OTHERS THEN
      w_err := w_err||'  '||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_DONNEE_PAIE - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
  	    raise;
  	  END IF;
    END ;
 END IF;
 IF p_validation = 1 THEN
   BEGIN
   	 INSERT INTO TGE_DONNEES_PAIE (NUMPAC                 ,
                                 PAIEZAD                    ,
                                 PERIODE                    ,
                                 TYPE_TRAITEMENT            ,
                                 TYPE_DONNEE                ,
                                 CODE_RUBRIQUE              ,
                                 CODE_CAISSE                ,
                                 NO_SEQUENCE                ,
                                 SENS                       ,
                                 CODE_IMPUTATION            ,
                                 ORIGINE                    ,
                                 NOMBRE                     ,
                                 TAUX                       ,
                                 MONTANT                    ,
                                 POURCENTAGE                ,
                                 DOMAINE_PRCTE              ,
                                 DERNIER_CODE_OPE           ,
                                 LOGIN_MAJ                  ,
                                 DATE_MAJ                   ,
                                 CLE_IMPORT                 ,
                                 IDPACMAT                   ,
                                 PERIODE_RATTACH_DEB        ,
                                 PERIODE_RATTACH_FIN        ,
                                 DATE_DEB_ARRET             ,
                                 PERIODE_AFFECTATION        ,
                                 TYPE_WRITER                ,
                                 CODE_REMPLACEMENT			,
                                 DATE_EFFET           		,
                                 ACTION_RETRO				,
                                 ACTION_RETRO_DATE
                                 )
                                 
              SELECT                   DONNEES.NUMPAC,
                                       DONNEES.PAIEZAD,
                                       DONNEES.PERIODE,
                                       DONNEES.TYPE_TRAITEMENT,
                                       DONNEES.TYPE_DONNEE,
                                       DONNEES.CODE_RUBRIQUE,
                                       DONNEES.CODE_CAISSE,
                                       is_number(DONNEES.NO_SEQUENCE+DONNEES.CMPT),
                                       DONNEES.SENS,
                                       DONNEES.CODE_IMPUTATION,
                                       DONNEES.ORIGINE,
                                       is_number(DONNEES.NOMBRE),
                                       is_number(DONNEES.TAUX),
                                       is_number(DONNEES.MONTANT),
                                       is_number(DONNEES.POURCENTAGE),
                                       DONNEES.DOMAINE_PRCTE,
                                       DONNEES.DERNIER_CODE_OPE,
                                       DONNEES.LOGIN_MAJ,
                                       DONNEES.DATE_MAJ,
                                       DONNEES.CLE_IMPORT,
                                       DONNEES.IDPACMAT,
                                       DONNEES.PERIODE_RATTACH_DEB,
                                       DONNEES.PERIODE_RATTACH_FIN,
                                       DONNEES.DATE_DEB_ARRET,
                                       DONNEES.PERIODE_AFFECTATION,
                                       DONNEES.TYPE_WRITER,
                                       DONNEES.CODE_REMPLACEMENT,
                                       DONNEES.DATE_EFFET,
                                       DONNEES.ACTION_RETRO,
                                       DONNEES.ACTION_RETRO_DATE
              FROM    
              (SELECT            dense_rank() over (partition by tg.NUMPAC,tg.PAIEZAD,tg.PERIODE,tg.TYPE_TRAITEMENT,tg.TYPE_DONNEE,tg.CODE_RUBRIQUE,tg.CODE_CAISSE order by tg.NUMLIGNE desc)  as CMPT,     
                                 TG.NUMPAC,
                                 TG.PAIEZAD,
                                 TG.PERIODE,
                                 TG.TYPE_TRAITEMENT,
                                 TG.TYPE_DONNEE ,
                                 TG.CODE_RUBRIQUE,
                                 NVL(TG.CODE_CAISSE,'*') AS CODE_CAISSE,
                            (select NVL(max(tp.no_sequence),0 )
                             from TGE_DONNEES_PAIE tp
                             where tp.NUMPAC=tg.NUMPAC
                             AND tp.PAIEZAD=tg.PAIEZAD
                             AND tp.PERIODE =tg.PERIODE
                             AND tp.TYPE_TRAITEMENT =tg.TYPE_TRAITEMENT
                             AND tp.TYPE_DONNEE = tg.TYPE_DONNEE
                             AND tp.CODE_RUBRIQUE =tg.code_rubrique
                             AND tp.CODE_CAISSE=NVL(tg.code_caisse,'*')) AS no_sequence,
                             TG.SENS,
                             TG.CODE_IMPUTATION,
                             TG.ORIGINE,
                             TG.NOMBRE                     ,
                             TG.TAUX                       ,
                             TG.MONTANT                    ,
                             TG.POURCENTAGE                ,
                             TG.DOMAINE_PRCTE              ,
                             'C'  AS   DERNIER_CODE_OPE ,
                             P_LOGIN AS LOGIN_MAJ,
                             TO_CHAR (sysdate, 'YYYYMMDDHH24MI') AS DATE_MAJ,
                             -- Pour les DV/DR, on va stocker une clé d'import même lorsque l'on vient de l'écran
                             -- afin de pouvoir retrouver la ligne créée et le no_sequence (pour les traces)
                             P_LOGIN||'#'||P_DATE_IMPORT||'#'||NUMLIGNE AS CLE_IMPORT,
                             CASE
                               WHEN TG.NUMPAC IS NOT NULL
                               AND TG.PACMAT  IS NOT NULL
                               THEN RPAD(TG.NUMPAC,6)|| TG.PACMAT
                               ELSE ' '
                             END AS IDPACMAT,
                             to_date(TG.PERIODE_RATTACH_DEB, 'YYYYMMDD') as PERIODE_RATTACH_DEB,
                             to_date(TG.PERIODE_RATTACH_FIN, 'YYYYMMDD') as PERIODE_RATTACH_FIN,
                             to_date(TG.DATE_DEB_ARRET, 'YYYYMMDD') as DATE_DEB_ARRET,
                             to_date(TG.PERIODE_AFFECTATION, 'YYYYMMDD') as PERIODE_AFFECTATION,
                             case 
                               when (select O.MODE_T2||'#'||O.ENVOI_MODE_R from TGE_REF_ORIGINE_GTA O where O.NUMPAC = TG.NUMPAC and O.CODE_ORIGINE = TG.ORIGINE) = 'R#N'
      						   then 'N'
      						   else NULL
                             end as TYPE_WRITER,
                             TG.CODE_REMPLACEMENT,
                             to_date(TG.DATE_EFFET,'YYYYMMDD') as DATE_EFFET,
                             -- Gestion Action Retro : pour ne pas bousiller les perfs, on va positionner une valeur '*' dans actionRetro et null dans actionRetroDate
                             -- et ensuite avec une requête d'update mettre à jour la valeur de actionRetro et actionRetroDate.
                             -- On évite ainsi de faire 2 sous-select sur TGE_REF_PAC ou une jointure globale pour récupérer TGE_REF_PAC.PERIODEENCOURS
                             case
                             	when  TG.PERIODE < (select PAC.PERIODEENCOURS from TGE_REF_PAC PAC where PAC.NUMPAC = TG.NUMPAC)
                             	then '*'
                             	else NULL
                             end as ACTION_RETRO,
                             NULL as ACTION_RETRO_DATE
                             
          FROM               TGE_IMPORT_DONNEES  TG
          WHERE              TG.LOGIN            = P_LOGIN 
          AND                TG.DATE_IMPORT      = P_DATE_IMPORT
          AND ((TG.ERREURS   IS NULL
          AND TG.STATUT  = 'TRAIT')
          OR (TG.ERREURS  IS NULL
          AND TG.STATUT   = 'TRANS')))DONNEES;
          
          -- Gestion Action Retro : si création d'une ligne rétro, on sauvegarde qu'il s'agit d'une création comme première action et la date à laquelle elle a eu lieu
          update TGE_DONNEES_PAIE set 
          	ACTION_RETRO = 'C',
          	ACTION_RETRO_DATE = DATE_MAJ
          where ACTION_RETRO = '*';
   END ;
   
   	--- Gestion de la trace pour les imports ou la MarketPlace : on enregistre une trace pour chaque ligne de l'import qui n'est pas en erreur
	IF P_TYPE_ACTION = 'VI' or P_TYPE_ACTION = 'MP' THEN
		functionnalityTrace := 'IMPORT_DONNEE_ELT_PAIE';
    	IF P_TYPE_ACTION = 'MP' THEN
			functionnalityTrace := 'IMPORT_DONNEE_ELT_PAIE_MP';
    	END IF;
    	
      	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début SYS_TRC_MODIF pour insertion DV/DR');
      	
		insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
	  		NAMES_VALUES_HAVE_CHANGED, AFTER_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
			select DI.LOGIN, SYSDATE, '3', functionnalityTrace, 
			-- KEY_VALUES
			'numPac='||D.NUMPAC||'&paieZad='||D.PAIEZAD||'&periode='||D.PERIODE||'&type_traitement='||D.TYPE_TRAITEMENT||'&type_donnee='||D.TYPE_DONNEE||'&code_rubrique='||D.CODE_RUBRIQUE||'&code_caisse='||D.CODE_CAISSE||'&no_sequence='||D.NO_SEQUENCE,
			-- SHORT_NAME : on gère le type de donnée DV/DR /DR Cotis et si c'est du remplacement ou non
			'Ajout d''une ' || decode(D.TYPE_DONNEE, '1', 'DV', '2', 'DR', 'DR cotis.') || decode(nvl(D.CODE_REMPLACEMENT, '*'), '*', '', ' rempl.'),
			-- ACTION
			'C',
			-- NAMES_VALUES_HAVE_CHANGED 
			'numPac^paieZad^periode^type_traitement^type_donnee^code_rubrique^code_caisse^no_sequence^sens^code_imputation^nombre^taux^montant^pourcentage^domaine_prcte^periode_rattach_deb^periode_rattach_fin^date_deb_arret^periode_affectation^origine^dernier_code_ope^login_maj^date_maj^code_remplacement^date_effet^idPacMat^cle_import',
			-- AFTER_CHANGE
			D.NUMPAC||'^'||D.PAIEZAD||'^'||D.PERIODE||'^'||D.TYPE_TRAITEMENT||'^'||D.TYPE_DONNEE||'^'||D.CODE_RUBRIQUE||'^'||D.CODE_CAISSE
			||'^'||D.NO_SEQUENCE||'^'||D.SENS||'^'||D.CODE_IMPUTATION||'^'||D.NOMBRE||'^'||D.TAUX||'^'||D.MONTANT||'^'||D.POURCENTAGE
			||'^'||D.DOMAINE_PRCTE||'^'||D.PERIODE_RATTACH_DEB||'^'||D.PERIODE_RATTACH_FIN||'^'||D.DATE_DEB_ARRET||'^'||D.PERIODE_AFFECTATION
			||'^'||D.ORIGINE||'^'||D.DERNIER_CODE_OPE||'^'||D.LOGIN_MAJ||'^'||D.DATE_MAJ
			||'^'||D.CODE_REMPLACEMENT||'^'||D.DATE_EFFET||'^'||D.IDPACMAT||'^'||D.CLE_IMPORT,
			-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
			D.NUMPAC, DI.PACMAT, D.PAIEZAD, DI.MATRICULE, D.DATE_EFFET
			from TGE_DONNEES_PAIE D inner join TGE_IMPORT_DONNEES DI on D.CLE_IMPORT = DI.LOGIN||'#'||DI.DATE_IMPORT||'#'||DI.NUMLIGNE
			where DI.LOGIN = P_LOGIN and DI.DATE_IMPORT = P_DATE_IMPORT;
	END IF;
   
   TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPORT_DONNEES');
   -- Mise à jour des lignes d'import qui sont encore en erreur après validation, statut prend TRANS
   UPDATE TGE_IMPORT_DONNEES
   SET STATUT = 'TRANS'
   WHERE LOGIN = P_LOGIN
   AND DATE_IMPORT = p_date_import
   AND (ERREURS IS NOT NULL
   AND STATUT = 'TRAIT');
	 
   -- Mise à jour des lignes d'import qui ne sont plus en erreur après validation, statut prend FIN
   UPDATE TGE_IMPORT_DONNEES
   SET STATUT ='FIN'
   WHERE LOGIN = P_LOGIN
   AND DATE_IMPORT = p_date_import
   AND ERREURS IS NULL;
   
	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début UPDATE TGE_IMPORT_LISTE');
	-- DV
	UPDATE TGE_IMPORT_LISTE
	SET NBLIGNES_ERR =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND ERREURS    IS NOT NULL
	  AND TYPE_IMPORT = '1'
	  ),
	  NBLIGNES_IMP =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND TYPE_IMPORT = '1'
	  ),
	  STATUT        ='TRANS'
	WHERE LOGIN     = P_LOGIN
	AND DATE_IMPORT = p_date_import
	AND TYPE = '1';
	-- DR
	UPDATE TGE_IMPORT_LISTE
	SET NBLIGNES_ERR =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND ERREURS    IS NOT NULL
	  AND TYPE_IMPORT = '3'
	  ),
	  NBLIGNES_IMP =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND TYPE_IMPORT = '3'
	  ),
	  STATUT        ='TRANS'
	WHERE LOGIN     = P_LOGIN
	AND DATE_IMPORT = p_date_import
	AND TYPE = '3';
	-- DR Cotis
	UPDATE TGE_IMPORT_LISTE
	SET NBLIGNES_ERR =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND ERREURS    IS NOT NULL
	  AND TYPE_IMPORT = '4'
	  ),
	  NBLIGNES_IMP =
	  (SELECT COUNT(*)
	  FROM TGE_IMPORT_DONNEES
	  WHERE LOGIN     = P_LOGIN
	  AND DATE_IMPORT = p_date_import
	  AND TYPE_IMPORT = '4'
	  ),
	  STATUT        ='TRANS'
	WHERE LOGIN     = P_LOGIN
	AND DATE_IMPORT = p_date_import
	AND TYPE = '4';
   
 END IF ;
EXCEPTION
  WHEN OTHERS THEN
  w_err := ' '||w_err|| sqlerrm;
  TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidDonneePaie - Erreur : ' || w_err);
  IF (P_LOGIN != 'BATCH' or SQLCODE='-20001') THEN
  	-- On remonte l'erreur à l'application
    raise;
  END IF;
END TGE_IMPORT_6070;
##
TGE_IMPORT_AVANCEMENT_PROC
=SQL=
CREATE OR REPLACE PROCEDURE TGE_IMPORT_AVANCEMENT_PROC(
    P_DATE_IMPORT IN VARCHAR2 ,
    txt           IN VARCHAR2 )
AS
 PRAGMA AUTONOMOUS_TRANSACTION;
  status INT;
BEGIN
  INSERT INTO TGE_IMPORT_AVANCEMENT VALUES
    (P_DATE_IMPORT ,systimestamp,txt
    );
    commit;
END TGE_IMPORT_AVANCEMENT_PROC;
##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_CARTE_ANNULATION
=SQL=
create or replace PROCEDURE TGE_IMPORT_CARTE_ANNULATION( P_LOGIN IN VARCHAR2, P_DATE_IMPORT IN VARCHAR2)
 AS
 

BEGIN
	/*
	 * ELEMENTS DE PAIE
	 */
	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début SYS_TRC_MODIF pour annulation EZ');
	-- On trace l'annulation des éléments (TGE_REF_TYPES_GTA.MATRIC_GTA = PACMAT)
	insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
		NAMES_VALUES_HAVE_CHANGED, BEFORE_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
	select distinct A.LOGIN, SYSDATE, '3', 'IMPORT_ELEMENT_PAIE', 
	-- KEY_VALUES
	'numPac='||E.NUMPAC||'&paieZad='||E.PAIEZAD||'&periode='||E.PERIODE||'&type_traitement='||E.TYPE_TRAITEMENT||
	'&code_element='||E.CODE_ELEMENT||'&indicatif='||E.INDICATIF||'&'||'code_remplacement='||E.CODE_REMPLACEMENT,
	-- SHORT_NAME : on gère si c'est un élément de remplacement ou non
	'Suppression d''un EZ' || decode(E.CODE_REMPLACEMENT, '*', '', ' rempl.'),
	-- ACTION
	'S',
	-- NAMES_VALUES_HAVE_CHANGED 
	'numPac^paieZad^periode^type_traitement^code_element^indicatif^valeur^origine^dernier_code_ope^login_maj^date_maj^idPacMat^code_remplacement^date_effet^cle_import',
	-- BEFORE_CHANGE
	E.NUMPAC||'^'||E.PAIEZAD||'^'||E.PERIODE||'^'||E.TYPE_TRAITEMENT||'^'||E.CODE_ELEMENT||'^'||E.INDICATIF||'^'||E.VALEUR
	||'^'||E.ORIGINE||'^'||E.DERNIER_CODE_OPE||'^'||E.LOGIN_MAJ||'^'||E.DATE_MAJ||'^'||E.IDPACMAT
	||'^'||E.CODE_REMPLACEMENT||'^'||E.DATE_EFFET||'^'||E.CLE_IMPORT,
	-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
	E.NUMPAC, A.PACMAT, E.PAIEZAD, A.MATRICULE, E.DATE_EFFET
	from TGE_ELEMENTS_PAIE E, TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	where A.LOGIN = P_LOGIN
	and A.DATE_IMPORT = P_DATE_IMPORT
	and A.NUMPAC = E.NUMPAC
	and GTA.NUMPAC = E.NUMPAC
	and A.ERREURS is null
	and GTA.CODE_GTA =(select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	and nvl(GTA.MATRIC_GTA,'PAIEZAD')='PACMAT'
	and A.PAIEZAD = E.PAIEZAD
	and(exists (
		select C.PAIEZAD
		from DIC_ADM_CONTRAT_SITU C
		where C.NUMPAC = A.NUMPAC
		and C.NUMPAC = E.NUMPAC
		and C.PAIEZAD = E.PAIEZAD
		and C.PACMAT = A.PACMAT
		)
	)
	and A.ORIGINE =E.ORIGINE
	and A.PERIODE = E.PERIODE
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where A.ORIGINE = CODE_ORIGINE
			and NUMPAC = E.NUMPAC
			and CODE_ORIGINE = E.ORIGINE
			and MODE_3060 != 'F'
			)
		and E.CODE_REMPLACEMENT = 'R'
		)
		or E.CODE_REMPLACEMENT = '*'
	);
	
	-- On trace l'annulation des éléments (TGE_REF_TYPES_GTA.MATRIC_GTA = PAIEZAD)
	insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
		NAMES_VALUES_HAVE_CHANGED, BEFORE_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
	select distinct A.LOGIN, SYSDATE, '3', 'IMPORT_ELEMENT_PAIE', 
	-- KEY_VALUES
	'numPac='||E.NUMPAC||'&paieZad='||E.PAIEZAD||'&periode='||E.PERIODE||'&type_traitement='||E.TYPE_TRAITEMENT||
	'&code_element='||E.CODE_ELEMENT||'&indicatif='||E.INDICATIF||'&'||'code_remplacement='||E.CODE_REMPLACEMENT,
	-- SHORT_NAME : on gère si c'est un élément de remplacement ou non
	'Suppression d''un EZ' || decode(E.CODE_REMPLACEMENT, '*', '', ' rempl.'),
	-- ACTION
	'S',
	-- NAMES_VALUES_HAVE_CHANGED 
	'numPac^paieZad^periode^type_traitement^code_element^indicatif^valeur^origine^dernier_code_ope^login_maj^date_maj^idPacMat^code_remplacement^date_effet^pacMat^cle_import',
	-- BEFORE_CHANGE
	E.NUMPAC||'^'||E.PAIEZAD||'^'||E.PERIODE||'^'||E.TYPE_TRAITEMENT||'^'||E.CODE_ELEMENT||'^'||E.INDICATIF||'^'||E.VALEUR
	||'^'||E.ORIGINE||'^'||E.DERNIER_CODE_OPE||'^'||E.LOGIN_MAJ||'^'||E.DATE_MAJ||'^'||E.IDPACMAT
	||'^'||E.CODE_REMPLACEMENT||'^'||E.DATE_EFFET||'^'||A.PACMAT||'^'||E.CLE_IMPORT,
	-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
	E.NUMPAC, A.PACMAT, E.PAIEZAD, A.MATRICULE, E.DATE_EFFET
	from TGE_ELEMENTS_PAIE E, TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	where A.LOGIN = P_LOGIN
	and A.DATE_IMPORT = P_DATE_IMPORT
	and A.NUMPAC = E.NUMPAC
	and GTA.NUMPAC = E.NUMPAC
	and A.ERREURS is null
	and GTA.CODE_GTA =(select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	and nvl(GTA.MATRIC_GTA,'PAIEZAD')='PAIEZAD'
	and A.PAIEZAD = E.PAIEZAD
	and A.ORIGINE =E.ORIGINE
	and A.PERIODE = E.PERIODE
	and (
		(exists (
	    	select 1
	        from TGE_REF_ORIGINE_GTA 
	        where A.ORIGINE = CODE_ORIGINE
	        and NUMPAC = E.NUMPAC
	        and CODE_ORIGINE = E.ORIGINE
	        and MODE_3060 != 'F'
	        )
		and E.CODE_REMPLACEMENT = 'R'
	    )
		or E.CODE_REMPLACEMENT = '*'
	);
	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début annulation EZ'); 
	-- Suppression dans TGE_ELEMENTS_PAIE des cartes d'annulation (TGE_REF_TYPES_GTA.MATRIC_GTA = PACMAT)
	delete from TGE_ELEMENTS_PAIE E
	where exists(
		select 1
		from TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
		where A.LOGIN = P_LOGIN
		and A.DATE_IMPORT = P_DATE_IMPORT
		and A.NUMPAC = E.NUMPAC
		and GTA.NUMPAC = E.NUMPAC
		and A.ERREURS is null
		and GTA.CODE_GTA = (select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
		and nvl(GTA.MATRIC_GTA,'PAIEZAD') = 'PACMAT'
		and A.PAIEZAD = E.PAIEZAD
		and (exists (
			select C.PAIEZAD
			from DIC_ADM_CONTRAT_SITU C
			where C.NUMPAC = A.NUMPAC
			and C.NUMPAC = E.NUMPAC
			and C.PAIEZAD = E.PAIEZAD
			and C.PACMAT = A.PACMAT
			)
		)
		and A.ORIGINE = E.ORIGINE
		and A.PERIODE = E.PERIODE
	)
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where NUMPAC = E.NUMPAC
			and CODE_ORIGINE = E.ORIGINE
			and MODE_3060 != 'F'
			)
		and E.CODE_REMPLACEMENT = 'R'
		)
		or E.CODE_REMPLACEMENT = '*'
	);
	--Suppression dans TGE_ELEMENTS_PAIE des cartes d'annulation (TGE_REF_TYPES_GTA.MATRIC_GTA = PAIZAD)
	delete from TGE_ELEMENTS_PAIE E
	where exists (
		select 1
		from TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	 	where A.LOGIN = P_LOGIN
	 	and A.DATE_IMPORT = P_DATE_IMPORT
	 	and A.NUMPAC = E.NUMPAC
	 	and GTA.NUMPAC = E.NUMPAC
	 	and A.ERREURS is null
	 	and GTA.CODE_GTA = (select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	 	and nvl(GTA.MATRIC_GTA,'PAIEZAD') = 'PAIEZAD'
	 	and A.PAIEZAD = E.PAIEZAD
	 	and A.ORIGINE= E.ORIGINE
	 	and A.PERIODE = E.PERIODE
	)
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where NUMPAC = E.NUMPAC
			and CODE_ORIGINE = E.ORIGINE
			and MODE_3060 != 'F'
			)
		and E.CODE_REMPLACEMENT = 'R'
		)
		or E.CODE_REMPLACEMENT = '*'
	);
	
	/**
	 * DONNEES DE PAIE
	 */
	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début SYS_TRC_MODIF pour annulation DV/DR');
	-- On trace l'annulation des données de paie (TGE_REF_TYPES_GTA.MATRIC_GTA = PACMAT)
	insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
		NAMES_VALUES_HAVE_CHANGED, BEFORE_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
	select distinct A.LOGIN, SYSDATE, '3', 'IMPORT_DONNEE_ELT_PAIE', 
	-- KEY_VALUES
	'numPac='||D.NUMPAC||'&paieZad='||D.PAIEZAD||'&periode='||D.PERIODE||'&type_traitement='||D.TYPE_TRAITEMENT
	||'&type_donnee='||D.TYPE_DONNEE||'&code_rubrique='||D.CODE_RUBRIQUE||'&code_caisse='||D.CODE_CAISSE||'&no_sequence='||D.NO_SEQUENCE,
	-- SHORT_NAME : on gère si c'est une DV, DR, DR Cotis. et si elle est de remplacement ou non
	'Suppression d''une ' || decode(D.TYPE_DONNEE, '1', 'DV', '2', 'DR', 'DR cotis.') || decode(D.CODE_REMPLACEMENT, '*', '', ' rempl.'),
	-- ACTION
	'S',
	-- NAMES_VALUES_HAVE_CHANGED 
	'numPac^paieZad^periode^type_traitement^type_donnee^code_rubrique^code_caisse^no_sequence^sens^code_imputation^nombre^taux^montant^pourcentage^domaine_prcte^periode_rattach_deb^periode_rattach_fin^date_deb_arret^periode_affectation^origine^dernier_code_ope^login_maj^date_maj^code_remplacement^date_effet^idPacMat^cle_import',
	-- BEFORE_CHANGE
	D.NUMPAC||'^'||D.PAIEZAD||'^'||D.PERIODE||'^'||D.TYPE_TRAITEMENT||'^'||D.TYPE_DONNEE||'^'||D.CODE_RUBRIQUE||'^'||D.CODE_CAISSE
	||'^'||D.NO_SEQUENCE||'^'||D.SENS||'^'||D.CODE_IMPUTATION||'^'||D.NOMBRE||'^'||D.TAUX||'^'||D.MONTANT||'^'||D.POURCENTAGE
	||'^'||D.DOMAINE_PRCTE||'^'||D.PERIODE_RATTACH_DEB||'^'||D.PERIODE_RATTACH_FIN||'^'||D.DATE_DEB_ARRET||'^'||D.PERIODE_AFFECTATION
	||'^'||D.ORIGINE||'^'||D.DERNIER_CODE_OPE||'^'||D.LOGIN_MAJ||'^'||D.DATE_MAJ
	||'^'||D.CODE_REMPLACEMENT||'^'||D.DATE_EFFET||'^'||D.IDPACMAT||'^'||D.CLE_IMPORT,
	-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
	D.NUMPAC, A.PACMAT, D.PAIEZAD, A.MATRICULE, D.DATE_EFFET
	from TGE_DONNEES_PAIE D, TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	where A.LOGIN = P_LOGIN
	and A.DATE_IMPORT = P_DATE_IMPORT
	and A.NUMPAC = D.NUMPAC
	and GTA.NUMPAC = D.NUMPAC
	and A.ERREURS is null
	and GTA.CODE_GTA =(select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	and nvl(GTA.MATRIC_GTA,'PAIEZAD')='PACMAT'
	and A.PAIEZAD = D.PAIEZAD
	and(exists (
		select C.PAIEZAD
		from DIC_ADM_CONTRAT_SITU C
		where C.NUMPAC = A.NUMPAC
		and C.NUMPAC = D.NUMPAC
		and C.PAIEZAD = D.PAIEZAD
		and C.PACMAT = A.PACMAT
		)
	)
	and A.ORIGINE = D.ORIGINE
	and A.PERIODE = D.PERIODE
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where A.ORIGINE = CODE_ORIGINE
			and NUMPAC = D.NUMPAC
			and CODE_ORIGINE = D.ORIGINE
			and MODE_3060 != 'F'
			)
		and D.CODE_REMPLACEMENT ='R'
		)
		or D.CODE_REMPLACEMENT is null
	);
	
	-- On trace l'annulation des données de paie (TGE_REF_TYPES_GTA.MATRIC_GTA = PAIEZAD)
	insert into SYS_TRC_MODIF (LOGIN, DATEMAJ, ROLE, FUNCTIONNALITY, KEYS_VALUES, SHORT_NAME, ACTION, 
		NAMES_VALUES_HAVE_CHANGED, BEFORE_CHANGE, NUMPAC, PACMAT, PAIEZAD, MATRIC, DATE_EFFET)
	select distinct A.LOGIN, SYSDATE, '3', 'IMPORT_DONNEE_ELT_PAIE', 
	-- KEY_VALUES
	'numPac='||D.NUMPAC||'&paieZad='||D.PAIEZAD||'&periode='||D.PERIODE||'&type_traitement='||D.TYPE_TRAITEMENT||'&type_donnee='||D.TYPE_DONNEE||'&code_rubrique='||D.CODE_RUBRIQUE||'&code_caisse='||D.CODE_CAISSE||'&no_sequence='||D.NO_SEQUENCE,
	-- SHORT_NAME : on gère si c'est une DV, DR, DR Cotis. et si elle est de remplacement ou non
	'Suppression d''un ' || decode(D.TYPE_DONNEE, '1', 'DV', '2', 'DR', 'DR cotis.') ||  decode(D.CODE_REMPLACEMENT, '*', '', ' rempl.'),
	-- ACTION
	'S',
	-- NAMES_VALUES_HAVE_CHANGED 
	'numPac^paieZad^periode^type_traitement^type_donnee^code_rubrique^code_caisse^no_sequence^sens^code_imputation^nombre^taux^montant^pourcentage^domaine_prcte^periode_rattach_deb^periode_rattach_fin^date_deb_arret^periode_affectation^origine^dernier_code_ope^login_maj^date_maj^code_remplacement^date_effet^idPacMat^cle_import',
	-- BEFORE_CHANGE
	D.NUMPAC||'^'||D.PAIEZAD||'^'||D.PERIODE||'^'||D.TYPE_TRAITEMENT||'^'||D.TYPE_DONNEE||'^'||D.CODE_RUBRIQUE||'^'||D.CODE_CAISSE
	||'^'||D.NO_SEQUENCE||'^'||D.SENS||'^'||D.CODE_IMPUTATION||'^'||D.NOMBRE||'^'||D.TAUX||'^'||D.MONTANT||'^'||D.POURCENTAGE
	||'^'||D.DOMAINE_PRCTE||'^'||D.PERIODE_RATTACH_DEB||'^'||D.PERIODE_RATTACH_FIN||'^'||D.DATE_DEB_ARRET||'^'||D.PERIODE_AFFECTATION
	||'^'||D.ORIGINE||'^'||D.DERNIER_CODE_OPE||'^'||D.LOGIN_MAJ||'^'||D.DATE_MAJ
	||'^'||D.CODE_REMPLACEMENT||'^'||D.DATE_EFFET||'^'||D.IDPACMAT||'^'||D.CLE_IMPORT,
	-- NUMPAC / PACMAT / PAIEZAD / MATRIC / DATE_EFFET
	D.NUMPAC, A.PACMAT, D.PAIEZAD, A.MATRICULE, D.DATE_EFFET
	from TGE_DONNEES_PAIE D, TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	where A.LOGIN = P_LOGIN
	and A.DATE_IMPORT = P_DATE_IMPORT
	and A.NUMPAC = D.NUMPAC
	and GTA.NUMPAC = D.NUMPAC
	and A.ERREURS is null
	and GTA.CODE_GTA =(select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	and nvl(GTA.MATRIC_GTA,'PAIEZAD')='PAIEZAD'
	and A.PAIEZAD = D.PAIEZAD
	and A.ORIGINE =D.ORIGINE
	and A.PERIODE = D.PERIODE
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where A.ORIGINE = CODE_ORIGINE
			and NUMPAC = D.NUMPAC
			and CODE_ORIGINE = D.ORIGINE
			and MODE_3060 != 'F'
			)
		and D.CODE_REMPLACEMENT ='R'
		)
		or D.CODE_REMPLACEMENT is null
	);
	TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Début annulation DV/DR');
	-- Suppression dans TGE_DONNEES_PAIE des cartes d'annulation (TGE_REF_TYPES_GTA.MATRIC_GTA = PACMAT)
	delete from TGE_DONNEES_PAIE D
	where exists(
		select 1
		from TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
		where A.LOGIN = P_LOGIN
		and A.DATE_IMPORT = P_DATE_IMPORT
		and A.NUMPAC = D.NUMPAC
		and GTA.NUMPAC = D.NUMPAC
		and A.ERREURS is null
		and GTA.CODE_GTA = (select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
		and nvl(GTA.MATRIC_GTA,'PAIEZAD') = 'PACMAT'
		and A.PAIEZAD = D.PAIEZAD
		and (exists (
			select C.PAIEZAD
			from DIC_ADM_CONTRAT_SITU C
			where C.NUMPAC = A.NUMPAC
			and C.NUMPAC = D.NUMPAC
			and C.PAIEZAD = D.PAIEZAD
			and C.PACMAT = A.PACMAT
			)
		)
		and A.ORIGINE = D.ORIGINE
		and A.PERIODE = D.PERIODE
	)
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where NUMPAC = D.NUMPAC
			and CODE_ORIGINE = D.ORIGINE
			and MODE_3060 != 'F'
			)
		and D.CODE_REMPLACEMENT = 'R'
		)
		or D.CODE_REMPLACEMENT is null
	);
	--Suppression dans TGE_DONNEES_PAIE des cartes d'annulation (TGE_REF_TYPES_GTA.MATRIC_GTA = PAIZAD)
	delete from TGE_DONNEES_PAIE D
	where exists (
		select 1
		from TGE_IMPORT_ANNULATION A, TGE_REF_TYPES_GTA GTA
	 	where A.LOGIN = P_LOGIN
	 	and A.DATE_IMPORT = P_DATE_IMPORT
	 	and A.NUMPAC = D.NUMPAC
	 	and GTA.NUMPAC = D.NUMPAC
	 	and A.ERREURS is null
	 	and GTA.CODE_GTA = (select CODE_GTA from TGE_REF_ORIGINE_GTA where NUMPAC = A.NUMPAC and CODE_ORIGINE = A.ORIGINE)
	 	and nvl(GTA.MATRIC_GTA,'PAIEZAD') = 'PAIEZAD'
	 	and A.PAIEZAD = D.PAIEZAD
	 	and A.ORIGINE= D.ORIGINE
	 	and A.PERIODE = D.PERIODE
	)
	and (
		(exists (
			select 1
			from TGE_REF_ORIGINE_GTA 
			where NUMPAC = D.NUMPAC
			and CODE_ORIGINE = D.ORIGINE
			and MODE_3060 != 'F'
			)
		and D.CODE_REMPLACEMENT = 'R'
		)
		or D.CODE_REMPLACEMENT is null
	);
	 
 END TGE_IMPORT_CARTE_ANNULATION;
##
TGE_IMPORT_IMPUTATION
=SQL=
CREATE OR REPLACE PROCEDURE TGE_IMPORT_IMPUTATION(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2,
    p_numpac VARCHAR2 )
AS
  req CLOB;
  reqvalues CLOB;
  reqInsert CLOB;
BEGIN
  -- Suppression des lignes dans dans DIC_TGE_IMPUTATION_PERMANENTE
  DELETE
  FROM dic_tge_imputations_perm a
  WHERE EXISTS
    (SELECT *
    FROM TGE_IMPORT_ELEMENTS b
    WHERE a.numpac      =b.numpac
    AND a.paiezad       =b.paiezad
    AND b.code_ELEMENT IN ('B690','B691')
    AND b.LOGIN         = P_LOGIN
    AND b.DATE_IMPORT   = p_date_import
    AND code_element   IN ('B690','B691')
    AND EXISTS
      (SELECT *
      FROM TGE_IMPORT_ELEMENTS c
      WHERE b.login     =c.login
      AND b.date_import =c.date_import
      AND b.numpac      =c.numpac
      AND b.paiezad     =c.paiezad
      AND c.code_element='B690'
      AND b.indicatif   =c.indicatif
      AND ERREURs      IS NULL
      )
    AND EXISTS
      (SELECT *
      FROM TGE_IMPORT_ELEMENTS c
      WHERE b.login              =c.login
      AND b.date_import          =c.date_import
      AND b.numpac               =c.numpac
      AND b.paiezad              =c.paiezad
      AND c.code_element         ='B691'
      AND is_number(b.indicatif) =is_number(c.indicatif)
      AND ERREURs               IS NULL
      )
    );
  -- Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE
  req      :='insert into DIC_TGE_IMPUTATIONS_PERM p(numpac,paiezad,MATRIC,pacmat';
  reqInsert:='select numpac,paiezad,MATRICULE,pacmat,';
  reqvalues:= ' from (select numpac,paiezad,MATRICULE,pacmat,code_element||''#''||indicatif as el, valeur';
  reqvalues:= reqvalues|| ' from TGE_IMPORT_ELEMENTS b where login='''||p_login||''' and date_import='''||P_DATE_IMPORT||''' 
and code_element in (''B690'',''B691'')  and  exists (select * from TGE_IMPORT_ELEMENTS c where b.login=c.login and b.date_import=c.date_import and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B690''  and b.indicatif   =c.indicatif and ERREURs is  null) 
and  exists (select * from TGE_IMPORT_ELEMENTS c where b.login=c.login and b.date_import=c.date_import and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B691''  and  b.indicatif   =c.indicatif and ERREURs is  null) ';
  reqvalues:= reqvalues|| ' ) pivot (max(valeur)   for(el) in (';
  FOR cur IN
  (SELECT ELEMENT,
    occurence,
    DOnneegxp,
    tablegxp
  FROM tge_ref_mapdo
  WHERE element IN ('B690','B691')
  AND numpac     =p_numpac
  UNION
  SELECT ELEMENT,
    occurence,
    DOnneegxp,
    tablegxp
  FROM tge_ref_mapdo
  WHERE element IN ('B690','B691')
  AND numpac     ='*'
  )
  LOOP
    req           :=req||','||cur.DONNEEGXP;
    reqvalues     := reqvalues||''''||cur.element||'#'||cur.occurence ||''' as '|| cur.DONNEEGXP||',';
    IF cur.element ='B690' THEN
      reqInsert   := reqInsert||cur.DONNEEGXP ||',';
    ELSE
      reqInsert:= reqInsert||' IS_NUMBER(replace('||cur.DONNEEGXP ||','','',''.'')) as '||cur.DONNEEGXP ||' ,';
    END IF;
  END LOOP;
  reqvalues:= SUBSTR(reqvalues,1,LENGTH(reqvalues)-1)||'))  ';
  reqInsert:= SUBSTR(reqInsert,1,LENGTH(reqInsert)-1);
  req      :=req||')  ';
  req      :=req||reqInsert|| reqvalues;
  EXECUTE_IMMEDIATE_STRING( req,0);
END TGE_IMPORT_IMPUTATION;
##
TGE_INSERT_RELIQ
=SQL=
CREATE OR REPLACE PROCEDURE TGE_INSERT_RELIQ (P_ID IN NUMBER,P_NUMPAC IN VARCHAR2 , P_PERIODE IN VARCHAR2 ,is_RETRO NUMBER) AS 
/********************************************************************************
Version     : V5.05.000
*********************************************************************************/
BEGIN
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_INSERT_RELIQ (Begin)','Début insertion pour le numpac : '||P_NUMPAC);
  
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_RELIQ_INCIDENTS_PAIE','Insertion dans TGE_RELIQ_INCIDENTS_PAIE à la période '|| P_PERIODE ||' et pour le numpac '|| P_NUMPAC);
  INSERT INTO TGE_RELIQ_INCIDENTS_PAIE 
  (ID,NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,TYPE_IP,CODE_IP,DATE_EFFET,CODE_IMPUTATION,HEURES,
   ORIGINE,LOGIN_CREATE,DATE_CREATE,ROLE_CREATE,ORIGINE_CREATE,LOGIN_MAJ,DATE_MAJ,ROLE_MAJ,ORIGINE_MAJ,
   CLE_IMPORT,CLE_ABSENCE,IDPACMAT,ENVOYE,TYPE_WRITER,JOUR_OUVRABLE,JOUR_OUVRE,JOUR_OEUVRE,JOUR_CALENDAIRE)
  select ID,NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,TYPE_IP,CODE_IP,DATE_EFFET,CODE_IMPUTATION,HEURES,
         ORIGINE,LOGIN_CREATE,DATE_CREATE,ROLE_CREATE,ORIGINE_CREATE,LOGIN_MAJ,DATE_MAJ,ROLE_MAJ,ORIGINE_MAJ,
         CLE_IMPORT,CLE_ABSENCE,IDPACMAT,ENVOYE,TYPE_WRITER,JOUR_OUVRABLE,JOUR_OUVRE,JOUR_OEUVRE,JOUR_CALENDAIRE
  FROM TGE_INCIDENTS_PAIE
  WHERE NUMPAC = P_NUMPAC 
  AND   to_date(periode) <= to_date(P_PERIODE,'yyyymm')
  AND nvl(ACTION_RETRO,'H') != 'H';
  
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_RELIQ_DONNEES_PAIE','Insertion dans  TGE_RELIQ_DONNEES_PAIE à la période '|| P_PERIODE ||' et pour le numpac '|| P_NUMPAC);
  INSERT INTO TGE_RELIQ_DONNEES_PAIE 
  (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,TYPE_DONNEE,CODE_RUBRIQUE,CODE_CAISSE,NO_SEQUENCE,SENS,CODE_IMPUTATION,
   ORIGINE,NOMBRE,TAUX,MONTANT,POURCENTAGE,DOMAINE_PRCTE,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,CLE_IMPORT,IDPACMAT,
   PERIODE_RATTACH_DEB,PERIODE_RATTACH_FIN,DATE_DEB_ARRET,TYPE_WRITER,PERIODE_AFFECTATION,CODE_REMPLACEMENT)
   
  select NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,TYPE_DONNEE,CODE_RUBRIQUE,CODE_CAISSE,NO_SEQUENCE,SENS,CODE_IMPUTATION,
         ORIGINE,NOMBRE,TAUX,MONTANT,POURCENTAGE,DOMAINE_PRCTE,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,CLE_IMPORT,IDPACMAT,
         PERIODE_RATTACH_DEB,PERIODE_RATTACH_FIN,DATE_DEB_ARRET,TYPE_WRITER,PERIODE_AFFECTATION,CODE_REMPLACEMENT
  FROM TGE_DONNEES_PAIE
  WHERE NUMPAC = P_NUMPAC 
  AND   periode  <=P_PERIODE
  AND nvl(ACTION_RETRO,'H') != 'H';
  
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_RELIQ_ELEMENTS_PAIE','Insertion dans  TGE_RELIQ_ELEMENTS_PAIE à la période '|| P_PERIODE ||' et pour le numpac '|| P_NUMPAC);
  INSERT INTO TGE_RELIQ_ELEMENTS_PAIE 
  (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,CODE_ELEMENT,INDICATIF,ORIGINE,SENS,VALEUR,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,CLE_IMPORT,IDPACMAT,TYPE_WRITER,CODE_REMPLACEMENT)
  select NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,CODE_ELEMENT,INDICATIF,ORIGINE,SENS,VALEUR,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,CLE_IMPORT,IDPACMAT,TYPE_WRITER,CODE_REMPLACEMENT
  FROM TGE_ELEMENTS_PAIE
  WHERE NUMPAC = P_NUMPAC 
  AND   periode  <=P_PERIODE
  AND nvl(ACTION_RETRO,'H') != 'H';
  
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_RELIQ_IMPUTATIONS','Insertion dans  TGE_RELIQ_IMPUTATIONS à la période '|| P_PERIODE ||' et pour le numpac '|| P_NUMPAC);
  INSERT INTO TGE_RELIQ_IMPUTATIONS 
  (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,IMPUTATION,NO_SEQUENCE,ORIGINE,NB_UNITE,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,IDPACMAT,TYPE_WRITER)
  select NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,IMPUTATION,NO_SEQUENCE,ORIGINE,NB_UNITE,DERNIER_CODE_OPE,LOGIN_MAJ,DATE_MAJ,IDPACMAT,TYPE_WRITER
  FROM TGE_IMPUTATIONS
  WHERE NUMPAC = P_NUMPAC 
  AND   periode  <=P_PERIODE;
  
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_RELIQ_PACMAT_TORESEND','Insertion dans  TGE_RELIQ_PACMAT_TORESEND à la période '|| P_PERIODE ||' et pour le numpac '|| P_NUMPAC);
  --tge_podif_pamat -retro des mal recycle 
  INSERT INTO TGE_RELIQ_PACMAT_TORESEND 
  (NUMPAC,PACMAT,TABLE_TO_SEND,DATE_MAJ)
  select  NUMPAC,PACMAT,TABLE_TO_SEND,DATE_MAJ
  FROM TGE_MODIF_PACMAT_TORESEND
  WHERE NUMPAC = P_NUMPAC ;
  IF is_RETRO =1 THEN 
  INSERT INTO TGE_RELIQ_PACMAT_TORESEND_RETRO
  WITH LISTE_DICOZ (element) AS ( select element from tge_ref_dicoz where numpac =P_NUMPAC and calcul_RETRO=1),
  LIST_TABLEGXP (tablegxp) as (
  SELECT tablegxp  FROM TGE_REF_MAPDO mapdo ,LISTE_DICOZ dicoz WHERE NUMPAC =P_NUMPAC and mapdo.element =dicoz.element
  UNION ALL 
  SELECT tablegxp  FROM TGE_REF_MAPDO mapdo ,LISTE_DICOZ dicoz WHERE NUMPAC ='*' and mapdo.element =dicoz.element
  AND TABLEGXP not in( select TABLEGXP  from TGE_REF_MAPDO mapdo ,LISTE_DICOZ dicoz  WHERE NUMPAC =P_NUMPAC and mapdo.element =dicoz.element ))

   SELECT * FROM TGE_RELIQ_PACMAT_TORESEND WHERE NUMPAC = P_NUMPAC AND TABLE_TO_SEND IN (SELECT TABLEGXP FROM LIST_TABLEGXP);
  END IF;
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_INSERT_RELIQ (End)','Fin insertion pour le numpac : '||P_NUMPAC);
END TGE_INSERT_RELIQ;
 ##
TGE_PURGE_HISTO
=SQL=
create or replace PROCEDURE TGE_PURGE_HISTO(
  p_numpac                  IN VARCHAR2,
  p_periode_en_cours        IN VARCHAR2)
AS
  TYPE t_col_name           IS TABLE OF user_tab_cols.column_name%TYPE;
  l_col_date                t_col_name;                                 -- la liste des colonnes de type DATE
  v_periode                 tge_ref_pac.periodeencours%type;            -- la periode en cours utilisée par le DELETE
BEGIN 
  -- définir la période
  IF p_periode_en_cours IS NULL THEN
    SELECT periodeencours INTO v_periode FROM TGE_REF_PAC WHERE NUMPAC = p_numpac;
  ELSE
    v_periode := p_periode_en_cours;
  END IF;

  IF (v_periode IS NOT NULL) THEN
    -- table(s) à traiter
    FOR ligne IN (SELECT * FROM TGE_REF_MAPTA WHERE NUMPAC = p_numpac AND ALLERRETOUR IN ('R','2') AND TO_NUMBER(NVL(NBMOISCONS, '0')) > 0 
                  UNION ALL(SELECT * FROM TGE_REF_MAPTA a WHERE NUMPAC = '*'  AND ALLERRETOUR IN ('R','2') AND TO_NUMBER(NVL(NBMOISCONS, '0')) > 0 
                         AND NOT EXISTS (SELECT * FROM TGE_REF_MAPTA b WHERE p_numpac = b.NUMPAC AND a.TABLEPARAM = b.TABLEPARAM))) 
    LOOP
      -- colonne(s) date(s)
      EXECUTE IMMEDIATE 'SELECT tc.column_name FROM user_constraints c, user_cons_columns cc, user_tab_cols tc WHERE c.constraint_name = cc.constraint_name ' ||
                        'AND c.table_name = cc.table_name AND cc.table_name = tc.table_name AND cc.column_name = tc.column_name AND c.constraint_type =''P'' ' ||
                        'AND tc.data_type = ''DATE'' AND c.table_name = ''' || ligne.tablephy || '''' BULK COLLECT INTO l_col_date;
      -- vérifier qu'il n'y a qu'une seul colonne de récupérée, si ce n'est pas le cas ne pas faire la purge
      IF (l_col_date IS NOT NULL AND l_col_date.COUNT = 1) THEN
        EXECUTE IMMEDIATE 'DELETE FROM ' || ligne.tablephy || ' WHERE NUMPAC = :1 AND ' || l_col_date(1) || ' < ADD_MONTHS(TO_DATE(:2, ''yyyymm''), :3)' USING p_numpac, v_periode, -ligne.nbmoiscons;
      END IF;
    END LOOP; 
  END IF;
EXCEPTION
WHEN OTHERS THEN
  raise_application_error(-20000, 'TGE_PURGE_HISTO(' || NVL(p_numpac, 'NULL') || ',' || NVL(p_periode_en_cours, 'NULL') || '). Cause: ' || SQLCODE || '-' || sqlerrm);
END TGE_PURGE_HISTO;
## 
TAG_CHARSET=@€éèç 
##
TGE_REGROUPE_ABS
=SQL=
CREATE OR REPLACE PROCEDURE TGE_REGROUPE_ABS(
    P_CLE_IMPORT IN VARCHAR2)
AS
BEGIN

	SYS_RECALCUL_STATS('TGE_ABSENCES');
	SYS_RECALCUL_STATS('TGE_INCIDENTS_PAIE');

  /*
  * Etape 1
  * Mise à jour des date de fin des absences pouvant être regroupé
  *
  */
  MERGE INTO TGE_ABSENCES USING
  (SELECT DISTINCT 
 	(SELECT MIN(CLE_ABSENCE) FROM TGE_INCIDENTS_PAIE INC2 WHERE INC2.NUMPAC = TB1.NUMPAC AND INC2.PAIEZAD = TB1.PAIEZAD AND INC2.DATE_EFFET = TB1.NEW_DATE_DEBUT AND INC2.ORIGINE = TB1.ORIGINE AND INC2.CODE_IP = TB1.CODE_IP and substr(REGEXP_REPLACE(INC2.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT) AS CLE_ABSENCE,
 	NEW_DATE_FIN,ORIGINE
 FROM (SELECT  NUMPAC,
    PAIEZAD,
    CODE_IP,
    MIN(d) NEW_DATE_DEBUT,
    MAX(d) NEW_DATE_FIN,
    ORIGINE
  FROM
    (SELECT INC.NUMPAC,
      INC.PAIEZAD,
      INC.CODE_IP,
      INC.ORIGINE ,
      INC.DATE_EFFET d,  
      ROW_NUMBER() OVER(ORDER BY INC.NUMPAC,INC.PAIEZAD,INC.CODE_IP, INC.ORIGINE, INC.DATE_EFFET) i
    FROM TGE_INCIDENTS_PAIE INC
    LEFT JOIN TGE_INCIDENTS_PAIE INCHP
    ON INC.NUMPAC      = INCHP.NUMPAC
    AND INC.PAIEZAD    = INCHP.PAIEZAD
    AND INC.DATE_EFFET = INCHP.DATE_EFFET
    AND INC.ORIGINE = INCHP.ORIGINE
    AND INC.ID        != INCHP.ID
    AND INCHP.CODE_IP  = 'HP'
	AND substr(REGEXP_REPLACE(INCHP.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT
    INNER JOIN TGE_REF_PRE PRE
    ON INC.NUMPAC   = PRE.NUMPAC
    AND INC.CODE_IP = PRE.CODE_INCIDENT
    WHERE 
    substr(REGEXP_REPLACE(INC.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT
    AND INC.CODE_IP     != 'HP'
    AND INC.CLE_ABSENCE IS NOT NULL
    AND (nvl(INC.HEURES,'0') = '0'
    OR (INC.HEURES      >= INCHP.HEURES)
    OR (PRE.UNITE        = 'J'
    AND INC.HEURES      >= 1))
    GROUP BY INC.NUMPAC,
      INC.PAIEZAD,
      INC.CODE_IP,
      INC.ORIGINE,
      INC.DATE_EFFET
    )
  GROUP BY NUMPAC,
    PAIEZAD,
    CODE_IP,
    ORIGINE	,
    (d-i)
   
  )TB1) TB ON (TGE_ABSENCES.ID = TB.CLE_ABSENCE and TGE_ABSENCES.ORIGINE = TB.ORIGINE)
WHEN MATCHED THEN
  UPDATE SET TGE_ABSENCES.DATE_FIN = TB.NEW_DATE_FIN;
  /*
  * Etape 2
  * Suppresion des absences pouvant être regroupé
  *
  */
 DELETE
 FROM TGE_ABSENCES
 WHERE
 substr(REGEXP_REPLACE(TGE_ABSENCES.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT
 AND exists
 (WITH inc_regroup as (
    SELECT
        inc.numpac,
        inc.paiezad,
        inc.code_ip,
        inc.date_effet d,
        inc.origine,
        inc.cle_absence,
        ROW_NUMBER() OVER(
            ORDER BY
                inc.numpac, inc.paiezad, inc.code_ip, inc.origine, inc.date_effet
        ) i
    FROM
        tge_incidents_paie   inc
        LEFT JOIN tge_incidents_paie   inchp ON inc.numpac = inchp.numpac
                                              AND inc.paiezad = inchp.paiezad
                                              AND inc.date_effet = inchp.date_effet
                                              AND inc.id != inchp.id
                                              AND inchp.code_ip = 'HP'
                                              AND substr(regexp_replace(inchp.cle_import, '#\d+$', ''
                                              ), 0, 80) = P_CLE_IMPORT
        INNER JOIN tge_ref_pre          pre ON inc.numpac = pre.numpac
                                      AND inc.code_ip = pre.code_incident
    WHERE
        substr(regexp_replace(inc.cle_import, '#\d+$', ''), 0, 80) = P_CLE_IMPORT
        AND inc.code_ip != 'HP'
        AND inc.cle_absence IS NOT NULL
        AND ( nvl(inc.heures, '0') = '0'
              OR ( inc.heures >= inchp.heures )
              OR ( pre.unite = 'J'
                   AND inc.heures >= 1 ) )
 )
 SELECT 1 from inc_regroup inc_source
 WHERE inc_source.cle_absence = TGE_ABSENCES.id
 AND NOT EXISTS (
 SELECT * from (
                SELECT
                    (
                        SELECT
                            MIN(cle_absence)
                        FROM
                            tge_incidents_paie inc2
                        WHERE
                            inc2.numpac = tb1.numpac
                            AND inc2.paiezad = tb1.paiezad
                            AND inc2.date_effet = tb1.new_date_debut
                            AND inc2.origine = tb1.origine
                            AND tb1.code_ip = inc2.code_ip
                            AND substr(regexp_replace(inc2.cle_import, '#\d+$', ''), 0, 80) = P_CLE_IMPORT
                    ) AS cle_absence
                FROM
                    (
                        SELECT
                            numpac,
                            paiezad,
                            code_ip,
                            MIN(d) new_date_debut,
                            origine
                        FROM
                            (
                                inc_regroup
                            )
                        GROUP BY
                            numpac,
                            paiezad,
                            code_ip,
                            ( d - i ),
                            origine
                    ) tb1)tb2 WHERE inc_source.cle_absence = tb2.cle_absence)
 );
  /*
  * Etape 3
  * Mise à jour des clé absences des incidents paie liée a des absences ayant été regroupé
  *
  */
  MERGE INTO TGE_INCIDENTS_PAIE USING
  (SELECT DISTINCT INC.ID AS ID,
    MIN(ABS.ID)       AS CLE
  FROM TGE_INCIDENTS_PAIE INC
  INNER JOIN DIC_ADM_CONTRAT_SITU S
  ON S.NUMPAC   = INC.NUMPAC
  AND S.PAIEZAD = INC.PAIEZAD
  AND INC.DATE_EFFET BETWEEN S.DSDSC AND S.DSFSC
  INNER JOIN TGE_ABSENCES ABS
  ON ABS.MATRIC   = S.MATRIC
  AND INC.CODE_IP = ABS.MOTIF
  AND INC.DATE_EFFET BETWEEN ABS.DATE_DEBUT AND ABS.DATE_FIN
  AND INC.ORIGINE = ABS.ORIGINE
  WHERE NOT EXISTS
    (SELECT 1 FROM TGE_ABSENCES WHERE ID = INC.CLE_ABSENCE
    )
  AND substr(REGEXP_REPLACE(INC.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT
  AND substr(REGEXP_REPLACE(ABS.CLE_IMPORT,'#\d+$',''),0,80) = P_CLE_IMPORT   
  AND INC.CLE_ABSENCE            IS NOT NULL
  GROUP BY INC.ID
  ) TB ON ( TGE_INCIDENTS_PAIE.ID = TB.ID)
WHEN MATCHED THEN
  UPDATE SET TGE_INCIDENTS_PAIE.CLE_ABSENCE = TB.CLE;
END TGE_REGROUPE_ABS;
##
TAG_CHARSET=@€éèç
##
TGE_RETRO_INSCRIPTION
=SQL=
CREATE OR REPLACE PROCEDURE TGE_RETRO_INSCRIPTION(
  P_NUMPAC IN VARCHAR2,
  P_PACMAT IN VARCHAR2,
  P_PERIODE_RETRO IN VARCHAR2,
  P_CODE_CHRONO IN VARCHAR2,
  P_PAIEZAD IN VARCHAR2,
  P_TABLE_MAJ IN VARCHAR2)
AS
  V_EXIST_TGE_MODIF_PACMAT_RETRO NUMBER;
  V_GAP_RETRO_MATRIC_UPDATE      NUMBER;
  V_PERIODE_RETRO_A_INSERE       VARCHAR2(20);
  V_DATE_LIMITE_RETRO            VARCHAR2(20);
  V_PERIODEENCOURS               VARCHAR2(6);
BEGIN
  V_PERIODE_RETRO_A_INSERE := P_PERIODE_RETRO;
  SELECT PERIODEENCOURS, GREATEST(DEB_HISTO_RETRO, TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS, 'YYYYMM'), -NB_MOIS_RETRO), 'YYYYMM'),NVL( PREMIERE_PAIE, '190101')) 
  INTO V_PERIODEENCOURS, V_DATE_LIMITE_RETRO
  FROM TGE_REF_PAC T
  LEFT JOIN SECUPACMAT S ON S.NUMPAC=T.NUMPAC AND S.PACMAT = P_PACMAT
  WHERE DEB_HISTO_RETRO IS NOT NULL 
  AND NB_MOIS_RETRO IS NOT NULL 
  AND T.NUMPAC = P_NUMPAC;
  IF (P_PERIODE_RETRO<V_DATE_LIMITE_RETRO) THEN
  V_PERIODE_RETRO_A_INSERE := V_DATE_LIMITE_RETRO;
  END IF;
  IF (V_PERIODE_RETRO_A_INSERE>= V_PERIODEENCOURS) THEN
  RETURN;
  END IF;
  SELECT COUNT(*)
  INTO V_EXIST_TGE_MODIF_PACMAT_RETRO
  FROM TGE_MODIF_PACMAT_RETRO
  WHERE NUMPAC      = P_NUMPAC
  AND PACMAT        = P_PACMAT
  AND TABLE_MAJ    	= P_TABLE_MAJ
  AND PERIODE_RETRO = V_PERIODE_RETRO_A_INSERE;
  IF (V_EXIST_TGE_MODIF_PACMAT_RETRO=0) THEN
    -- S'il n'y a pas encore de ligne dans TGE_MODIF_PACMAT_RETRO pour le NUMPAC / PACMAT / PERIODE_RETRO, on insère
    INSERT INTO TGE_MODIF_PACMAT_RETRO VALUES (
      P_NUMPAC,
      P_PACMAT,
      V_PERIODE_RETRO_A_INSERE,
      P_TABLE_MAJ,
      SYSDATE
    );
  END IF;
  SELECT COUNT(*)
  INTO V_GAP_RETRO_MATRIC_UPDATE
  FROM GAP_RETRO_MATRIC 
  WHERE NUMPAC        = P_NUMPAC
  AND PACMAT          = P_PACMAT
  AND PERIODE_RETRO   = V_PERIODE_RETRO_A_INSERE
  AND MIN_CODE_CHRONO < P_CODE_CHRONO;
  IF(V_GAP_RETRO_MATRIC_UPDATE=0) THEN
    -- S'il n'y a pas de ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, et avec un CODE_CHRONO > au CODE_CHRONO qui a été modifié, on met à jour
    SELECT COUNT(*)
    INTO V_GAP_RETRO_MATRIC_UPDATE
    FROM GAP_RETRO_MATRIC 
    WHERE NUMPAC      = P_NUMPAC
    AND PACMAT        = P_PACMAT
    AND PERIODE_RETRO = V_PERIODE_RETRO_A_INSERE;
    IF(V_GAP_RETRO_MATRIC_UPDATE=0) THEN
      -- S'il n'y a pas encore de ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, on insère
      INSERT INTO GAP_RETRO_MATRIC VALUES (
        P_NUMPAC,
        P_PACMAT,
        V_PERIODE_RETRO_A_INSERE,
        P_CODE_CHRONO,
        P_PAIEZAD
      );
    ELSE
      -- S'il y a déjà une ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, on met à jour
      UPDATE GAP_RETRO_MATRIC SET 
        MIN_CODE_CHRONO = P_CODE_CHRONO,
        PAIEZAD_RETRO   = P_PAIEZAD
      WHERE MIN_CODE_CHRONO > P_CODE_CHRONO
      AND NUMPAC            = P_NUMPAC
      AND PACMAT            = P_PACMAT
      AND PERIODE_RETRO     = V_PERIODE_RETRO_A_INSERE;
    END IF;
  END IF;
END TGE_RETRO_INSCRIPTION;
##
TGE_RETRO_INSCRIPTION_RELIQ
=SQL=
CREATE OR REPLACE PROCEDURE TGE_RETRO_INSCRIPTION_RELIQ (P_ID IN NUMBER,P_NUMPAC IN VARCHAR2 , P_PERIODE IN VARCHAR2 ) AS 
/********************************************************************************
Version     : V5.05.04
*********************************************************************************/
BEGIN


  FSED.FSED_AVANCEMENT_PLSQL(p_id,'tge_retro_inscription_reliq (Begin)','Début inscription retro des reliq pour le numpac: '||P_NUMPAC);
  
  FOR C IN
 (select numpac,pacmat,periode,min(code_chrono)as CODE_CHRONO ,paiezad,table_maj from 
(
with table_chrono (numpac,pacmat,paiezad, code_chrono,DSDSC,DSFSC) as 
(select numpac,pacmat,paiezad, code_chrono,DSDSC,DSFSC from DIC_ADM_CONTRAT_SITU dacs where numpac=P_NUMPAC)

select tge.numpac,substr(tge.idpacmat,7,length(tge.idpacmat)) as pacmat,tge.periode as periode ,dacs.code_chrono, tge.paiezad ,'TGE_DONNEES_PAIE' as table_maj from TGE_RELIQ_DONNEES_PAIE tge ,table_chrono dacs 
where tge.numpac=P_NUMPAC and tge.numpac=dacs.numpac and  tge.paiezad=dacs.paiezad and substr(tge.idpacmat,7,length(tge.idpacmat))= dacs.pacmat 
and TO_DATE(tge.periode,'YYYYMM') BETWEEN  TRUNC(dacs.DSDSC,'MONTH') AND dacs.DSFSC
union all 
select tge.numpac,substr(tge.idpacmat,7,length(tge.idpacmat))as pacmat,tge.periode as periode,dacs.code_chrono, tge.paiezad ,'TGE_ELEMENTS_PAIE' as table_maj from TGE_RELIQ_ELEMENTS_PAIE  tge ,table_chrono dacs 
where tge.numpac=P_NUMPAC and tge.numpac=dacs.numpac and  tge.paiezad=dacs.paiezad and substr(tge.idpacmat,7,length(tge.idpacmat))= dacs.pacmat 
and TO_DATE(tge.periode,'YYYYMM') BETWEEN  TRUNC(dacs.DSDSC,'MONTH') AND dacs.DSFSC
union all 
select tge.numpac,substr(tge.idpacmat,7,length(tge.idpacmat))as pacmat,to_char(tge.periode,'YYYYMM')as periode,dacs.code_chrono, tge.paiezad ,'TGE_INCIDENTS_PAIE' as table_maj from TGE_RELIQ_INCIDENTS_PAIE  tge ,table_chrono dacs 
where tge.numpac=P_NUMPAC and tge.numpac=dacs.numpac and  tge.paiezad=dacs.paiezad and substr(tge.idpacmat,7,length(tge.idpacmat))= dacs.pacmat 
and to_date(tge.periode) BETWEEN  TRUNC(dacs.DSDSC,'MONTH') AND dacs.DSFSC
union all
select tge.numpac,tge.pacmat as pacmat ,P_PERIODE as periode,dacs.code_chrono, dacs.paiezad,tge.table_to_send  as table_maj from TGE_RELIQ_PACMAT_TORESEND_RETRO tge,table_chrono dacs 
where tge.numpac=P_NUMPAC and tge.numpac=dacs.numpac  and tge.pacmat= dacs.pacmat 
and to_date(P_PERIODE,'YYYYMM') BETWEEN  TRUNC(dacs.DSDSC,'MONTH') AND dacs.DSFSC)
group by numpac,pacmat,periode,paiezad,table_maj
 )
 LOOP
   TGE_RETRO_INSCRIPTION(C.NUMPAC, C.PACMAT,C.periode, C.CODE_CHRONO, C.PAIEZAD, C.table_maj); 
 END LOOP;
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'tge_retro_inscription_reliq (End)','Fin inscription retro des reliq pour le numpac : '||P_NUMPAC);
END TGE_RETRO_INSCRIPTION_RELIQ;
##
TAG_CHARSET=@€éèç
##
TGE_RETRO_INSCRIPT_WITH_CHECK
=SQL=
CREATE OR REPLACE PROCEDURE TGE_RETRO_INSCRIPT_WITH_CHECK(
  P_NUMPAC IN VARCHAR2, 
  P_PACMAT IN VARCHAR2, 
  P_PERIODE_YYYYMM IN VARCHAR2, 
  P_CODE_CHRONO IN VARCHAR2, 
  P_PAIEZAD IN VARCHAR2, 
  P_TABLE_MAJ IN VARCHAR2, 
  P_REQ_COUNT_CHECK_SPECIF IN VARCHAR2 DEFAULT NULL) 
AS
  V_PERIODEENCOURS     VARCHAR2(6);
  V_DEB_RETRO          VARCHAR2(6);
  V_DEB_HISTO_RETRO    VARCHAR2(6);
  V_NB_MOIS_RETRO      NUMBER;
  V_COUNT_CHECK_SPECIF NUMBER;
BEGIN
  BEGIN
    SELECT T.PERIODEENCOURS,
      T.DEB_RETRO,
      GREATEST(DEB_HISTO_RETRO,NVL( PREMIERE_PAIE, '190101')),
      nvl(T.NB_MOIS_RETRO,0)
    INTO V_PERIODEENCOURS,
      V_DEB_RETRO,
      V_DEB_HISTO_RETRO,
      V_NB_MOIS_RETRO
    FROM TGE_REF_PAC T
    LEFT JOIN SECUPACMAT S ON S.NUMPAC=T.NUMPAC AND S.PACMAT = P_PACMAT
    WHERE T.NUMPAC = P_NUMPAC;
  END;
  IF(V_PERIODEENCOURS >= V_DEB_RETRO AND V_DEB_RETRO IS NOT NULL) THEN
    BEGIN
      V_COUNT_CHECK_SPECIF := 1;
      IF P_REQ_COUNT_CHECK_SPECIF IS NOT NULL THEN
        EXECUTE IMMEDIATE P_REQ_COUNT_CHECK_SPECIF INTO V_COUNT_CHECK_SPECIF;
      END IF;
      IF(P_PERIODE_YYYYMM  < V_PERIODEENCOURS AND V_COUNT_CHECK_SPECIF > 0)THEN
        IF(TO_DATE(P_PERIODE_YYYYMM ,'YYYYMM') < ADD_MONTHS(TO_DATE(V_PERIODEENCOURS,'YYYYMM'),-V_NB_MOIS_RETRO)) THEN
          --La période de rétroactivité maximum est dépassée
          RAISE_APPLICATION_ERROR(-20001, 'CODERR=TGERET01');
        ELSIF (P_PERIODE_YYYYMM < V_DEB_HISTO_RETRO AND V_DEB_HISTO_RETRO IS NOT NULL) THEN
          --La rétroactivité est impossible avant la période de début de conservation des historiques
          RAISE_APPLICATION_ERROR(-20001, 'CODERR=TGERET02');
        ELSE
          TGE_RETRO_INSCRIPTION(P_NUMPAC,
            P_PACMAT,
            P_PERIODE_YYYYMM,
            P_CODE_CHRONO,
            P_PAIEZAD,
            P_TABLE_MAJ);
        END IF;
      END IF;
    END;
  END IF;
END TGE_RETRO_INSCRIPT_WITH_CHECK;
##
TGE_SEQ_NUM_ECHANGE_UP
=SQL=
CREATE OR REPLACE
PROCEDURE TGE_SEQ_NUM_ECHANGE_UP(
    p_NUMPAC         IN VARCHAR2 ,
    p_PERIODEENCOURS IN VARCHAR2 ,
    num_echange_str OUT VARCHAR2 )
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
  num_echange NUMBER;
BEGIN
  SELECT DERNIER_NUM_ECHANGE
  INTO num_echange
  FROM TGE_REF_PER
  WHERE numpac      =p_NUMPAC
  AND PERIODEENCOURS=p_PERIODEENCOURS FOR UPDATE ;
  IF num_echange   IS NULL OR num_echange=9999 THEN
    num_echange    :=0;
  END IF;
  num_echange    :=num_echange+1;
  num_echange_str:=LPAD(TO_CHAR(num_echange),4,'0');
  UPDATE TGE_REF_PER
  SET DERNIER_NUM_ECHANGE=num_echange_str
  WHERE numpac           =p_NUMPAC
  AND PERIODEENCOURS     =p_PERIODEENCOURS;
  COMMIT;
END TGE_SEQ_NUM_ECHANGE_UP;
##
TRACE_DBMS_OUTPUT
=SQL=
CREATE OR REPLACE PROCEDURE trace_dbms_output(
  p_call_name  IN VARCHAR2, -- nom de la procédure/fonction
  p_output_msg IN VARCHAR2) -- le message à sauver
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
  v_debug_mode BOOLEAN:=FALSE; -- ON / OFF sur l'activation du traçage
BEGIN
  IF (v_debug_mode = TRUE) THEN
    -- sauver le message dans la table TRACE_DBMS_OUTPUT_PUT_LINE
    INSERT INTO trace_dbms_output_put_line(date_trace, call_name, output_msg)
     VALUES (CURRENT_TIMESTAMP, p_call_name, p_output_msg); COMMIT;
  END IF;
EXCEPTION WHEN OTHERS THEN
  raise_application_error(-20000, 'TRACE_DBMS_OUTPUT(' || p_call_name || ', ' || p_output_msg || '). Cause: ' || SQLCODE || '-' || sqlerrm);
END trace_dbms_output;
##
TRANSFERT_DOSSIER_DBLINK
=SQL=
create or replace PROCEDURE TRANSFERT_DOSSIER_DBLINK (DbLinkSource VARCHAR2,dernierMoisPaieOnly varchar2) AS
 v_requete CLOB; 
 v_requeteTempo CLOB;
 v_requeteTempoSelect CLOB;
 v_requeteInsert CLOB; 
 v_requeteSelect CLOB;
 v_requeteDelete CLOB;
 v_requeteDeleteSuppl CLOB;
 v_nbColonneKO number;
 v_nbMAPTA number;
 v_nbColonneFormatKO number;
 v_aliasDBlink varchar2(6);
 v_colonneDTDEBHist varchar2(50);
 v_cleMatric varchar2(1);
 v_cleNumpacPacmat varchar2(1);
 v_cleNumpacPaiezad varchar2(1);
 v_moisPaie varchar2(10);
 TYPE TcolonneList is table of varchar2(30);
 v_colonneKO TcolonneList;
 v_colonneTable TcolonneList;
 v_colonnePK TcolonneList;
 DbLinkCible varchar2(30);
 DbLinkCibleBis varchar2(30);
 v_nbMatricToTransf number;
 
 CURSOR c_triggers IS SELECT object_name FROM user_objects WHERE lower(object_type)='trigger' and (lower(object_name) like 'horo%' or lower(object_name) like 'crf%' or lower(object_name) like 'trg_sec%' or lower(object_name) like 'trg_dic%'); nom_obj VARCHAR(500);
 CURSOR c_triggers_crf IS SELECT object_name FROM user_objects WHERE lower(object_type)='trigger' and (lower(object_name) like 'crf%'); nom_obj_crf VARCHAR(500);
 BEGIN
 v_requete := 'select sys_context( ''userenv'', ''current_schema'' ) from dual';
 EXECUTE IMMEDIATE v_requete into DbLinkCible;
 
 v_requete := 'TRUNCATE TABLE DBL_TRANSFERT_DOSSIER_LOG';
  EXECUTE_IMMEDIATE_STRING ( v_requete,0);
 
 v_requete := 'SELECT COUNT(*) from DIC_DBL_TRANSDOSS_MATRIC';
 EXECUTE IMMEDIATE v_requete into v_nbMatricToTransf;
 -- Cette procédure a pour but de transférer les matricules provenant d'une base source via DbLink
 -- La liste des matricules à transférer est dans la table DIC_DBL_TRANSDOSS_MATRIC
 -- La liste des tables à transférer est dans la table DIC_DBL_TRANSDOSS_TABLE
 -- Le suivi de la procédure se trouve dans la table DBL_TRANSFERT_DOSSIER_LOG
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Début du transfert des dossiers à partir de '|| DbLinkSource );
 select count(*) into v_nbMAPTA from DIC_DBL_TRANSDOSS_TABLE, tge_ref_mapta where tge_ref_mapta.tableparam = dic_dbl_transdoss_table.transdoss_nom_table and dic_dbl_transdoss_table.transdoss_actif = 'O' and tge_ref_mapta.allerretour in ('A','2');
 if v_nbMatricToTransf > '50' and v_nbMAPTA > 0 THEN
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Désactivation des triggers');
 -- on désactive les triggers avant le transfert
 FOR curs_trigger IN c_triggers
 LOOP
 nom_obj:=curs_trigger.object_name;
  EXECUTE_IMMEDIATE_STRING  ('ALTER TRIGGER ' || nom_obj ||' DISABLE ',0);
 END LOOP;
 ELSE
 -- on désactive les triggers avant le transfert
 FOR curs_trigger IN c_triggers_crf
 LOOP
 nom_obj:=curs_trigger.object_name;
  EXECUTE_IMMEDIATE_STRING  ('ALTER TRIGGER ' || nom_obj ||' DISABLE ',0);
 END LOOP;
 END IF;
 -- on récupère les tables à transférer
 FOR uneTableATranferer IN (SELECT TRANSDOSS_NOM_TABLE from DIC_DBL_TRANSDOSS_TABLE where TRANSDOSS_ACTIF = 'O')
 LOOP
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Traitement table ' || uneTableATranferer.TRANSDOSS_NOM_TABLE);
 -- On contrôle que la table peut être transférée sans erreurs, toutes les colonnes existantes sur la base cible doivent exister dans la source
 v_requete := 'select count(column_name) from all_tab_columns@' || DbLinkSource || ' where owner = upper(''' || DbLinkSource || ''') and table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''') and column_name not in (select column_name from user_tab_columns where table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || '''))';
 EXECUTE IMMEDIATE v_requete into v_nbColonneKO;
 
 -- ETAPE I : Contrôle des colonne des tables
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 -- Si une colonne est manquante dans la source
 IF v_nbColonneKO > 0 THEN
 v_requete := 'select column_name from all_tab_columns@' || DbLinkSource || ' where owner = upper(''' || DbLinkSource || ''') and table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''') and column_name not in (select column_name from user_tab_columns where table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || '''))';
 EXECUTE IMMEDIATE v_requete BULK COLLECT into v_colonneKO ;
 FOR i IN 1 .. v_colonneKO.COUNT
 LOOP
 -- On indique la colonne ko dans la table de log
 insert into DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate,'Attention !!, pour la table  ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ', la colonne ' || v_colonneKO(i) || ' n''existe pas dans la base mais existe dans ' || DbLinkSource || ' cette colonne n''est donc pas transférée');
 END LOOP;
 END IF;
 -- si pas de colonnes manquantes, on contrôle que les colonnes ont bien le même format entre la source uneTableATranferer.TRANSDOSS_NOM_TABLE la cible
 v_requete :=  'select count(column_name) from user_tab_columns cible where table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''') and column_name in (select dblink.column_name from all_tab_columns@' || DbLinkSource || ' dblink where dblink.owner = upper(''' || DbLinkSource || ''') and dblink.table_name = cible.table_name and dblink.column_name = cible.column_name and
 (dblink.data_type <> cible.data_type or (dblink.data_type = cible.data_type and dblink.data_length > cible.data_length)
 or (dblink.data_type = cible.data_type and dblink.data_type = ''NUMBER'' and (nvl(dblink.data_precision,''99'') > nvl(cible.data_precision,''99'') or nvl(dblink.data_scale,''99'') > nvl(cible.data_scale,''99'')))))';
 EXECUTE IMMEDIATE v_requete into v_nbColonneFormatKO;
 -- Si une colonne n'est pas au même format dans la source
 IF v_nbColonneFormatKO > 0 THEN
 v_requete :=  'select column_name from user_tab_columns cible where table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''') and column_name in (select dblink.column_name from all_tab_columns@' || DbLinkSource || ' dblink where dblink.owner = upper(''' || DbLinkSource || ''') and dblink.table_name = cible.table_name and dblink.column_name = cible.column_name and
 (dblink.data_type <> cible.data_type or (dblink.data_type = cible.data_type and dblink.data_length > cible.data_length)
 or (dblink.data_type = cible.data_type and dblink.data_type = ''NUMBER'' and (nvl(dblink.data_precision,''99'') > nvl(cible.data_precision,''99'') or nvl(dblink.data_scale,''99'') > nvl(cible.data_scale,''99'')))))';
 
 EXECUTE IMMEDIATE v_requete BULK COLLECT into v_colonneKO ;
 FOR i IN 1 .. v_colonneKO.COUNT
 LOOP
 -- On indique la colonne ko dans la table de log
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Attention !!, pour la table  ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ', la colonne ' || v_colonneKO(i) || ' a un format différent avec ' || DbLinkSource);
 END LOOP;
 END IF;
 
 -- ETAPE II : Transfert de table
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Préparation requête de la table ' || uneTableATranferer.TRANSDOSS_NOM_TABLE);
 -- EVOL 07/03/2017 on utilise maintenant des temporary tables pour améliorer les perfs
 begin
  EXECUTE_IMMEDIATE_STRING ( 'DROP TABLE TRANSFERT_DOSS_TMP ',0);
 EXCEPTION WHEN OTHERS THEN
 dbms_output.put_line ('Temporary inexistante ok TRANSFERT_DOSS_TMP');
 END;
 begin
 v_requeteTempo := 'CREATE GLOBAL TEMPORARY TABLE TRANSFERT_DOSS_TMP on commit delete rows as select * from ' || DbLinkSource || '.' || uneTableATranferer.TRANSDOSS_NOM_TABLE || '@' || DbLinkSource || ' where 0=1';
  EXECUTE_IMMEDIATE_STRING ( v_requeteTempo,0);
 EXCEPTION WHEN OTHERS THEN
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Temporary mal créée TRANSFERT_DOSS_TMP');
 dbms_output.put_line ('Temporary mal créée TRANSFERT_DOSS_TMP');
 END; 
 commit;
 -- on prépare la requête d'insert, sans idpacmat et avec transco du numpac
 -- insert into DIC_ENFANT@ZTGECARPRDFR01 () select * from dic_enfant;
 v_requete :=  'select s.column_name from all_tab_columns@' || DbLinkSource || ' s, all_tab_columns c  where s.owner = upper(''' || DbLinkSource || ''') and  s.table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''') and s.column_name not in (select column_name from all_tab_cols where owner = (select sys_context(''USERENV'',''SESSION_SCHEMA'') from dual) and virtual_column = ''YES'' and table_name = upper(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''')) and c.owner = upper(''' || DbLinkCible || ''') and c.table_name = s.table_name and c.column_name = s.column_name ';
 
 EXECUTE IMMEDIATE v_requete BULK COLLECT into v_colonneTable;
 v_requeteTempo := 'INSERT INTO TRANSFERT_DOSS_TMP (';
 v_requeteTempoSelect := 'SELECT ';
 v_requeteInsert := 'INSERT INTO ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || '(';
 v_requeteSelect := 'SELECT ';
 
 FOR i IN 1 .. v_colonneTable.COUNT
 LOOP
 -- Si c'est la dernière colonne de la table
 IF i = v_colonneTable.COUNT THEN
 v_requeteInsert := v_requeteInsert || v_colonneTable(i) || ') ';
 v_requeteTempo := v_requeteTempo || v_colonneTable(i) || ') ';
 v_requeteTempoSelect := v_requeteTempoSelect || v_colonneTable(i);
 IF v_colonneTable(i) IN ('NUMPAC','CURRENT_NUMPAC') THEN
 -- on fait la transco du pac
 v_requeteSelect := v_requeteSelect || '(select min(TRANSDOSS_PAC_CIBLE) from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_SOURCE = sel.' || v_colonneTable(i) || ')';
 ELSE
 v_requeteSelect := v_requeteSelect || CRF_TRANSFERT_CAST_COLUMN(DbLinkSource, uneTableATranferer.TRANSDOSS_NOM_TABLE, v_colonneTable(i));
 END IF;
 -- Sinon on boucle sur la liste des colonnes pour préaprer le insert select
 ELSE
 v_requeteInsert := v_requeteInsert || v_colonneTable(i) || ',';
 v_requeteTempo := v_requeteTempo || v_colonneTable(i) || ',';
 v_requeteTempoSelect := v_requeteTempoSelect || v_colonneTable(i) || ',';
 -- on fait la transco du pac
 IF v_colonneTable(i) IN ('NUMPAC','CURRENT_NUMPAC') THEN
 v_requeteSelect := v_requeteSelect || '(select min(TRANSDOSS_PAC_CIBLE) from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_SOURCE = sel.' || v_colonneTable(i) || ' ),';
 ELSE
 v_requeteSelect := v_requeteSelect || CRF_TRANSFERT_CAST_COLUMN(DbLinkSource, uneTableATranferer.TRANSDOSS_NOM_TABLE, v_colonneTable(i)) || ',';
 END IF;
 END IF;
 END LOOP;
 
 v_requeteInsert := v_requeteInsert || v_requeteSelect || ' FROM TRANSFERT_DOSS_TMP sel ';
 
 -- on prépare la clause where
 -- on récupère les clés primaires pour voir si on requête sur matric, ou numpac pacmat, ou numpac paiezad
 v_requete := 'SELECT cols.column_name FROM user_constraints cons, user_cons_columns cols WHERE cols.table_name = ''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''' AND cons.constraint_type = ''P'' AND cons.constraint_name = cols.constraint_name';
 EXECUTE IMMEDIATE v_requete BULK COLLECT into v_colonnePK;
 -- initialisation des flags
 v_cleMatric := 'N';
 v_cleNumpacPacmat := 'N';
 v_cleNumpacPaiezad := 'N';
 FOR i IN 1 .. v_colonnePK.COUNT
 LOOP
 -- Si une des colonnes clé est Matric alors c'est le matric la clé
 IF v_colonnePK(i) = 'MATRIC' THEN
 v_cleMatric := 'O';
 v_cleNumpacPacmat := 'N';
 v_cleNumpacPaiezad := 'N';
 END IF;
 -- Si une des colonnes clé est PACMAT alors c'est le numpac pacmat la clé
 IF v_colonnePK(i) = 'PACMAT' THEN
 v_cleMatric := 'N';
 v_cleNumpacPacmat := 'O';
 v_cleNumpacPaiezad := 'N';
 END IF;
 -- Si une des colonnes clé est PAIEZAD alors c'est le numpac paiezad la clé
 IF v_colonnePK(i) = 'PAIEZAD' AND uneTableATranferer.TRANSDOSS_NOM_TABLE <> 'DIC_ADM_CONTRAT_HISTO' THEN
 v_cleMatric := 'N';
 v_cleNumpacPacmat := 'N';
 v_cleNumpacPaiezad := 'O';
 END IF;
 END LOOP;
 
 -- En fonction de la clé, on construit la clause where et le delete pour faire l'annul et remplace
 IF v_cleMatric = 'O' THEN
 v_requeteDelete := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_MATRIC = sel.matric)';
 v_requeteInsert := v_requeteInsert || ' WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_MATRIC = sel.matric)';
 END IF;
 v_requeteDeleteSuppl := '';
 IF v_cleNumpacPacmat = 'O' THEN
 IF uneTableATranferer.TRANSDOSS_NOM_TABLE in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
	v_requeteDeleteSuppl := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_CIBLE = sel.numpac and a.TRANSDOSS_PACMAT = sel.pacmat)';
	IF uneTableATranferer.TRANSDOSS_NOM_TABLE = 'DIC_ADM_CONTRAT' THEN
		v_requeteDelete := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_MATRIC = sel.matric)';
	ELSE 
		v_requeteDelete := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE NOT EXISTS (select a.MATRIC from DIC_ADM_CONTRAT a where a.numpac = sel.numpac and a.pacmat = sel.pacmat and a.matric = sel.matric and a.numcnt = sel.numcnt) AND EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_CIBLE = sel.numpac and a.TRANSDOSS_PACMAT = sel.pacmat)';
	END IF;
	v_requeteInsert := v_requeteInsert || ' WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_SOURCE = sel.numpac and a.TRANSDOSS_PACMAT = sel.pacmat)';
 ELSE
	v_requeteDelete := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_CIBLE = sel.numpac and a.TRANSDOSS_PACMAT = sel.pacmat)';
	v_requeteInsert := v_requeteInsert || ' WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_SOURCE = sel.numpac and a.TRANSDOSS_PACMAT = sel.pacmat)';
 END IF;
 END IF;
 IF v_cleNumpacPaiezad = 'O' THEN
 v_requeteDelete := 'DELETE FROM ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' sel WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_CIBLE = sel.numpac and a.TRANSDOSS_PAIEZAD = sel.paiezad)';
 v_requeteInsert := v_requeteInsert || ' WHERE EXISTS (select TRANSDOSS_MATRIC from DIC_DBL_TRANSDOSS_MATRIC a where a.TRANSDOSS_PAC_SOURCE = sel.numpac and a.TRANSDOSS_PAIEZAD = sel.paiezad)';
 -- pour les tables de retour de paie, la clé est forcément paiezad, on peut ne transférer que le dernier mois de paie
 IF dernierMoisPaieOnly = 'O' and uneTableATranferer.TRANSDOSS_NOM_TABLE in ('DIC_TGE_RESPAIE_RUBRIQUE','DIC_TGE_RESPAIE_CUMCOT','DIC_TGE_RESPAIE_CUMCOTM','DIC_TGE_RESPAIE_HISTO','DIC_TGE_RESPAIE_JRSIND','DIC_TGE_RESPAIE_CUMASO','DIC_TGE_RESPAIE_CUMIPA','DIC_TGE_RESPAIE_CL_CONGE','DIC_TGE_RESPAIE_CL_HIST1') THEN
 v_requete := 'SELECT to_char(MAX(DTDEB_HISTO),''dd.mm.yyyy'') from ' || DbLinkSource || '.DIC_TGE_RESPAIE_HISTO@' || DbLinkSource || ' ';
 EXECUTE IMMEDIATE v_requete into v_moisPaie;
 v_requete := 'SELECT cols.column_name FROM user_constraints cons, user_cons_columns cols WHERE cols.table_name = ''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''' AND cons.constraint_type = ''P'' AND cons.constraint_name = cols.constraint_name and (cols.column_name like ''%DTDEB%'' OR cols.column_name like ''%PERIODEPAIE%'')';
 EXECUTE IMMEDIATE v_requete into v_colonneDTDEBHist;
 v_requeteDelete := v_requeteDelete || ' and ' || v_colonneDTDEBHist || ' = to_date(''' || v_moisPaie || ''',''dd.mm.yyyy'')';
 v_requeteInsert := v_requeteInsert || ' and ' || v_colonneDTDEBHist || ' = to_date(''' || v_moisPaie || ''',''dd.mm.yyyy'')';
 END IF;
 END IF;
 
 IF v_cleMatric <> 'O' and v_cleNumpacPacmat <> 'O' and v_cleNumpacPaiezad <> 'O' THEN
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'La table ' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ' n''a pas été traitée car elle ne contient ni matric, ou pacmat ou paiezad en clé');
 ELSE
 --dbms_output.put_line(v_requeteInsert);
 -- on insère ensuite dans la table définitive
  EXECUTE_IMMEDIATE_STRING  (v_requeteDelete,0);
 IF uneTableATranferer.TRANSDOSS_NOM_TABLE in ('DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
  EXECUTE_IMMEDIATE_STRING ( v_requeteDeleteSuppl,0);
 END IF;
 -- on fait un premier commit pour les rubriques après le delete
 IF uneTableATranferer.TRANSDOSS_NOM_TABLE = 'DIC_TGE_RESPAIE_RUBRIQUE' THEN
 commit;
 END IF;
  -- on remplie la table temporary 
 v_requeteTempo :=  v_requeteTempo || v_requeteTempoSelect || ' FROM ' || DbLinkSource || '.' || uneTableATranferer.TRANSDOSS_NOM_TABLE || '@' || DbLinkSource || '';
  EXECUTE_IMMEDIATE_STRING ( v_requeteTempo,0);
 
 EXECUTE_IMMEDIATE_STRING  (v_requeteInsert,0);
 -- si table DIC_ADM_PERSO, on purge melpro pour éviter les envois de mail en RC sauf si on est en prod
 v_requete := 'select count(*) from dual where sys_context( ''userenv'', ''current_schema'' ) like ''%PRD%'' ';
 EXECUTE IMMEDIATE v_requete into DbLinkCibleBis;
 IF uneTableATranferer.TRANSDOSS_NOM_TABLE = 'DIC_ADM_PERSO' and DbLinkCibleBis = 0 THEN
 	update dic_adm_perso set melpro = '';
 END IF;
 END IF;
 begin
  EXECUTE_IMMEDIATE_STRING  ('DROP TABLE TRANSFERT_DOSS_TMP ',0);
 EXCEPTION WHEN OTHERS THEN
 dbms_output.put_line ('Temporary inexistante ok TRANSFERT_DOSS_TMP');
 END;
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Fin du transfert de la table ' || uneTableATranferer.TRANSDOSS_NOM_TABLE);
 commit;
 END LOOP;
 if v_nbMatricToTransf > '50' THEN
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Réactivation des triggers');
 -- on active les triggers à la fin du transfert
 FOR curs_trigger IN c_triggers
 LOOP
 nom_obj:=curs_trigger.object_name;
  EXECUTE_IMMEDIATE_STRING ( 'ALTER TRIGGER ' || nom_obj ||' ENABLE ',0);
 END LOOP;
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Fin du traitement lancement du recalcul des stats');
 commit;
 FOR uneTableATranferer IN (SELECT TRANSDOSS_NOM_TABLE from DIC_DBL_TRANSDOSS_TABLE where TRANSDOSS_ACTIF = 'O')
 LOOP
 v_requete := 'CALL SYS_RECALCUL_STATS(''' || uneTableATranferer.TRANSDOSS_NOM_TABLE || ''')';
  EXECUTE_IMMEDIATE_STRING ( v_requete,0);
 END LOOP;
 INSERT INTO DBL_TRANSFERT_DOSSIER_LOG (DATE_EXEC,MESSAGE) values (sysdate, 'Fin du recalcul des stats');
 ELSE
 -- on active les triggers à la fin du transfert
 FOR curs_trigger IN c_triggers_crf
 LOOP
 nom_obj:=curs_trigger.object_name;
  EXECUTE_IMMEDIATE_STRING ( 'ALTER TRIGGER ' || nom_obj ||' ENABLE ',0);
 END LOOP;
 END IF;
 commit;
 end TRANSFERT_DOSSIER_DBLINK;
 ##
VERIF_MAJ_CAD_30
=SQL=
CREATE OR REPLACE PROCEDURE VERIF_MAJ_CAD_30 
(
  P_ID IN NUMBER 
, P_NUMPAC IN VARCHAR2 
) AS 
BEGIN

INSERT INTO TGE_MAJ_30_MATRIC_TEMPORARY
SELECT  matric
FROM DIC_ADM_CONTRAT_SITU
WHERE numpac =P_NUMPAC
AND paiezad IN
  (SELECT DISTINCT 
      imp.paiezad
    FROM
      (SELECT *
      FROM TGE_REF_MAPDO
      WHERE numpac= p_numpac
      AND TRTPARTICULIER LIKE 'CAD=%'
    UNION ALL
    SELECT *
    FROM TGE_REF_MAPDO
    WHERE numpac     ='*'
    AND ELEMENT NOT IN
      (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=p_numpac
      )
    AND TRTPARTICULIER LIKE 'CAD=%'
      ) DO ,
      tge_import_fsed_30 imp
    WHERE id_trt        = p_id
    AND imp.code_element= do.element);
COMMIT;
 
 
INSERT INTO TGE_MAJ_30_CPT_TEMPORARY
SELECT SUBSTR(SUBSTR(DO.TRTPARTICULIER,1,instr(DO.TRTPARTICULIER,',')-1), 
       instr(SUBSTR(DO.TRTPARTICULIER,1,instr(DO.TRTPARTICULIER,',')-1),'=')+1,
       LENGTH(SUBSTR(DO.TRTPARTICULIER,1,instr(DO.TRTPARTICULIER,',')-1)))
FROM
  (SELECT *
  FROM TGE_REF_MAPDO
  WHERE numpac= P_NUMPAC
  AND TRTPARTICULIER LIKE 'CAD=%'
  UNION ALL
  SELECT *
  FROM TGE_REF_MAPDO
  WHERE numpac     ='*'
  AND ELEMENT NOT IN
    (SELECT ELEMENT FROM TGE_REF_MAPDO WHERE numpac=P_NUMPAC
    )
  AND TRTPARTICULIER LIKE 'CAD=%'
  ) DO ,
  tge_import_fsed_30 imp
WHERE id_trt        = P_ID
AND imp.code_element= do.element ;
COMMIT;

END VERIF_MAJ_CAD_30;
##
HORO_DIC_ADM_CONTRAT_SITU
=SQL=
CREATE OR REPLACE TRIGGER HORO_DIC_ADM_CONTRAT_SITU BEFORE INSERT OR UPDATE ON DIC_ADM_CONTRAT_SITU FOR EACH ROW 
BEGIN 
  IF UPDATING AND NVL(:NEW.DATE_DERNIERE_MODIF,SYSDATE)=TO_DATE('19010101','yyyymmdd') THEN
    :NEW.DATE_DERNIERE_MODIF := :OLD.DATE_DERNIERE_MODIF;
  ELSE
    :NEW.DATE_DERNIERE_MODIF := SYSDATE;
  END IF;
  IF INSERTING THEN
    :NEW.DATE_CREATION := SYSDATE;
  END IF;
END;
##
TAG_CHARSET=@€éèç
##
ORG_CM_ENTITE_OPEN_TO_NIV
=SQL=
create or replace
TRIGGER "ORG_CM_ENTITE_OPEN_TO_NIV" AFTER INSERT OR UPDATE
ON STD_STRUC_ENTITE_OPEN FOR EACH ROW
declare 
-- trigger qui modifie dans la table de niveau appropriée les dates d'ouverture et de fermeture
derNiv       NUMBER        :=0 ;
codts  NUMBER        :=0 ;
LE$trop_long exception ;
pragma exception_init( LE$trop_long, -12899 ) ;
BEGIN
-- recuperation du niveau
   begin 
    select Sn.niveau,Sn.CODTS into derNiv,codts from  std_struc_entite se, std_struc_niv sn 
    where se.type_entite=sn.type_entite 
     and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin 
       and se.code_entite=:new.CODE_ENTITE;
      --dbms_output.put_line('derNiv : '||derNiv);
      --FIXME utiliser la procédure trace_dbms_output()
     exception
     when no_data_found then
     --dbms_output.put_line('ici'||derNiv);
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
     when others then
     --dbms_output.put_line('pas de niveau');
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
    end;
      --dbms_output.put_line('autre begin');
      --FIXME utiliser la procédure trace_dbms_output()
   BEGIN
         if derNiv =1 then 
  --mise à jour dans NIV1
           --dbms_output.put_line('avant update niv1 : '||:new.DATE_OUV);
           --FIXME utiliser la procédure trace_dbms_output()
           update NIV1 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV1=:new.CODE_ENTITE ;
          end if;
           if derNiv =2 then 
  --mise à jour dans NIV2
            update NIV2 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV2=:new.CODE_ENTITE ;
         end if;
  --mise à jour dans NIV3
         if derNiv =3 then 
            update NIV3 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV3=:new.CODE_ENTITE ;
       end if;
         --insertion dans NIV4
    if derNiv =4 then 
            update NIV4 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV4=:new.CODE_ENTITE ;
        end if;
  --mise à jour dans NIV5
    if derNiv =5 then 
            update NIV5 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV5=:new.CODE_ENTITE ;
      end if;
  --mise à jour dans NIV6
           if derNiv =6 then 
            update NIV6 set DATE_OUV=:new.DATE_OUV,DATE_FERM=:new.DATE_FERM where CODTS=codts and CODNIV6=:new.CODE_ENTITE ;
     end if;
      exception
when LE$trop_long then
  --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
  --FIXME utiliser la procédure trace_dbms_output()
  NULL;
  When OTHERS then
   --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
   --FIXME utiliser la procédure trace_dbms_output()
   null;
end ;
END;
##
ORG_CM_ENTITE_OPEN_TO_NIV
=SQL=
DROP TRIGGER ORG_CM_ENTITE_OPEN_TO_NIV
##
TAG_CHARSET=@€éèç
##
ORG_C_ARBRE_TO_NIV
=SQL=
create or replace
TRIGGER "ORG_C_ARBRE_TO_NIV" BEFORE INSERT 
ON STD_STRUC_ARBRE FOR EACH ROW
declare 
-- trigger qui créer dans la table de niveau et la table adresse appropriée l'occurrence correspondante à une insertion dans STD_STRUC_ARBRE
  dateouv VARCHAR2(8) := '';
  dateferm VARCHAR2(8) := '';
  lib VARCHAR2(255) := '';
  derniv NUMBER := 0;
  codniv1 VARCHAR2(10) := '';
  codniv2 VARCHAR2(10) := '';
  codniv3 VARCHAR2(10) := '';
  codniv4 VARCHAR2(10) := '';
  idAdr VARCHAR2(25) := '';
  sirenAdr VARCHAR2(14) := '';
  nicAdr VARCHAR2(5) := '';
  sigleAdr VARCHAR2(20) := '';
  comAdr VARCHAR2(50) := '';
  numvoiAdr VARCHAR2(4) := '';
  bisterAdr VARCHAR2(1) := '';
  typvoiAdr VARCHAR2(3) := '';
  nomvoiAdr VARCHAR2(35) := '';
  cinseeAdr VARCHAR2(6) := '';
  bourgAdr VARCHAR2(30) := '';
  copostAdr VARCHAR2(5) := '';
  budistAdr VARCHAR2(30) := '';
  noteleAdr VARCHAR2(20) := '';
  nofaxAdr VARCHAR2(20) := '';
  emailAdr VARCHAR2(50) := '';
  copaysAdr VARCHAR2(3) := '';
  typstrAdr VARCHAR2(4) := '';
  table_mutante EXCEPTION;
  pragma exception_init(table_mutante,   -4091);
  le$trop_long EXCEPTION;
  pragma exception_init(le$trop_long,   -12899);
BEGIN
-- si l'occurrence de STD_STRUC_ARBRE est à la date du jour on va tenter la création dans une table de niveau
  if to_char(SYSDATE,'yyyymmdd') between :new.date_eff and :new.date_fin then
-- recuperation du niveau
    begin 
      select Sn.niveau,se.id_adresse,se.SIREN,se.NIC into derNiv,idAdr,sirenAdr,nicAdr from  std_struc_entite se, std_struc_niv sn
      where sn.codts=:new.CODTS and se.type_entite=sn.type_entite and se.code_entite=:new.CODE_ENTITE
      and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
      and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin ;
      --dbms_output.put_line('derNiv : '||derNiv);
      --dbms_output.put_line('adresse id : '||idAdr);
      --FIXME utiliser la procédure trace_dbms_output()
    exception
     when no_data_found then
       --dbms_output.put_line('pas de donnée trouvée');
       --FIXME utiliser la procédure trace_dbms_output()
       NULL;
     when others then
       --dbms_output.put_line('pas de niveau'||derNiv);
       --FIXME utiliser la procédure trace_dbms_output()
       NULL;
    end;
    begin 
      select date_ouv,date_ferm into dateouv,dateferm from STD_STRUC_ENTITE_OPEN WHERE CODE_ENTITE=:new.CODE_ENTITE ;
    exception
     when no_data_found then
      --dbms_output.put_line('Date ouv : '||dateouv||'Date ferm : '||dateferm);
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    end;
    begin 
      select libelle into lib from STD_STRUC_ENTITE WHERE CODE_ENTITE=:new.CODE_ENTITE AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN  ;
      --dbms_output.put_line('libelle : '||lib);
      --FIXME utiliser la procédure trace_dbms_output()
    exception
      when no_data_found then
        --dbms_output.put_line('pas de donnée trouvée libellé : '||lib);
        --FIXME utiliser la procédure trace_dbms_output()
        NULL;
      when others then
        --dbms_output.put_line('problème recherche libellé : '||lib);
        --FIXME utiliser la procédure trace_dbms_output()
        NULL;
    end;
    begin 
       --dbms_output.put_line('Recherche des informations de l''adresse : ');
       --FIXME utiliser la procédure trace_dbms_output()
       if idAdr is not null then
        select SIGLE,COMADR,NUMVOI,BISTER,TYPVOI,NOMVOI,CINSEE,BOURG,COPOST,BUDIST,COPAYS,NOTELE,NOFAX,EMAIL into  sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr , cinseeAdr, bourgAdr,copostAdr, budistAdr,copaysAdr,  noteleAdr, nofaxAdr ,  emailAdr    from  STD_ADRESSE WHERE ID_ADRESSE=idAdr;
       --dbms_output.put_line('identifiant adresse : '||idAdr||' comadr : '||COMADR);
       --FIXME utiliser la procédure trace_dbms_output()
       end if;
    exception
       when no_data_found then
         --dbms_output.put_line('pas de donnée trouvée adresse'||idAdr);
         --FIXME utiliser la procédure trace_dbms_output()
         NULL;
       when others then
         --dbms_output.put_line('problème recherche adresse : '||idAdr);
         --FIXME utiliser la procédure trace_dbms_output()
         NULL;
       end;
    BEGIN
         if derNiv =1 then 
  --insertion dans NIV1
            if lib is not null then
             insert into NIV1 (CODTS,CODNIV1,LIBNIV1,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV1 (CODTS,CODNIV1,LIBNIV1,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
              if ( idAdr is not null or sirenAdr is not null or nicAdr is not null)   then
                 --dbms_output.put_line('Création dans la table adresses : '||idAdr);
                 --FIXME utiliser la procédure trace_dbms_output()
               insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,:new.CODE_ENTITE,'','','','','',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;

         end if;
        if derNiv =2 then 
  --insertion dans NIV2
            if lib is not null then
             insert into NIV2 (CODTS,CODNIV1,CODNIV2,LIBNIV2,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,:new.CODE_ENT_MERE,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV2 (CODTS,CODNIV1,CODNIV2,LIBNIV2,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,:new.CODE_ENT_MERE,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
             if ( idAdr is not null or sirenAdr is not null or nicAdr is not null)   then
               insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,:new.CODE_ENT_MERE,:new.CODE_ENTITE,'','','','',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;
         end if;
   --insertion dans NIV3
         if derNiv =3 then
         BEGIN 
           select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= :new.CODE_ENT_MERE AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
          EXCEPTION
          WHEN TABLE_MUTANTE THEN 
            --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;    
          END ;
             if lib is not null then
             insert into NIV3 (CODTS,CODNIV1,CODNIV2,CODNIV3,LIBNIV3,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,:new.CODE_ENT_MERE,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV3 (CODTS,CODNIV1,CODNIV2,CODNIV3,LIBNIV3,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,:new.CODE_ENT_MERE,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
              if ( idAdr is not null or sirenAdr is not null or nicAdr is not null)   then
              insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,codniv1,:new.CODE_ENT_MERE,:new.CODE_ENTITE,'','','',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;
        end if;
         --insertion dans NIV4
    if derNiv =4 then 
          begin
            select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= :new.CODE_ENT_MERE AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
          EXCEPTION
          WHEN TABLE_MUTANTE THEN 
            --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;    
          END ;
             --dbms_output.put_line('codniv1 : '||codniv1);
             --dbms_output.put_line('codniv2 : '||codniv2);
             --FIXME utiliser la procédure trace_dbms_output()
              if lib is not null then
             insert into NIV4 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,LIBNIV4,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,:new.CODE_ENT_MERE,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV4 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,LIBNIV4,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,:new.CODE_ENT_MERE,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
              if ( idAdr is not null or sirenAdr is not null or nicAdr is not null)   then
              insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,codniv1,codniv2,:new.CODE_ENT_MERE,:new.CODE_ENTITE,'','',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;
        end if;
         --insertion dans NIV5
    if derNiv =5 then
      begin
            select CODE_ENT_MERE into codniv3 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= :new.CODE_ENT_MERE AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            --dbms_output.put_line('codniv1 : '||codniv1);
            --dbms_output.put_line('codniv2 : '||codniv2);
            --dbms_output.put_line('codniv3 : '||codniv3);
            --FIXME utiliser la procédure trace_dbms_output()
          EXCEPTION
          WHEN TABLE_MUTANTE THEN 
            --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;    
          END ;
             if lib is not null then
             insert into NIV5 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,LIBNIV5,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,codniv3,:new.CODE_ENT_MERE,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV5 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,LIBNIV5,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,codniv3,:new.CODE_ENT_MERE,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
             if ( idAdr is not null or sirenAdr is not null or nicAdr is not null)   then
               insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,codniv1,codniv2,codniv3,:new.CODE_ENT_MERE,:new.CODE_ENTITE,'',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;
        end if;
         --insertion dans NIV6
           if derNiv =6 then 
           begin
           select CODE_ENT_MERE into codniv4 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= :new.CODE_ENT_MERE AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv3 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv4 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=:new.CODTS and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
            --dbms_output.put_line('codniv1 : '||codniv1);
            --dbms_output.put_line('codniv2 : '||codniv2);
            --dbms_output.put_line('codniv3 : '||codniv3);
            --dbms_output.put_line('codniv4 : '||codniv4);
            --FIXME utiliser la procédure trace_dbms_output()
          EXCEPTION
          WHEN TABLE_MUTANTE THEN 
            --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;    
          END ;
           if lib is not null then
             insert into NIV6 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,LIBNIV6,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,codniv3,codniv4,:new.CODE_ENT_MERE,:new.CODE_ENTITE,SUBSTR(lib,0,100),dateouv,dateferm,0);
            else
            insert into NIV6 (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,LIBNIV6,DATE_OUV,DATE_FERM,EST_PREV ) values (:new.CODTS,codniv1,codniv2,codniv3,codniv4,:new.CODE_ENT_MERE,:new.CODE_ENTITE,null,dateouv,dateferm,0);
            end if;
             if (idAdr is not null or sirenAdr is not null or nicAdr is not null ) then
              insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (:new.CODTS,codniv1,codniv2,codniv3,codniv4,:new.CODE_ENT_MERE,:new.CODE_ENTITE,sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,sirenAdr,nicAdr,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
            end if;
       end if;
    exception
    when LE$trop_long then
      --dbms_output.put_line('Une des colonnes de NIV1 dans la liste n''a pas la taille attendue : CODNIV1 - '||:new.CODE_ENTITE||' DATE_OUV - '||dateouv||' DATE_FERM - '||dateferm);
      --FIXME utiliser la procédure trace_dbms_output()
      NULL;
    When OTHERS then
      --dbms_output.put_line('Problème sur requête de recherche de niveau');
      --dbms_output.put_line( 'Code    erreur : ' || to_char( SQLCODE )) ;
      --dbms_output.put_line( 'libellé erreur : ' || to_char( SQLERRM )) ; 
      null;
     end ;
  end if;
END;
##
ORG_C_ARBRE_TO_NIV
=SQL=
DROP TRIGGER ORG_C_ARBRE_TO_NIV
##
TAG_CHARSET=@€éèç
##
ORG_M_ADRESSE_TO_ADR
=SQL=
create or replace
TRIGGER "ORG_M_ADRESSE_TO_ADR" AFTER UPDATE
ON STD_ADRESSE FOR EACH ROW
declare 
-- trigger qui modifie dans la table adresse les infos si besoin
  existeValeur  NUMBER :=0;
    codniv1 VARCHAR2(10) := '';
  codniv2 VARCHAR2(10) := '';
  codniv3 VARCHAR2(10) := '';
  codniv4 VARCHAR2(10) := '';
 codniv5 VARCHAR2(10) := '';

 TYPE LIG_ADRESSE IS RECORD
 ( derNiv NUMBER ,
      codts NUMBER ,
      entite  VARCHAR2(25) ,
      siren VARCHAR2(14) ,
      nic  VARCHAR2(5)
     );
    rec_adr LIG_ADRESSE ;
   Cursor C_Adr is select SN.NIVEAU ,SN.CODTS,SE.CODE_ENTITE,SE.SIREN,SE.NIC  from  std_struc_entite se, std_struc_niv sn ,STD_STRUC_ARBRE SA
    where sn.codts=SA.CODTS and se.type_entite=sn.type_entite and se.code_entite=SA.CODE_ENTITE
     and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between SA.date_eff and SA.date_fin 
    and se.ID_ADRESSE=:new.ID_ADRESSE;
 Begin
  --dbms_output.put_line('début curseur ');
  --FIXME utiliser la procédure trace_dbms_output() 
    Open C_Adr ;
    Loop
   Fetch C_Adr into rec_adr ;
     Exit when C_Adr%NOTFOUND ;
        --dbms_output.put_line('enregistrement ');
        --FIXME utiliser la procédure trace_dbms_output() 
              begin 
               --dbms_output.put_line('Avant mise à jour adresse : '||:new.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
           if rec_adr.derNiv=1 then 
               --update ou insertion de l'adresse pour niveau 1
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV1=rec_adr.entite and (codniv2 ='' or codniv2 is null) ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,rec_adr.entite,'','','','','',:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV1=rec_adr.entite and (codniv2 ='' or codniv2 is null) ;            
                  end if;
          end if;
          if rec_adr.derNiv=2 then 
               --update ou insertion de l'adresse pour niveau 2
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV2=rec_adr.entite and (codniv3 ='' or codniv3 is null) ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     NULL;
                      BEGIN 
                         select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= rec_adr.entite AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                      EXCEPTION
                      WHEN OTHERS THEN 
                          --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
                          --FIXME utiliser la procédure trace_dbms_output()
                          NULL;    
                  END ;
                  insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,codniv1,rec_adr.entite,'','','','',:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV2=rec_adr.entite and (codniv3 ='' or codniv3 is null) ;            
                  end if;
          end if;
          if rec_adr.derNiv=3 then 
               --update ou insertion de l'adresse pour niveau 2
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV3=rec_adr.entite and (codniv4 ='' or codniv4 is null) ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     NULL;
                      BEGIN 
                         select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                     EXCEPTION
                      WHEN OTHERS THEN 
                          --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
                          --FIXME utiliser la procédure trace_dbms_output()
                          NULL;    
                  END ;
                  insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,codniv1,codniv2,rec_adr.entite,'','','',:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV3=rec_adr.entite and (codniv4 ='' or codniv4 is null) ;            
                  end if;
          end if;
          if rec_adr.derNiv=4 then 
               --update ou insertion de l'adresse pour niveau 2
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV4=rec_adr.entite and (codniv5 ='' or codniv5 is null) ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     NULL;
                      BEGIN 
                         select CODE_ENT_MERE into codniv3 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= rec_adr.entite AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                     EXCEPTION
                      WHEN OTHERS THEN 
                          --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
                          --FIXME utiliser la procédure trace_dbms_output()
                          NULL;
                  END ;
                  insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,codniv1,codniv2,codniv3,rec_adr.entite,'','',:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV4=rec_adr.entite and (codniv5 ='' or codniv5 is null) ;            
                  end if;
          end if;
         if rec_adr.derNiv=5 then 
               --update ou insertion de l'adresse pour niveau 2
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV5=rec_adr.entite and (codniv6 ='' or codniv6 is null) ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     NULL;
                      BEGIN 
                         select CODE_ENT_MERE into codniv4 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= rec_adr.entite AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv3 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv4 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                     EXCEPTION
                      WHEN OTHERS THEN 
                          --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
                          --FIXME utiliser la procédure trace_dbms_output()
                          NULL;    
                  END ;
                  insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,codniv1,codniv2,codniv3,codniv4,rec_adr.entite,'',:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV5=rec_adr.entite and (codniv6 ='' or codniv6 is null) ;            
                  end if;
          end if;
         if rec_adr.derNiv=6 then 
               --update ou insertion de l'adresse pour niveau 2
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV6=rec_adr.entite  ;
                exception
                   when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     NULL;
                      BEGIN 
                         select CODE_ENT_MERE into codniv5 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= rec_adr.entite AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv4 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv5 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv3 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv4 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv2 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv3 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                         select CODE_ENT_MERE into codniv1 from STD_STRUC_ARBRE where CODTS=rec_adr.codts and CODE_ENTITE= codniv2 AND  to_char(SYSDATE,'yyyymmdd') between DATE_EFF and DATE_FIN ;
                     EXCEPTION
                      WHEN OTHERS THEN 
                          --DBMS_OUTPUT.PUT_LINE('Fausse alerte');
                          --FIXME utiliser la procédure trace_dbms_output()
                          NULL;    
                  END ;
                  insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (rec_adr.codts,codniv1,codniv2,codniv3,codniv4,codniv5,rec_adr.entite,:new.SIGLE,:new.COMADR,:new.NUMVOI,:new.BISTER,:new.TYPVOI,:new.NOMVOI,:new.CINSEE,:new.BOURG,:new.COPOST,:new.BUDIST,:new.NOTELE,rec_adr.siren,rec_adr.nic,:new.NOFAX,:new.EMAIL,:new.COPAYS,'');            
                end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                    --dbms_output.put_line('Update adresse ');
                    --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=:new.SIGLE,CPLADR=:new.COMADR,NUMV=:new.NUMVOI,BTQ=:new.BISTER,TYPV=:new.TYPVOI,NOMV=:new.NOMVOI,INSEE=:new.CINSEE,COM=:new.BOURG,CP=:new.COPOST,DISTRI=:new.BUDIST,TEL=:new.NOTELE,SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX=:new.NOFAX,EMAIL=:new.EMAIL,CODP=:new.COPAYS,TYPSTR=''  where CODTS=rec_adr.codts and CODNIV6=rec_adr.entite  ;            
                  end if;
          end if;
          exception
  When OTHERS then
    --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
    --dbms_output.put_line( 'Code    erreur : ' || to_char( SQLCODE )) ;
    --dbms_output.put_line( 'libellé erreur : ' || to_char( SQLERRM )) ; 
    --dbms_output.put_line('problème de mise à jour de l''adresse');
    --FIXME utiliser la procédure trace_dbms_output()
    NULL;
            end;
       End loop ;
         --dbms_output.put_line('fin curseur ');
         --FIXME utiliser la procédure trace_dbms_output() 
  End ;
##
ORG_M_ADRESSE_TO_ADR
=SQL=
DROP TRIGGER ORG_M_ADRESSE_TO_ADR
##
TAG_CHARSET=@€éèç
##
ORG_M_ENTITE_TO_NIV
=SQL=
create or replace
TRIGGER "ORG_M_ENTITE_TO_NIV" AFTER UPDATE
ON STD_STRUC_ENTITE FOR EACH ROW
declare 
-- trigger qui modifie dans la table de niveau appropriée le libellé
derNiv NUMBER        :=0 ;
codts  NUMBER        :=0 ;
  sigleAdr VARCHAR2(20) := '';
  comAdr VARCHAR2(50) := '';
  numvoiAdr VARCHAR2(4) := '';
  bisterAdr VARCHAR2(1) := '';
  typvoiAdr VARCHAR2(3) := '';
  nomvoiAdr VARCHAR2(35) := '';
  cinseeAdr VARCHAR2(6) := '';
  bourgAdr VARCHAR2(30) := '';
  copostAdr VARCHAR2(5) := '';
  budistAdr VARCHAR2(30) := '';
  noteleAdr VARCHAR2(20) := '';
  nofaxAdr VARCHAR2(20) := '';
  emailAdr VARCHAR2(50) := '';
  copaysAdr VARCHAR2(3) := '';
  typstrAdr VARCHAR2(4) := '';
  existeValeur  NUMBER :=0;
LE$trop_long exception ;
pragma exception_init( LE$trop_long, -12899 ) ;
BEGIN
-- si l'occurrence de STD_STRUC_ENTITE est à la date du jour on va tenter la mise à jour dans une table de niveau
 if to_char(SYSDATE,'yyyymmdd') between :new.date_eff and :new.date_fin then
-- recuperation du niveau
   begin 
    select Sn.niveau,SA.CODTS into derNiv,codts from  std_struc_niv sn ,STD_STRUC_ARBRE SA
    where sn.codts=SA.CODTS and sn.type_entite=:new.TYPE_ENTITE and SA.CODE_ENTITE=:new.CODE_ENTITE
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between SA.date_eff and SA.date_fin ;
      --dbms_output.put_line('derNiv : '||derNiv);
      --FIXME utiliser la procédure trace_dbms_output()
     exception
     when no_data_found then
     --dbms_output.put_line('ici'||derNiv);
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
     when others then
     --dbms_output.put_line('pas de niveau');
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
    end;
  -- recuperation infos adresse
       begin 
       if :new.ID_ADRESSE !='' then
        select SIGLE,COMADR,NUMVOI,BISTER,TYPVOI,NOMVOI,CINSEE,BOURG,COPOST,BUDIST,COPAYS,NOTELE,NOFAX,EMAIL into  sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr , cinseeAdr, bourgAdr,copostAdr, budistAdr,copaysAdr,  noteleAdr, nofaxAdr ,  emailAdr    from  STD_ADRESSE WHERE ID_ADRESSE=:new.ID_ADRESSE;
      --dbms_output.put_line('identifiant adresse : '||:new.ID_ADRESSE);
      --FIXME utiliser la procédure trace_dbms_output()
       end if;
    exception
       when no_data_found then
       --dbms_output.put_line('pas de donnée trouvée adresse'||:new.ID_ADRESSE);
       --FIXME utiliser la procédure trace_dbms_output()
       NULL;
       when others then
        --dbms_output.put_line('problème recherche adresse : '||:new.ID_ADRESSE);
        --FIXME utiliser la procédure trace_dbms_output()
        NULL;
    end;
      --dbms_output.put_line('autre begin');
      --FIXME utiliser la procédure trace_dbms_output()
   BEGIN
         if derNiv =1 then 
  --mise à jour dans NIV1
           --dbms_output.put_line('avant update niv1 : '||:new.LIBELLE);
           --FIXME utiliser la procédure trace_dbms_output()
               if :new.LIBELLE is not null then
                 update NIV1 set LIBNIV1=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV1=:new.CODE_ENTITE ;
                    else
                update NIV1 set LIBNIV1='' where CODTS=codts and CODNIV1=:new.CODE_ENTITE ;
             end if;
               begin 
               --dbms_output.put_line('Avant mise à jour adresse : '||:new.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
               if ( :new.ID_ADRESSE is not null or :new.SIREN is not null or :new.NIC is not null)   then
              --update ou insertion
                begin
                    select CODTS into existeValeur from std_adrstr where CODTS=codts and CODNIV1=:new.CODE_ENTITE and (codniv2 ='' or codniv2 is null) ;
                                     exception
             when no_data_found then
                     --dbms_output.put_line('Insere adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                     insert into STD_ADRSTR (CODTS,CODNIV1,CODNIV2,CODNIV3,CODNIV4,CODNIV5,CODNIV6,SIGLE,CPLADR,NUMV,BTQ,TYPV,NOMV,INSEE,COM,CP,DISTRI,TEL,SIREN,NIC,FAX,EMAIL,CODP,TYPSTR) values (codts,:new.CODE_ENTITE,'','','','','',sigleAdr,comAdr,numvoiAdr,bisterAdr,typvoiAdr,nomvoiAdr,cinseeAdr,bourgAdr,copostAdr,budistAdr,noteleAdr,:new.SIREN,:new.NIC,nofaxAdr,emailAdr,copaysAdr,typstrAdr);            
             end;
                --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
                --FIXME utiliser la procédure trace_dbms_output()
                 if ( existeValeur is not null and existeValeur>0) then
                     --dbms_output.put_line('Update adresse ');
                     --FIXME utiliser la procédure trace_dbms_output()
                    update STD_ADRSTR set SIGLE=sigleAdr,CPLADR=comAdr,NUMV=numvoiAdr,BTQ=bisterAdr,TYPV=typvoiAdr,NOMV=nomvoiAdr,INSEE=cinseeAdr,COM=bourgAdr,CP=copostAdr,DISTRI=budistAdr,TEL=noteleAdr,SIREN=:new.SIREN,NIC=:new.NIC,FAX=nofaxAdr,EMAIL=emailAdr,CODP=copaysAdr,TYPSTR=typstrAdr  where CODTS=codts and CODNIV1=:new.CODE_ENTITE and (codniv2 ='' or codniv2 is null) ;            
                  end if;
             else
               --dbms_output.put_line('Delete adresse ');
               --FIXME utiliser la procédure trace_dbms_output()
              delete from STD_ADRSTR where CODTS=codts and CODNIV1=:new.CODE_ENTITE and (codniv2 ='' or codniv2 is null) ;
            end if;
               exception
  When OTHERS then
    --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
    --dbms_output.put_line( 'Code    erreur : ' || to_char( SQLCODE )) ;
    --dbms_output.put_line( 'libellé erreur : ' || to_char( SQLERRM )) ; 
    --dbms_output.put_line('problème de mise à jour de l''adresse');
    --FIXME utiliser la procédure trace_dbms_output()
    NULL;
            end;
           end if;
           if derNiv =2 then 
  --mise à jour dans NIV2
               if :new.LIBELLE is not null then
                 update NIV2 set LIBNIV2=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV2=:new.CODE_ENTITE ;
                    else
                update NIV2 set LIBNIV2='' where CODTS=codts and CODNIV2=:new.CODE_ENTITE ;
             end if;
         end if;
  --mise à jour dans NIV3
         if derNiv =3 then 
               if :new.LIBELLE is not null then
                 update NIV3 set LIBNIV3=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV3=:new.CODE_ENTITE ;
                    else
                update NIV3 set LIBNIV3='' where CODTS=codts and CODNIV3=:new.CODE_ENTITE ;
             end if;
      end if;
         --insertion dans NIV4
    if derNiv =4 then 
               if :new.LIBELLE is not null then
                 update NIV4 set LIBNIV4=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV4=:new.CODE_ENTITE ;
                    else
                update NIV4 set LIBNIV4='' where CODTS=codts and CODNIV4=:new.CODE_ENTITE ;
             end if;
       end if;
  --mise à jour dans NIV5
    if derNiv =5 then 
               if :new.LIBELLE is not null then
                 update NIV5 set LIBNIV5=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV5=:new.CODE_ENTITE ;
                    else
                update NIV5 set LIBNIV5='' where CODTS=codts and CODNIV5=:new.CODE_ENTITE ;
             end if;
     end if;
  --mise à jour dans NIV6
           if derNiv =6 then 
              if :new.LIBELLE is not null then
                 update NIV6 set LIBNIV6=SUBSTR(:new.LIBELLE,0,100) where CODTS=codts and CODNIV6=:new.CODE_ENTITE ;
                    else
                update NIV6 set LIBNIV6='' where CODTS=codts and CODNIV6=:new.CODE_ENTITE ;
             end if;
     end if;
      exception
when LE$trop_long then
  --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
  --FIXME utiliser la procédure trace_dbms_output()
  NULL;
  When OTHERS then
   --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
   --FIXME utiliser la procédure trace_dbms_output()
   null;
end ;
end if;
END;
##
ORG_M_ENTITE_TO_NIV
=SQL=
DROP TRIGGER ORG_M_ENTITE_TO_NIV
##
TAG_CHARSET=@€éèç
##
ORG_S_ADRESSE_TO_ADR
=SQL=
create or replace
TRIGGER "ORG_S_ADRESSE_TO_ADR" AFTER DELETE
ON STD_ADRESSE FOR EACH ROW
declare 
-- trigger qui supprime dans la table adresse ou mets à blanc les infos si besoin
  existeValeur  NUMBER :=0;
 TYPE LIG_ADRESSE IS RECORD
 ( derNiv NUMBER ,
      codts NUMBER ,
      entite  VARCHAR2(25) ,
      siren VARCHAR2(14) ,
      nic  VARCHAR2(5)
     );
    rec_adr LIG_ADRESSE ;
   Cursor C_Adr is select SN.NIVEAU ,SN.CODTS,SE.CODE_ENTITE,SE.SIREN,SE.NIC  from  std_struc_entite se, std_struc_niv sn ,STD_STRUC_ARBRE SA
    where sn.codts=SA.CODTS and se.type_entite=sn.type_entite and se.code_entite=SA.CODE_ENTITE
     and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between SA.date_eff and SA.date_fin 
    and se.ID_ADRESSE=:old.ID_ADRESSE;
 Begin
  --dbms_output.put_line('début curseur ');
  --FIXME utiliser la procédure trace_dbms_output() 
    Open C_Adr ;
    Loop
   Fetch C_Adr into rec_adr ;
     Exit when C_Adr%NOTFOUND ;
       begin 
        --dbms_output.put_line('enregistrement ');
        --FIXME utiliser la procédure trace_dbms_output() 
          if rec_adr.derNiv=1 then 
        --mise à jour dans NIV1
               --dbms_output.put_line('Avant mise à jour adresse : '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV1=rec_adr.entite and (codniv2 ='' or codniv2 is null) ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV1=rec_adr.entite and (codniv2 ='' or codniv2 is null) ;            
                  end if;
              end if;
          if rec_adr.derNiv=2 then 
         --mise à jour de adresse pour niveau 2
               --dbms_output.put_line('Avant mise à jour adresse niveau 2 : '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV2=rec_adr.entite and (codniv3 ='' or codniv3 is null) ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV2=rec_adr.entite and (codniv3 ='' or codniv3 is null) ;            
                  end if;
              end if;
          if rec_adr.derNiv=3 then 
           --mise à jour de adresse pour niveau 3
               --dbms_output.put_line('Avant mise à jour adresse niv 3: '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV3=rec_adr.entite and (codniv4 ='' or codniv4 is null) ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV3=rec_adr.entite and (codniv4 ='' or codniv4 is null) ;            
                  end if;
              end if;
         if rec_adr.derNiv=4 then 
           --mise à jour de adresse pour niveau 4
               --dbms_output.put_line('Avant mise à jour adresse niv4: '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV4=rec_adr.entite and (codniv5 ='' or codniv5 is null) ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV4=rec_adr.entite and (codniv5 ='' or codniv5 is null) ;            
                  end if;
              end if;
         if rec_adr.derNiv=5 then 
          --mise à jour de adresse pour niveau 5
               --dbms_output.put_line('Avant mise à jour adresse niv5 : '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV5=rec_adr.entite and (codniv6 ='' or codniv6 is null) ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV5=rec_adr.entite and (codniv6 ='' or codniv6 is null) ;            
                  end if;
              end if;
         if rec_adr.derNiv=6 then 
        --mise à jour de adresse pour niveau 6
               --dbms_output.put_line('Avant mise à jour adresse niv6 : '||:old.ID_ADRESSE);
               --FIXME utiliser la procédure trace_dbms_output()
              --suppression ou mise à blanc des champs autres que siren ou nic
                if (rec_adr.siren is null and rec_adr.nic is null ) then 
                     delete from STD_ADRSTR where CODTS=rec_adr.codts and CODNIV6=rec_adr.entite ;            
                else
                    update STD_ADRSTR set SIGLE='',CPLADR='',NUMV='',BTQ='',TYPV='',NOMV='',INSEE='',COM='',CP='',DISTRI='',TEL='',SIREN=rec_adr.siren,NIC=rec_adr.nic,FAX='',EMAIL='',CODP='',TYPSTR=''  where CODTS=rec_adr.codts and CODNIV6=rec_adr.entite ;            
                  end if;
              end if;
    exception
      When OTHERS then
          --dbms_output.put_line('Code type structure existe dans adresse : '||existeValeur);
          --dbms_output.put_line( 'Code    erreur : ' || to_char( SQLCODE )) ;
          --dbms_output.put_line( 'libellé erreur : ' || to_char( SQLERRM )) ; 
          --dbms_output.put_line('problème de mise à jour de l''adresse');
          --FIXME utiliser la procédure trace_dbms_output()
          NULL;
      end;
    End loop ;
         --dbms_output.put_line('fin curseur ');
         --FIXME utiliser la procédure trace_dbms_output() 
  End ;
##
ORG_S_ADRESSE_TO_ADR
=SQL=
DROP TRIGGER ORG_S_ADRESSE_TO_ADR
##
TAG_CHARSET=@€éèç
##
ORG_S_ARBRE_TO_NIV
=SQL=
create or replace
TRIGGER "ORG_S_ARBRE_TO_NIV" AFTER DELETE
ON STD_STRUC_ARBRE FOR EACH ROW
declare 
-- trigger qui modifie dans la table de niveau appropriée les dates d'ouverture et de fermeture
derNiv       NUMBER        :=0 ;
BEGIN
-- si l'occurrence de STD_STRUC_ARBRE est à la date du jour on va tenter la création dans une table de niveau
 if to_char(SYSDATE,'yyyymmdd') between :old.date_eff and :old.date_fin then
-- recuperation du niveau
 begin 
    --dbms_output.put_line('ici'||derNiv);
    --FIXME utiliser la procédure trace_dbms_output()
    select Sn.niveau into derNiv from  std_struc_entite se, std_struc_niv sn 
    where sn.codts=:old.CODTS and se.type_entite=sn.type_entite and se.code_entite=:old.CODE_ENTITE
     and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin ;
    --dbms_output.put_line('niveau : '||derNiv);
    --FIXME utiliser la procédure trace_dbms_output()
    exception
     when no_data_found then
     --dbms_output.put_line('ici'||derNiv);
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
     when others then
     --dbms_output.put_line('pas de niveau');
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
    end;
   BEGIN
      --dbms_output.put_line('code entite : '||:old.CODE_ENTITE);
      --dbms_output.put_line('derNiv : '||derNiv);
      --FIXME utiliser la procédure trace_dbms_output()
         if derNiv =1 then 
  --suppression dans NIV1
           delete from NIV1 where CODTS=:old.CODTS and CODNIV1=:old.CODE_ENTITE ;
          end if;
           if derNiv =2 then 
  --suppression dans NIV2
           delete from NIV2 where CODTS=:old.CODTS and CODNIV2=:old.CODE_ENTITE ;
         end if;
  --suppression dans NIV3
         if derNiv =3 then 
           delete from NIV3 where CODTS=:old.CODTS and CODNIV3=:old.CODE_ENTITE ;
       end if;
   --suppression dans NIV4
    if derNiv =4 then 
           delete from NIV4 where CODTS=:old.CODTS and CODNIV4=:old.CODE_ENTITE ;
        end if;
  --suppression dans NIV5
    if derNiv =5 then 
           delete from NIV5 where CODTS=:old.CODTS and CODNIV5=:old.CODE_ENTITE ;
      end if;
  --suppression dans NIV6
           if derNiv =6 then 
           delete from NIV6 where CODTS=:old.CODTS and CODNIV6=:old.CODE_ENTITE ;
     end if;
      exception
  When OTHERS then
   --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
   --FIXME utiliser la procédure trace_dbms_output()
   null;
end ;
end if;
END;
##
ORG_S_ARBRE_TO_NIV
=SQL=
DROP TRIGGER ORG_S_ARBRE_TO_NIV
##
TAG_CHARSET=@€éèç
##
ORG_S_ENTITE_OPEN_TO_NIV
=SQL=
create or replace
TRIGGER "ORG_S_ENTITE_OPEN_TO_NIV" AFTER DELETE
ON STD_STRUC_ENTITE_OPEN FOR EACH ROW
declare 
-- trigger qui modifie dans la table de niveau appropriée les dates d'ouverture et de fermeture
derNiv       NUMBER        :=0 ;
codts  NUMBER        :=0 ;
BEGIN
-- recuperation du niveau
      --dbms_output.put_line('code entite avant : '||:old.CODE_ENTITE);
      --FIXME utiliser la procédure trace_dbms_output()
 begin 
    select Sn.niveau,Sn.CODTS into derNiv,codts from  std_struc_entite se, std_struc_niv sn 
    where se.type_entite=sn.type_entite 
     and to_char(SYSDATE,'yyyymmdd') between se.date_eff and se.date_fin 
    and to_char(SYSDATE,'yyyymmdd') between sn.date_eff and sn.date_fin 
       and se.code_entite=:old.CODE_ENTITE;
     exception
     when no_data_found then
     --dbms_output.put_line('ici'||derNiv);
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
     when others then
     --dbms_output.put_line('pas de niveau');
     --FIXME utiliser la procédure trace_dbms_output()
     NULL;
    end;
   BEGIN
      --dbms_output.put_line('code entite : '||:old.CODE_ENTITE);
      --dbms_output.put_line('derNiv : '||derNiv);
      --FIXME utiliser la procédure trace_dbms_output()
         if derNiv =1 then 
  --mise à jour dans NIV1
           update NIV1 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV1=:old.CODE_ENTITE ;
          end if;
           if derNiv =2 then 
  --mise à jour dans NIV2
            update NIV2 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV2=:old.CODE_ENTITE ;
         end if;
  --mise à jour dans NIV3
         if derNiv =3 then 
            update NIV3 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV3=:old.CODE_ENTITE ;
       end if;
         --insertion dans NIV4
    if derNiv =4 then 
            update NIV4 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV4=:old.CODE_ENTITE ;
        end if;
  --mise à jour dans NIV5
    if derNiv =5 then 
            update NIV5 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV5=:old.CODE_ENTITE ;
      end if;
  --mise à jour dans NIV6
           if derNiv =6 then 
            update NIV6 set DATE_OUV='',DATE_FERM='' where CODTS=codts and CODNIV6=:old.CODE_ENTITE ;
     end if;
      exception
  When OTHERS then
   --dbms_output.put_line('problème de mise à jour lié à non existance probable dans table de niveau');
   --FIXME utiliser la procédure trace_dbms_output()
   null;
end ;
END;
##
ORG_S_ENTITE_OPEN_TO_NIV
=SQL=
DROP TRIGGER ORG_S_ENTITE_OPEN_TO_NIV
##
TGE_MAPDO_CREATE_TRIGGER
=SQL IF_TRIGGER_EXIST=TGE_MAPDO_CREATE_TRIGGER=
DROP TRIGGER TGE_MAPDO_CREATE_TRIGGER
##
TICK_ETAT_CALC_ATT_TRG
=SQL=
CREATE OR REPLACE TRIGGER TICK_ETAT_CALC_ATT_TRG 
AFTER INSERT ON ETAT_CALC_ATTENTE FOR EACH ROW
BEGIN
  UPDATE TICK_ETAT_CALC_ATT set DERNIER_TICK = :new.TICK;
END;
##
TRG_ALTER_META
=SQL=
CREATE OR REPLACE TRIGGER TRG_ALTER_META
AFTER ALTER ON SCHEMA
DECLARE
  nomTableAlter VARCHAR2(128);
  suffixTableAlter VARCHAR2(128);
  doTest NUMBER;
  listePrefix TAB_VARCHAR:=META_LISTE_PREFIX_TABLE();
  existeTable NUMBER;
  nbTables NUMBER;
BEGIN
  nomTableAlter := UPPER(ORA_DICT_OBJ_NAME);
  doTest := 0;
  FOR i IN listePrefix.first..listePrefix.last
  LOOP
    IF INSTR(nomTableAlter,listePrefix(i)||'_')=1 THEN
      suffixTableAlter := SUBSTR(nomTableAlter,LENGTH(listePrefix(i))+1);
      doTest := 1;
    END IF;
    EXIT WHEN doTest=1;
  END LOOP;
  IF doTest=1 THEN
    nbTables := 0;
    FOR i IN listePrefix.first..listePrefix.last
    LOOP
      SELECT COUNT(*) INTO existeTable FROM USER_TABLES WHERE TABLE_NAME=listePrefix(i)||suffixTableAlter;
      nbTables := nbTables+existeTable;
      EXIT WHEN existeTable=0;
    END LOOP;
    IF nbTables=listePrefix.last THEN
      RAISE_APPLICATION_ERROR(-20000,'Pour mettre à jour la structure d''une table META ou d''une table devant avoir la même structure qu''une table META, merci d''utiliser la procédure META_MODIF_STRUCTURE (pour supprimer une colonne, passez le 3ème paramètre à NULL)');    
    END IF;
  END IF;
END TRG_ALTER_META;
##
TAG_CHARSET=@€éèç
##
TRG_DIC_ADM_CONTRAT_SITU
=SQL=
CREATE OR REPLACE TRIGGER TRG_DIC_ADM_CONTRAT_SITU FOR INSERT OR UPDATE OR DELETE ON DIC_ADM_CONTRAT_SITU COMPOUND TRIGGER 
  codeChrono NUMBER;
  TYPE T_MPE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.MPE%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabMpeByNumpac T_MPE_BY_NUMPAC;
  
  TYPE T_TRAITEMENT_PERIODES_INDIV IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(100);
  -- Ce tableau indexé contient plusieurs chose :
  -- + Une entrée avec un code PAC + un PAIEZAD --> Un flag permettant de savoir si le couple NUMPAC/PAIEZAD a déjà été traité
  -- + Une entrée avec un code PAC --> La période en cours du PAC
  tabTrtPeriodesIndividuelles T_TRAITEMENT_PERIODES_INDIV;
  
  v_numpac DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE;
  v_pacmat DIC_ADM_CONTRAT_SITU.PACMAT%TYPE;
  v_numcnt DIC_ADM_CONTRAT_SITU.NUMCNT%TYPE;
  v_paiezad DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE;
  v_codeChrono DIC_ADM_CONTRAT_SITU.CODE_CHRONO%TYPE;
  V_DE_SSAAMM VARCHAR2(6);
  periode_deb_histo_retro VARCHAR2(6);
  periode_paie_en_cours   VARCHAR2(6);
  periode_deb_retro       VARCHAR2(6);
  nb_mois_retro           NUMBER;
  TYPE paiezadTabType is table of DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE ;
  TYPE numpacTabType is  table of DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE ;
  paiezadTab paiezadTabType := paiezadTabType();
  numpacTab numpacTabType := numpacTabType();
  mpe TGE_REF_PAC.MPE%TYPE;
  auMoinsUnPacMpe BOOLEAN;
  v_countSecNav    NUMBER := -1;
  prefixeCodeChrono VARCHAR2(5);
  quantiemeCodeChrono NUMBER;
  suffixeCodeChrono NUMBER;
  existeCodeChrono NUMBER;
   v_jobIdx          NUMBER;
  BEFORE STATEMENT IS BEGIN
    SELECT COUNT(*) INTO v_countSecNav FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';
    IF v_countSecNav>0 THEN
      RAISE_APPLICATION_ERROR(-20000,'CODERR=GENREC03');
    END IF;
  END BEFORE STATEMENT;
  BEFORE EACH ROW IS BEGIN
    v_numpac := NVL(:NEW.NUMPAC,:OLD.NUMPAC);
    v_pacmat := NVL(:NEW.PACMAT,:OLD.PACMAT);
    v_numcnt := NVL(:NEW.NUMCNT,:OLD.NUMCNT);
    IF NOT tabMpeByNumpac.exists(v_numpac) THEN
      BEGIN
        SELECT NVL(MPE,'N') INTO mpe FROM TGE_REF_PAC WHERE NUMPAC=v_numpac;
      EXCEPTION WHEN OTHERS THEN mpe := 'N'; END;
      tabMpeByNumpac(v_numpac) := mpe;
    END IF; 
    -- On vérifie qu'on ne modifie ni le NUMPAC, ni le PACMAT, ni le NUMCNT, ni le PAIEZAD
    IF UPDATING AND (NOT :OLD.NUMPAC=:NEW.NUMPAC OR NOT :OLD.PACMAT=:NEW.PACMAT OR NOT :OLD.NUMCNT=:NEW.NUMCNT OR NOT :OLD.PAIEZAD=:NEW.PAIEZAD) THEN
      -- Message d'erreur --> On interdit la mise à jour du NUMPAC, du PACMAT, du NUMCNT et du PAIEZAD : il faut faire un delete puis un insert
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour des colonnes NUMPAC, PACMAT, NUMCNT et PAIEZAD n''est pas autorisée : vous devez supprimer puis recréer la situation');
    END IF;
    -- On vérifie qu'on ne modifie pas le RHID et qu'il n'est pas vide
    IF (INSERTING OR UPDATING) AND :NEW.MATRIC IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'La colonne MATRIC doit être renseignée dans DIC_ADM_CONTRAT_SITU');
    END IF;
    IF UPDATING AND NOT :OLD.MATRIC=:NEW.MATRIC THEN
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne MATRIC n''est pas autorisée');
    END IF;
    -- On vérifie qu'on ne modifie pas le RHID et qu'il n'est pas vide
    IF (INSERTING OR UPDATING) AND :NEW.DSDSC IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'La colonne DSDSC doit être renseignée dans DIC_ADM_CONTRAT_SITU');
    END IF;
    IF UPDATING AND NOT :OLD.DSDSC=:NEW.DSDSC THEN
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne DSDSC n''est pas autorisée');
    END IF;
    
    IF INSERTING AND :NEW.CODE_CHRONO IS NULL THEN
      IF tabMpeByNumpac(v_numpac)='N' THEN
        -- CODE CHRONO à 000000 si pac non mpe
        :NEW.CODE_CHRONO := '000000';
      ELSE
        -- si pac en MPE CODE_CHRONO calculée à partir de la date de début de situation : Année (sans le siècle) + quantième de jour (3 caractères) + '0'
        prefixeCodeChrono := SUBSTR(TO_CHAR(:NEW.DSDSC,'yyyy'),3);
        quantiemeCodeChrono := :NEW.DSDSC- trunc(:NEW.DSDSC,'yyyy')+1;
        -- Le suffix est toujours à 0
        suffixeCodeChrono := 0;
        -- On va vérifier que le code chrono n'existe pas pour le PACMAT (cas d'une modification de date d'embauche qui aurait gardé le même code chrono)
        -- ou bien d'autres cas, voir la fonction EXISTS_CODE_CHRONO
        LOOP
          :NEW.CODE_CHRONO := prefixeCodeChrono || LPAD(quantiemeCodeChrono,3,'0') || suffixeCodeChrono;
          existeCodeChrono := EXISTS_CODE_CHRONO(:NEW.NUMPAC, :NEW.PACMAT, :NEW.CODE_CHRONO);
          EXIT WHEN existeCodeChrono=0;
          quantiemeCodeChrono := quantiemeCodeChrono + 1;
          EXIT WHEN quantiemeCodeChrono=1000;
        END LOOP;
        IF quantiemeCodeChrono=1000 THEN
          -- On ne peut plus créer de CODE_CHRONO pour cette date de début de situation : on lance une erreur
          RAISE_APPLICATION_ERROR(-20000,'Nombre maximum de codes chrono atteint pour une situation de contrat débutant le '||TO_CHAR(:NEW.DSDSC,'dd.mm.yyyy')||' pour le matricule paie '||:NEW.PACMAT||' du PAC '||:NEW.NUMPAC);
        END IF;
        auMoinsUnPacMpe := TRUE;
      END IF;
    ELSE
      IF UPDATING AND NOT :OLD.CODE_CHRONO=:NEW.CODE_CHRONO THEN
        RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne CODE_CHRONO n''est pas autorisée');
      END IF;
      IF DELETING AND NOT tabMpeByNumpac(v_numpac)='N' THEN
        auMoinsUnPacMpe := TRUE;
        MERGE INTO DELETED_PAIEZAD C USING (SELECT :OLD.NUMPAC AS NUMPAC, :OLD.PACMAT AS PACMAT, :OLD.NUMCNT AS NUMCNT, :OLD.PAIEZAD AS PAIEZAD, :OLD.CODE_CHRONO as CODE_CHRONO FROM DUAL) Z ON (C.NUMPAC=Z.NUMPAC AND C.PACMAT=Z.PACMAT AND C.NUMCNT=Z.NUMCNT AND C.PAIEZAD=Z.PAIEZAD)
        WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, MATRIC, PAIEZAD, DATE_SUPPRESSION, CODE_CHRONO) VALUES (:OLD.NUMPAC, :OLD.PACMAT, :OLD.NUMCNT, :OLD.MATRIC, :OLD.PAIEZAD, SYSDATE, :OLD.CODE_CHRONO);
      END IF;
    END IF;
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', CURRENT_PAIEZAD=(SELECT PAIEZAD FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND DIC_ADM_CONTRAT_HISTO.DATE_EFF=DIC_ADM_CONTRAT.DATE_EFF_CONTRAT) WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat AND NUMCNT=v_numcnt;
  END BEFORE EACH ROW;
  
  AFTER EACH ROW IS BEGIN
    v_numpac := NVL(:NEW.NUMPAC,:OLD.NUMPAC);
    v_paiezad :=NVL(:NEW.paiezad,:OLD.paiezad);
    -- On ne traite chaque couple NUMPAC/PAIEZAD qu'une seule fois
    IF (INSERTING OR DELETING OR (UPDATING('DSFSC') AND NOT :NEW.DSFSC=:OLD.DSFSC)) AND NOT tabTrtPeriodesIndividuelles.exists(v_numpac||v_paiezad) THEN
        SELECT  GREATEST (NVL( s.PREMIERE_PAIE, '190101'),z.DEB_HISTO_RETRO )AS DEB_HISTO_RETRO,
	      z.PERIODEENCOURS,
	      z.DEB_RETRO,
	      z.NB_MOIS_RETRO
	    INTO periode_deb_histo_retro,
	      periode_paie_en_cours,
	      periode_deb_retro, 
	      nb_mois_retro
	    FROM TGE_REF_PAC z LEFT JOIN secupacmat s
        ON s.numpac=z.numpac AND s.pacmat = v_pacmat
	    WHERE z.NUMPAC = v_numpac  ;
	    tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := periode_paie_en_cours;
	    IF(periode_deb_histo_retro IS NOT NULL AND periode_paie_en_cours >= periode_deb_histo_retro) THEN
	      tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := TO_CHAR(NVL(:NEW.dsdsc,:OLD.dsdsc), 'YYYYMM');
	    END IF;
      IF DELETING THEN
        -- Suppression : on supprime de la table des périodes individuelles
        DELETE FROM TGE_PERIODE_RECUEIL_PAIEZAD WHERE NUMPAC = v_numpac AND PAIEZAD = v_paiezad;
        -- Inscription Retro
        IF(periode_paie_en_cours >= periode_deb_retro AND periode_deb_retro IS NOT NULL) THEN
        	-- La période rétro doit être >= à :
            -- - La date de début des histos de rétro
            -- - La période en cours - le nombre de mois de rétro
            -- On prend donc la plus grande de ces 2 dates + la date d'effet
            V_DE_SSAAMM := GREATEST(TO_CHAR(LEAST(NVL(:NEW.DSDSC,:OLD.DSDSC), NVL(:OLD.DSDSC,:NEW.DSDSC)) ,'YYYYMM'),periode_deb_histo_retro,TO_CHAR(ADD_MONTHS(to_date(periode_paie_en_cours,'YYYYMM'),-nb_mois_retro),'YYYYMM'));
            IF(V_DE_SSAAMM < periode_paie_en_cours) THEN
    			v_pacmat := NVL(:NEW.PACMAT,:OLD.PACMAT);
            	v_codeChrono := NVL(:NEW.CODE_CHRONO,:OLD.CODE_CHRONO);
            	
            	TGE_RETRO_INSCRIPTION(v_numpac, v_pacmat, V_DE_SSAAMM, v_codeChrono, v_paiezad, 'DIC_ADM_CONTRAT_SITU');
            END IF;
        END IF;
      ELSE
        -- Création ou modification de la date de fin : on met à jour la table des périodes individuelles
        paiezadTab.EXTEND ;
        paiezadTab(paiezadTab.LAST) := v_paiezad;
        numpacTab.EXTEND ;
        numpacTab(numpacTab.LAST) :=v_numpac;
      END IF;
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS BEGIN
    IF (INSERTING OR DELETING) AND auMoinsUnPacMpe THEN
      -- On supprime de la table DELETED_PAIEZAD les situations qui n'ont pas lieu d'y être (situations recréés avec le même PAIEZAD)
      DELETE FROM DELETED_PAIEZAD WHERE (NUMPAC,PACMAT,CODE_CHRONO) IN (SELECT NUMPAC,PACMAT,CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU);
    END IF;
    FOR i IN 1..numpacTab.count LOOP
    	DBMS_JOB.SUBMIT(v_jobIdx , 'TGE_ALIM_PERIODE_INDIV(0, '''||numpacTab(i)||''', '''|| tabTrtPeriodesIndividuelles(numpacTab(i)||paiezadTab(i)) ||''', '''|| paiezadTab(i) ||''');' , sysdate-1);
   END LOOP ;
  END AFTER STATEMENT;
END;
##
TRG_DIC_IDX_CONTRAT_HISTO
=SQL=
create or replace TRIGGER TRG_DIC_IDX_CONTRAT_HISTO BEFORE INSERT OR DELETE ON DIC_IDX_CONTRAT_HISTO FOR EACH ROW
BEGIN
  IF INSERTING THEN
    IF :NEW.NOM_DONNEE IN ('+','*') THEN
      -- Insertion d'un contrat : on crée une ligne dans DIC_IDX_CONTRAT_HISTO_COMP
      MERGE INTO DIC_IDX_CONTRAT_HISTO_COMP USING (SELECT 1 FROM DUAL) ON (NUMPAC=:NEW.NUMPAC AND PACMAT=:NEW.PACMAT AND NUMCNT=:NEW.NUMCNT AND DATE_EFF=:NEW.DATE_EFF AND NOM_DONNEE=:NEW.NOM_DONNEE) WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_DERNIERE_MODIF) VALUES (:NEW.NUMPAC, :NEW.PACMAT, :NEW.NUMCNT, :NEW.DATE_EFF, :NEW.NOM_DONNEE, SYSDATE);
    ELSE
      -- Insertion d'une rupture sur une donnée : on supprime la ligne correspondante de DIC_IDX_CONTRAT_HISTO_COMP
      DELETE FROM DIC_IDX_CONTRAT_HISTO_COMP WHERE NUMPAC=:NEW.NUMPAC AND PACMAT=:NEW.PACMAT AND NUMCNT=:NEW.NUMCNT AND DATE_EFF=:NEW.DATE_EFF AND NOM_DONNEE=:NEW.NOM_DONNEE;
    END IF;
  ELSIF DELETING AND NOT NVL(:OLD.RUPTURE_CONTRAT,'N')='O' THEN
    -- Suppression d'une rupture : on crée une ligne dans DIC_IDX_CONTRAT_HISTO_COMP
    MERGE INTO DIC_IDX_CONTRAT_HISTO_COMP USING (SELECT 1 FROM DUAL) ON (NUMPAC=:OLD.NUMPAC AND PACMAT=:OLD.PACMAT AND NUMCNT=:OLD.NUMCNT AND DATE_EFF=:OLD.DATE_EFF AND NOM_DONNEE=:OLD.NOM_DONNEE) WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, DATE_EFF, NOM_DONNEE, DATE_DERNIERE_MODIF) VALUES (:OLD.NUMPAC, :OLD.PACMAT, :OLD.NUMCNT, :OLD.DATE_EFF, :OLD.NOM_DONNEE, SYSDATE);
  END IF;
END TRG_DIC_IDX_CONTRAT_HISTO;
##
TRG_DIC_TGE_IMPUTATIONS_PERM
=SQL=
CREATE OR REPLACE TRIGGER trg_dic_tge_imputations_perm BEFORE
  INSERT OR
  UPDATE OR
  DELETE ON dic_tge_imputations_perm 
  REFERENCING NEW AS n 
  FOR EACH ROW 
  DECLARE 
  	nouvelleImputation imputations_perm_tmp%ROWTYPE;
  BEGIN
    nouvelleImputation.NUMPAC              := :n.numpac;
    nouvelleImputation.PAIEZAD             := :n.numpac;
    nouvelleImputation.CODE_IMPUTATION_01  := :n.CODE_IMPUTATION_01;
    nouvelleImputation.CODE_IMPUTATION_02  := :n.CODE_IMPUTATION_02;
    nouvelleImputation.CODE_IMPUTATION_03  := :n.CODE_IMPUTATION_03;
    nouvelleImputation.CODE_IMPUTATION_04  := :n.CODE_IMPUTATION_04;
    nouvelleImputation.CODE_IMPUTATION_05  := :n.CODE_IMPUTATION_05;
    nouvelleImputation.CODE_IMPUTATION_06  := :n.CODE_IMPUTATION_06;
    nouvelleImputation.CODE_IMPUTATION_07  := :n.CODE_IMPUTATION_07;
    nouvelleImputation.CODE_IMPUTATION_08  := :n.CODE_IMPUTATION_08;
    nouvelleImputation.CODE_IMPUTATION_09  := :n.CODE_IMPUTATION_09;
    nouvelleImputation.CODE_IMPUTATION_10  := :n.CODE_IMPUTATION_10;
    nouvelleImputation.CODE_IMPUTATION_11  := :n.CODE_IMPUTATION_11;
    nouvelleImputation.CODE_IMPUTATION_12  := :n.CODE_IMPUTATION_12;
    nouvelleImputation.CODE_IMPUTATION_13  := :n.CODE_IMPUTATION_13;
    nouvelleImputation.CODE_IMPUTATION_14  := :n.CODE_IMPUTATION_14;
    nouvelleImputation.CODE_IMPUTATION_15  := :n.CODE_IMPUTATION_15;
    nouvelleImputation.CODE_IMPUTATION_16  := :n.CODE_IMPUTATION_16;
    nouvelleImputation.CODE_IMPUTATION_17  := :n.CODE_IMPUTATION_17;
    nouvelleImputation.CODE_IMPUTATION_18  := :n.CODE_IMPUTATION_18;
    nouvelleImputation.CODE_IMPUTATION_19  := :n.CODE_IMPUTATION_19;
    nouvelleImputation.CODE_IMPUTATION_20  := :n.CODE_IMPUTATION_20;
    nouvelleImputation.CODE_IMPUTATION_21  := :n.CODE_IMPUTATION_21;
    nouvelleImputation.CODE_IMPUTATION_22  := :n.CODE_IMPUTATION_22;
    nouvelleImputation.CODE_IMPUTATION_23  := :n.CODE_IMPUTATION_23;
    nouvelleImputation.CODE_IMPUTATION_24  := :n.CODE_IMPUTATION_24;
    nouvelleImputation.CODE_IMPUTATION_25  := :n.CODE_IMPUTATION_25;
    nouvelleImputation.CODE_IMPUTATION_26  := :n.CODE_IMPUTATION_26;
    nouvelleImputation.CODE_IMPUTATION_27  := :n.CODE_IMPUTATION_27;
    nouvelleImputation.CODE_IMPUTATION_28  := :n.CODE_IMPUTATION_28;
    nouvelleImputation.CODE_IMPUTATION_29  := :n.CODE_IMPUTATION_29;
    nouvelleImputation.CODE_IMPUTATION_30  := :n.CODE_IMPUTATION_30;
    nouvelleImputation.CODE_IMPUTATION_31  := :n.CODE_IMPUTATION_31;
    nouvelleImputation.CODE_IMPUTATION_32  := :n.CODE_IMPUTATION_32;
    nouvelleImputation.CODE_IMPUTATION_33  := :n.CODE_IMPUTATION_33;
    nouvelleImputation.CODE_IMPUTATION_34  := :n.CODE_IMPUTATION_34;
    nouvelleImputation.CODE_IMPUTATION_35  := :n.CODE_IMPUTATION_35;
    nouvelleImputation.CODE_IMPUTATION_36  := :n.CODE_IMPUTATION_36;
    nouvelleImputation.CODE_IMPUTATION_37  := :n.CODE_IMPUTATION_37;
    nouvelleImputation.CODE_IMPUTATION_38  := :n.CODE_IMPUTATION_38;
    nouvelleImputation.CODE_IMPUTATION_39  := :n.CODE_IMPUTATION_39;
    nouvelleImputation.CODE_IMPUTATION_40  := :n.CODE_IMPUTATION_40;
    nouvelleImputation.POURCENT_IMPUT_01   := :n.POURCENT_IMPUT_01;
    nouvelleImputation.POURCENT_IMPUT_02   := :n.POURCENT_IMPUT_02;
    nouvelleImputation.POURCENT_IMPUT_03   := :n.POURCENT_IMPUT_03;
    nouvelleImputation.POURCENT_IMPUT_04   := :n.POURCENT_IMPUT_04;
    nouvelleImputation.POURCENT_IMPUT_05   := :n.POURCENT_IMPUT_05;
    nouvelleImputation.POURCENT_IMPUT_06   := :n.POURCENT_IMPUT_06;
    nouvelleImputation.POURCENT_IMPUT_07   := :n.POURCENT_IMPUT_07;
    nouvelleImputation.POURCENT_IMPUT_08   := :n.POURCENT_IMPUT_08;
    nouvelleImputation.POURCENT_IMPUT_09   := :n.POURCENT_IMPUT_09;
    nouvelleImputation.POURCENT_IMPUT_10   := :n.POURCENT_IMPUT_10;
    nouvelleImputation.POURCENT_IMPUT_11   := :n.POURCENT_IMPUT_11;
    nouvelleImputation.POURCENT_IMPUT_12   := :n.POURCENT_IMPUT_12;
    nouvelleImputation.POURCENT_IMPUT_13   := :n.POURCENT_IMPUT_13;
    nouvelleImputation.POURCENT_IMPUT_14   := :n.POURCENT_IMPUT_14;
    nouvelleImputation.POURCENT_IMPUT_15   := :n.POURCENT_IMPUT_15;
    nouvelleImputation.POURCENT_IMPUT_16   := :n.POURCENT_IMPUT_16;
    nouvelleImputation.POURCENT_IMPUT_17   := :n.POURCENT_IMPUT_17;
    nouvelleImputation.POURCENT_IMPUT_18   := :n.POURCENT_IMPUT_18;
    nouvelleImputation.POURCENT_IMPUT_19   := :n.POURCENT_IMPUT_19;
    nouvelleImputation.POURCENT_IMPUT_20   := :n.POURCENT_IMPUT_20;
    nouvelleImputation.POURCENT_IMPUT_21   := :n.POURCENT_IMPUT_21;
    nouvelleImputation.POURCENT_IMPUT_22   := :n.POURCENT_IMPUT_22;
    nouvelleImputation.POURCENT_IMPUT_23   := :n.POURCENT_IMPUT_23;
    nouvelleImputation.POURCENT_IMPUT_24   := :n.POURCENT_IMPUT_24;
    nouvelleImputation.POURCENT_IMPUT_25   := :n.POURCENT_IMPUT_25;
    nouvelleImputation.POURCENT_IMPUT_26   := :n.POURCENT_IMPUT_26;
    nouvelleImputation.POURCENT_IMPUT_27   := :n.POURCENT_IMPUT_27;
    nouvelleImputation.POURCENT_IMPUT_28   := :n.POURCENT_IMPUT_28;
    nouvelleImputation.POURCENT_IMPUT_29   := :n.POURCENT_IMPUT_29;
    nouvelleImputation.POURCENT_IMPUT_30   := :n.POURCENT_IMPUT_30;
    nouvelleImputation.POURCENT_IMPUT_31   := :n.POURCENT_IMPUT_31;
    nouvelleImputation.POURCENT_IMPUT_32   := :n.POURCENT_IMPUT_32;
    nouvelleImputation.POURCENT_IMPUT_33   := :n.POURCENT_IMPUT_33;
    nouvelleImputation.POURCENT_IMPUT_34   := :n.POURCENT_IMPUT_34;
    nouvelleImputation.POURCENT_IMPUT_35   := :n.POURCENT_IMPUT_35;
    nouvelleImputation.POURCENT_IMPUT_36   := :n.POURCENT_IMPUT_36;
    nouvelleImputation.POURCENT_IMPUT_37   := :n.POURCENT_IMPUT_37;
    nouvelleImputation.POURCENT_IMPUT_38   := :n.POURCENT_IMPUT_38;
    nouvelleImputation.POURCENT_IMPUT_39   := :n.POURCENT_IMPUT_39;
    nouvelleImputation.POURCENT_IMPUT_40   := :n.POURCENT_IMPUT_40;
    nouvelleImputation.DATE_CREATION       := :n.DATE_CREATION;
    nouvelleImputation.DATE_DERNIERE_MODIF := :n.DATE_DERNIERE_MODIF;
    nouvelleImputation.PACMAT              := :n.PACMAT;
    nouvelleImputation.MATRIC              := :n.MATRIC;
    nouvelleImputation.IDPACMAT            := :n.IDPACMAT;
    nouvelleImputation.TYPE_WRITER         := :n.TYPE_WRITER;
    INSERT INTO imputations_perm_tmp VALUES nouvelleImputation;
    IF inserting THEN
		insert into imputations_perm
			select c.numpac, c.paiezad, c.numcnt, imp.imput_number, imp.code_imput, imp.pourcent_imput from 
			(select numpac as new_numpac, paiezad as new_paiezad, code_imput, pourcent_imput, imput_number 
			from imputations_perm_tmp 
			unpivot ((code_imput, pourcent_imput) for imput_number 
			in ((code_imputation_01, pourcent_imput_01) AS 'IMPUT_01',
			  (code_imputation_02, pourcent_imput_02) AS 'IMPUT_02',
			  (code_imputation_03, pourcent_imput_03) AS 'IMPUT_03',
			  (code_imputation_04, pourcent_imput_04) AS 'IMPUT_04',
			  (code_imputation_05, pourcent_imput_05) AS 'IMPUT_05',
			  (code_imputation_06, pourcent_imput_06) AS 'IMPUT_06',
			  (code_imputation_07, pourcent_imput_07) AS 'IMPUT_07',
			  (code_imputation_08, pourcent_imput_08) AS 'IMPUT_08',
			  (code_imputation_09, pourcent_imput_09) AS 'IMPUT_09',
			  (code_imputation_10, pourcent_imput_10) AS 'IMPUT_10',
			  (code_imputation_11, pourcent_imput_11) AS 'IMPUT_11',
			  (code_imputation_12, pourcent_imput_12) AS 'IMPUT_12',
			  (code_imputation_13, pourcent_imput_13) AS 'IMPUT_13',
			  (code_imputation_14, pourcent_imput_14) AS 'IMPUT_14',
			  (code_imputation_15, pourcent_imput_15) AS 'IMPUT_15',
			  (code_imputation_16, pourcent_imput_16) AS 'IMPUT_16',
			  (code_imputation_17, pourcent_imput_17) AS 'IMPUT_17',
			  (code_imputation_18, pourcent_imput_18) AS 'IMPUT_18',
			  (code_imputation_19, pourcent_imput_19) AS 'IMPUT_19',
			  (code_imputation_20, pourcent_imput_20) AS 'IMPUT_20',
			  (code_imputation_21, pourcent_imput_21) AS 'IMPUT_21',
			  (code_imputation_22, pourcent_imput_22) AS 'IMPUT_22',
			  (code_imputation_23, pourcent_imput_23) AS 'IMPUT_23',
			  (code_imputation_24, pourcent_imput_24) AS 'IMPUT_24',
			  (code_imputation_25, pourcent_imput_25) AS 'IMPUT_25',
			  (code_imputation_26, pourcent_imput_26) AS 'IMPUT_26',
			  (code_imputation_27, pourcent_imput_27) AS 'IMPUT_27',
			  (code_imputation_28, pourcent_imput_28) AS 'IMPUT_28',
			  (code_imputation_29, pourcent_imput_29) AS 'IMPUT_29',
			  (code_imputation_30, pourcent_imput_30) AS 'IMPUT_30',
			  (code_imputation_31, pourcent_imput_31) AS 'IMPUT_31',
			  (code_imputation_32, pourcent_imput_32) AS 'IMPUT_32',
			  (code_imputation_33, pourcent_imput_33) AS 'IMPUT_33',
			  (code_imputation_34, pourcent_imput_34) AS 'IMPUT_34',
			  (code_imputation_35, pourcent_imput_35) AS 'IMPUT_35',
			  (code_imputation_36, pourcent_imput_36) AS 'IMPUT_36',
			  (code_imputation_37, pourcent_imput_37) AS 'IMPUT_37',
			  (code_imputation_38, pourcent_imput_38) AS 'IMPUT_38',
			  (code_imputation_39, pourcent_imput_39) AS 'IMPUT_39',
			  (code_imputation_40, pourcent_imput_40) AS 'IMPUT_40'))) imp 
			inner join (select numpac, paiezad, max(numcnt) as numcnt 
			from dic_adm_contrat_situ group by numpac, paiezad) c on (c.numpac = :n.numpac and c.paiezad = :n.paiezad);
		delete from imputations_perm_tmp;
	end if;
		
	IF updating THEN
		delete from imputations_perm where numpac = :n.numpac and paiezad = :n.paiezad;
			insert into imputations_perm
			select c.numpac, c.paiezad, c.numcnt, imp.imput_number, imp.code_imput, imp.pourcent_imput from 
			(select numpac as new_numpac, paiezad as new_paiezad, code_imput, pourcent_imput, imput_number 
			from imputations_perm_tmp 
			unpivot ((code_imput, pourcent_imput) for imput_number 
			in ((code_imputation_01, pourcent_imput_01) AS 'IMPUT_01',
			  (code_imputation_02, pourcent_imput_02) AS 'IMPUT_02',
			  (code_imputation_03, pourcent_imput_03) AS 'IMPUT_03',
			  (code_imputation_04, pourcent_imput_04) AS 'IMPUT_04',
			  (code_imputation_05, pourcent_imput_05) AS 'IMPUT_05',
			  (code_imputation_06, pourcent_imput_06) AS 'IMPUT_06',
			  (code_imputation_07, pourcent_imput_07) AS 'IMPUT_07',
			  (code_imputation_08, pourcent_imput_08) AS 'IMPUT_08',
			  (code_imputation_09, pourcent_imput_09) AS 'IMPUT_09',
			  (code_imputation_10, pourcent_imput_10) AS 'IMPUT_10',
			  (code_imputation_11, pourcent_imput_11) AS 'IMPUT_11',
			  (code_imputation_12, pourcent_imput_12) AS 'IMPUT_12',
			  (code_imputation_13, pourcent_imput_13) AS 'IMPUT_13',
			  (code_imputation_14, pourcent_imput_14) AS 'IMPUT_14',
			  (code_imputation_15, pourcent_imput_15) AS 'IMPUT_15',
			  (code_imputation_16, pourcent_imput_16) AS 'IMPUT_16',
			  (code_imputation_17, pourcent_imput_17) AS 'IMPUT_17',
			  (code_imputation_18, pourcent_imput_18) AS 'IMPUT_18',
			  (code_imputation_19, pourcent_imput_19) AS 'IMPUT_19',
			  (code_imputation_20, pourcent_imput_20) AS 'IMPUT_20',
			  (code_imputation_21, pourcent_imput_21) AS 'IMPUT_21',
			  (code_imputation_22, pourcent_imput_22) AS 'IMPUT_22',
			  (code_imputation_23, pourcent_imput_23) AS 'IMPUT_23',
			  (code_imputation_24, pourcent_imput_24) AS 'IMPUT_24',
			  (code_imputation_25, pourcent_imput_25) AS 'IMPUT_25',
			  (code_imputation_26, pourcent_imput_26) AS 'IMPUT_26',
			  (code_imputation_27, pourcent_imput_27) AS 'IMPUT_27',
			  (code_imputation_28, pourcent_imput_28) AS 'IMPUT_28',
			  (code_imputation_29, pourcent_imput_29) AS 'IMPUT_29',
			  (code_imputation_30, pourcent_imput_30) AS 'IMPUT_30',
			  (code_imputation_31, pourcent_imput_31) AS 'IMPUT_31',
			  (code_imputation_32, pourcent_imput_32) AS 'IMPUT_32',
			  (code_imputation_33, pourcent_imput_33) AS 'IMPUT_33',
			  (code_imputation_34, pourcent_imput_34) AS 'IMPUT_34',
			  (code_imputation_35, pourcent_imput_35) AS 'IMPUT_35',
			  (code_imputation_36, pourcent_imput_36) AS 'IMPUT_36',
			  (code_imputation_37, pourcent_imput_37) AS 'IMPUT_37',
			  (code_imputation_38, pourcent_imput_38) AS 'IMPUT_38',
			  (code_imputation_39, pourcent_imput_39) AS 'IMPUT_39',
			  (code_imputation_40, pourcent_imput_40) AS 'IMPUT_40'))) imp 
			inner join (select numpac, paiezad, max(numcnt) as numcnt 
			from dic_adm_contrat_situ group by numpac, paiezad) c on (c.numpac = :n.numpac and c.paiezad = :n.paiezad);
	end if;
	if deleting then
		delete from imputations_perm where numpac = :old.numpac and paiezad = :old.paiezad;
	end if;
END trg_dic_tge_imputations_perm;
##
TRG_GAP_TRT
=SQL=
CREATE OR REPLACE TRIGGER TRG_GAP_TRT FOR INSERT OR UPDATE ON GAP_TRT COMPOUND TRIGGER

 v_matric varchar2(6);
 v_ligOld GAP_TRT%ROWTYPE;
 v_ligNew GAP_TRT%ROWTYPE;
 v_periode varchar2(6);
 v_event varchar2(4000);
 v_nature VARCHAR2(32);
 v_date_fin_trait DATE;
 v_nature_varsys varchar2(4000);
 BEFORE EACH ROW IS BEGIN
 IF INSERTING THEN
 -- On initialise le 'OLD' (car :OLD n'existe pas, en insertion)
 v_ligOld := NULL; 
 ELSE
 v_ligOld.NUMPAC := :OLD.NUMPAC;
 v_ligOld.DATE_FIN_TRT  := :OLD.DATE_FIN_TRT ;
 v_ligOld.PERIODE_PAIE   := :OLD.PERIODE_PAIE  ;
 v_ligOld.NATURE   := :OLD.NATURE  ;
  END IF;
 v_ligNew.NUMPAC := :NEW.NUMPAC;
 v_ligNew.DATE_FIN_TRT := :NEW.DATE_FIN_TRT;
 v_ligNew.PERIODE_PAIE := :NEW.PERIODE_PAIE;
 v_ligNew.NATURE   := :NEW.NATURE  ;
 
select NVL(VALVAR, ' ') into v_nature_varsys from sys_varsys where module='MP' and codvar='MP_NOTIF_RESPAIE';
 v_matric := NVL(v_ligNew.NUMPAC,v_ligOld.NUMPAC);
 v_nature := NVL(v_ligNew.NATURE,v_ligOld.NATURE);
 v_date_fin_trait := NVL(v_ligNew.DATE_FIN_TRT,v_ligOld.DATE_FIN_TRT);
 v_event :='payrollProcessingJob.status.change';
 v_periode := to_char(to_date(NVL(v_ligNew.PERIODE_PAIE,v_ligOld.PERIODE_PAIE),'YYYYMM'), 'MMYYYY')  ;
 -- DEBUT TRAITEMENT MP NOTIF TR
IF  v_date_fin_trait IS NOT NULL AND v_nature = v_nature_varsys AND (v_nature = 'RN' OR v_nature = 'Z4CONLOT')  THEN
 MERGE INTO MP_EVENTS DE
 USING (SELECT v_matric AS MATRIC,v_event AS EVENT, v_periode AS CLE_SECONDAIRE FROM DUAL) Z
 ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT AND Z.CLE_SECONDAIRE=DE.CLE_SECONDAIRE)
 WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,CLE_SECONDAIRE,ACTION,DATE_MODIF) VALUES (v_matric,v_event,v_periode,'C',CURRENT_TIMESTAMP);
 END IF;
 -- FIN TRAITEMENT TRAITEMENT MP NOTIF TR
 END BEFORE EACH ROW; 
 END TRG_GAP_TRT;
 ##
TRG_META_WKF_ID_GEN_PAGE
=SQL=
CREATE OR REPLACE TRIGGER TRG_META_WKF_ID_GEN_PAGE 
BEFORE INSERT OR UPDATE ON META_WKF_OPERATION_ECRANS 
FOR EACH ROW 
BEGIN
  IF :NEW.TYPE_ECRAN IN ('RECH','RECAP') THEN
    IF :OLD.ID_GEN_PAGE IS NOT NULL THEN
      -- ID_GEN_PAGE a déjà une valeur : on la laisse !
      :NEW.ID_GEN_PAGE := :OLD.ID_GEN_PAGE;
    ELSIF :NEW.ID_GEN_PAGE IS NULL THEN
      -- ID_GEN_PAGE n'a pas de valeur, et on n'en fourni pas non plus : on la calcule
      :NEW.ID_GEN_PAGE := DBMS_RANDOM.STRING('X', 8);
    END IF;
  ELSE
    :NEW.ID_GEN_PAGE := NULL;
  END IF;
END; 
##
TRG_SIMU_TGE_STRUC
=SQL=
CREATE OR REPLACE TRIGGER TRG_SIMU_TGE_STRUC
AFTER ALTER ON SCHEMA
DECLARE
  V_TABLE_NAME VARCHAR2 (30);
  V_TABLE_SIMU_NAME VARCHAR2 (30);
  V_SQL_TEXT ORA_NAME_LIST_T;
  V_STMT   VARCHAR2 (4000);
  NO_SUCH_TABLE EXCEPTION;
  PRAGMA EXCEPTION_INIT (NO_SUCH_TABLE, -942);
  DONT_TOUCH_SIMU EXCEPTION;
  PRAGMA EXCEPTION_INIT (DONT_TOUCH_SIMU, -20001);
BEGIN
  IF UPPER(ORA_DICT_OBJ_NAME)='TGE_ELEMENTS_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='TGE_DONNEES_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='TGE_ABSENCES'
      OR UPPER(ORA_DICT_OBJ_NAME)='TGE_INCIDENTS_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='TGE_PERIODE_RECUEIL_PAIEZAD' THEN
    V_TABLE_NAME := ORA_DICT_OBJ_NAME;
    IF UPPER(V_TABLE_NAME)='TGE_PERIODE_RECUEIL_PAIEZAD' THEN
      -- Petite rustine pour la table TGE_PERIODE_RECUEIL_PAIEZAD dont le nom est un peu long ...
      V_TABLE_SIMU_NAME := 'SIMU_TGE_PERIODE_RECUEIL_PZAD';
    ELSE
      V_TABLE_SIMU_NAME := 'SIMU_'||V_TABLE_NAME;
    END IF;
    -- Modification de la structure d'une des tables ayant été dupliquées pour la simulation de paie --> On exécute le même ALTER sur la table de simu
    FOR i IN 1 .. ORA_SQL_TXT (V_SQL_TEXT)
    LOOP
      V_STMT := V_STMT || UPPER(V_SQL_TEXT (i));
    END LOOP;
    IF (INSTR(UPPER(V_STMT),'CONSTRAINT')<=0 AND INSTR(UPPER(V_STMT),'PRIMARY KEY')<=0) THEN
      V_STMT :=  REPLACE(V_STMT,V_TABLE_NAME,'/*FROM TRG*/'||V_TABLE_SIMU_NAME);
      EXECUTE_IMMEDIATE_STRING(V_STMT,0); 
    END IF;
  ELSIF UPPER(ORA_DICT_OBJ_NAME)='SIMU_TGE_ELEMENTS_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='SIMU_TGE_DONNEES_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='SIMU_TGE_ABSENCES'
      OR UPPER(ORA_DICT_OBJ_NAME)='SIMU_TGE_INCIDENTS_PAIE'
      OR UPPER(ORA_DICT_OBJ_NAME)='SIMU_TGE_PERIODE_RECUEIL_PZAD' THEN
    V_TABLE_SIMU_NAME := ORA_DICT_OBJ_NAME;
    IF UPPER(V_TABLE_SIMU_NAME)='SIMU_TGE_PERIODE_RECUEIL_PZAD' THEN
      -- Petite rustine pour la table TGE_PERIODE_RECUEIL_PAIEZAD dont le nom est un peu long ...
      V_TABLE_NAME := 'TGE_PERIODE_RECUEIL_PAIEZAD';
    ELSE
      V_TABLE_NAME := SUBSTR(V_TABLE_SIMU_NAME,6);
    END IF;
    -- Modification de la structure d'une des tables de la simulation de paie --> Interdit (c'est fait automatiquement), à moins qu'on vienne du trigger
    FOR i IN 1 .. ORA_SQL_TXT (V_SQL_TEXT)
    LOOP
      V_STMT := V_STMT || UPPER(V_SQL_TEXT (i));
    END LOOP;
    IF INSTR(UPPER(V_STMT),'/*FROM TRG*/')<=0 THEN
      RAISE_APPLICATION_ERROR(-20001,'La table '||V_TABLE_SIMU_NAME||' ne doit pas être modifiée directement : la modification de cette table est faite automatiquement lors de la modification de la table '||V_TABLE_NAME||'. Si les structures des 2 tables sont déphasées, vous devez désactiver le trigger TRG_SIMU_TGE_STRUC pour les réaligner. Merci de penser à le réactiver après !');
    END IF;
  END IF;
EXCEPTION
  WHEN NO_SUCH_TABLE THEN
    RAISE_APPLICATION_ERROR(-20002,'La table '||V_TABLE_SIMU_NAME||' n''existe pas, merci de la créer avec la même structure que '||V_TABLE_NAME||' avec une colonne DOS_NUM en tout début, et dans la clé primaire, avant toute modification');
  WHEN DONT_TOUCH_SIMU THEN
    RAISE;
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003,'Une erreur est survenue lors de la mise à jour de la structure de la table '||V_TABLE_SIMU_NAME||' (conjointement à '||V_TABLE_NAME||') : vous devez désactiver le trigger TRG_SIMU_TGE_STRUC pour faire la modification de '||V_TABLE_NAME||' et de '||V_TABLE_SIMU_NAME||'. Merci de penser à le réactiver après ! '||SQLERRM(SQLCODE));
END TRG_SIMU_TGE_STRUC;
##
TAG_CHARSET=@€éèç
##
TRG_SYS_USR_AOID_MATRIC
=SQL=
CREATE OR REPLACE TRIGGER TRG_SYS_USR_AOID_MATRIC BEFORE DELETE OR INSERT OR UPDATE OF AOID,MATRIC ON SYS_USR_AOID_MATRIC FOR EACH ROW 
BEGIN
IF INSERTING OR UPDATING THEN
 MERGE INTO SYS_USR_TOSEND_PASSPORT T
 USING (select 1 from dual) S
 ON (T.AOID = :new.AOID)
 WHEN MATCHED THEN
 UPDATE SET STATUT = 'TO_SEND', DATE_MAJ = sysdate
 WHEN NOT MATCHED THEN
 INSERT (AOID,STATUT,DATE_MAJ) values (:new.AOID,'TO_SEND',sysdate);
END IF;
IF DELETING THEN
	UPDATE SYS_USR_TOSEND_PASSPORT SET  STATUT = 'TO_SEND' where AOID = :old.AOID;
END IF;
END;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_ABSENCES
=SQL=
CREATE OR REPLACE TRIGGER TRG_TGE_ABSENCES AFTER INSERT OR UPDATE ON TGE_ABSENCES FOR EACH ROW 
BEGIN
	IF INSERTING THEN
		DBMS_OUTPUT.PUT_LINE('SUBMIT'||:NEW.ID);
		INSERT INTO MP_EVENTS M (MATRIC,EVENT,CLE_SECONDAIRE,ACTION,DATE_MODIF) VALUES (:NEW.MATRIC,'timeOffRequest.submit',:NEW.ID,'C',CURRENT_TIMESTAMP); 
	ELSIF UPDATING AND :OLD.STATUT !='N' AND :NEW.STATUT ='N' AND :OLD.WKF_DOSNUM IS NOT NULL  THEN 
		DBMS_OUTPUT.PUT_LINE('CANCEL'||:OLD.ID);
		INSERT INTO MP_EVENTS M (MATRIC,EVENT,CLE_SECONDAIRE,ACTION,DATE_MODIF) VALUES (:OLD.MATRIC,'timeOffRequest.cancel',:OLD.ID,'S',CURRENT_TIMESTAMP); 
	END IF;
END;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_DONNEES_PAIE
=SQL=
create or replace trigger trg_tge_donnees_paie FOR
  insert or
  update or
  delete on tge_donnees_paie COMPOUND TRIGGER
  
  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   number;
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  V_CODE_RUBRIQUE    varchar2(6);
  V_OPTION_RETRO     varchar2(1);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   varchar2(6);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
  end if;

  if (v_type_writer <> 'N' AND v_type_writer <> 'M') then
    v_numpac       := nvl(:new.numpac, :old.numpac);
    v_paiezad      := nvl(:new.paiezad, :old.paiezad);
    
    BEGIN
	    SELECT t.pacmat,nvl(t.periode_recyclage,1),CODE_CHRONO
	    INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
	    from dic_adm_contrat_situ d, secupacmat t
	    where d.numpac = v_numpac 
	    and d.paiezad  = v_paiezad
	    and d.numpac   = t.numpac
	    and d.pacmat   = t.pacmat
	    and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
	EXCEPTION
 	WHEN OTHERS THEN
 		-- Trop souvent cette requête plante (surtout en environnement de dev, on catche l'erreur et on écrit une log)
 		trace_dbms_output( 'TRG_TGE_DONNEES_PAIE', 'Erreur avec le collaborateur : problème avec DIC_ADM_CONTRAT_SITU ou SECUPACMAT.');
 	END;
 	
 	-- S'il y a eu un souci avec la requête précédente, on n'exécute pas la suite
 	if v_pacmat is not null then
 	    if v_periode_recycl = 3 then
	      raise_application_error(-20001, 'CODERR=GENREC02');
	    elsif v_periode_recycl >= 10 then
	      raise_application_error(-20001, 'CODERR=GENREC01');
	    elsif v_periode_recycl = 1 then
	      v_recycl            := 'N';
	      IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
	        select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
	      END IF;
	      IF DELETING THEN
	        date_test_recycl := :old.periode;
	      ELSE
	        date_test_recycl := :new.periode;
	      END IF;
	      if (NVL(date_test_recycl,'000000') <= tabPeriodeByNumpac(v_numpac)) then
	        if inserting or deleting then
	          v_recycl := 'O';
	        elsif updating then
	          if :new.code_caisse            <> :old.code_caisse or (:new.code_caisse is not null and :old.code_caisse is null) or (:new.code_caisse is null and :old.code_caisse is not null) then
	            v_recycl                     := 'O';
	          elsif :new.code_imputation     <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
	            v_recycl                     := 'O';
	          elsif :new.code_rubrique       <> :old.code_rubrique or (:new.code_rubrique is not null and :old.code_rubrique is null) or (:new.code_rubrique is null and :old.code_rubrique is not null) then
	            v_recycl                     := 'O';
	          elsif :new.date_deb_arret      <> :old.date_deb_arret or (:new.date_deb_arret is not null and :old.date_deb_arret is null) or (:new.date_deb_arret is null and :old.date_deb_arret is not null) then
	            v_recycl                     := 'O';
	          elsif :new.domaine_prcte       <> :old.domaine_prcte or (:new.domaine_prcte is not null and :old.domaine_prcte is null) or (:new.domaine_prcte is null and :old.domaine_prcte is not null) then
	            v_recycl                     := 'O';
	          elsif :new.montant             <> :old.montant or (:new.montant is not null and :old.montant is null) or (:new.montant is null and :old.montant is not null) then
	            v_recycl                     := 'O';
	          elsif :new.nombre              <> :old.nombre or (:new.nombre is not null and :old.nombre is null) or (:new.nombre is null and :old.nombre is not null) then
	            v_recycl                     := 'O';
	          elsif :new.no_sequence         <> :old.no_sequence or (:new.no_sequence is not null and :old.no_sequence is null) or (:new.no_sequence is null and :old.no_sequence is not null) then
	            v_recycl                     := 'O';
	          elsif :new.origine             <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
	            v_recycl                     := 'O';
	          elsif :new.periode_affectation <> :old.periode_affectation or (:new.periode_affectation is not null and :old.periode_affectation is null) or (:new.periode_affectation is null and :old.periode_affectation is not null) then
	            v_recycl                     := 'O';
	          elsif :new.periode_rattach_deb <> :old.periode_rattach_deb or (:new.periode_rattach_deb is not null and :old.periode_rattach_deb is null) or (:new.periode_rattach_deb is null and :old.periode_rattach_deb is not null) then
	            v_recycl                     := 'O';
	          elsif :new.periode_rattach_fin <> :old.periode_rattach_fin or (:new.periode_rattach_fin is not null and :old.periode_rattach_fin is null) or (:new.periode_rattach_fin is null and :old.periode_rattach_fin is not null) then
	            v_recycl                     := 'O';
	          elsif :new.pourcentage         <> :old.pourcentage or (:new.pourcentage is not null and :old.pourcentage is null) or (:new.pourcentage is null and :old.pourcentage is not null) then
	            v_recycl                     := 'O';
	          elsif :new.sens                <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
	            v_recycl                     := 'O';
	          elsif :new.taux                <> :old.taux or (:new.taux is not null and :old.taux is null) or (:new.taux is null and :old.taux is not null) then
	            v_recycl                     := 'O';
	          elsif :new.type_donnee         <> :old.type_donnee or (:new.type_donnee is not null and :old.type_donnee is null) or (:new.type_donnee is null and :old.type_donnee is not null) then
	            v_recycl                     := 'O';
	          elsif :new.type_traitement     <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
	            v_recycl                     := 'O';
	          elsif :new.periode             <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
	            v_recycl                     := 'O';
	          elsif :new.code_remplacement   <> :old.code_remplacement or (:new.code_remplacement is not null and :old.code_remplacement is null) or (:new.code_remplacement is null and :old.code_remplacement is not null) then
	            v_recycl                     := 'O';
	          elsif :new.action_retro        <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
	            v_recycl                     := 'O';
	          end if;
	        end if;
	        if v_recycl = 'O' then
	          begin
	            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
	          when not matched then
	            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
	          exception
	          when others then 
	            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
	            --FIXME utiliser la procédure trace_dbms_output()
	            NULL;
	          end;
	        end if;
	      end if;
	    end if;
	    /** Test de mise en rétro **/
	    v_retro            := 'N';
	    if inserting or deleting then
	      v_retro := 'O';
	    elsif updating then
	      if :new.code_caisse            <> :old.code_caisse or (:new.code_caisse is not null and :old.code_caisse is null) or (:new.code_caisse is null and :old.code_caisse is not null) then
	        v_retro                     := 'O';
	      elsif :new.code_imputation     <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
	        v_retro                     := 'O';
	      elsif :new.code_rubrique       <> :old.code_rubrique or (:new.code_rubrique is not null and :old.code_rubrique is null) or (:new.code_rubrique is null and :old.code_rubrique is not null) then
	        v_retro                     := 'O';
	      elsif :new.date_deb_arret      <> :old.date_deb_arret or (:new.date_deb_arret is not null and :old.date_deb_arret is null) or (:new.date_deb_arret is null and :old.date_deb_arret is not null) then
	        v_retro                     := 'O';
	      elsif :new.domaine_prcte       <> :old.domaine_prcte or (:new.domaine_prcte is not null and :old.domaine_prcte is null) or (:new.domaine_prcte is null and :old.domaine_prcte is not null) then
	        v_retro                     := 'O';
	      elsif :new.montant             <> :old.montant or (:new.montant is not null and :old.montant is null) or (:new.montant is null and :old.montant is not null) then
	        v_retro                     := 'O';
	      elsif :new.nombre              <> :old.nombre or (:new.nombre is not null and :old.nombre is null) or (:new.nombre is null and :old.nombre is not null) then
	        v_retro                     := 'O';
	      elsif :new.no_sequence         <> :old.no_sequence or (:new.no_sequence is not null and :old.no_sequence is null) or (:new.no_sequence is null and :old.no_sequence is not null) then
	        v_retro                     := 'O';
	      elsif :new.origine             <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
	        v_retro                     := 'O';
	      elsif :new.periode_affectation <> :old.periode_affectation or (:new.periode_affectation is not null and :old.periode_affectation is null) or (:new.periode_affectation is null and :old.periode_affectation is not null) then
	        v_retro                     := 'O';
	      elsif :new.periode_rattach_deb <> :old.periode_rattach_deb or (:new.periode_rattach_deb is not null and :old.periode_rattach_deb is null) or (:new.periode_rattach_deb is null and :old.periode_rattach_deb is not null) then
	        v_retro                     := 'O';
	      elsif :new.periode_rattach_fin <> :old.periode_rattach_fin or (:new.periode_rattach_fin is not null and :old.periode_rattach_fin is null) or (:new.periode_rattach_fin is null and :old.periode_rattach_fin is not null) then
	        v_retro                     := 'O';
	      elsif :new.pourcentage         <> :old.pourcentage or (:new.pourcentage is not null and :old.pourcentage is null) or (:new.pourcentage is null and :old.pourcentage is not null) then
	        v_retro                     := 'O';
	      elsif :new.sens                <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
	        v_retro                     := 'O';
	      elsif :new.taux                <> :old.taux or (:new.taux is not null and :old.taux is null) or (:new.taux is null and :old.taux is not null) then
	        v_retro                     := 'O';
	      elsif :new.type_donnee         <> :old.type_donnee or (:new.type_donnee is not null and :old.type_donnee is null) or (:new.type_donnee is null and :old.type_donnee is not null) then
	        v_retro                     := 'O';
	      elsif :new.type_traitement     <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
	        v_retro                     := 'O';
	      elsif :new.periode             <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
	        v_retro                     := 'O';
	      elsif :new.code_remplacement   <> :old.code_remplacement or (:new.code_remplacement is not null and :old.code_remplacement is null) or (:new.code_remplacement is null and :old.code_remplacement is not null) then
	        v_retro                     := 'O';
	      elsif :new.action_retro        <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
	        v_retro                     := 'O';
	      end if;
	    end if;
	    if v_retro = 'O' then
	      V_PERIODE := NVL(:NEW.PERIODE,:OLD.PERIODE);
	      V_CODE_RUBRIQUE := NVL(:OLD.CODE_RUBRIQUE,:NEW.CODE_RUBRIQUE);
	      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_DONNEES_PAIE', 'SELECT COUNT(*) FROM TGE_REF_RUBRIQUE WHERE TGE_REF_RUBRIQUE.CODERUB = '''||V_CODE_RUBRIQUE||''' AND NUMPAC = '''||V_NUMPAC||''' AND NVL(OPTION_RETRO,''N'') <> ''N''');
	    END IF;
	  /** Fin test de mise en rétro **/
	end if;
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_donnees_paie;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_ELEMENTS_PAIE
=SQL=
create or replace trigger trg_tge_elements_paie FOR
  insert or
  update or
  delete on tge_elements_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   number;
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_CODE_ELEMENT     varchar2(4);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   varchar2(6);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
  end if;

  if (v_type_writer <> 'N' AND v_type_writer <> 'M') then
    v_numpac       := nvl(:new.numpac, :old.numpac);
    v_paiezad      := nvl(:new.paiezad, :old.paiezad);
    
    BEGIN
	    SELECT t.pacmat,nvl(t.periode_recyclage,1),CODE_CHRONO
	    INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
	    from dic_adm_contrat_SITU d, secupacmat t
	    where d.numpac = v_numpac
	    and d.paiezad  = v_paiezad
	    and d.numpac   = t.numpac
	    and d.pacmat   = t.pacmat
	    and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
	EXCEPTION
	WHEN OTHERS THEN
		-- Trop souvent cette requête plante (surtout en environnement de dev, on catche l'erreur et on écrit une log)
	 	trace_dbms_output( 'TRG_TGE_ELEMENTS_PAIE', 'Erreur avec le collaborateur : problème avec DIC_ADM_CONTRAT_SITU ou SECUPACMAT.');
	END;
	
	-- S'il y a eu un souci avec la requête précédente, on n'exécute pas la suite
 	if v_pacmat is not null then
 	    if v_periode_recycl = 3 then
	      raise_application_error(-20001, 'CODERR=GENREC02');
	    elsif v_periode_recycl >= 10 then
	      raise_application_error(-20001, 'CODERR=GENREC01');
	    elsif v_periode_recycl = 1 then
	      v_recycl            := 'N';
	      IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
	        select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
	      END IF;
	      IF DELETING THEN
	        date_test_recycl := :old.periode;
	      ELSE
	        date_test_recycl := :new.periode;
	      END IF;
	      if (NVL(date_test_recycl,'000000') <= tabPeriodeByNumpac(v_numpac)) then
	        if inserting or deleting then
	          v_recycl := 'O';
	        elsif updating then
	          -- Les valeurs des colonnes clés ne peuvent pas être nulls 
	          if :new.code_element         <> :old.code_element then
	            v_recycl                   := 'O';
	          elsif :new.indicatif         <> :old.indicatif then
	            v_recycl                   := 'O';
	          elsif :new.origine           <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
	            v_recycl                   := 'O';
	          elsif :new.sens              <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
	            v_recycl                   := 'O';
	          elsif :new.type_traitement   <> :old.type_traitement then
	            v_recycl                   := 'O';
	          elsif :new.valeur            <> :old.valeur or (:new.valeur is not null and :old.valeur is null) or (:new.valeur is null and :old.valeur is not null) then
	            v_recycl                   := 'O';
	          elsif :new.periode           <> :old.periode then
	            v_recycl                   := 'O';
	          elsif :new.code_remplacement <> :old.code_remplacement then
	            v_recycl                   := 'O';
	          elsif :new.action_retro      <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
	            v_recycl                   := 'O';
	          end if;
	        end if;
	        if v_recycl = 'O' then
	          begin
	            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
	          when not matched then
	            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
	          exception
	          when others then
	            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
	            --FIXME utiliser la procédure trace_dbms_output()
	            NULL;
	          end;
	        end if;
	      end if;
	    end if;
	    /** Test de mise en rétro **/
	    v_retro            := 'N';
	    if inserting or deleting then
	      v_retro := 'O';
	    elsif updating then
	      -- Les valeurs des colonnes clés ne peuvent pas être nulls 
	      if :new.code_element         <> :old.code_element then
	        v_retro                   := 'O';
	      elsif :new.indicatif         <> :old.indicatif then
	        v_retro                   := 'O';
	      elsif :new.origine           <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
	        v_retro                   := 'O';
	      elsif :new.sens              <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
	        v_retro                   := 'O';
	      elsif :new.type_traitement   <> :old.type_traitement then
	        v_retro                   := 'O';
	      elsif :new.valeur            <> :old.valeur or (:new.valeur is not null and :old.valeur is null) or (:new.valeur is null and :old.valeur is not null) then
	        v_retro                   := 'O';
	      elsif :new.periode           <> :old.periode then
	        v_retro                   := 'O';
	      elsif :new.code_remplacement <> :old.code_remplacement then
	        v_retro                   := 'O';
	      elsif :new.action_retro      <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
	        v_retro                   := 'O';
	      end if;
	    end if;
	    if v_retro = 'O' then
	      V_PERIODE := NVL(:NEW.PERIODE,:OLD.PERIODE);
	      V_CODE_ELEMENT := NVL(:NEW.CODE_ELEMENT,:OLD.CODE_ELEMENT);
	      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_ELEMENTS_PAIE', 'SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE TGE_REF_DICOZ.ELEMENT = '''||V_CODE_ELEMENT||''' AND NUMPAC = '''||V_NUMPAC||'''');
	    END IF;
	  /** Fin test de mise en rétro **/
	end if;
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_elements_paie;
##
TRG_TGE_IMPUTATIONS
=SQL=
create or replace trigger trg_tge_imputations FOR
  insert or
  update or
  delete on tge_imputations COMPOUND TRIGGER

  type pacmats       is record (r_numpac varchar2(6), r_pacmat varchar2(8), r_periode_recycl number);
  type tab_pacmats   is table of pacmats index by binary_integer;
  tab                tab_pacmats;
  v_recycl           varchar2(1);
  v_periode_recycl   number;
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_bypass_trigger   number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   varchar2(6);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
  end if;

  if (v_type_writer <> 'N' AND v_type_writer <> 'M') then
    v_numpac      := nvl(:new.numpac, :old.numpac);
    v_paiezad     := nvl(:new.paiezad, :old.paiezad);
    select t.numpac       as r_numpac,
      t.pacmat            as r_pacmat,
      t.periode_recyclage as r_periode_recycl bulk collect into tab
    from dic_adm_contrat_SITU d, secupacmat t
    where d.numpac = v_numpac
    and d.paiezad  = v_paiezad
    and d.numpac   = t.numpac
    and d.pacmat   = t.pacmat;
    if tab.exists(1) then
      for i in 1..tab.last
      loop
        v_pacmat           := tab(i).r_pacmat;
        v_periode_recycl   := nvl(tab(i).r_periode_recycl, 1);
 	    if v_periode_recycl = 3 then
	      raise_application_error(-20001, 'CODERR=GENREC02');
	    elsif v_periode_recycl >= 10 then
	      raise_application_error(-20001, 'CODERR=GENREC01');
	    elsif v_periode_recycl = 1 then
          v_recycl            := 'N';
          IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
            select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
          END IF;
          IF DELETING THEN
            date_test_recycl := :old.periode;
          ELSE
            date_test_recycl := :new.periode;
          END IF;
          if (NVL(date_test_recycl,'000000') <= tabPeriodeByNumpac(v_numpac)) then
            if inserting or deleting then
              v_recycl := 'O';
            elsif updating then
              if :new.imputation         <> :old.imputation or (:new.imputation is not null and :old.imputation is null) or (:new.imputation is null and :old.imputation is not null) then
                v_recycl                 := 'O';
              elsif :new.nb_unite        <> :old.nb_unite or (:new.nb_unite is not null and :old.nb_unite is null) or (:new.nb_unite is null and :old.nb_unite is not null) then
                v_recycl                 := 'O';
              elsif :new.no_sequence     <> :old.no_sequence or (:new.no_sequence is not null and :old.no_sequence is null) or (:new.no_sequence is null and :old.no_sequence is not null) then
                v_recycl                 := 'O';
              elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
                v_recycl                 := 'O';
              elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
                v_recycl                 := 'O';
              elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
                v_recycl                 := 'O';
              end if;
            end if;
            if v_recycl = 'O' then
              begin
                merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
              when not matched then
                insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
              exception
              when others then
                --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
                --FIXME utiliser la procédure trace_dbms_output()
                NULL;
              end;
            end if;
          end if;
        end if;
      end loop;
    end if;
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_imputations;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_INCIDENTS_PAIE
=SQL=
create or replace trigger trg_tge_incidents_paie FOR
  insert or
  update or
  delete on tge_incidents_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   number;
  v_numpac           varchar2(6);
  v_old_numpac       varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_old_paiezad      varchar2(8);
  v_date_effet       DATE; 
  v_periode_retro    VARCHAR2(6);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  dateFinRecueil DATE;
  --moisPaie  VARCHAR2(6);
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   DATE;
  date_effet_recycl   DATE;
  A520 VARCHAR2(32);
  A521 VARCHAR2(32);
  A523 VARCHAR2(32);
  activite VARCHAR2(32);
  etablissement VARCHAR2(32);
  categorie VARCHAR2(32);
  nomTablegxp VARCHAR2(32);
  requete CLOB;
  V_IS_T2           NUMBER;
  V_ORIGINE_CREATE  VARCHAR2(32);
  BEFORE STATEMENT IS BEGIN
    -- action de 'bypass' le trigger 
    select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;   
    v_old_numpac := 'X' ;
  END BEFORE STATEMENT;
BEFORE EACH ROW
IS
begin
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité
    v_numpac        := NVL(:new.numpac, :old.numpac);
    v_paiezad       := NVL(:new.paiezad, :old.paiezad);
    IF v_old_numpac != v_numpac THEN
     -- Récupération des info du pac    
     SELECT 
       PERIODEENCOURS,
       DEB_RETRO
     INTO
       V_PERIODEENCOURS,
       V_DEB_RETRO
     FROM TGE_REF_PAC
       WHERE NUMPAC = v_numpac; 
    end if;
    
    if deleting then
      v_type_writer := nvl(:old.type_writer, 'O');
    else
      v_type_writer := nvl(:new.type_writer, 'O');
      -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
      :new.type_writer := null;
    end if;

    if (v_type_writer <> 'N' AND v_type_writer <> 'M') then
      --La colonne PERIODE_INIT ne peut pas être modifiée, elle doit contenir la valeur initiale de la colonne PERIODE (avant tout recalcul).
      IF INSERTING THEN
        :NEW.PERIODE_INIT := :NEW.PERIODE;
      ELSIF UPDATING THEN 
        :NEW.PERIODE_INIT := :OLD.PERIODE_INIT;
      END IF;
    
      if INSERTING or UPDATING then
        BEGIN
          IF NVL(:new.code_ip, :old.code_ip) != 'HP'  AND V_DEB_RETRO IS NOT NULL AND V_DEB_RETRO <= V_PERIODEENCOURS THEN
            v_date_effet    := NVL(:new.date_effet, :old.date_effet);
            V_ORIGINE_CREATE := NVL(:new.ORIGINE_CREATE, :old.ORIGINE_CREATE);
            SELECT COUNT(*) INTO V_IS_T2 
            FROM DIC_ADM_CONTRAT_HISTO 
            WHERE V_ORIGINE_CREATE = 'BATCH' 
            AND NUMPAC = v_numpac 
            AND PAIEZAD = v_paiezad 
            AND ZA996 = 'A' 
            AND v_date_effet BETWEEN DATE_EFF AND DATE_SORTIE_SIT_BO;
            
            IF  V_IS_T2 = 0 THEN 
              SELECT MIN(MOIS_PAIE) 
              INTO v_periode_retro
              FROM TGE_PERIODE_RECUEIL_PAIEZAD
              WHERE numpac = v_numpac
              AND paiezad  = v_paiezad
              AND v_date_effet BETWEEN DEBUT_PERIODE_RECUEIL AND FIN_PERIODE_RECUEIL;
              
              IF v_periode_retro IS NOT NULL THEN
                :new.periode     := TO_DATE(v_periode_retro || 01, 'yyyyMMdd');
              END IF;
            END IF;
          END IF;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            -- Période de recueil non trouvé
            null;
        END;
      END IF;
  
      BEGIN
        SELECT t.pacmat,nvl(t.periode_recyclage,1),CODE_CHRONO
        INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
        from dic_adm_contrat_SITU d, secupacmat t
        where d.numpac = v_numpac
        and d.paiezad  = v_paiezad
        and d.numpac   = t.numpac
        and d.pacmat   = t.pacmat
        and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          null;
      END;
 	    if v_periode_recycl = 3 then
	      raise_application_error(-20001, 'CODERR=GENREC02');
	    elsif v_periode_recycl >= 10 then
	      raise_application_error(-20001, 'CODERR=GENREC01');
	    elsif v_periode_recycl = 1 then
        /** Test de mise en recyclage **/
        v_recycl            := 'N';
        --Période de recueil individuelle
        --select periodeencours into moisPaie from tge_ref_pac where numpac = v_numpac;
        BEGIN
          --Période de recueil individuelle
          SELECT FIN_PERIODE_RECUEIL INTO dateFinRecueil from tge_periode_recueil_paiezad where numpac=v_numpac 
          and MOIS_PAIE=V_PERIODEENCOURS and paiezad=v_paiezad ;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          dateFinRecueil:=null;
        END;
        --Période de recueil génèrique
        if(dateFinRecueil  is null) then  
          if v_old_numpac  !=  v_numpac OR ( v_old_numpac  =  v_numpac AND A520 is null  and A521 is  null and A523  is null) THEN 
            SELECT tablegxp ,
              A520_DONNEE ,
              A521_DONNEE ,
              A523_DONNEE into 
            nomTablegxp,A520,A521,A523
            FROM
            (
            SELECT DISTINCT c.element,
              c.tablegxp,
              c.DONNEEGXP
            FROM tge_ref_mapdo c
            WHERE C.numpac = v_numpac
            AND c.element IN ('A520','A521', 'A523')
            UNION ALL
            SELECT DISTINCT c.element,
              c.tablegxp,
              c.DONNEEGXP
            FROM tge_ref_mapdo c
            WHERE C.numpac                  ='*'
            AND c.element                  IN ('A520','A521', 'A523')
            AND (c.TABLEGXP,c.ELEMENT) NOT IN
            (SELECT a.TABLEGXP,
              a.element
            FROM tge_ref_mapdo a
            WHERE a.numpac = v_numpac
            AND A.ELEMENT IN ('A520','A521', 'A523')
            )
            ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element) IN('A520' AS A520,'A521' AS A521, 'A523' AS A523));
          end if; 
          if( A520 is  not null  and A521 is not null and A523  is not null) then
            requete:='select '||A520|| ','||A521||','||A523||'  from '||nomTablegxp||' d '; 
            requete:=requete || ' where numpac='''||v_numpac||''' and paiezad='''|| v_paiezad  || ''' and pacmat='''||v_pacmat||''''; 
            if( nomTablegxp='DIC_ADM_CONTRAT_HISTO') then
              requete:=requete || ' and sysdate BETWEEN date_eff and date_fin_bo AND rownum=1';
            end if;
            BEGIN
              EXECUTE IMMEDIATE requete into activite,etablissement,categorie;
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              dateFinRecueil:=null;
            END;
          end if;
          if(activite is not null and etablissement is not null and categorie is not null) then
            BEGIN
              select 
                max(to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 37, 8),'DDMMYYYY')) into  dateFinRecueil
              from tge_ref_vrval   
              WHERE numero_de_pac = v_numpac 
              AND SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 19 , 6 ) = to_char(to_date(V_PERIODEENCOURS,'YYYYMM'),'MMYYYY') 
              AND CODE_TABLE = 'LTP'  
              AND IS_BETWEEN_NLS_FRENCH(LPAD(activite,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,1 ,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,3,2),2) )  = 'TRUE' 
              AND IS_BETWEEN_NLS_FRENCH(LPAD(etablissement,5),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,5 ,5),5), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,10,5),5))  = 'TRUE' 
              AND IS_BETWEEN_NLS_FRENCH(LPAD(categorie,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,15,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,17,2),2) )  = 'TRUE' ;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                dateFinRecueil:=null;
            END;
          end if;
        end if;
        if (dateFinRecueil is null) then
          select LAST_DAY( to_date(V_PERIODEENCOURS,'YYYYMM') ) into dateFinRecueil from dual;
        end if;
        IF DELETING THEN
          date_test_recycl := :old.periode;
          date_effet_recycl :=:old.date_effet;
        ELSE
          date_test_recycl := :new.periode;
          IF updating THEN
            date_effet_recycl :=LEAST(:new.date_effet,:old.date_effet);
          ELSE
            date_effet_recycl :=:new.date_effet;
          END IF;
        END IF;
        IF  (NVL(TO_CHAR(date_effet_recycl,'yyyymm'),'000000') > to_char(dateFinRecueil,'YYYYMMDD' ) ) THEN
          date_test_recycl := TO_DATE('20991231','yyyymmdd');
        END IF;
        if (NVL(TO_CHAR(date_effet_recycl,'yyyymm'),'000000') <= to_char(dateFinRecueil,'YYYYMMDD' ) ) then
          if inserting or deleting then
            v_recycl := 'O';
          elsif updating then
            if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
              v_recycl                 := 'O';
            elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
              v_recycl                 := 'O';
            elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
              v_recycl                 := 'O';
            elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
              v_recycl                 := 'O';
            elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
              v_recycl                 := 'O';
            elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
              v_recycl                 := 'O';
            elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
              v_recycl                 := 'O';
            elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
              v_recycl                 := 'O';
            elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
              v_recycl                 := 'O';
            end if;
          end if;
          if v_recycl = 'O' then
            begin
              merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
            when not matched then
              insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
            exception
            when others then
              --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
              --FIXME utiliser la procédure trace_dbms_output()
              NULL;
            end;
          end if;
        end if;
      end if; /** Fin test de mise en recyclage **/
      -- Si TYPE_WRITER = 'R', on bypass la mise en rétro (le code appelant devra le faire lui-même si nécessaire)
      IF v_type_writer <> 'R' AND V_DEB_RETRO IS NOT NULL AND V_DEB_RETRO <= V_PERIODEENCOURS THEN
        /** Test de mise en rétro **/
        v_retro            := 'N';
        if inserting or deleting then
          v_retro := 'O';
        elsif updating then
          -- Les valeurs des colonnes clés ne peuvent pas être nulls 
          if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
            v_retro                 := 'O';
          elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
            v_retro                 := 'O';
          elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
            v_retro                 := 'O';
          elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
            v_retro                 := 'O';
          elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_retro                 := 'O';
          elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
            v_retro                 := 'O';
          elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
            v_retro                 := 'O';
          elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
            v_retro                 := 'O';
          elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_retro                 := 'O';
          end if;
        end if;
        if v_retro = 'O' then
          V_PERIODE := TO_CHAR(NVL(:NEW.PERIODE,:OLD.PERIODE),'YYYYMM');
          TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_INCIDENTS_PAIE');
        END IF;
      END IF; /** Fin test de mise en rétro **/
    end if; /** Fin test v_type_writer <> N et M **/
    v_old_numpac  :=  v_numpac; 
  end if; /** Fin test v_bypass_trigger **/
END BEFORE EACH ROW;
end trg_tge_incidents_paie;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_REF_DICOZ
=SQL=
CREATE OR REPLACE TRIGGER TRG_TGE_REF_DICOZ 
BEFORE INSERT OR UPDATE ON TGE_REF_DICOZ

FOR EACH ROW

BEGIN

IF :NEW.GROUPE in ('ATJ','HCO','IND') and :NEW.OCC1='12' THEN

:NEW.OCC1:='13';

END IF;

IF :NEW.GROUPE ='HIS' and :NEW.OCC1='0' THEN

:NEW.OCC1:='18';

END IF;

END TRG_TGE_REF_DICOZ;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_REF_PAC
=SQL=
create or replace trigger TRG_TGE_REF_PAC before update on TGE_REF_PAC for each row
begin
if ( (:OLD.MPE = 'C') and (:NEW.MPE != 'C')) then
  raise_application_error(-20000, 'Désactivation des CSCP non autorisée pour le pac '||:OLD.numpac);
elsif ( (:OLD.MPE != 'N' and :OLD.MPE != ' ') and (:NEW.MPE = 'N' or :NEW.MPE = ' ' )) then
  raise_application_error(-20000, 'Passage de MPE à non MPE non autorisé pour le pac '||:OLD.numpac);
end if;
end TRG_TGE_REF_PAC;
##
ARBRE
==
CREATE OR REPLACE FORCE VIEW "ARBRE" ("TYPEARBRE", "CODENOEUD", "CODEPERE", "LIBCNOEUD", "LIBLNOEUD", "POSSEDEFILS", "ESTELEMENTAIRE", "ORDRE", "TYPENOEUD") AS   SELECT TYPEARBRE , CODENOEUD , CODEPERE , LIBCNOEUD ,LIBLNOEUD , POSSEDEFILS , ESTELEMENTAIRE , ORDRE , TYPENOEUD FROM STD_ARBRE  
##
DBGAP_INDICATOR
==
CREATE OR REPLACE FORCE VIEW "DBGAP_INDICATOR" ("LIBELLE", "INDIC", "VALUE") AS select 'Nombre de ligne dans DIC_ADM_CONTRAT' as LIBELLE, 'DIC_ADM_CONTRAT' as INDIC,count(*) as VALUE from DIC_ADM_CONTRAT union select 'Nombre de ligne dans DIC_ADM_CONTRAT_HISTO' as LIBELLE, 'DIC_ADM_CONTRAT_HISTO' as INDIC,count(*) as VALUE from DIC_ADM_CONTRAT_HISTO union select 'Nombre de ligne dans DIC_ADM_PERSO' as LIBELLE, 'DIC_ADM_PERSO' as INDIC,count(*) as VALUE from DIC_ADM_PERSO union select 'Nombre de ligne dans DIC_ADM_PERSO_HISTO' as LIBELLE, 'DIC_ADM_PERSO_HISTO' as INDIC,count(*) as VALUE from DIC_ADM_PERSO_HISTO union select 'Nombre de société présente dans DIC_SOCIETE mais pas dans la table STD_STRUC_ENTITE ' as LIBELLE, 'DIC_SOCIETE NOT IN STD_STRUC_ENTITE' as INDIC,count(*) as VALUE from DIC_SOCIETE where CODSTE_STE not in (select CODE_ENTITE from STD_STRUC_ENTITE)
##
TAG_CHARSET=@€éèç
##
DOC_CONTAINER_METADATA_VIEW
=SQL=
CREATE OR REPLACE FORCE VIEW DOC_CONTAINER_METADATA_VIEW (DOC_ID, DOC_TYPE, PAC, ETAB, PACMAT, PAIEZAD, COMPANY_ID, ASSOCIATE_ID, PERIODE_PAIE, EXERCICE, MOTEUR_PAIE, BULLETIN_REF, IMPORT_REF, PERIODE_PAIE_SIMUL, GRP_EDIT, NUM_ECH, ANNEXE_INC, ANNEXE_LABEL, NOM, PRENOM) AS SELECT D.DOC_ID, D.DOC_TYPE, D.PAC, D.ETAB, D.PACMAT, D.PAIEZAD, D.COMPANY_ID, D.ASSOCIATE_ID, D.PERIODE_PAIE, D.EXERCICE, D.MOTEUR_PAIE, D.BULLETIN_REF, D.IMPORT_REF, D.PERIODE_PAIE_SIMUL, SUBSTR(D.GRP_EDIT, 0, INSTR(D.GRP_EDIT, '.', 1) - 1) GRP_EDIT, D.NUM_ECH, D.ANNEXE_INC, D.ANNEXE_LABEL, NOM, PRENOM FROM SECUMATRIC S RIGHT JOIN DOC_CONTAINER_METADATA D ON S.NUMPAC = D.PAC AND S.PACMAT = D.PACMAT
##
DPAE_LAST_STATUS
==
CREATE OR REPLACE FORCE VIEW DPAE_LAST_STATUS AS SELECT DISTINCT IDDPAE, FIRST_VALUE(DATE_EFFET) OVER(PARTITION BY IDDPAE ORDER BY DATE_EFFET DESC) AS DATE_EFFET, FIRST_VALUE(STATUS) OVER(PARTITION BY IDDPAE ORDER BY DATE_EFFET DESC) AS STATUS FROM DPAE_STATUS
##
ETAT_CIV
=SQL=
CREATE OR REPLACE VIEW ETAT_CIV
AS
  (SELECT DAP.matric,
    DAP.TITRE                     AS TCIVI,
    DAP.NOM                       AS NOMFAM,
    DAP.NOMJF                     AS NOMJF,
    DAP.PRENOM                    AS PRENOM,
    DAP.SEXE                      AS SEXE,
    TO_CHAR(DAP.DSNAI,'yyyymmdd') AS DTNAI,
    DAP.MELPRO                    AS EMAIL,
    ''                            AS FLAG,
    '2'                           AS TYPE_MATRIC,
    ''                            AS ET_HORAIREHEBDO,
    ''                            AS ET_COEFMAJ,
    (SELECT DACH.ZA523
    FROM DIC_ADM_CONTRAT_HISTO DACH
    WHERE DACH.NUMPAC = DAP.CURRENT_NUMPAC
    AND DACH.PACMAT   = DAP.CURRENT_PACMAT
    AND DACH.NUMCNT   = DAP.CURRENT_NUMCNT
    AND DACH.DATE_EFF = DAP.DATE_EFF_CONTRAT
    AND SYSDATE BETWEEN DACH.DATE_EFF AND DACH.DATE_FIN
    )  AS ET_CATPRO,
    '' AS ET_CATREM,
    '' AS ET_TYPEPAIE,
    (SELECT DACH.ZA557
    FROM DIC_ADM_CONTRAT_HISTO DACH
    WHERE DACH.NUMPAC = DAP.CURRENT_NUMPAC
    AND DACH.PACMAT   = DAP.CURRENT_PACMAT
    AND DACH.NUMCNT   = DAP.CURRENT_NUMCNT
    AND DACH.DATE_EFF = DAP.DATE_EFF_CONTRAT
    AND SYSDATE BETWEEN DACH.DATE_EFF AND DACH.DATE_FIN
    )  AS ET_CLASSIF,
    '' AS ET_CODECOTOR,
    (SELECT code_entite
    FROM std_struc_affectation
    WHERE codts=
      (SELECT valvar
      FROM sys_varsys
      WHERE module ='GPC'
      AND codvar   ='STRUCTURE_JUR'
      )
    AND matric                       = DAP.matric
    AND TO_CHAR(SYSDATE,'yyyymmdd') >= DATE_EFF
    AND TO_CHAR(SYSDATE,'yyyymmdd') <= NVL( DATE_FIN, '20991231')
    AND EST_AFFEC_PRINCIPAL          = 1
    ) AS ET_CODE_ENTITE_JUR,
    (SELECT code_entite
    FROM std_struc_affectation
    WHERE codts=
      (SELECT valvar
      FROM sys_varsys
      WHERE module ='GPC'
      AND codvar   ='STRUCTURE_ADM'
      )
    AND matric                       = DAP.matric
    AND TO_CHAR(SYSDATE,'yyyymmdd') >= DATE_EFF
    AND TO_CHAR(SYSDATE,'yyyymmdd') <= NVL( DATE_FIN, '20991231')
    AND EST_AFFEC_PRINCIPAL          = 1
    ) AS ET_CODE_ENTITE_ADM,
    (SELECT code_entite
    FROM std_struc_affectation
    WHERE codts=
      (SELECT valvar
      FROM sys_varsys
      WHERE module ='GPC'
      AND codvar   ='STRUCTURE_GEO'
      )
    AND matric                       = DAP.matric
    AND TO_CHAR(SYSDATE,'yyyymmdd') >= DATE_EFF
    AND TO_CHAR(SYSDATE,'yyyymmdd') <= NVL( DATE_FIN, '20991231')
    AND EST_AFFEC_PRINCIPAL          = 1
    )  AS ET_CODE_ENTITE_GEO,
    '' AS ET_CODEAFFNIV,
    '' AS ET_LIBAFFNIV,
    '' AS ET_RAISONSOC,
    '' AS ET_DTDEBGROUPE,
    '' AS ET_DTFINGROUPE,
    SAN.DTDEBSOCIETE AS DTDEBSOCIETE,
    SAN.DTFINSOCIETE AS ET_DTFINSOCIETE,
    '' AS ET_CODEMOTIFENTREE,
    '' AS ET_CODEMOTIFSORTIE,
    '' AS ET_CODERECOURS,
    '' AS ET_DTANCIENNETE,
    '' AS ET_DTDEBMATERNITE,
    '' AS ET_DTFINMATERNITE,
    '' AS ET_TYPECNT,
    (SELECT DACH.ZT061
    FROM DIC_ADM_CONTRAT_HISTO DACH
    WHERE DACH.NUMPAC = DAP.CURRENT_NUMPAC
    AND DACH.PACMAT   = DAP.CURRENT_PACMAT
    AND DACH.NUMCNT   = DAP.CURRENT_NUMCNT
    AND DACH.DATE_EFF = DAP.DATE_EFF_CONTRAT
    AND SYSDATE BETWEEN DACH.DATE_EFF AND DACH.DATE_FIN
    )  AS ET_NATCNT,
    '' AS ET_DTDEBCNT,
    '' AS ET_DTFINCNT,
    '' AS ET_CODESUSCNT,
    '' AS ET_DTDEBSUSCNT,
    '' AS ET_DTFINSUSCNT,
    '' AS ET_DTDEBEMP,
    (SELECT
      CASE upper(valvar)
        WHEN 'TRUE'
        THEN
          (SELECT NVL(SEC.EMPLOI,'*')
          FROM secumatric SEC
          WHERE SEC.NUMPAC = DAP.CURRENT_NUMPAC
          AND SEC.PACMAT   = DAP.CURRENT_PACMAT
          )
        ELSE '*'
      END
    FROM sys_varsys
    WHERE codvar LIKE 'AVECEMPLOILOC'
    ) AS ET_CODEEMPL,
    (SELECT SEC.METIER
    FROM SECUMATRIC SEC
    WHERE SEC.NUMPAC = DAP.CURRENT_NUMPAC
    AND SEC.PACMAT   = DAP.CURRENT_PACMAT
    ) AS ET_CODEEMPT,
    (SELECT SEC.FILIR
    FROM SECUMATRIC SEC
    WHERE SEC.NUMPAC = DAP.CURRENT_NUMPAC
    AND SEC.PACMAT   = DAP.CURRENT_PACMAT
    ) AS ET_CODEFAM,
    (SELECT SEC.SSFIL
    FROM SECUMATRIC SEC
    WHERE SEC.NUMPAC = DAP.CURRENT_NUMPAC
    AND SEC.PACMAT   = DAP.CURRENT_PACMAT
    )  AS ET_CODEMET,
    '' AS ET_CODEROLE,
    '' AS ET_CODEINSEE,
    '' AS ET_DTDEBPROF,
    '' AS ET_LOCALITE,
    '' AS ET_CODEPOSTAL,
    '' AS ET_BURDIST,
    '' AS ET_TELEPHONE,
    '' AS ET_LIEUDIT,
    '' AS ET_NUMV,
    '' AS ET_BTQ,
    '' AS ET_TYPVOIE,
    '' AS ET_NOMVOIE,
    '' AS ET_CODPAYS,
    '' AS ET_CODTYPCOL,
    '' AS ET_CODADM1,
    '' AS ET_CODADM2,
    '' AS ET_CODADM3,
    '' AS ET_CODADM4,
    '' AS ET_CODADM5,
    '' AS ET_CODADM6,
    '' AS ET_BULLETIN,
    '' AS ET_USERMODELE,
    '' AS ET_CODE_UID,
    '' AS ET_HR_ENTITE,
    '' AS ET_TEL_PRO_FIXE,
    '' AS ET_TEL_PRO_PORT,
    '' AS ET_FAX_PRO,
    '' AS ET_EMAIL_PERSO
  FROM DIC_ADM_PERSO DAP
  LEFT JOIN STD_STRUCT_DATEAFFJURIDIQUE SAN
  ON SAN.matric = DAP.matric
  )
##
FAMMETIER
==
CREATE OR REPLACE FORCE VIEW "FAMMETIER" ("CODFMET", "LIBFMET") AS   SELECT CODFMET,LIBFMET FROM POS_FAMMETIER  
##
FTEINT
==
CREATE OR REPLACE FORCE VIEW "FTEINT" ("MATRIC", "TCIVI", "NOMFAM", "PRENOM", "DATDEB", "DATFIN", "FONCT", "TYPP", "LIB", "CODDISPO", "LIBDISPO", "DOM_EXPERTISE") AS   (  (SELECT FOR_HFTEINT.MATRIC ,    ETAT_CIV.TCIVI ,    ETAT_CIV.NOMFAM ,    ETAT_CIV.PRENOM ,    FOR_HFTEINT.DATDEB ,    FOR_HFTEINT.DATFIN ,    FOR_HFTEINT.FONCT ,    FOR_HFTEINT.TYPP ,    TYPPERSO.LIB ,    'D'                    AS CODDISPO ,    'Disponible'           AS LIBDISPO ,    FOR_HFTEINT.DOM_EXPERTISE AS DOM_EXPERTISE  FROM FOR_HFTEINT ,    ETAT_CIV ,    TYPPERSO  WHERE TYPPERSO.FLTP   <> '3'  AND FOR_HFTEINT.MATRIC = ETAT_CIV.MATRIC  AND FOR_HFTEINT.TYPP   = TYPPERSO.COD  AND ( (DATFIN          = ''  OR DATFIN             IS NULL  OR DATFIN             >= TO_CHAR ( sysdate ,'yyyymmdd' ) )  AND DATDEB            <= TO_CHAR ( sysdate ,'yyyymmdd' ) )  )UNION  (SELECT FOR_HFTEINT.MATRIC ,    ETAT_CIV.TCIVI ,    ETAT_CIV.NOMFAM ,    ETAT_CIV.PRENOM ,    FOR_HFTEINT.DATDEB ,    FOR_HFTEINT.DATFIN ,    FOR_HFTEINT.FONCT ,    FOR_HFTEINT.TYPP ,    TYPPERSO.LIB ,    'I'                                              AS CODDISPO ,    'Attention cette personne n''est plus disponible'AS LIBDISPO ,    FOR_HFTEINT.DOM_EXPERTISE   AS DOM_EXPERTISE  FROM FOR_HFTEINT ,    ETAT_CIV ,    TYPPERSO  WHERE TYPPERSO.FLTP   <> '3'  AND FOR_HFTEINT.MATRIC = ETAT_CIV.MATRIC  AND FOR_HFTEINT.TYPP   = TYPPERSO.COD  AND ( DATFIN          <= TO_CHAR ( sysdate ,'yyyymmdd' )AND DATDEB            <= TO_CHAR ( sysdate ,'yyyymmdd' ) )) ) 
##
TAG_CHARSET=@€éèç
##
GAP_RETRO_MATRIC_ALL
=SQL=
CREATE OR REPLACE FORCE VIEW GAP_RETRO_MATRIC_ALL AS  (SELECT PACMAT, NUMPAC, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION SELECT PACMAT, NUMPAC, PERIODE_RETRO FROM GAP_SELECTION_RETRO )
##
GAP_RUBFAVORITES
==
CREATE OR REPLACE FORCE VIEW "GAP_RUBFAVORITES" ("CODRUB", "FAMILL", "LIBFAM", "LIBTOT", "SENS", "AJOUT", "NAJOUT", "TAJOUT", "MAJOUT", "MODIF", "NMODIF", "TMODIF", "MMODIF", "REGUL", "NREGUL", "TREGUL", "MREGUL", "RESUL", "RESULG", "RESULC", "TRAIT", "SSREGL", "ORDRE") AS   Select CODRUB,FAMILL,LIBFAM,LIBTOT,SENS,AJOUT,NAJOUT,TAJOUT,MAJOUT,MODIF,NMODIF,TMODIF,MMODIF,REGUL,NREGUL,TREGUL,MREGUL,RESUL,RESULG,RESULC,TRAIT,SSREGL,ROWNUM  from STD_FRUBRIQ where CODRUB in('APP12','APP11','APP09','APP07','APP06','APP05','APP04')  
##
GAP_TRT_DATE
==
CREATE OR REPLACE FORCE VIEW GAP_TRT_DATE (ID_TRT, NUMPAC, PACMAT, PERIODE_PAIE, MODELE, NATURE, DATE_PREVUE_TRT) AS SELECT T.ID_TRT, L.NUMPAC, L.PACMAT, T.PERIODE_PAIE,T.MODELE, T.NATURE, T.DATE_PREVUE_TRT FROM GAP_TRT T, GAP_TRT_LISTE_MAT L WHERE T.ID_TRT=L.ID_TRT AND T.NUMPAC=L.NUMPAC AND TO_CHAR(T.DATE_PREVUE_TRT,'yyyyMMdd') = TO_CHAR(SYSDATE,'yyyyMMdd') ORDER BY T.DATE_PREVUE_TRT DESC
##
TAG_CHARSET=@€éèç
##
GA_EDITIONS_GAP_SE
==
CREATE OR REPLACE FORCE VIEW "GA_EDITIONS_GAP_SE" ("CODE", "LIBELLE", "TYPE", "SAL_DATA", "CNT_DATA", "IS_DOCSERV", "IS_MODE_ASYNCHRONE", "IS_DISPO_COLLAB", "DESCRIPTION", "IMG_SPECIMEN_PATH", "NATCNT", "IS_EMBAUCHE", "IS_MODIF_RENOUVEL_CDD", "IS_MODIF_TRANSFO_CDD_CDI", "IS_MODIF_CONTRAT", "IS_MODIF_AFFECTATION", "IS_MODIF_CLASSIFICATION", "IS_MODIF_HORAIRES", "IS_MODIF_APPOINTEMENT", "IS_MODIF_DSN", "IS_DEPART", "IS_SIGNATURE") AS  SELECT DECODE(NVL(is_signature,'N'),'O', g.code || '#' || g.type,g.code) code,DECODE(NVL(g.is_signature,'N'),'O', g.libelle || ' (avec signature électronique)',g.libelle) libelle, g.TYPE, g.SAL_DATA,g.CNT_DATA,g.IS_DOCSERV,g.IS_MODE_ASYNCHRONE,g.IS_DISPO_COLLAB,g.DESCRIPTION,g.IMG_SPECIMEN_PATH,g.NATCNT,g.IS_EMBAUCHE,g.IS_MODIF_RENOUVEL_CDD,g.IS_MODIF_TRANSFO_CDD_CDI,g.IS_MODIF_CONTRAT,g.IS_MODIF_AFFECTATION,g.IS_MODIF_CLASSIFICATION,g.IS_MODIF_HORAIRES,g.IS_MODIF_APPOINTEMENT, g.IS_MODIF_DSN,g.IS_DEPART,g.IS_SIGNATURE FROM GA_EDITIONS_GAP g UNION SELECT g.code, g.libelle || ' (sans signature électronique)' libelle, g.TYPE, g.SAL_DATA, g.CNT_DATA, g.IS_DOCSERV, g.IS_MODE_ASYNCHRONE, g.IS_DISPO_COLLAB, g.DESCRIPTION, g.IMG_SPECIMEN_PATH, g.NATCNT, g.IS_EMBAUCHE, g.IS_MODIF_RENOUVEL_CDD, g.IS_MODIF_TRANSFO_CDD_CDI, g.IS_MODIF_CONTRAT, g.IS_MODIF_AFFECTATION, g.IS_MODIF_CLASSIFICATION, g.IS_MODIF_HORAIRES, g.IS_MODIF_APPOINTEMENT, g.IS_MODIF_DSN, g.IS_DEPART, g.IS_SIGNATURE FROM GA_EDITIONS_GAP g WHERE NVL(g.is_signature,'N') = 'O'
##
GA_STRUC_CHAMPS_HRO
==
CREATE OR REPLACE FORCE VIEW "GA_STRUC_CHAMPS_HRO" ("CODTS", "TYPE_DONNEE", "NOM_CHAMP") AS   (SELECT CODTS,REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(TYPE_DONNEE,'CODE_ENTITE#NIV%','CODNIV'),'LIBELLE_ENTITE#NIV%','LIBNIV'),'CODE_ENTITE#TYPE%','CODENT_TYPE_'),'LIBELLE_ENTITE#TYPE%','LIBENT_TYPE_'),'#TYPE%','_TYPE_'),'#NIV%','_NIV'),NOM_DONNEE FROM STD_STRUC_DONNEES_HOST)
##
GEST_MATRIC_INSCRI_RECYCL
=SQL=
CREATE OR REPLACE FORCE VIEW GEST_MATRIC_INSCRI_RECYCL (
  NOM,
  PRENOM,
  NUMPAC,
  PACMAT,
  PAIEZAD,
  LIST_LOGIN,
  DATEMAJ,
  MODIF_OU_INSCRIT
) AS
SELECT
  T2.NOM,
  T2.PRENOM,
  T2.NUMPAC,
  T2.PACMAT,
  T2.PAIEZAD,
  T2.LIST_LOGIN,
  CASE
    T2.MODIF_OU_INSCRIT
    WHEN 'M' THEN NULL
    ELSE GREATEST (
      NVL(
        (
          SELECT
            MAX(TO_CHAR(DATE_MAJ, 'yyyymmddHH24MISS')) AS DATEMAJ
          FROM
            TGE_MODIF_PACMAT_TORESEND TOR
          WHERE
            TOR.NUMPAC = T2.NUMPAC
            AND TOR.PACMAT = T2.PACMAT
        ),
        '19000101010100'
      ),
      NVL(
        (
          SELECT
            MAX(DATE_MAJ) || '00' AS DATEMAJ
          FROM
            TGE_ELEMENTS_PAIE TEP
          WHERE
            TEP.NUMPAC = T2.NUMPAC
            AND TEP.PAIEZAD = T2.PAIEZAD
        ),
        '19000101010100'
      ),
      NVL(
        (
          SELECT
            MAX(DATE_MAJ) || '00' AS DATEMAJ
          FROM
            TGE_IMPUTATIONS TUP
          WHERE
            TUP.NUMPAC = T2.NUMPAC
            AND TUP.PAIEZAD = T2.PAIEZAD
        ),
        '19000101010100'
      ),
      NVL(
        (
          SELECT
            MAX(TO_CHAR(DATE_MAJ, 'yyyymmddHH24MISS')) AS DATEMAJ
          FROM
            TGE_INCIDENTS_PAIE TIP
          WHERE
            TIP.NUMPAC = T2.NUMPAC
            AND TIP.PAIEZAD = T2.PAIEZAD
        ),
        '19000101010100'
      ),
      NVL(
        (
          SELECT
            MAX(DATE_MAJ) || '00' AS DATEMAJ
          FROM
            TGE_DONNEES_PAIE TDP
          WHERE
            TDP.NUMPAC = T2.NUMPAC
            AND TDP.PAIEZAD = T2.PAIEZAD
        ),
        '19000101010100'
      )
    )
  END DATEMAJ,
  T2.MODIF_OU_INSCRIT
FROM
  (
    SELECT
      SEC.NOM,
      SEC.PRENOM,
      SEC.NUMPAC AS NUMPAC,
      SEC.PACMAT AS PACMAT,
      DICADM.CURRENT_PAIEZAD AS PAIEZAD,
      T1.LIST_LOGIN || CASE
        WHEN GAP1.PACMAT IS NOT NULL
        AND INSTR(T1.LIST_LOGIN, '__AUTOMATIC__') = 0 THEN ', __AUTOMATIC__'
        ELSE ''
      END AS LIST_LOGIN,
      MODIF_OU_INSCRIT || CASE
        WHEN GAP1.PACMAT IS NOT NULL THEN 'A'
        ELSE ''
      END AS MODIF_OU_INSCRIT
    FROM
      (
        SELECT
          DISTINCT SELMAT2.NUMPAC,
          SELMAT2.PACMAT,
          (
            SELECT
              LISTAGG(SELMAT1.LOGIN, ',') WITHIN GROUP(
                ORDER BY
                  SELMAT1.LOGIN
              )
            FROM
              (
                SELECT
                  NUMPAC,
                  PACMAT,
                  CASE
                    WHEN PRENOM IS NOT NULL
                    AND NOM IS NOT NULL THEN PRENOM || ' ' || NOM || '(' || GAP_SELECTION_PACMAT.LOGIN || ')'
                    ELSE GAP_SELECTION_PACMAT.LOGIN
                  END AS LOGIN,
                  GAP_SELECTION_PACMAT.NOMTRAITEMENT
                FROM
                  GAP_SELECTION_PACMAT
                  LEFT JOIN SYS_USR_CONFIG_IHM ON SYS_USR_CONFIG_IHM.LOGIN = GAP_SELECTION_PACMAT.LOGIN
                WHERE
                  GAP_SELECTION_PACMAT.NOMTRAITEMENT = 'RECYCLAG'
              ) SELMAT1
            WHERE
              SELMAT1.NUMPAC = SELMAT2.NUMPAC
              AND SELMAT1.PACMAT = SELMAT2.PACMAT
              AND SELMAT1.NOMTRAITEMENT = 'RECYCLAG'
          ) AS LIST_LOGIN,
          'M' AS MODIF_OU_INSCRIT
        FROM
          GAP_SELECTION_PACMAT SELMAT2
        WHERE
          SELMAT2.NOMTRAITEMENT = 'RECYCLAG'
        UNION
        ALL
        SELECT
          NUMPAC,
          PACMAT,
          '__AUTOMATIC__' AS LOGIN,
          'A' AS MODIF_OU_INSCRIT
        FROM
          GAP_RECYCL_MATRIC
        WHERE
          (
            GAP_RECYCL_MATRIC.NUMPAC,
            GAP_RECYCL_MATRIC.PACMAT
          ) NOT IN (
            SELECT
              SELMAT3.NUMPAC,
              SELMAT3.PACMAT
            FROM
              GAP_SELECTION_PACMAT SELMAT3
            WHERE
              SELMAT3.NOMTRAITEMENT = 'RECYCLAG'
          )
      ) T1
      LEFT JOIN GAP_RECYCL_MATRIC GAP1 ON GAP1.NUMPAC = T1.NUMPAC
      AND GAP1.PACMAT = T1.PACMAT
      INNER JOIN SECUPACMAT SEC ON SEC.NUMPAC = T1.NUMPAC
      AND SEC.PACMAT = T1.PACMAT
      INNER JOIN DIC_ADM_CONTRAT DICADM ON DICADM.NUMCNT = SEC.CURRENT_NUMCNT
      AND DICADM.NUMPAC = SEC.NUMPAC
      AND DICADM.PACMAT = SEC.PACMAT
  ) T2
##
HELPDESK_DERNIER_COMMIT
==
CREATE OR REPLACE FORCE VIEW "HELPDESK_DERNIER_COMMIT" ("CODFICHE", "NUM_COMMIT", "DESCRIPTION_COMMIT", "LIMITES", "NOM_PAGE_ENTREE", "IMPACT_MAINFRAME", "PARAMETRAGE", "VARSYS", "NOUVEL_ECRAN", "SCRIPT", "USERCVS", "DATE_COMMIT", "DERNIER_COMMIT", "IMPACT_AIDE") AS   SELECT CODFICHE,NUM_COMMIT,DESCRIPTION_COMMIT,LIMITES,NOM_PAGE_ENTREE,IMPACT_MAINFRAME,PARAMETRAGE,VARSYS,NOUVEL_ECRAN,SCRIPT,USERCVS,DATE_COMMIT,DERNIER_COMMIT,IMPACT_AIDE FROM HELPDESK_COMMIT WHERE DERNIER_COMMIT='O'
##
HELPDESK_QUALITY
==
CREATE OR REPLACE FORCE VIEW "HELPDESK_QUALITY" ("CODFICHE", "Q1", "Q2", "Q3", "Q4") AS   select hd.codfiche, count(hd1.codfiche) Q1, count(hd2.codfiche) Q2, count(hd3.codfiche) Q3, count(hd4.codfiche) Q4 from helpdesk_fiche hd left outer join (select codfiche, codficheliee, codsta from helpdesk_fiche where typfiche ='A' and codsta in(1,2,3,5) and codficheliee is not null) hd1 on hd1.codficheliee = hd.codfiche left outer join (select codfiche, codficheliee, codsta from helpdesk_fiche where typfiche ='A' and codsta in(4) and codficheliee is not null) hd2 on hd2.codficheliee = hd.codfiche left outer join (select codfiche, codficheliee, codsta from helpdesk_fiche where typfiche ='A' and codsta in(6) and codficheliee is not null) hd3 on hd3.codficheliee = hd.codfiche left outer join (select codfiche, codficheliee, codsta from helpdesk_fiche where typfiche ='A' and codsta in(7,9) and codficheliee is not null) hd4 on hd4.codficheliee = hd.codfiche group by hd.codfiche having ( count(hd1.codfiche) > 0 OR count(hd2.codfiche) > 0 or count(hd3.codfiche) > 0 or count(hd4.codfiche) > 0) order by 1 desc
##
HELPDESK_RESP
==
CREATE OR REPLACE FORCE VIEW HELPDESK_RESP ("LOGIN", "MATRIC", "NOM", "PRENOM", "ACRO", "EMAIL", "REQUETE", "ROLE", "ACTIF", "ESTEXPERT") AS SELECT sys_usr_externe.login,'' AS matric,UPPER(sys_usr_externe.nomfam) AS nom,UPPER(sys_usr_externe.prenom) AS prenom,SUBSTR(UPPER(sys_usr_externe.prenom),0,1)||SUBSTR(UPPER(sys_usr_externe.nomfam),0,1)||SUBSTR(UPPER(sys_usr_externe.nomfam),LENGTH(UPPER(sys_usr_externe.nomfam)),LENGTH(UPPER(sys_usr_externe.nomfam))+1) AS ACRO,sys_usr_externe.email,REQUETESIMPLE_HELPDESK.requete,sys_sec_usr_helpdesk.equipe,sys_usr_connu.actif,sys_sec_usr_helpdesk.ESTEXPERT FROM sys_usr_externe,sys_sec_usr_helpdesk,REQUETESIMPLE_HELPDESK,sys_usr_connu WHERE sys_usr_connu.login =sys_usr_externe.login and  sys_usr_externe.login    = sys_sec_usr_helpdesk.login AND sys_sec_usr_helpdesk.liste = REQUETESIMPLE_HELPDESK.nomrequete (+) UNION ALL SELECT sys_usr_config.login,ETAT_CIV.matric,ETAT_CIV.nomfam,ETAT_CIV.prenom,SUBSTR(ETAT_CIV.prenom,0,1)||SUBSTR(ETAT_CIV.nomfam,0,1)||SUBSTR(ETAT_CIV.nomfam,LENGTH(ETAT_CIV.nomfam),LENGTH(ETAT_CIV.nomfam)+1) AS ACRO,ETAT_CIV.email,REQUETESIMPLE_HELPDESK.requete,sys_sec_usr_helpdesk.equipe,sys_usr_connu.actif,sys_sec_usr_helpdesk.ESTEXPERT FROM sys_usr_config,ETAT_CIV,sys_sec_usr_helpdesk,REQUETESIMPLE_HELPDESK,sys_usr_connu WHERE sys_usr_config.requetematric = ETAT_CIV.matric AND sys_sec_usr_helpdesk.login     = sys_usr_config.login and sys_usr_connu.login =sys_usr_config.login AND sys_sec_usr_helpdesk.liste     = REQUETESIMPLE_HELPDESK.nomrequete (+) order by login
##
HELPDESK_SUIVIVERSION
==
CREATE OR REPLACE FORCE VIEW "HELPDESK_SUIVIVERSION" ("LIBMOD", "TRIMPLANIFACT", "NEXTVERSION", "NBFICHE", "NBANO", "NBEVO", "NBFICHE_REA", "NBANO_REA", "NBEVO_REA", "NBFICHE_TST_OK", "NBFICHE_TST_ATESTER", "PC_QUALITE", "PC_AV_REA", "PC_AV_TST", "DATESORTIERD", "DATE_FIN_CONTENU", "DATE_FIN_DEV", "DATE_FIN_TEST_1", "DATE_FIN_REWORK", "DATE_FIN_TEST_2") AS   select distinct libmod,trimplanifact,HELPDESK_VERSION.NEXTVERSION,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (3,4,6,7,9) ) nbfiche,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and typfiche <>'E' and codsta in (3,4,6,7,9)) nbano,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact  and typfiche ='E' and codsta in (3,4,6,7,9)) nbevo,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact  and codsta in (4,6,7,9)) nbfiche_rea,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact  and typfiche <>'E' and codsta in (4,6,7,9)) nbano_rea,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact  and typfiche ='E' and codsta in (4,6,7,9)) nbevo_rea,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and codtst in (5,6,7) and codsta in (3,4,6,7,9)) NBFICHE_TST_OK,(select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and nvl(codtst,'0')=0 and codsta in (3,4,6,7,9)) NBFICHE_TST_ATESTER,(NVL((select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and codtst in (5,6,7) and codsta in (3,4,6,7,9))/NULLIF((select count(codfiche) from helpdesk_fiche hd where hd.codmod = helpdesk_fiche.codmod and hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (3,4,6,7,9)),0),0)*100) AS PC_QUALITE,(NVL((select count(codfiche) from helpdesk_fiche hd where hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (4,6,7,9))/NULLIF((select count(codfiche) from helpdesk_fiche hd where hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (3,4,6,7,9)),0),0)*100) AS PC_AV_REA,(NVL((select count(codfiche) from helpdesk_fiche hd where hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (4,6,7,9) and codtst in (5,6,7) )/NULLIF((select count(codfiche) from helpdesk_fiche hd where hd.trimplanifact = helpdesk_fiche.trimplanifact and codsta in (3,4,6,7,9)),0),0)*100) AS PC_AV_TST,HELPDESK_VERSION.DATESORTIERD,HELPDESK_VERSION.DATE_FIN_CONTENU,HELPDESK_VERSION.DATE_FIN_DEV,HELPDESK_VERSION.DATE_FIN_TEST_1,HELPDESK_VERSION.DATE_FIN_REWORK,HELPDESK_VERSION.DATE_FIN_TEST_2 from helpdesk_fiche, helpdesk_module,helpdesk_version where helpdesk_fiche.codmod = helpdesk_module.codmod and helpdesk_fiche.trimplanifact = helpdesk_version.libversion and helpdesk_version.estdisponible = 0 order by 3,2,1 desc 
##
HEUPART
==
CREATE OR REPLACE FORCE VIEW "HEUPART" ("CODFOR", "CODACT", "CODSES", "OCCSEQ", "MATRIC", "CODTYPH", "NBH") AS   ( SELECT CODFOR,CODACT,CODSES,OCCSEQ,MATRIC,'01' AS CODTYPH, NBHTOT AS NBH FROM FOR_FEUILLE_TEMPS WHERE (NBHTTRA IS NOT NULL))  
##
HRORG_DOSSIERS_PERDUS
==
CREATE OR REPLACE FORCE VIEW "HRORG_DOSSIERS_PERDUS" ("TYPE_KO", "DOS_NUM", "TRACE_NUM", "PROC_NUM", "PROC_LIBELLE", "OP_NUM", "OP_LIBELLE", "DATEWKF", "DOS_REF", "DOS_DESC", "FCT_ROLE", "CODE_USER", "ROLE_USER", "CODE_TS", "DATE_EFFET_HRO", "CODE_ENTITE", "GV_VALIDE") AS ( select 'INACCESSIBLE' AS TYPE_KO, dos_num, trace_num, proc_num, proc_libelle, op_num, op_libelle, datewkf, dos_ref, dos_desc, fct_role, code_user, role_user, code_ts, date_effet_hro, code_entite, hrorg_get_groupe_valideur (code_ts,op_num,date_effet_hro,code_entite) as gv_valide from ( select wt.trace_num, wt.dos_num, wt.proc_num, wpr.proc_libelle, wt.op_num, wo.op_libelle, TO_CHAR(TO_DATE(wpa3.p_val, 'YYYYMMDDHH24MISS'), 'DD/MM/YYYY')as datewkf, wt.dos_ref, wt.dos_desc, wr.fct_role, wp.code_user, wp.role_user, (select count(distinct up.login) from sys_groupe_valideurs gv, sys_usr_profil up where gv.login=up.login and (wr.fct_role='*' or to_char(code_profil)=wr.fct_role) and groupe_valideurs=wp.code_user) as ExpertOk, nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) as code_ts, nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) as date_effet_hro, nvl(wpa1.p_val,(select DECODE(code_entite,'@NON_AFFECTE@','(Non affecté)',code_entite) from std_struc_affectation where matric=wpa2.p_val and codts=nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) and nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) between date_eff and date_fin)) as code_entite from wkf_tracabilite wt inner join wkf_op_roleall wr on wr.op_num = wt.op_num inner join wkf_possession wp on wp.trace_num = wt.trace_num inner join wkf_operations wo on wt.op_num = wo.op_num and wt.proc_num = wo.proc_num inner join wkf_processus wpr on wt.proc_num = wpr.proc_num left outer join wkf_param wpa1 on wt.dos_num=wpa1.dos_num and wpa1.p_nom='HRO_GV_CODE_ENTITE' left outer join wkf_param wpa2 on wt.dos_num=wpa2.dos_num and wpa2.p_nom='MATRIC' left outer join wkf_param wpa3 on wt.dos_num=wpa3.dos_num and wpa3.p_nom='DATE_INITIALIZE' left outer join wkf_param wpa4 on wt.dos_num=wpa4.dos_num and wpa4.p_nom='HRO_GV_CODTS' left outer join wkf_param wpa5 on wt.dos_num=wpa5.dos_num and wpa5.p_nom='HRO_GV_DATE_EFFET' where wt.etat='D' and wp.role_user='GV' ) where ExpertOk=0 UNION select 'OBSOLETE', dos_num, trace_num, proc_num, proc_libelle, op_num, op_libelle, datewkf, dos_ref, dos_desc, fct_role, code_user, role_user, code_ts, date_effet_hro, code_entite, hrorg_get_groupe_valideur (code_ts,op_num,date_effet_hro,code_entite) as gv_valide from ( select wt.trace_num, wt.dos_num, wt.proc_num, wpr.proc_libelle, wt.op_num, wo.op_libelle, TO_CHAR(TO_DATE(wpa3.p_val, 'YYYYMMDDHH24MISS'), 'DD/MM/YYYY')as datewkf, wt.dos_ref, wt.dos_desc, wr.fct_role, wp.code_user, wp.role_user, nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) as code_ts, nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) as date_effet_hro, nvl(wpa1.p_val,(select DECODE(code_entite,'@NON_AFFECTE@','(Non affecté)',code_entite) from std_struc_affectation where matric=wpa2.p_val and codts=nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) and nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) between date_eff and date_fin)) as code_entite from wkf_tracabilite wt inner join wkf_op_roleall wr on wr.op_num = wt.op_num inner join wkf_possession wp on wp.trace_num = wt.trace_num inner join wkf_operations wo on wt.op_num = wo.op_num and wt.proc_num = wo.proc_num inner join wkf_processus wpr on wt.proc_num = wpr.proc_num left outer join wkf_param wpa1 on wt.dos_num=wpa1.dos_num and wpa1.p_nom='HRO_GV_CODE_ENTITE' left outer join wkf_param wpa2 on wt.dos_num=wpa2.dos_num and wpa2.p_nom='MATRIC' left outer join wkf_param wpa3 on wt.dos_num=wpa3.dos_num and wpa3.p_nom='DATE_INITIALIZE' left outer join wkf_param wpa4 on wt.dos_num=wpa4.dos_num and wpa4.p_nom='HRO_GV_CODTS' left outer join wkf_param wpa5 on wt.dos_num=wpa5.dos_num and wpa5.p_nom='HRO_GV_DATE_EFFET' where wt.etat='T' and wt.DOS_DESC LIKE ('%obsolète%') and wp.role_user='GV' ) UNION select 'PERDU', dos_num, trace_num, proc_num, proc_libelle, op_num, op_libelle, datewkf, dos_ref, dos_desc, fct_role, code_user, role_user, code_ts, date_effet_hro, code_entite, hrorg_get_groupe_valideur (code_ts,op_num,date_effet_hro,code_entite) as gv_valide from ( select wt.trace_num, wt.dos_num, wt.proc_num, wpr.proc_libelle, wt.op_num, wo.op_libelle, TO_CHAR(TO_DATE(wpa3.p_val, 'YYYYMMDDHH24MISS'), 'DD/MM/YYYY')as datewkf, wt.dos_ref, wt.dos_desc, wr.fct_role, wp.code_user, wp.role_user, wbg.fct_num, fu.fct_class, nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) as code_ts, nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) as date_effet_hro, nvl(wpa1.p_val,(select DECODE(code_entite,'@NON_AFFECTE@','(Non affecté)',code_entite) from std_struc_affectation where matric=wpa2.p_val and codts=nvl(wpa4.p_val,(select codts from std_struc_type where critere_valideurs=1)) and nvl(wpa5.p_val, to_char(SYSDATE, 'yyyymmdd')) between date_eff and date_fin)) as code_entite from wkf_tracabilite wt inner join wkf_op_roleall wr on wr.op_num = wt.op_num inner join wkf_possession wp on wp.trace_num = wt.trace_num inner join wkf_operations wo on wt.op_num = wo.op_num and wt.proc_num = wo.proc_num inner join wkf_processus wpr on wt.proc_num = wpr.proc_num left outer join wkf_param wpa1 on wt.dos_num=wpa1.dos_num and wpa1.p_nom='HRO_GV_CODE_ENTITE' left outer join wkf_param wpa2 on wt.dos_num=wpa2.dos_num and wpa2.p_nom='MATRIC' left outer join wkf_param wpa3 on wt.dos_num=wpa3.dos_num and wpa3.p_nom='DATE_INITIALIZE' left outer join wkf_param wpa4 on wt.dos_num=wpa4.dos_num and wpa4.p_nom='HRO_GV_CODTS' left outer join wkf_param wpa5 on wt.dos_num=wpa5.dos_num and wpa5.p_nom='HRO_GV_DATE_EFFET' left outer join wkf_branch_gen wbg on wbg.code_retour=wt.code_retour and wbg.op_dest_num=wt.op_num and wbg.tr_num=wt.tr_emet left outer join wkf_fctuser fu on fu.fct_num=wbg.fct_num where wt.etat in ('D','P') and wp.role_user='R' and wp.code_user='DBA' ) where fct_class like '%GroupeValideurs%' )
##
TAG_CHARSET=@€éèç
##
HRORG_SECU_GV
==
CREATE OR REPLACE FORCE VIEW "HRORG_SECU_GV" ("CODTS", "CODE_ENTITE", "DATE_EFF", "DATE_FIN", "LOGIN", "CID") AS   ( select a.codts, a.code_entite, a.date_eff, a.date_fin, gv.login, a.cid from std_struc_arbre a, sys_groupe_valideurs gv where a.groupe_valideurs=gv.groupe_valideurs  union all  select distinct a.codts, i.code_entite, i.date_eff, i.date_fin, gv.login, a.cid from std_struc_arbre a, std_struc_arbre_ratt_indirect i, sys_groupe_valideurs gv where a.groupe_valideurs=gv.groupe_valideurs and a.codts=i.codts and a.cid = i.cid and i.date_eff < a.date_fin and i.date_fin > a.date_eff and a.code_entite=i.code_ent_mere  ) 
##
HUB_SCH_LOGIN
==
CREATE OR REPLACE FORCE VIEW "HUB_SCH_LOGIN" ("LOGIN") AS   select distinct u.login from sys_usr_config u, sys_usr_connu c where c.NOMLONG='HUB' and u.LOGIN=c.LOGIN order by u.login  
##
JOUPART
==
CREATE OR REPLACE FORCE VIEW "JOUPART" ("CODFOR", "CODACT", "CODSES", "OCCSEQ", "MATRIC", "CODTYPJ", "NBJ") AS   ( SELECT CODFOR,CODACT,CODSES,OCCSEQ,MATRIC,'01' AS CODTYPJ, NBJTOT AS NBJ FROM FOR_FEUILLE_TEMPS WHERE (NBJTOT IS NOT NULL) UNION SELECT CODFOR,CODACT,CODSES,OCCSEQ,MATRIC,'02' AS CODTYPJ, NBHEBER AS NBJ FROM FOR_FEUILLE_TEMPS WHERE ( NBHEBER IS NOT NULL))  
##
LVRD_DICTIONNAIRE_IHM
=SQL=
Create or replace view LVRD_DICTIONNAIRE_IHM (COMPANY_ID, NOM_DICTIONNAIRE, LIBELLE_DICTIONNAIRE, TYPE_CLE_SALARIE, CHAMPS_CLE, EST_SUPPRIME,NUM_LIVRABLE) AS 
(SELECT COMPANY_ID,
  NOM_DICTIONNAIRE,
  LIBELLE_DICTIONNAIRE,
  TYPE_CLE_SALARIE,
  CHAMPS_CLE,  
  EST_SUPPRIME,
  NUM_LIVRABLE
FROM LVRD_DICTIONNAIRE
UNION
SELECT 'TGE',
  'DIC_ADM_PERSO',
  'Données administratives personnelles',
  'R',
  NULL,
  NULL,
  NULL
FROM DUAL
UNION
SELECT 'TGE',
  'DIC_ADM_PERSO_HISTO',
  'Données administratives personnelles (historisées)',
  'R',
  NULL,
  NULL,
  NULL
FROM DUAL
UNION
SELECT 'TGE',
  'DIC_ADM_CONTRAT',
  'Données administratives contractuelles',
  'P',
  NULL,
  NULL,
  NULL
FROM DUAL
UNION
SELECT 'TGE',
  'DIC_ADM_CONTRAT_HISTO',
  'Données administratives contractuelles (historisées)',
  'P',
  NULL,
  NULL,
  NULL
FROM DUAL
UNION
SELECT 'TGE',
  'DIC_DONNEES_VIRTUELLES',
  'Données virtuelles (non-stockées)',
  NULL,
  NULL,
  NULL,
  NULL
FROM DUAL
)
##
LVRD_ECRAN_GROUPE_DONNEE_LIGHT
=SQL=
 CREATE OR REPLACE FORCE VIEW LVRD_ECRAN_GROUPE_DONNEE_LIGHT (NUM_LIVRABLE,COMPANY_ID, NOM_PAGE, ID_GROUPE_ECRAN, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ID_GROUPE_DONNEES) AS 
  SELECT 
  MLGD.NUM_LIVRABLE,
  MLGD.COMPANY_ID,
 ME.NOM_PAGE,
 ME.ID_GROUPE_DONNEES,
 MLGD.NOM_DONNEE,
 MLGD.SUFFIXE_OU_LIBELLE,
 MLGD.ID_GROUPE_DONNEES
 FROM LVRD_LIEN_GROUPE_DONNEE_LIGHT MLGD,
 LVRD_ECRAN ME
 WHERE MLGD.COMPANY_ID   =ME.COMPANY_ID
 AND ME.ID_GROUPE_DONNEES=MLGD.ID_GROUPE
 AND ME.NUM_LIVRABLE=MLGD.NUM_LIVRABLE
 UNION ALL
 SELECT 
 MLGD.NUM_LIVRABLE,
 MLGD.COMPANY_ID,
 'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
 MWOE.RECAP_ID_GROUPE_1,
 MLGD.NOM_DONNEE,
 MLGD.SUFFIXE_OU_LIBELLE,
 MLGD.ID_GROUPE_DONNEES
 FROM LVRD_LIEN_GROUPE_DONNEE_LIGHT MLGD,
 LVRD_WKF_OPERATION_ECRANS MWOE
 WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
 AND MWOE.RECAP_ID_GROUPE_1=MLGD.ID_GROUPE
 AND MWOE.NUM_LIVRABLE=MLGD.NUM_LIVRABLE
 UNION ALL
 SELECT 
 MLGD.NUM_LIVRABLE,
 MLGD.COMPANY_ID,
 'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
 MWOE.RECAP_ID_GROUPE_2,
 MLGD.NOM_DONNEE,
 MLGD.SUFFIXE_OU_LIBELLE,
 MLGD.ID_GROUPE_DONNEES
 FROM LVRD_LIEN_GROUPE_DONNEE_LIGHT MLGD,
 LVRD_WKF_OPERATION_ECRANS MWOE
 WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
 AND MWOE.RECAP_ID_GROUPE_2=MLGD.ID_GROUPE
 AND MWOE.NUM_LIVRABLE=MLGD.NUM_LIVRABLE
 UNION ALL
 SELECT 
 MLGD.NUM_LIVRABLE,
 MLGD.COMPANY_ID,
 'RAPPELSAISIE_'||ME.NOM_PAGE,
 MWOE.RECHERCHE_ID_GROUPE_LECTURE,
 MLGD.NOM_DONNEE,
 MLGD.SUFFIXE_OU_LIBELLE,
 MLGD.ID_GROUPE_DONNEES
 FROM LVRD_LIEN_GROUPE_DONNEE_LIGHT MLGD,
 LVRD_ECRAN ME,
 LVRD_WKF_OPERATION_ECRANS MWOE
 WHERE MLGD.COMPANY_ID     =ME.COMPANY_ID
 AND MLGD.COMPANY_ID   =MWOE.COMPANY_ID
 AND MWOE.RECHERCHE_ID_GROUPE_LECTURE=MLGD.ID_GROUPE
 AND ME.NOM_PAGE=MWOE.ECRAN_NOM_PAGE
 AND ME.NUM_LIVRABLE=MLGD.NUM_LIVRABLE
 AND MWOE.NUM_LIVRABLE=MLGD.NUM_LIVRABLE
 ##
LVRD_ECRAN_IHM
=SQL=
CREATE OR REPLACE FORCE VIEW LVRD_ECRAN_IHM (NUM_LIVRABLE, COMPANY_ID, NOM_PAGE, LIBELLE_PAGE, COMPLEMENT_LIBELLE, CODE_DESTINATION, ROLE_ECRAN, NOM_DICTIONNAIRE, MODULE_ECRAN, BOUTONS_ECRAN, ID_GROUPE_DONNEES, TYPE_ECRAN, NOM_SERVICELET, ID_PROJET, NUM_VERSION_RD, EST_SUPPRIME, PERSONNALISE) AS 
  SELECT 
  NUM_LIVRABLE,
  COMPANY_ID,
 NOM_PAGE,
 LIBELLE_PAGE,
 NULL AS COMPLEMENT_LIBELLE,
 CODE_DESTINATION,
 ROLE_ECRAN,
 NOM_DICTIONNAIRE,
 MODULE_ECRAN,
 BOUTONS_ECRAN,
 ID_GROUPE_DONNEES,
 TYPE_ECRAN,
 NOM_SERVICELET,
 ID_PROJET,
 NUM_VERSION_RD,
 EST_SUPPRIME,
 PERSONNALISE
 FROM LVRD_ECRAN
 UNION ALL
 SELECT 
 NUM_LIVRABLE,
 COMPANY_ID,
 'GEN_PAGE_RECAP_'||OP_NUM||'_'||ID_GEN_PAGE AS NOM_PAGE,
 NVL(LIBELLE_ECRAN_RECAP,'Récapitulatif') AS LIBELLE_PAGE,
 '('||OP_NUM||') '||(SELECT ME.OP_LIBELLE FROM WKF_OPERATIONS ME WHERE ME.OP_NUM = LVRD_WKF_OPERATION_ECRANS.OP_NUM AND ME.COMP_WEB='_PARAM_DYN_') AS COMPLEMENT_LIBELLE,
 'WorkflowParamDyn' AS CODE_DESTINATION,
 '' AS ROLE_ECRAN,
 '' AS NOM_DICTIONNAIRE,
 ''||OP_NUM AS MODULE_ECRAN,
 NULL AS BOUTONS_ECRAN,
 RECAP_ID_GROUPE_1 AS ID_GROUPE_DONNEES,
 'W' AS TYPE_ECRAN,
 NULL AS NOM_SERVICELET,
 (SELECT ID_PROJET FROM LVRD_WKF_OPERATION_ECRANS_INFO WHERE LVRD_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=LVRD_WKF_OPERATION_ECRANS.COMPANY_ID AND LVRD_WKF_OPERATION_ECRANS_INFO.OP_NUM=LVRD_WKF_OPERATION_ECRANS.OP_NUM AND LVRD_WKF_OPERATION_ECRANS_INFO.NUM_LIVRABLE=LVRD_WKF_OPERATION_ECRANS.NUM_LIVRABLE) AS ID_PROJET,
 (SELECT NUM_VERSION_RD FROM LVRD_WKF_OPERATION_ECRANS_INFO WHERE LVRD_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=LVRD_WKF_OPERATION_ECRANS.COMPANY_ID AND LVRD_WKF_OPERATION_ECRANS_INFO.OP_NUM=LVRD_WKF_OPERATION_ECRANS.OP_NUM AND LVRD_WKF_OPERATION_ECRANS_INFO.NUM_LIVRABLE=LVRD_WKF_OPERATION_ECRANS.NUM_LIVRABLE) AS NUM_VERSION_RD,
 NULL AS EST_SUPPRIME,
 NULL AS PERSONNALISE
 FROM LVRD_WKF_OPERATION_ECRANS
 WHERE TYPE_ECRAN='RECAP' AND RECAP_ID_GROUPE_1 IS NOT NULL
 UNION ALL
 SELECT 
 NUM_LIVRABLE,
 COMPANY_ID,
 'GEN_PAGE_RECAP_'||OP_NUM||'_'||ID_GEN_PAGE AS NOM_PAGE,
 NVL(LIBELLE_ECRAN_RECAP,'Récapitulatif') AS LIBELLE_PAGE,
 '('||OP_NUM||') '||(SELECT ME.OP_LIBELLE FROM WKF_OPERATIONS ME WHERE ME.OP_NUM = LVRD_WKF_OPERATION_ECRANS.OP_NUM AND ME.COMP_WEB='_PARAM_DYN_') AS COMPLEMENT_LIBELLE,
 'WorkflowParamDyn' AS CODE_DESTINATION,
 '' AS ROLE_ECRAN,
 '' AS NOM_DICTIONNAIRE,
 ''||OP_NUM AS MODULE_ECRAN,
 NULL AS BOUTONS_ECRAN,
 RECAP_ID_GROUPE_2 AS ID_GROUPE_DONNEES,
 'W' AS TYPE_ECRAN,
 NULL AS NOM_SERVICELET,
 (SELECT ID_PROJET FROM LVRD_WKF_OPERATION_ECRANS_INFO WHERE LVRD_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=LVRD_WKF_OPERATION_ECRANS.COMPANY_ID AND LVRD_WKF_OPERATION_ECRANS_INFO.OP_NUM=LVRD_WKF_OPERATION_ECRANS.OP_NUM AND LVRD_WKF_OPERATION_ECRANS_INFO.NUM_LIVRABLE=LVRD_WKF_OPERATION_ECRANS.NUM_LIVRABLE) AS ID_PROJET,
 (SELECT NUM_VERSION_RD FROM LVRD_WKF_OPERATION_ECRANS_INFO WHERE LVRD_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=LVRD_WKF_OPERATION_ECRANS.COMPANY_ID AND LVRD_WKF_OPERATION_ECRANS_INFO.OP_NUM=LVRD_WKF_OPERATION_ECRANS.OP_NUM AND LVRD_WKF_OPERATION_ECRANS_INFO.NUM_LIVRABLE=LVRD_WKF_OPERATION_ECRANS.NUM_LIVRABLE) AS NUM_VERSION_RD,
 NULL AS EST_SUPPRIME,
 NULL AS PERSONNALISE
 FROM LVRD_WKF_OPERATION_ECRANS
 WHERE TYPE_ECRAN='RECAP' AND RECAP_ID_GROUPE_2 IS NOT NULL
##
LVRD_LIEN_GROUPES_DONNEES_ALL
=SQL=
CREATE OR REPLACE FORCE VIEW LVRD_LIEN_GROUPES_DONNEES_ALL (NUM_LIVRABLE,COMPANY_ID, ID_GROUPE, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ORDRE, ID_GROUPE_DONNEES)
                                                                                                   AS
WITH liensDonneesGroupes(NUM_LIVRABLE, company_id, id_groupe, nom_donnee, id_groupe_donnees, suffixe_ou_libelle) AS
  (SELECT 
  gd.NUM_LIVRABLE,
  gd.company_id,
    gd.id_groupe,
    CASE
      WHEN SUBSTR(gd.nom_donnee,1,1)='#'
      THEN gd.nom_donnee
        ||'£'
        ||gd.id_groupe
      ELSE gd.nom_donnee
    END AS nom_donnee,
    gd.id_groupe,
    gd.suffixe_ou_libelle
  FROM lvrd_groupe_donnees gd
  UNION ALL
  SELECT 
  l.NUM_LIVRABLE,
  l.company_id,
    l.id_groupe,
    CASE
      WHEN SUBSTR(gd.nom_donnee,1,1)='#'
      THEN gd.nom_donnee
        ||'£'
        ||gd.id_groupe
      ELSE gd.nom_donnee
    END AS nom_donnee,
    gd.id_groupe,
    gd.suffixe_ou_libelle
  FROM lvrd_groupe_donnees gd,
    liensDonneesGroupes l
  WHERE gd.company_id=l.company_id
  AND gd.id_groupe   =l.suffixe_ou_libelle
  AND l.nom_donnee LIKE '#GROUPE%'
  )
SELECT 
NUM_LIVRABLE,
company_id,
  id_groupe,
  CASE
    WHEN INSTR(nom_donnee,'£')=0
    THEN nom_donnee
    ELSE SUBSTR(nom_donnee,1,INSTR(nom_donnee,'£')-1)
  END AS nom_donnee,
  suffixe_ou_libelle,
  LVRD_ORDRE_DONNEE_IN_GROUPE(NUM_LIVRABLE, company_id, id_groupe, nom_donnee) AS ordre,
  id_groupe_donnees
FROM liensDonneesGroupes
##
LVRD_LIEN_GROUPE_DONNEE_LIGHT
=SQL=
CREATE OR REPLACE FORCE VIEW LVRD_LIEN_GROUPE_DONNEE_LIGHT (NUM_LIVRABLE, COMPANY_ID, ID_GROUPE, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ID_GROUPE_DONNEES)
AS
  SELECT 
    NUM_LIVRABLE,
    COMPANY_ID,
    CONNECT_BY_ROOT(ID_GROUPE) AS ID_GROUPE,
    NOM_DONNEE,
    SUFFIXE_OU_LIBELLE,
    ID_GROUPE AS ID_GROUPE_DONNEES
  FROM LVRD_GROUPE_DONNEES
    START WITH 1                 =1
    CONNECT BY NOCYCLE ID_GROUPE = PRIOR SUFFIXE_OU_LIBELLE
   AND COMPANY_ID                 = PRIOR COMPANY_ID
   AND NUM_LIVRABLE = PRIOR NUM_LIVRABLE
   AND PRIOR NOM_DONNEE LIKE '#GROUPE%'
##
LVRD_WKF_LIBELLE
=SQL=
CREATE OR REPLACE FORCE VIEW LVRD_WKF_LIBELLE AS 
SELECT * FROM 
  (SELECT  H.NUM_LIVRABLE,H.NOM_PAGE,H.OP_NUM,H.LIBELLE_PAGE,AA.PROC_NUM,AA.PROC_LIBELLE,AA.OP_LIBELLE,H.COMPANY_ID
FROM
  (SELECT T1.NOM_PAGE,T1.COMPANY_ID,T2.OP_NUM,T1.NUM_LIVRABLE,T1.LIBELLE_PAGE
  	FROM LVRD_ECRAN T1
	  LEFT JOIN 
	  LVRD_WKF_OPERATION_ECRANS T2
	  ON  T1.NOM_PAGE     = T2.ECRAN_NOM_PAGE
	  AND T1.COMPANY_ID   = T2.COMPANY_ID
	  AND T1.NUM_LIVRABLE = T2.NUM_LIVRABLE
  )H
LEFT JOIN
  (SELECT DISTINCT TABLE_INFO_WKF.*,COMPANY_ID,LVRD_WKF_OPERATION_ECRANS.ECRAN_NOM_PAGE,LVRD_WKF_OPERATION_ECRANS.NUM_LIVRABLE
	  FROM LVRD_WKF_OPERATION_ECRANS
	  JOIN
	    (SELECT P.PROC_NUM,P.PROC_LIBELLE,O.OP_NUM,O.OP_LIBELLE
		    FROM 
		    WKF_PROCESSUS P
		    JOIN WKF_OPERATIONS O
		    ON O.proc_num  = P.PROC_NUM
	    ) TABLE_INFO_WKF 
	    ON TABLE_INFO_WKF.OP_NUM = LVRD_WKF_OPERATION_ECRANS.OP_NUM 
	 
	  ) AA  ON AA.ECRAN_NOM_PAGE = H.NOM_PAGE AND H.OP_NUM = AA.OP_NUM  AND AA.NUM_LIVRABLE = H.NUM_LIVRABLE
  )
##
MASS_LISTE
=SQL=
create or replace view MASS_LISTE as 
SELECT M.NUM_SAISIE,
  L.nom_page as NOMPAGE,
  M.LOGIN,
  TO_CHAR(M.DTMODIF,'DD.MM.YYYY') as DTMODIF,
  TO_CHAR(M.DTCREAT,'DD.MM.YYYY') as DTCREAT,
  NVL(RTRIM((SELECT H.NOM||' '||H.PRENOM FROM SYS_USR_CONFIG_IHM H WHERE H.LOGIN =M.LOGINCREAT)),M.LOGINCREAT) as LOGINCREAT,
  nvl(M.NBTOT,0) as NBTOT,
  nvl(M.NBERR,0) as NBERR,
  M.NUM_SAISIE_ORIGIN,
  (select max(L.libelle_saisie) from mass_liste_saisies L where L.nompage like '%'||M.nompage||'%'  and L.num_saisie = M.num_saisie ) as libelle,
 nvl((CASE
  when (select count(*) from mass_saisies_ligne S where s.num_saisie=M.num_saisie )>0 then 
    (select count(*) from mass_saisies_ligne S where s.num_saisie=M.num_saisie and valide is not null ) 
  ELSE
    0
    END),0) as  NBVALIDE,
    L.LIBELLE as libelle_page
FROM MASS_LISTE_SAISIES M LEFT JOIN sys_sch_element L ON  L.nom_page like 'Ext%'||M.nompage and L.nom_page not like 'Ext%BacASable%'||M.nompage
WHERE NOMPAGE is not null and DTCREAT is not null 
##
METAGT
==
CREATE OR REPLACE FORCE VIEW "METAGT" ("MATRIC", "DATDEB", "DATFIN", "CODFMET", "CODMETIER") AS   SELECT MATRIC,DATDEB,DATFIN,CODFMET,CODMETIER FROM POS_METAGT  
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_ERREURS_PARAMETRAGES
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_ERREURS_PARAMETRAGES"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_ERREURS_PARAMETRAGES
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_ERREURS_PARAMETRAGES" ("DATE_MAJ", "NIVEAU_GRAVITE", "TYPE_OBJET", "NOM_OBJET", "MSG_ERREURS", "ERREUR")
BUILD IMMEDIATE
USING INDEX 
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  WITH liensdonneesgroupes_trav (
    company_id,
    id_groupe,
    id_groupe_fils,
    nom_donnee,
    infos_diverses,
    chemin,
    ordre
  ) AS (
    SELECT
      gd.company_id,
      gd.id_groupe,
      case when gd.nom_donnee like '#GROUPE%' then gd.suffixe_ou_libelle else '' end id_groupe_fils,
      case when gd.nom_donnee not like '#GROUPE%' then gd.nom_donnee else '' end nom_donnee,
      gd.TABLEAU_REQUETE_NOMPAGE || ';' || gd.TABLEAU_REQUETE_IDREQUETE || ';' || gd.NOM_PAGE_AJOUT || ';' || gd.NOM_PAGE_MODIF,
      '' chemin,
      LPAD(gd.ordre, 4, '0') ordre
    FROM
      ref_groupe_donnees gd
    UNION ALL
    SELECT
      l_parent.company_id,
      l_parent.id_groupe,
      case when gd.nom_donnee like '#GROUPE%' then gd.suffixe_ou_libelle else '' end id_groupe_fils,
      case when gd.nom_donnee not like '#GROUPE%' then gd.nom_donnee else '' end nom_donnee,
      gd.TABLEAU_REQUETE_NOMPAGE || ';' || gd.TABLEAU_REQUETE_IDREQUETE || ';' || gd.NOM_PAGE_AJOUT || ';' || gd.NOM_PAGE_MODIF,
      chemin || '/' || l_parent.id_groupe_fils chemin,
      l_parent.ordre || LPAD(gd.ordre, 4, '0') ordre
    FROM 
      liensdonneesgroupes_trav l_parent
      inner join ref_groupe_donnees gd on gd.company_id=l_parent.company_id and gd.id_groupe=l_parent.id_groupe_fils    
  ),
  liensdonneesgroupes (
    company_id,
    id_groupe,
    id_groupe_fils,
    nom_donnee,
    infos_diverses,
    chemin,
    ordre
  ) as (
    select 
      company_id, 
      id_groupe, 
      id_groupe_fils, 
      nom_donnee, 
      infos_diverses, 
      nvl(chemin, id_groupe) chemin, 
      ROW_NUMBER() OVER (PARTITION BY company_id, id_groupe ORDER BY ordre) ordre
    from 
      liensdonneesgroupes_trav
    WHERE 
      nom_donnee is not null
  ),
  liensdonneesgroupesSansMiseEnForme (
    company_id,
    id_groupe,
    id_groupe_fils,
    nom_donnee,
    infos_diverses,
    chemin,
    ordre
  ) as (
    select 
      company_id, 
      id_groupe, 
      id_groupe_fils, 
      nom_donnee, 
      infos_diverses, 
      nvl(chemin, id_groupe) chemin, 
      ROW_NUMBER() OVER (PARTITION BY company_id, id_groupe ORDER BY ordre) ordre
    from 
      liensdonneesgroupes
    WHERE 
      nom_donnee is not null
      and nom_donnee not like '#EOL%'
      and nom_donnee not like '#TEXTE%'
      and nom_donnee not like '#LIBELLE%'
      and nom_donnee not like '#SEP_ZONE%'
      and nom_donnee not like '#TABLEAU%'
      and nom_donnee not like '#BOUTON%'
  ),
  rechercheProximiteGroupe (
    company_id, 
    id_groupe, 
    id_groupe_similaire, 
    nb_rapprochement
  ) as (
    select 
      g1.company_id, 
      g1.id_groupe, 
      g2.id_groupe, 
      count(*)
    from 
      liensdonneesgroupes g1
      inner join liensdonneesgroupes g2 on g1.company_id=g2.company_id and g1.nom_donnee=g2.nom_donnee and g1.ordre=g2.ordre and g1.infos_diverses=g2.infos_diverses
    where 
      g1.id_groupe!=g2.id_groupe
    group by 
      g1.company_id, 
      g1.id_groupe, 
      g2.id_groupe
  )  
  select 
    SYSDATE DATE_MAJ, 
    NIVEAU_GRAVITE, 
    TYPE_OBJET, 
    NOM_OBJET, 
    NIVEAU_GRAVITE || ' - ' || MSG_ERREURS, 
    ERREUR 
  from (
    select 
      'GROUPE' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID_GROUPE NOM_OBJET, 
      'Référence dans un groupe à une donnée inconnue' MSG_ERREURS, 
      NOM_DONNEE ERREUR  
    from 
      meta_groupe_donnees
    where 
      NOM_DONNEE not like '#%'
      and nom_donnee not in (
        select 
          nom_donnee 
        from 
          meta_donnee_ecran
      )
    UNION ALL
    select 
      'WKF_OPERATIONS' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      '' || OP_NUM NOM_OBJET, 
      'Référence à un processus inexistant' MSG_ERREURS, 
      '' || PROC_NUM ERREUR   
    from 
      wkf_operations 
    where 
      proc_num not in (
        select 
          proc_num 
        from 
          wkf_processus 
        where 
          proc_num is not null
      )
    UNION ALL
    select 
      'WKF_OPERATIONS' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      '' || OP_NUM NOM_OBJET, 
      'Aucun écran wkf associé à l opération' MSG_ERREURS, 
      '' ERREUR   
    from 
      wkf_operations 
    where 
      COMP_WEB='_PARAM_DYN_' 
      and op_num not in (
        select 
          op_num 
        from 
          meta_wkf_operation_ecrans
      )
    UNION ALL
    select 
      'META_WKF_OPERATION_ECRAN' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      '' || OP_NUM NOM_OBJET, 
      'Paramétrage wkf sur opération inexistante' MSG_ERREURS, 
      '' || OP_NUM ERREUR   
    from 
      meta_wkf_operation_ecrans 
    where 
      op_num not in (
        select 
          op_num 
        from 
          wkf_operations 
        where 
          op_num is not null
      )
    UNION ALL
    select 
      'META_WKF_OPERATION_ECRANS_INFO' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      '' || OP_NUM NOM_OBJET, 
      'Paramétrage wkf sur opération inexistante' MSG_ERREURS, 
      '' || OP_NUM ERREUR   
    from 
      meta_wkf_operation_ecrans_info 
    where 
      op_num not in (
        select 
          op_num 
        from 
          wkf_operations 
        where 
          op_num is not null
      )
    UNION ALL
    select 
      'META_DONNEE_ECRAN' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      NOM_DONNEE NOM_OBJET, 
      'Donnée sans donnée générale associé' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_donnee_ecran 
    where 
      nom_donnee not in (
        select 
          nom_donnee 
        from 
          meta_donnee_generale
      )
    UNION ALL
    select 
      'META_DONNEE_GENERALE' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      NOM_DONNEE NOM_OBJET, 
      'Donnée générale sans ergo générale' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_donnee_generale 
    where 
      nom_donnee not in (
        select 
          nom_donnee 
        from 
          meta_donnee_ecran 
        where 
          nom_page='*'
      )
    UNION ALL
    select 
      'META_REGLEGESTION' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID_REGLEGESTION NOM_OBJET, 
      'Règle non référencée dans meta_reglegestion_desc' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_reglegestion 
    where 
      id_reglegestion not in (
        select 
          id_reglegestion 
        from 
          meta_reglegestion_desc
      )
    UNION ALL
    select 
      'META_REGLEGESTION_DESC' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID_REGLEGESTION NOM_OBJET, 
      'Règle non référencée dans meta_reglegestion' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_reglegestion_desc
    where 
      id_reglegestion not in (
        select 
          id_reglegestion 
        from 
          meta_reglegestion
      )
    UNION ALL
    select 
      'META_ECRAN' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      NOM_PAGE NOM_OBJET, 
      'Id_projet inconnu' MSG_ERREURS, 
      '' || ID_PROJET ERREUR   
    from 
      meta_ecran 
    where 
      id_projet is not null 
      and id_projet not in (
        select 
          id_projet 
        from 
          meta_projet 
        where 
          termine!='O'
      )
    UNION ALL
    select 
      'META_DONNEE_GENERALE' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      NOM_DONNEE NOM_OBJET, 
      'Id_projet inconnu' MSG_ERREURS, 
      '' || ID_PROJET ERREUR   
    from 
      meta_donnee_generale
    where 
      id_projet is not null 
      and id_projet not in (
        select 
          id_projet 
        from 
          meta_projet 
        where 
          termine!='O'
      )
    UNION ALL
    select 
      'META_GROUPE_DONNEES_INFO' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID_GROUPE NOM_OBJET, 
      'Id_projet inconnu' MSG_ERREURS, 
      '' || ID_PROJET ERREUR   
    from 
      meta_groupe_donnees_info
    where 
      id_projet is not null 
      and id_projet not in (
        select 
          id_projet 
        from 
          meta_projet 
        where 
          termine!='O'
      )
    UNION ALL
    select 
      'META_REGLEGESTION_DESC' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID_REGLEGESTION NOM_OBJET, 
      'Id_projet inconnu' MSG_ERREURS, 
      '' || ID_PROJET ERREUR   
    from 
      meta_reglegestion_desc
    where 
      id_projet is not null 
      and id_projet not in (
        select 
          id_projet 
        from 
          meta_projet 
        where 
          termine!='O'
      )
    UNION ALL
    select 
      TYPE_DONNEE TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      ID NOM_OBJET, 
      'Référence à une règle de gestion inconnue' MSG_ERREURS, 
      ID_REGLE ERREUR 
    from (
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_AUT_RD ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_AUT_RD is not null
      UNION ALL 
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_AUT_CLI ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_AUT_CLI is not null
      UNION ALL 
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_AFF_RD ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_AFF_RD is not null
      UNION ALL 
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_AFF_CLI ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_AFF_CLI is not null
      UNION ALL 
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_CTL_RD ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_CTL_RD is not null
      UNION ALL 
      select 
        'META_DONNEE_ECRAN' TYPE_DONNEE, 
        NOM_DONNEE||'-'||NOM_PAGE ID, 
        ID_REGLEGESTION_CTL_CLI ID_REGLE  
      from 
        META_DONNEE_ECRAN 
      where 
        ID_REGLEGESTION_CTL_CLI is not null
      UNION ALL 
      select 
        'META_ECRAN' TYPE_DONNEE, 
        NOM_PAGE ID, 
        ID_REGLEGESTION_AUT_RD ID_REGLE  
      from 
        META_ECRAN 
      where 
        ID_REGLEGESTION_AUT_RD is not null
      UNION ALL 
      select 
        'META_ECRAN' TYPE_DONNEE, 
        NOM_PAGE ID, 
        ID_REGLEGESTION_AUT_CLI ID_REGLE  
      from 
        META_ECRAN 
      where 
        ID_REGLEGESTION_AUT_CLI is not null
      UNION ALL 
      select 
        'META_ECRAN' TYPE_DONNEE, 
        NOM_PAGE ID, 
        ID_REGLEGESTION_CTL_RD ID_REGLE  
      from 
        META_ECRAN 
      where 
        ID_REGLEGESTION_CTL_RD is not null
      UNION ALL 
      select 
        'META_ECRAN' TYPE_DONNEE, 
        NOM_PAGE ID, 
        ID_REGLEGESTION_CTL_CLI ID_REGLE  
      from 
        META_ECRAN 
      where 
        ID_REGLEGESTION_CTL_CLI is not null
      UNION ALL 
      select 
        'META_GROUPE_DONNEES' TYPE_DONNEE, 
        ID_GROUPE ID, 
        ID_REGLEGESTION_CTL_RD_SUPP ID_REGLE  
      from 
        META_GROUPE_DONNEES 
      where 
        ID_REGLEGESTION_CTL_RD_SUPP is not null
      UNION ALL 
      select 
        'META_GROUPE_DONNEES' TYPE_DONNEE, 
        ID_GROUPE ID, 
        ID_REGLEGESTION_CTL_CLI_SUPP ID_REGLE  
      from 
        META_GROUPE_DONNEES 
      where 
        ID_REGLEGESTION_CTL_CLI_SUPP is not null
      UNION ALL 
      select 
        'META_GROUPE_DONNEES_INFO' TYPE_DONNEE, 
        ID_GROUPE ID, 
        ID_REGLEGESTION_AFF_RD ID_REGLE  
      from 
        META_GROUPE_DONNEES_INFO 
      where 
        ID_REGLEGESTION_AFF_RD is not null
      UNION ALL 
      select 
        'META_GROUPE_DONNEES_INFO' TYPE_DONNEE, 
        ID_GROUPE ID, 
        ID_REGLEGESTION_AFF_CLI ID_REGLE  
      from 
        META_GROUPE_DONNEES_INFO 
      where 
        ID_REGLEGESTION_AFF_CLI is not null
      UNION ALL 
      select 
        'META_WKF_OPERATION_ECRANS' TYPE_DONNEE, 
        OP_NUM||'-'||ECRAN_NOM_PAGE, 
        ECRAN_ID_REGLEGESTION_COND ID_REGLE  
      from 
        META_WKF_OPERATION_ECRANS 
      where 
        ECRAN_ID_REGLEGESTION_COND is not null
      UNION ALL 
      select 
        'META_WKF_OPERATION_ECRANS' TYPE_DONNEE, 
        OP_NUM||'-'||ECRAN_NOM_PAGE, 
        RECHERCHE_ID_REGLEGESTION_CTL ID_REGLE  
      from 
        META_WKF_OPERATION_ECRANS 
      where 
        RECHERCHE_ID_REGLEGESTION_CTL is not null
    )
    where ID_REGLE not in ( 
      select 
        id_reglegestion 
      from 
        meta_reglegestion_desc
    )
    UNION ALL
    select 
      'META_DONNEE_ECRAN' TYPE_OBJET, 
      '1' NIVEAU_GRAVITE, 
      NOM_DONNEE NOM_OBJET, 
      'Ergo dédiée sur page inconnue' MSG_ERREURS, 
      NOM_PAGE ERREUR  
    from 
      meta_donnee_ecran 
    where 
      nom_page!='*' 
      and nom_page not in (
        select 
          nom_page 
        from 
          meta_ecran
        union all
        select 
          'GEN_PAGE_RECAP_' || OP_NUM || '_' || ID_GEN_PAGE  
        from 
          meta_wkf_operation_ecrans
      )
    UNION ALL
    select 
      'META_GROUPE_DONNEES' TYPE_OBJET, 
      '2' NIVEAU_GRAVITE, 
      ID_GROUPE NOM_OBJET, 
      'Groupe non utilisé' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_groupe_donnees_info
    where 
      id_groupe not in (
        select id_groupe from (
          select 
            'META_ECRAN' TYPE_DONNEE, 
            NOM_PAGE NOM_OBJET, 
            ID_GROUPE_DONNEES ID_GROUPE  
          from 
            META_ECRAN 
          where 
            ID_GROUPE_DONNEES is not null
          UNION ALL 
          select 
            'META_WKF_OPERATION_ECRANS' TYPE_DONNEE, 
            OP_NUM||'-'||ECRAN_NOM_PAGE NOM_OBJET, 
            RECHERCHE_ID_GROUPE_LECTURE ID_GROUPE  
          from 
            META_WKF_OPERATION_ECRANS 
          where 
            RECHERCHE_ID_GROUPE_LECTURE is not null
          UNION ALL 
          select 
            'META_WKF_OPERATION_ECRANS' TYPE_DONNEE, 
            OP_NUM||'-'||ECRAN_NOM_PAGE, 
            RECAP_ID_GROUPE_1 ID_GROUPE  
          from 
            META_WKF_OPERATION_ECRANS 
          where 
            RECAP_ID_GROUPE_1 is not null
          UNION ALL 
          select 
            'META_WKF_OPERATION_ECRANS' TYPE_DONNEE, 
            OP_NUM||'-'||ECRAN_NOM_PAGE, 
            RECAP_ID_GROUPE_2 ID_GROUPE  
          from 
            META_WKF_OPERATION_ECRANS 
          where 
            RECAP_ID_GROUPE_2 is not null
          UNION ALL 
          select 
            'META_WKF_OPERATION_ECRANS_INFO' TYPE_DONNEE, 
            '' || OP_NUM, 
            ID_GROUPE_ECRITURE ID_GROUPE  
          from 
            META_WKF_OPERATION_ECRANS_INFO 
          where 
            ID_GROUPE_ECRITURE is not null
          UNION ALL
          select 
            'META_GROUPE_DONNEES' TYPE_DONNEE, 
            ID_GROUPE, 
            SUFFIXE_OU_LIBELLE ID_GROUPE 
          from 
            meta_groupe_donnees 
          where 
            NOM_DONNEE like '#GROUP%'
        )
      )
    UNION ALL
    select 
      'META_ECRAN' TYPE_OBJET, 
      '2' NIVEAU_GRAVITE, 
      NOM_PAGE NOM_OBJET, 
      'Ecran WKF non utilisé' MSG_ERREURS, 
      '' ERREUR   
    from 
      meta_ecran 
    where 
      type_ecran='W'
      and nom_page not in (
        select 
          ecran_nom_page 
        from 
          meta_wkf_operation_ecrans 
        where 
          ecran_nom_page is not null
        union all
        select 
          ecran_nom_page_alternatif 
        from 
          meta_wkf_operation_ecrans 
        where 
          ecran_nom_page_alternatif is not null
      )
/*
    UNION ALL
    select 
      'DONNEE' TYPE_OBJET, 
      liensdonneesgroupesSansMiseEnForme.nom_donnee NOM_OBJET, 
      'Données présentes plusieurs fois dans un écran' MSG_ERREURS,  
      ref_ecran.nom_page || ' : ' ||  listagg(liensdonneesgroupesSansMiseEnForme.chemin, ' et ') 
    from 
      liensdonneesgroupesSansMiseEnForme
      inner join ref_ecran on ref_ecran.id_groupe_donnees=liensdonneesgroupesSansMiseEnForme.id_groupe and ref_ecran.company_id=liensdonneesgroupesSansMiseEnForme.company_id
    group by 
      ref_ecran.libelle_page, 
      ref_ecran.nom_page, 
      liensdonneesgroupesSansMiseEnForme.nom_donnee
    having 
      count(*)>1
    order by 
      1, 2, 3
    UNION ALL
    select 
      * 
    from 
      rechercheProximiteGroupe
    where 
      nb_rapprochement = (
        select 
          count(*) 
        from 
          liensdonneesgroupes g1 
        where 
          g1.company_id=rechercheProximiteGroupe.company_id 
          and g1.id_groupe=rechercheProximiteGroupe.id_groupe_similaire
      )
*/
  )
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_MODELE_DONNEES"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_MODELE_DONNEES
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_MODELE_DONNEES" ("DATE_MAJ", "ALP_ESPACE", "ALP_REGROUPEMENT", "ALP_THEME", "ALP_LIBELLE_PAGE", "ALP_NOM_PAGE", "ALP_ONGLET", "ALP_ORDRE", "ALP_DONNEE", "ALP_DONNEE_LIBELLE", "ALP_DICTIONNAIRE", "TYPE_DONNEE", "ALP_DONNEE_ELT", "MODE_SAISIE", "REFERENTIEL", "PROFILS_HABILITES")
BUILD IMMEDIATE
USING INDEX 
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  WITH liensdonneesgroupes (
    company_id,
    id_groupe,
    nom_donnee,
    id_groupe_donnees,
    suffixe_ou_libelle,
    onglet,
    ordre
  ) AS (
    SELECT
      gd.company_id,
      gd.id_groupe,
      CASE
        WHEN substr(gd.nom_donnee, 1, 1) = '#' THEN gd.nom_donnee || '£' || gd.id_groupe
        ELSE gd.nom_donnee
      END AS nom_donnee,
      gd.id_groupe,
      gd.suffixe_ou_libelle,
      '',
      LPAD(gd.ordre, 4, '0')
    FROM
      ref_groupe_donnees gd
    UNION ALL
    SELECT
      l.company_id,
      l.id_groupe,
      CASE
        WHEN substr(gd.nom_donnee, 1, 1) = '#' THEN gd.nom_donnee || '£' || gd.id_groupe
        ELSE gd.nom_donnee
      END AS nom_donnee,
      gd.id_groupe,
      gd.suffixe_ou_libelle,
      decode(gd_info.est_onglet, 'O', gd_info.libelle_groupe, l.onglet),
      l.ordre||LPAD(gd.ordre, 4, '0')
    FROM
      ref_groupe_donnees        gd,
      liensdonneesgroupes        l,
      ref_groupe_donnees_info   gd_info
    WHERE
      gd.company_id = l.company_id
      AND gd.id_groupe = gd_info.id_groupe
      AND gd.id_groupe = l.suffixe_ou_libelle
      AND l.nom_donnee LIKE '#GROUPE%'
  )
  select 
    SYSDATE DATE_MAJ,
    espace_elt.libelle alp_espace,
    regroupement_elt.libelle alp_regroupement,
    theme_elt.libelle alp_theme,
    page_elt.libelle
    || (
      CASE
        WHEN sys_pages_modal_restriction.nom_page_modale IS NOT NULL THEN ' (popup)'
        ELSE ''
      END
    ) alp_libelle_page,
    e.nom_page alp_nom_page, 
    liensdonneesgroupes.onglet alp_onglet,
    row_number () over (partition by e.nom_page order by liensdonneesgroupes.ordre asc) alp_ordre,
    liensdonneesgroupes.nom_donnee alp_donnee,
    nvl(ref_donnee_ecran.libelle_donnee, ref_donnee_ecran_defaut.libelle_donnee)alp_donnee_libelle,
    ref_donnee_generale.nom_dictionnaire alp_dictionnaire,
    case 
      when ref_donnee_generale.type_donnee='9' then 'N' || ref_donnee_generale.longueur_masque_nb_entiers  || CASE WHEN NVL(ref_donnee_generale.nb_decimaux, 0)>0 THEN  '.' || ref_donnee_generale.nb_decimaux  ElSE '' END
      when ref_donnee_generale.type_donnee='N' then 'N' || ref_donnee_generale.longueur_masque_nb_entiers 
      when ref_donnee_generale.type_donnee='D' then ref_donnee_generale.longueur_masque_nb_entiers
      when ref_donnee_generale.type_donnee='X' then 'X'||ref_donnee_generale.longueur_masque_nb_entiers
      else ref_donnee_generale.type_donnee 
    end as type_donnee,
    RTRIM((select linearisereq('select distinct tge_ref_mapdo.numpac ||'':'' || element from tge_ref_mapdo where tge_ref_mapdo.donneegxp=''' || ref_donnee_generale.nom_donnee ||''' and nvl(occurence, ''*'')!=''!!''' , ',') from dual), ',')
    alp_donnee_elt,
    case 
      when ref_donnee_ecran_defaut.nom_donnee='LINAIS' then 'text' 
      when nvl(ref_donnee_ecran.mode_saisie, ref_donnee_ecran_defaut.mode_saisie)='searchStruct' 
      then 'hro - '||nvl(substr(ref_donnee_ecran.search_structure_param, instr(ref_donnee_ecran.search_structure_param, 'CODTS='),  7), substr(ref_donnee_ecran_defaut.search_structure_param, instr(ref_donnee_ecran_defaut.search_structure_param, 'CODTS='),  7) )
      else nvl(ref_donnee_ecran.mode_saisie, ref_donnee_ecran_defaut.mode_saisie) 
    end as MODE_SAISIE,
    case 
      when nvl(ref_donnee_ecran.mode_saisie, ref_donnee_ecran_defaut.mode_saisie)='checkbox' then ref_donnee_generale.checkbox_valeur_on || '/' || ref_donnee_generale.checkbox_valeur_off  
      when sys_requetes_jsp.nomtable = q'[ (select 'O' as code,'Oui' as libelle  from dual union select 'N' as Code,'Non' as Libelle from dual)]' then 'O/N-slh'
      else sys_requetes_jsp.nomtable 
    end referentiel,
    RTRIM((
      select linearisereq(
        'select sys_sch_profil.code_profil from sys_sch_profil inner join sys_sch_profil_p on sys_sch_profil_p.code_profil=sys_sch_profil.code_profil and sys_sch_profil_p.nom_page=''' || page_elt.nom_page || ''''
        , ', '
      ) 
      from dual
    ), ', ') as profils_habilites
  from 
    ref_ecran e
    left outer join sys_pages_modal_restriction ON nom_page_modale = 'Ext.adp.Modules.' || e.code_destination || '.'  || e.module_ecran || '.'  || e.role_ecran || '.'  || e.nom_page || '.'  || e.nom_page    
    inner join sys_sch_element page_elt ON page_elt.nom_page = 'Ext.adp.Modules.' || e.code_destination || '.'  || e.module_ecran || '.'  || e.role_ecran || '.'  || e.nom_page || '.'  || e.nom_page or page_elt.nom_page = sys_pages_modal_restriction.nom_page_bur_liee    
    inner join sys_schemas page_lien ON page_elt.code_element = page_lien.code_elt AND page_elt.niveau = page_lien.niveau
    inner join sys_schemas theme_lien ON page_lien.code_asso_pere = theme_lien.code_asso
    inner join sys_sch_element theme_elt ON theme_lien.code_elt = theme_elt.code_element AND theme_lien.niveau = theme_elt.niveau
    inner join sys_schemas regroupement_lien ON theme_lien.code_asso_pere = regroupement_lien.code_asso
    inner join sys_sch_element regroupement_elt ON regroupement_lien.code_elt = regroupement_elt.code_element AND regroupement_lien.niveau = regroupement_elt.niveau
    inner join sys_schemas espace_lien ON regroupement_lien.code_asso_pere = espace_lien.code_asso
    inner join sys_sch_element espace_elt ON espace_lien.code_elt = espace_elt.code_element AND espace_lien.niveau = espace_elt.niveau
    inner join liensdonneesgroupes ON e.id_groupe_donnees = liensdonneesgroupes.id_groupe AND liensdonneesgroupes.company_id = '*'
    inner join ref_donnee_generale ON liensdonneesgroupes.nom_donnee = ref_donnee_generale.nom_donnee AND ref_donnee_generale.company_id = '*' and nvl(actif, 'O')='O'
    inner join ref_donnee_ecran ref_donnee_ecran_defaut ON ref_donnee_generale.nom_donnee = ref_donnee_ecran_defaut.nom_donnee AND ref_donnee_ecran_defaut.company_id = '*' AND ref_donnee_ecran_defaut.nom_page = '*'
    left outer join ref_donnee_ecran ON ref_donnee_generale.nom_donnee = ref_donnee_ecran.nom_donnee AND ref_donnee_ecran.company_id = '*' AND ref_donnee_ecran.nom_page = e.nom_page
    left outer join sys_requetes_jsp on sys_requetes_jsp.nompage=nvl(ref_donnee_ecran.appeltable_nompage, ref_donnee_ecran_defaut.appeltable_nompage) and sys_requetes_jsp.idrequete=nvl(ref_donnee_ecran.appeltable_idrequete, ref_donnee_ecran_defaut.appeltable_idrequete)
  where
    1=1
    and ref_donnee_ecran_defaut.nom_donnee not in ('TRAV_LINAIS_ET', 'TRAV_LINAIS_FR')
    and (nvl(ref_donnee_ecran.mode_saisie, ref_donnee_ecran_defaut.mode_saisie) not in ('hidden') or ref_donnee_ecran_defaut.nom_donnee='LINAIS')
    and (ref_donnee_generale.nom_dictionnaire like e.nom_dictionnaire||'%' or ref_donnee_generale.nom_dictionnaire='DIC_DONNEES_VIRTUELLES')
    and page_elt.nom_page in (select nom_page from sys_sch_profil_p)
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_RECHERCHE_GLOBALE
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_RECHERCHE_GLOBALE"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_RECHERCHE_GLOBALE
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_RECHERCHE_GLOBALE" ("DATE_MAJ", "THEME", "TYPE_OBJ", "OBJ", "DATA")
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  select 
    * 
  from (
    select SYSDATE DATE_MAJ, 
      THEME, 
      TYPE_OBJ, 
      UPPER(obj) OBJ, 
      TO_CLOB(regexp_replace(DATA, '\s', ' ')) DATA 
    from (
      select 
        'Tools Ecran' THEME, 
        'META_ECRAN' TYPE_OBJ, 
        NOM_PAGE OBJ, 
        TO_CLOB(COMPANY_ID || ' | ' || NOM_PAGE || ' | ' || LIBELLE_PAGE || ' | ' || CODE_DESTINATION || ' | ' || ROLE_ECRAN || ' | ' || NOM_DICTIONNAIRE || ' | ' || MODULE_ECRAN || ' | ' || BOUTONS_ECRAN || ' | ' || ID_GROUPE_DONNEES || ' | ' || TYPE_ECRAN || ' | ' || NOM_SERVICELET || ' | ' || ID_PROJET || ' | ' || NUM_VERSION_RD || ' | ' || EST_SUPPRIME || ' | ' || PERSONNALISE || ' | ' || ID_REGLEGESTION_AUT_RD || ' | ' || ID_REGLEGESTION_AUT_CLI || ' | ' || TYPE_REGLEGESTION_AUT_CLI || ' | ' || ID_REGLEGESTION_CTL_RD || ' | ' || ID_REGLEGESTION_CTL_CLI || ' | ' || TYPE_REGLEGESTION_CTL_CLI || ' | ' || CODEDI || ' | ' || TOUTES_PERIODES_EMPLOI || ' | ' || SURCHARGE_EDITION || ' | ' || PERSO_PJ_UX || ' | ' || DESCRIPTION_DA) DATA  
      from 
        META_ECRAN 
      where 
        company_id='*'
      UNION ALL
      select 
        'Tools Donnée', 
        'META_DONNEE_GENERALE', 
        NOM_DONNEE, 
        TO_CLOB(COMPANY_ID || ' | ' || NOM_DONNEE || ' | ' || LIBELLE_DONNEE || ' | ' || NOM_DICTIONNAIRE || ' | ' || TYPE_DONNEE || ' | ' || LONGUEUR_MASQUE_NB_ENTIERS || ' | ' || NB_DECIMAUX || ' | ' || CHECKBOX_VALEUR_ON || ' | ' || CHECKBOX_VALEUR_OFF || ' | ' || MODELE || ' | ' || UTILISATION || ' | ' || ACTIF || ' | ' || ID_PROJET || ' | ' || NUM_VERSION_RD || ' | ' || EST_SUPPRIME || ' | ' || PERSONNALISE || ' | ' || MINUSCULES_AUTORISEES || ' | ' || NOM_DONNEE_CLE_DIC_REFERENCE || ' | ' || PROPAGER_TOUTES_OCCURRENCES) DATA  
      from 
        META_DONNEE_GENERALE 
      where 
        company_id='*'
      UNION ALL
      select 
        'Tools Donnée', 
        'META_DONNEE_ECRAN', 
        NOM_DONNEE, 
        TO_CLOB(COMPANY_ID||' | ' || NOM_DONNEE||' | ' || NOM_PAGE||' | ' || LIBELLE_DONNEE||' | ' || EST_OBLIGATOIRE||' | ' || MODE_SAISIE||' | ' || APPELTABLE_NOMPAGE||' | ' || APPELTABLE_IDREQUETE||' | ' || APPELTABLE_LISTELIBELLE||' | ' || APPELTABLE_LISTECHAMPS||' | ' || APPELTABLE_PARAMETRES||' | ' || AFFICHE_CHOIX_VIDE_SELECT||' | ' || VALEUR_DEFAUT||' | ' || ID_REGLEGESTION_AUT_RD||' | ' || ID_REGLEGESTION_AUT_CLI||' | ' || TYPE_REGLEGESTION_AUT_CLI||' | ' || ID_REGLEGESTION_AFF_RD||' | ' || ID_REGLEGESTION_AFF_CLI||' | ' || TYPE_REGLEGESTION_AFF_CLI||' | ' || ID_REGLEGESTION_CTL_RD||' | ' || ID_REGLEGESTION_CTL_CLI||' | ' || TYPE_REGLEGESTION_CTL_CLI||' | ' || SEARCH_STRUCTURE_PARAM||' | ' || REFRESH_AFTER_CHANGE||' | ' || SPAN_CHECK_VALUE||' | ' || LIB_ALIGN_TOP||' | ' || NB_LIGNE_TEXTEAREA||' | ' || NB_COLONNE_TEXTEAREA) DATA  
      from 
        META_DONNEE_ECRAN 
      where 
        company_id='*'
      UNION ALL
      select
         'Appel Table/Tableau', 
        'SYS_REQUETES_JSP', 
        NOMPAGE||' | ' || IDREQUETE, 
        TO_CLOB(NOMPAGE||' | ' || IDREQUETE||' | ' || NOMBASE||' | ' || NOMTABLE||' | ' || LISTCOLAFF) || TO_CLOB(' | ' || LISTCOLSET||' | ' || CLAUSEWHERE) ||TO_CLOB(' | ' || CLAUSEMAX||' | ' || CLAUSEDISTINCT||' | ' || CLAUSEORDRE||' | ' || DESCREQ||' | ' || LIBREQ||' | ' || LISTLIBCOLAFF) 
      from 
        SYS_REQUETES_JSP
      UNION ALL
      select 
        'Règle gestion', 
        'META_REGLEGESTION_DESC', 
        ID_REGLEGESTION, 
        TO_CLOB(REGLE_SYNTHETIQUE||' | ' || COMPANY_ID||' | ' || ID_REGLEGESTION||' | ' || TYPE_REGLE||' | ' || LIBELLE||' | ' || ID_PROJET||' | ' || NUM_VERSION_RD||' | ' || EST_SUPPRIME||' | ' || REGLES_ECR||' | ' || DESCRIPTION||' | ' || FLAG_SPECIF_TYPE_REGLE||' | ' || PERSONNALISE||' | ' || REGLES_ALGO)  
      from 
        META_REGLEGESTION_DESC 
      where 
        company_id='*'
      UNION ALL
      select 
        'Groupe donnée', 
        'META_GROUPE_DONNEES_INFO', 
        ID_GROUPE, 
        TO_CLOB(COMPANY_ID||' | ' || ID_GROUPE||' | ' || ID_REGLEGESTION_AFF_RD||' | ' || ID_REGLEGESTION_AFF_CLI||' | ' || TYPE_REGLEGESTION_AFF_CLI||' | ' || EST_ONGLET||' | ' || ID_PROJET||' | ' || NUM_VERSION_RD||' | ' || EST_SUPPRIME||' | ' || LIBELLE_GROUPE||' | ' || DESCRIPTION_GROUPE||' | ' || PERSONNALISE) 
      from 
        META_GROUPE_DONNEES_INFO 
      where 
        company_id='*'
      UNION ALL
      select 
        'Groupe donnée', 
        'META_GROUPE_DONNEES', 
        ID_GROUPE, 
        TO_CLOB(DONNEE_CODE_EDITION ||' | ' || MESSAGE_CONFIRMATION||' | ' || BOUTONS_TABLEAU_MULTIPLE||' | ' || COMPANY_ID||' | ' || ID_GROUPE||' | ' || NOM_DONNEE||' | ' || ORDRE||' | ' || A_COTE_DONNEE_PRECEDENTE||' | ' || SUFFIXE_OU_LIBELLE||' | ' || TABLEAU_REQUETE_NOMPAGE||' | ' || TABLEAU_REQUETE_IDREQUETE||' | ' || NOM_PAGE_AJOUT||' | ' || NOM_PAGE_MODIF||' | ' || ID_REGLEGESTION_CTL_RD_SUPP||' | ' || ID_REGLEGESTION_CTL_CLI_SUPP||' | ' || TYPE_REGLEGESTION_CTL_CLI_SUPP||' | ' || MASQUER_LE_LIBELLE)  
      from 
        META_GROUPE_DONNEES 
      where 
        company_id='*'
      UNION ALL
      select 
        'Msg Erreurs', 
        'SYS_DEF_ERREURS', 
        CODERR, 
        TO_CLOB(CODERR ||' | ' || CODMOD ||' | ' || LIBERR ||' | ' || TYPERR) 
      from 
        SYS_DEF_ERREURS
      UNION ALL
      select 
        'Requête fusion', 
        'EDI_REQ_SQL', 
        NOMREQ, 
        TO_CLOB(NOMREQ || DELIMITEUR_TEXT || ' | ' || SEPAR_CHAMP || ' | ' || SEPAR_CHAMP_SR || ' | ' || AFFICHE_SR_VIDE || ' | ' || SANSDOUBLONS || ' | ' || PROPRIETAIRE) || ' | ' || FINREQ  DATA  
      from 
        EDI_REQ_SQL
      UNION ALL
      select 
        'Requête fusion', 
        'EDI_REQ_SQL_CF', 
        NOMREQ, 
        TO_CLOB(NOMREQ || ' | ' || NOMCHAMPFUSION || ' | ' || VALEURSELECT || ' | ' || SEPAR_CHAMP || ' | ' || ORDRE || ' | ' || TYPEDATA || ' | ' || LIBCHAMPFUSION || ' | ' || TAILLE)   DATA  
      from 
        EDI_REQ_SQL_CF
      UNION ALL
      select 
        'Alerte portail', 
        'ALERT_TREE', 
        ALERT_ID, 
        TO_CLOB(ALERT_ID || ' | ' || ALERT_LEAF || ' | ' || ALERT_TITLE || ' | ' || ALERT_PARENT_ID || ' | ' || ALERT_ORDER)   DATA  
      from 
        ALERT_TREE
      UNION ALL
      select 
        'Alerte portail', 
        'ALERT_PROP', 
        ALERT_ID, 
        TO_CLOB(ALERT_ID || ' | ' || ALERT_ORDER || ' | ' || ALERT_DESC || ' | ' || PAGE_REDIRECT || ' | ' || INDEX_SQL || ' | ' || ALERT_ACTIVATE || ' | ' || ALERT_WKF || ' | ' || SQL_SELECT || ' | ' || SQL_FROM || ' | ' || SQL_WHERE_1 || ' | ' || SQL_WHERE_2 || ' | ' || PEOPLE_ID || ' | ' || STR_ID || ' | ' || PACMAT_ID)   DATA  
      from 
        ALERT_PROP
      UNION ALL
      select 
        'Mapdo', 
        'TGE_REF_MAPDO', 
        NUMPAC || ' - ' || ELEMENT, 
        TO_CLOB(NUMPAC || ' - ' || ELEMENT ||' - ' || OCCURENCE || ' | ' || DONNEEGXP || ' | ' || TABLEGXP || ' | ' || DONNFILTRE || ' | ' || OPERFILTRE || ' | ' || VALFILTRE || ' | ' || TRTPARTICULIER || ' | ' || ENVOI_SYSTEMATIQUE || ' | ' || FORCABLE_ECRAN_GENERE)   DATA  
      from 
        TGE_REF_MAPDO
      UNION ALL
      select 
        'Structure table', 
        'TABLE', 
        table_name, 
        TO_CLOB(table_name) 
      from 
        user_tables
      UNION ALL
      select 
        'Structure table', 
        'COLONNE', 
        table_name || '.' ||column_name, 
        TO_CLOB(table_name || '.' ||column_name) 
      from 
        user_tab_cols
      UNION ALL
      select 
        'Sources', 
        type, 
        name, 
        linearisereq('select substr(text, 0, 2000) from user_source where name=''' || name || ''' order by line', ' ') 
      from 
        user_source 
      group by type, name
    )
  UNION ALL
    select 
      SYSDATE, 
      'Sources', 
      'VIEW', 
      VIEW_NAME, 
      TO_LOB(TEXT) 
    from 
      user_views
  union all
    select 
      SYSDATE, 
      'Sources', 
      'MVIEW', 
      MVIEW_NAME, 
      TO_LOB(QUERY) 
    from 
      user_mviews
)
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_VAL_ZONE
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_VAL_ZONE"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_VAL_ZONE
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_VAL_ZONE" ("DATE_MAJ", "NOM_DONNEE", "LIBELLE_DONNEE", "TYPE", "ID", "ORIGINE", "PORTEE", "APERCU")
BUILD IMMEDIATE
USING INDEX 
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  select 
    SYSDATE DATE_MAJ, 
    "NOM_DONNEE",
    "LIBELLE_DONNEE",
    "TYPE",
    NVL(ID_REGLEGESTION, APPELTABLE_NOMPAGE || ' - ' || APPELTABLE_IDREQUETE) ID,
    "ORIGINE",
    "PORTEE",
    "APERCU" 
  from (
    with "META_AT_IMPACT_REGLEGESTION" (
      "ID_REGLEGESTION", 
      "TYPE_APPEL", 
      "ID_OBJET", 
      "PORTEE"
    ) AS  (
      select ID_REGLEGESTION, "TYPE_APPEL","ID_OBJET","PORTEE" 
      from (
        select 
          'DONNEE_AUT_RD' TYPE_APPEL, 
          NOM_DONNEE ID_OBJET, 
          NOM_PAGE PORTEE, 
          ID_REGLEGESTION_AUT_RD ID_REGLEGESTION 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_AUT_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'DONNEE_AUT_CLI', 
          NOM_DONNEE, 
          NOM_PAGE, 
          ID_REGLEGESTION_AUT_CLI 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_AUT_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'DONNEE_CTL_RD', 
          NOM_DONNEE, 
          NOM_PAGE, 
          ID_REGLEGESTION_CTL_RD 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_CTL_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'DONNEE_CTL_CLI', 
          NOM_DONNEE, 
          NOM_PAGE, 
          ID_REGLEGESTION_CTL_CLI 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_CTL_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'DONNEE_AFF_RD', 
          NOM_DONNEE, 
          NOM_PAGE, 
          ID_REGLEGESTION_AFF_RD 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_AFF_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'DONNEE_AFF_CLI', 
          NOM_DONNEE, 
          NOM_PAGE, 
          ID_REGLEGESTION_AFF_CLI 
        from 
          META_DONNEE_ECRAN 
        where 
          ID_REGLEGESTION_AFF_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'REGLE_DEFAUT_CLI', 
          NOM_DONNEE, 
          NOM_PAGE, 
          REPLACE(VALEUR_DEFAUT, 'ID_REGLE=', '') 
        from 
          META_DONNEE_ECRAN 
        where 
          VALEUR_DEFAUT IS NOT NULL 
          and COMPANY_ID='*' 
          and VALEUR_DEFAUT like 'ID_REGLE=%'
        union
        select 
          'EST_OBLIGATOIRE_CLI', 
          NOM_DONNEE, 
          NOM_PAGE, 
          SUBSTR(EST_OBLIGATOIRE, 3) 
        from 
          META_DONNEE_ECRAN 
        where 
          EST_OBLIGATOIRE IS NOT NULL 
          and COMPANY_ID='*' 
          and EST_OBLIGATOIRE like 'R_%'
        union
        select 
          'GRP_ID_REGLEGESTION_CTL_CLI_SUPP', 
          ID_GROUPE, 
          '', 
          ID_REGLEGESTION_CTL_CLI_SUPP 
        from 
          META_GROUPE_DONNEES 
        where 
          ID_REGLEGESTION_CTL_CLI_SUPP IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'GRP_ID_REGLEGESTION_AFF_RD', 
          ID_GROUPE, 
          '',     
          ID_REGLEGESTION_AFF_RD 
        from 
          META_GROUPE_DONNEES_INFO 
        where 
          ID_REGLEGESTION_AFF_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'GRP_ID_REGLEGESTION_AFF_CLI', 
          ID_GROUPE, 
          '',     
          ID_REGLEGESTION_AFF_CLI 
        from 
          META_GROUPE_DONNEES_INFO 
        where 
          ID_REGLEGESTION_AFF_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_AUT_RD', 
          NOM_PAGE, 
          '', 
          ID_REGLEGESTION_AUT_RD 
        from 
          META_ECRAN 
        where 
          ID_REGLEGESTION_AUT_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_AUT_CLI', 
          NOM_PAGE, 
          '', 
          ID_REGLEGESTION_AUT_CLI 
        from 
          META_ECRAN 
        where 
          ID_REGLEGESTION_AUT_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_CTL_RD', 
          NOM_PAGE, 
          '', 
          ID_REGLEGESTION_CTL_RD 
        from 
          META_ECRAN 
        where 
          ID_REGLEGESTION_CTL_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_CTL_CLI', 
          NOM_PAGE, 
          '', 
          ID_REGLEGESTION_CTL_CLI 
        from 
          META_ECRAN 
        where 
          ID_REGLEGESTION_CTL_CLI IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_AFF_RD', 
          ID_GROUPE, 
          '',
          ID_REGLEGESTION_AFF_RD 
        from 
          meta_groupe_donnees_info 
        where 
          ID_REGLEGESTION_AFF_RD IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'GROUPE_AFF_CLI', 
          ID_GROUPE, 
          '', 
          id_reglegestion_aff_cli 
        from 
          meta_groupe_donnees_info 
        where 
          id_reglegestion_aff_cli IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'SOUS_REGLE', 
          ID_REGLEGESTION, 
          '', 
          REGEXP_SUBSTR(META_REGLEGESTION.OPERANDE2, 'IDREGLE£([^£]*)', 1,1, NULL, 1)  
        from 
          META_REGLEGESTION 
        where 
          OPERANDE2 like 'IDREGLE£%' 
          and COMPANY_ID='*'
        union
        select 
          'ECRAN_WKF_REG_AFF', 
          'OP_NUM=' || OP_NUM, 
          '', 
          ECRAN_ID_REGLEGESTION_COND 
        from 
          META_WKF_OPERATION_ECRANS 
        where 
          ECRAN_ID_REGLEGESTION_COND IS NOT NULL 
          and COMPANY_ID='*'
        union
        select 
          'TAB_HOMONYMIE_CTL', 
          'OP_NUM=' || OP_NUM, 
          '', 
          RECHERCHE_ID_REGLEGESTION_CTL 
        from 
          META_WKF_OPERATION_ECRANS 
        where 
          RECHERCHE_ID_REGLEGESTION_CTL IS NOT NULL 
          and COMPANY_ID='*'
      )
    )
    , donneeMisAJourParAppelTable (
      nom_donnee, 
      nom_page, 
      appeltable_nompage, 
      appeltable_idrequete, 
      list_nom_donnee_maj, 
      nom_donnee_maj
    ) as (
      select 
        nom_donnee, 
        nom_page, 
        appeltable_nompage, 
        appeltable_idrequete, 
        replace(appeltable_listechamps, ' ', ''), 
        '' nom_donnee_maj
      from 
        meta_donnee_ecran
      where 
        appeltable_nompage is not null
      union all
      select 
        nom_donnee, 
        nom_page, 
        appeltable_nompage, 
        appeltable_idrequete, 
        case when list_nom_donnee_maj like '%,%' then substr(list_nom_donnee_maj, instr(list_nom_donnee_maj, ',')+1) else '' end list_nom_donnee_maj,
        case when list_nom_donnee_maj like '%,%' then substr(list_nom_donnee_maj, 0, instr(list_nom_donnee_maj, ',')-1) else list_nom_donnee_maj end nom_donnee_maj
      from 
        donneeMisAJourParAppelTable
      where 
        list_nom_donnee_maj is not null
    )
    -- Recherche dans la colonne résultat des règles de gestion
    select
      META_DONNEE_GENERALE.NOM_DONNEE NOM_DONNEE,
      META_DONNEE_ECRAN.LIBELLE_DONNEE,
      'Valoriser depuis règle' || CASE WHEN META_REGLEGESTION.operande1='@vide££' and META_REGLEGESTION.operateur='VAL' THEN ' (mise à blanc)' ELSE '' END TYPE,
      META_REGLEGESTION.ID_REGLEGESTION,
      '' appeltable_nompage, 
      '' appeltable_idrequete,
      META_AT_IMPACT_REGLEGESTION.ID_OBJET origine,
      META_AT_IMPACT_REGLEGESTION.PORTEE portee,
      META_REGLEGESTION.operande1 || ' ' || META_REGLEGESTION.operateur || META_REGLEGESTION.operande2 apercu
    from 
      META_REGLEGESTION, META_DONNEE_GENERALE, META_DONNEE_ECRAN, META_AT_IMPACT_REGLEGESTION
    where
      META_REGLEGESTION.ID_REGLEGESTION=META_AT_IMPACT_REGLEGESTION.ID_REGLEGESTION
      and META_REGLEGESTION.company_id='*'
      and META_DONNEE_GENERALE.company_id=META_REGLEGESTION.company_id
      and META_DONNEE_ECRAN.company_id=META_REGLEGESTION.company_id
      and META_DONNEE_ECRAN.NOM_DONNEE=META_DONNEE_GENERALE.NOM_DONNEE
      and META_DONNEE_ECRAN.NOM_PAGE='*'
      and (
        META_REGLEGESTION.RESULTAT='DONNEE£' || META_DONNEE_GENERALE.NOM_DONNEE
        or
        (
          META_REGLEGESTION.RESULTAT='@donneecourante£' 
          and 
          META_DONNEE_GENERALE.NOM_DONNEE=META_AT_IMPACT_REGLEGESTION.ID_OBJET
        )
      )
    union all
    -- Recherche sur les fonctions RAZ
    select
      META_DONNEE_GENERALE.NOM_DONNEE,
      META_DONNEE_GENERALE.LIBELLE_DONNEE,
      'Valoriser depuis règle (mise à blanc)',
      META_REGLEGESTION.ID_REGLEGESTION,
      '', 
      '',
      META_AT_IMPACT_REGLEGESTION.ID_OBJET origine,
      META_AT_IMPACT_REGLEGESTION.PORTEE portee,
      'Raz ...'
    from 
      META_REGLEGESTION, 
      META_DONNEE_GENERALE, 
      META_DONNEE_ECRAN,  
      META_AT_IMPACT_REGLEGESTION
    where
      OPERATEUR='FCT'
      and META_DONNEE_ECRAN.company_id='*'
      and META_DONNEE_ECRAN.NOM_DONNEE=META_DONNEE_GENERALE.NOM_DONNEE
      and META_DONNEE_ECRAN.NOM_PAGE='*'
      and META_REGLEGESTION.company_id='*'
      and META_DONNEE_GENERALE.company_id='*'
      and OPERANDE2 like '%FONCTION£RAZ%'
      and (
        OPERANDE2 like '%=DONNEE^'  || META_DONNEE_GENERALE.NOM_DONNEE || '§%'
        OR 
        OPERANDE2 like '%=DONNEE^'  || META_DONNEE_GENERALE.NOM_DONNEE
      )
      and META_REGLEGESTION.ID_REGLEGESTION=META_AT_IMPACT_REGLEGESTION.ID_REGLEGESTION
    union all
    -- Recherche sur les fonctions de calcul de durée
    select
      META_DONNEE_GENERALE.NOM_DONNEE,
      META_DONNEE_GENERALE.LIBELLE_DONNEE,
      'Valoriser depuis règle', META_REGLEGESTION.ID_REGLEGESTION,
      '', 
      '',
      META_AT_IMPACT_REGLEGESTION.ID_OBJET origine,
      META_AT_IMPACT_REGLEGESTION.PORTEE portee,
      'Calcul durée ....'
    from 
      META_REGLEGESTION, 
      META_DONNEE_GENERALE, 
      META_DONNEE_ECRAN, 
      META_AT_IMPACT_REGLEGESTION
    where
      OPERATEUR='FCT'
      and META_DONNEE_ECRAN.company_id='*'
      and META_DONNEE_ECRAN.NOM_DONNEE=META_DONNEE_GENERALE.NOM_DONNEE
      and META_DONNEE_ECRAN.NOM_PAGE='*'
      and META_REGLEGESTION.company_id='*'
      and META_DONNEE_GENERALE.company_id='*'
      and OPERANDE2  like 'FONCTION£CALCUL_DUREE_JOUR_MOIS_ANNEE%'
      and (
        OPERANDE2 like '%§RES_NB_JOURS=DONNEE^' || META_DONNEE_GENERALE.NOM_DONNEE || '§%'
        OR
        OPERANDE2 like '%§RES_NB_MOIS=DONNEE^' || META_DONNEE_GENERALE.NOM_DONNEE || '§%'
        OR
        OPERANDE2 like '%§RES_NB_ANNEES=DONNEE^' || META_DONNEE_GENERALE.NOM_DONNEE
      )
      and META_REGLEGESTION.ID_REGLEGESTION=META_AT_IMPACT_REGLEGESTION.ID_REGLEGESTION
    union all
    -- recherche au niveau de appels tables
    select 
      dMaj.nom_donnee_maj, d2.libelle_donnee, 
      case when dMaj.nom_donnee=dMaj.nom_donnee_maj then 'Valoriser par appel table' ELSE 'Valoriser depuis appel table' END type,
      '' id_reglegestion,
      dMaj.appeltable_nompage, dMaj.appeltable_idrequete || '', dMaj.nom_donnee,
      LISTAGG(dMaj.nom_page, ', ') WITHIN GROUP (ORDER BY dMaj.nom_page) ,
      '' apercu
    from 
      donneeMisAJourParAppelTable dMaj
      inner join meta_donnee_generale d1 on d1.nom_donnee=dMaj.nom_donnee_maj and d1.company_id='*'
      inner join meta_donnee_ecran d2 on d2.nom_donnee=dMaj.nom_donnee_maj and d2.nom_page='*'
    where 
      dMaj.nom_donnee_maj is not null 
      and dMaj.nom_donnee_maj not like '#%'
    group by 
      dMaj.nom_donnee, 
      d2.libelle_donnee, 
      dMaj.appeltable_nompage, 
      dMaj.appeltable_idrequete, 
      dMaj.nom_donnee_maj
  )
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_WORKFLOWS
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_WORKFLOWS"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_WORKFLOWS
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_WORKFLOWS" ("DATE_MAJ", "PROC_NUM", "PROC_LIBELLE", "OP_NUM", "OP_LIBELLE", "OP_STATUTPROC", "DESTINATION", "EVT_UX", "ORDRE_REQ", "EST_UTILISE", "IS_WKF_UX")
BUILD IMMEDIATE
USING INDEX 
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  select
    sysdate DATE_MAJ,
    to_char(p.proc_num) PROC_NUM, 
    p.proc_libelle, 
    to_char(o.op_num) OP_NUM, 
    o.op_libelle, 
    CASE  o.op_statutproc
      WHEN 'I' THEN 'Initiale'
      WHEN 'N' THEN 'Normale'
      WHEN 'F' THEN 'Finale'
      WHEN 'TIF' THEN 'Initiale Finale Terminale'
      WHEN 'TF' THEN 'Finale Terminale'
      WHEN 'IF' THEN 'Intiale Finale'
      ELSE op_statutproc
    END op_statutproc, 
    RTRIM(linearisereq('select code_retour from wkf_branch_gen br where br.op_emet_num=''' || o.op_num || '''', ', '), ', ') destination,
    RTRIM(linearisereq('select ux.libelle from mp_ref_events ux where ux.op_num=''' || o.op_num || '''', ', '), ', ') evt_ux,
    row_number() over (order by p.proc_libelle, CASE WHEN o.op_statutproc like '%I%' THEN 1 WHEN o.op_statutproc='N' THEN 2 WHEN o.op_statutproc like '%F%' THEN 3 ELSE 9 END, o.op_num) ordre_req,
    CASE 
      WHEN EXISTS (select t.proc_num from wkf_tracabilite t where t.op_num=o.op_num) THEN 'O' 
      ELSE 'N' 
    END EST_UTILISE,
    CASE 
      WHEN EXISTS(select * from mp_ref_events inner join wkf_operations o1 on o1.op_num=mp_ref_events.op_num inner join wkf_processus p1 on p1.proc_num=o1.proc_num where p1.proc_num=p.proc_num) THEN 'O' 
      ELSE 'N' 
    END is_wkf_ux
  from 
    wkf_processus p
    inner join wkf_operations o on o.proc_num=p.proc_num
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS
=SQL=
BEGIN
  EXECUTE_IMMEDIATE_STRING('DROP MATERIALIZED VIEW "META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS"',0);
EXCEPTION WHEN OTHERS THEN NULL;
END;
##
META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS
=SQL=
CREATE MATERIALIZED VIEW "META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS" ("DATE_MAJ", "PROC_NUM", "PROC_LIBELLE", "OP_NUM", "OP_LIBELLE", "TYPE_ECRAN", "ECRAN_NOM", "ECRAN_LIBELLE", "ORDRE", "ECRAN_RECHERCHE", "ECRAN_RECAP_GRP1", "ECRAN_RECAP_GRP2", "ORDRE_REQ")
BUILD IMMEDIATE
USING INDEX 
REFRESH FORCE ON DEMAND START WITH sysdate+5/1400 NEXT SYSDATE + 1
AS 
  select
    sysdate date_maj,
    to_char(p.proc_num) proc_num, 
    p.proc_libelle, 
    to_char(o.op_num) op_num, 
    o.op_libelle, 
    meta_wkf_operation_ecrans.TYPE_ECRAN,
    CASE
      WHEN meta_wkf_operation_ecrans.TYPE_ECRAN='RECAP' THEN 'GEN_PAGE_RECAP_' || META_WKF_OPERATION_ECRANS.OP_NUM || '_' || META_WKF_OPERATION_ECRANS.ID_GEN_PAGE
      ELSE  meta_wkf_operation_ecrans.ecran_nom_page
    END ecran_nom,
    CASE
      WHEN meta_wkf_operation_ecrans.TYPE_ECRAN='RECH' THEN NVL(meta_wkf_operation_ecrans.libelle_ecran_recap, 'Recherche d''homonymie')
      WHEN meta_wkf_operation_ecrans.TYPE_ECRAN='RECAP' THEN NVL(meta_wkf_operation_ecrans.libelle_ecran_recap, 'Récapitulatif de la saisie')
      ELSE e.libelle_page    
    END ecran_libelle,
    meta_wkf_operation_ecrans.ordre,
    CASE 
      WHEN RECHERCHE_REQUETE_NOMPAGE IS NOT NULL THEN RECHERCHE_REQUETE_NOMPAGE || ' - ' || RECHERCHE_REQUETE_IDREQUETE 
      ELSE '' 
    END ECRAN_RECHERCHE,
    recap_id_groupe_1 ECRAN_RECAP_GRP1,
    recap_id_groupe_2 ECRAN_RECAP_GRP2,
    row_number() over (order by p.proc_libelle, CASE WHEN o.op_statutproc like '%I%' THEN 1 WHEN o.op_statutproc='N' THEN 2 WHEN o.op_statutproc like '%F%' THEN 3 ELSE 9 END, o.op_num, meta_wkf_operation_ecrans.ordre) ordre_req
  from 
    META_WKF_OPERATION_ECRANS
    LEFT OUTER JOIN WKF_OPERATIONS o on o.op_num=meta_wkf_operation_ecrans.op_num
    LEFT OUTER JOIN WKF_PROCESSUS p on o.proc_num=p.proc_num
    LEFT OUTER JOIN REF_ECRAN e on e.company_id='*' and e.nom_page=meta_wkf_operation_ecrans.ecran_nom_page
##
META_DICTIONNAIRE_IHM
==
CREATE OR REPLACE FORCE VIEW "META_DICTIONNAIRE_IHM" ("COMPANY_ID", "NOM_DICTIONNAIRE", "LIBELLE_DICTIONNAIRE", "TYPE_CLE_SALARIE", "CHAMPS_CLE", "ID_PROJET", "EST_SUPPRIME", "HISTORISE") AS   (SELECT COMPANY_ID, NOM_DICTIONNAIRE, LIBELLE_DICTIONNAIRE, TYPE_CLE_SALARIE, CHAMPS_CLE, ID_PROJET, EST_SUPPRIME,nvl(HISTORISE,'N') as HISTORISE FROM META_DICTIONNAIRE UNION SELECT '*', 'DIC_ADM_PERSO', 'Données administratives personnelles', 'R', NULL, NULL, NULL,'N' FROM DUAL UNION SELECT '*', 'DIC_ADM_PERSO_HISTO', 'Données administratives personnelles (historisées)', 'R', NULL, NULL, NULL, 'O' FROM DUAL UNION SELECT '*', 'DIC_ADM_CONTRAT', 'Données administratives contractuelles', 'M', NULL, NULL, NULL,'N' FROM DUAL UNION SELECT '*', 'DIC_ADM_CONTRAT_HISTO', 'Données administratives contractuelles (historisées)', 'M', NULL, NULL, NULL,'O' FROM DUAL UNION SELECT '*', 'DIC_DONNEES_VIRTUELLES', 'Données virtuelles (non-stockées)', NULL, NULL, NULL, NULL,'N' FROM DUAL )
##
META_ECRANS_GROUPES_DONNEES
=SQL=
CREATE OR REPLACE FORCE VIEW META_ECRANS_GROUPES_DONNEES (COMPANY_ID, NOM_PAGE, ID_GROUPE_ECRAN, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ORDRE, ID_GROUPE_DONNEES)
AS
  SELECT MLGD.COMPANY_ID,
    ME.NOM_PAGE,
    ME.ID_GROUPE_DONNEES,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ORDRE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPES_DONNEES_ALL MLGD,
    META_ECRAN ME
  WHERE MLGD.COMPANY_ID   =ME.COMPANY_ID
  AND ME.ID_GROUPE_DONNEES=MLGD.ID_GROUPE 
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_1,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ORDRE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPES_DONNEES_ALL MLGD,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_1=MLGD.ID_GROUPE
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_2,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ORDRE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPES_DONNEES_ALL MLGD,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_2=MLGD.ID_GROUPE
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'RAPPELSAISIE_'||ME.NOM_PAGE,
    MWOE.RECHERCHE_ID_GROUPE_LECTURE,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ORDRE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPES_DONNEES_ALL MLGD,
    META_ECRAN ME,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID     =ME.COMPANY_ID
  AND MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECHERCHE_ID_GROUPE_LECTURE=MLGD.ID_GROUPE
  AND ME.NOM_PAGE=MWOE.ECRAN_NOM_PAGE
##
META_ECRAN_GROUPE_DONNEE_LIGHT
=SQL=
CREATE OR REPLACE FORCE VIEW META_ECRAN_GROUPE_DONNEE_LIGHT (COMPANY_ID, NOM_PAGE, ID_GROUPE_ECRAN, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ID_GROUPE_DONNEES)
AS
  SELECT MLGD.COMPANY_ID,
    ME.NOM_PAGE,
    ME.ID_GROUPE_DONNEES,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    META_ECRAN ME
  WHERE MLGD.COMPANY_ID   =ME.COMPANY_ID
  AND ME.ID_GROUPE_DONNEES=MLGD.ID_GROUPE 
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_1,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_1=MLGD.ID_GROUPE
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'||MWOE.OP_NUM||'_'||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_2,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_2=MLGD.ID_GROUPE
  UNION ALL
  SELECT MLGD.COMPANY_ID,
    'RAPPELSAISIE_'||ME.NOM_PAGE,
    MWOE.RECHERCHE_ID_GROUPE_LECTURE,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM META_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    META_ECRAN ME,
    META_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID     =ME.COMPANY_ID
  AND MLGD.COMPANY_ID   =MWOE.COMPANY_ID
  AND MWOE.RECHERCHE_ID_GROUPE_LECTURE=MLGD.ID_GROUPE
  AND ME.NOM_PAGE=MWOE.ECRAN_NOM_PAGE
##
META_ECRAN_IHM
=SQL=
CREATE OR REPLACE FORCE VIEW META_ECRAN_IHM (COMPANY_ID, NOM_PAGE, LIBELLE_PAGE, COMPLEMENT_LIBELLE, CODE_DESTINATION, ROLE_ECRAN, NOM_DICTIONNAIRE, MODULE_ECRAN, BOUTONS_ECRAN, ID_GROUPE_DONNEES, TYPE_ECRAN, NOM_SERVICELET, ID_PROJET, NUM_VERSION_RD, EST_SUPPRIME, PERSONNALISE) AS 
  SELECT COMPANY_ID,
    NOM_PAGE,
    LIBELLE_PAGE,
    NULL AS COMPLEMENT_LIBELLE,
    CODE_DESTINATION,
    ROLE_ECRAN,
    NOM_DICTIONNAIRE,
    MODULE_ECRAN,
    BOUTONS_ECRAN,
    ID_GROUPE_DONNEES,
    TYPE_ECRAN,
    NOM_SERVICELET,
    ID_PROJET,
    NUM_VERSION_RD,
    EST_SUPPRIME,
    PERSONNALISE
  FROM META_ECRAN
  UNION ALL
  SELECT COMPANY_ID,
    'GEN_PAGE_RECAP_'||OP_NUM||'_'||ID_GEN_PAGE AS NOM_PAGE,
    NVL(LIBELLE_ECRAN_RECAP,'Récapitulatif') AS LIBELLE_PAGE,
    '('||OP_NUM||') '||(SELECT ME.OP_LIBELLE FROM WKF_OPERATIONS ME WHERE ME.OP_NUM = META_WKF_OPERATION_ECRANS.OP_NUM AND ME.COMP_WEB='_PARAM_DYN_') AS COMPLEMENT_LIBELLE,
    'WorkflowParamDyn' AS CODE_DESTINATION,
    '' AS ROLE_ECRAN,
    '' AS NOM_DICTIONNAIRE,
    ''||OP_NUM AS MODULE_ECRAN,
    NULL AS BOUTONS_ECRAN,
    RECAP_ID_GROUPE_1 AS ID_GROUPE_DONNEES,
    'W' AS TYPE_ECRAN,
    NULL AS NOM_SERVICELET,
    (SELECT ID_PROJET FROM META_WKF_OPERATION_ECRANS_INFO WHERE META_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=META_WKF_OPERATION_ECRANS.COMPANY_ID AND META_WKF_OPERATION_ECRANS_INFO.OP_NUM=META_WKF_OPERATION_ECRANS.OP_NUM) AS ID_PROJET,
    (SELECT NUM_VERSION_RD FROM META_WKF_OPERATION_ECRANS_INFO WHERE META_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=META_WKF_OPERATION_ECRANS.COMPANY_ID AND META_WKF_OPERATION_ECRANS_INFO.OP_NUM=META_WKF_OPERATION_ECRANS.OP_NUM) AS NUM_VERSION_RD,
    NULL AS EST_SUPPRIME,
    NULL AS PERSONNALISE
  FROM META_WKF_OPERATION_ECRANS
  WHERE TYPE_ECRAN='RECAP' AND RECAP_ID_GROUPE_1 IS NOT NULL
  UNION ALL
  SELECT COMPANY_ID,
    'GEN_PAGE_RECAP_'||OP_NUM||'_'||ID_GEN_PAGE AS NOM_PAGE,
    NVL(LIBELLE_ECRAN_RECAP,'Récapitulatif') AS LIBELLE_PAGE,
    '('||OP_NUM||') '||(SELECT ME.OP_LIBELLE FROM WKF_OPERATIONS ME WHERE ME.OP_NUM = META_WKF_OPERATION_ECRANS.OP_NUM AND ME.COMP_WEB='_PARAM_DYN_') AS COMPLEMENT_LIBELLE,
    'WorkflowParamDyn' AS CODE_DESTINATION,
    '' AS ROLE_ECRAN,
    '' AS NOM_DICTIONNAIRE,
    ''||OP_NUM AS MODULE_ECRAN,
    NULL AS BOUTONS_ECRAN,
    RECAP_ID_GROUPE_2 AS ID_GROUPE_DONNEES,
    'W' AS TYPE_ECRAN,
    NULL AS NOM_SERVICELET,
    (SELECT ID_PROJET FROM META_WKF_OPERATION_ECRANS_INFO WHERE META_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=META_WKF_OPERATION_ECRANS.COMPANY_ID AND META_WKF_OPERATION_ECRANS_INFO.OP_NUM=META_WKF_OPERATION_ECRANS.OP_NUM) AS ID_PROJET,
    (SELECT NUM_VERSION_RD FROM META_WKF_OPERATION_ECRANS_INFO WHERE META_WKF_OPERATION_ECRANS_INFO.COMPANY_ID=META_WKF_OPERATION_ECRANS.COMPANY_ID AND META_WKF_OPERATION_ECRANS_INFO.OP_NUM=META_WKF_OPERATION_ECRANS.OP_NUM) AS NUM_VERSION_RD,
    NULL AS EST_SUPPRIME,
    NULL AS PERSONNALISE
  FROM META_WKF_OPERATION_ECRANS
  WHERE TYPE_ECRAN='RECAP' AND RECAP_ID_GROUPE_2 IS NOT NULL
##
META_GROUPEDONNEES_CROISES
=SQL=
CREATE OR REPLACE VIEW META_GROUPEDONNEES_CROISES AS
 SELECT 
	 A.COMPANY_ID,
	 A.ID_GROUPE,
	 A.LIBELLE_GROUPE,
	 Z.NOM_OBJET,
	 Z.UTILISATION,
	 Z.DESCRIPTION,
	 A.EST_SUPPRIME
 
 FROM
 (
SELECT
 
 'GROUPE' AS UTILISATION,
 META_GROUPE_DONNEES.ID_GROUPE AS NOM_OBJET,
 META_GROUPE_DONNEES.SUFFIXE_OU_LIBELLE AS ID_GROUPE,
 META_GROUPE_DONNEES.COMPANY_ID,
 META_GROUPE_DONNEES_INFO.LIBELLE_GROUPE AS DESCRIPTION
 
 FROM META_GROUPE_DONNEES  JOIN META_GROUPE_DONNEES_INFO ON META_GROUPE_DONNEES_INFO.ID_GROUPE = META_GROUPE_DONNEES.ID_GROUPE AND META_GROUPE_DONNEES_INFO.COMPANY_ID= META_GROUPE_DONNEES.COMPANY_ID   WHERE META_GROUPE_DONNEES.NOM_DONNEE LIKE '#GROUPE%'
 
 
 UNION ALL
 SELECT
 
 'ECRAN' AS UTILISATION,
 NOM_PAGE AS NOM_OBJET,
 ID_GROUPE_DONNEES AS ID_GROUPE,
 COMPANY_ID,
 LIBELLE_PAGE AS DESCRIPTION
 
 FROM META_ECRAN
 
 UNION ALL
 SELECT distinct
 
 'WORKFLOW ECRITURE' AS UTILISATION,
 ''||OP_NUM||'' AS NOM_OBJET,
 ID_GROUPE_ECRITURE AS ID_GROUPE,
 COMPANY_ID ,
 ( SELECT  WKF_OPERATIONS.OP_LIBELLE FROM WKF_OPERATIONS WHERE META_WKF_OPERATION_ECRANS_INFO.OP_NUM = WKF_OPERATIONS.OP_NUM ) AS DESCRIPTION
 
 FROM META_WKF_OPERATION_ECRANS_INFO
 where ID_GROUPE_ECRITURE is not null
 UNION ALL
 SELECT distinct
 
 'WORKFLOW INITIALISATION ' AS UTILISATION,
 ''||OP_NUM||' '||ECRAN_NOM_PAGE||'' AS NOM_OBJET,
 RECHERCHE_ID_GROUPE_LECTURE AS ID_GROUPE,
 COMPANY_ID ,
 ( SELECT  WKF_OPERATIONS.OP_LIBELLE FROM WKF_OPERATIONS WHERE META_WKF_OPERATION_ECRANS.OP_NUM = WKF_OPERATIONS.OP_NUM ) AS DESCRIPTION
 
 FROM META_WKF_OPERATION_ECRANS
 where TYPE_ECRAN='RECH' AND RECHERCHE_ID_GROUPE_LECTURE is not null
 UNION ALL
 
 SELECT distinct
 
 'WORKFLOW RAPPEL DE SAISIE' AS UTILISATION,
 ''||OP_NUM||' '||ECRAN_NOM_PAGE||'' AS NOM_OBJET,
 RECHERCHE_ID_GROUPE_LECTURE AS ID_GROUPE,
 COMPANY_ID ,
 ( SELECT  WKF_OPERATIONS.OP_LIBELLE FROM WKF_OPERATIONS WHERE META_WKF_OPERATION_ECRANS.OP_NUM = WKF_OPERATIONS.OP_NUM ) AS DESCRIPTION
 
 FROM META_WKF_OPERATION_ECRANS
 where TYPE_ECRAN <> 'RECH' AND RECHERCHE_ID_GROUPE_LECTURE is not null
 
 UNION ALL
 SELECT distinct
 
 'WORKFLOW RECAP 1' AS UTILISATION,
 ''||OP_NUM||' '||ECRAN_NOM_PAGE||'' AS NOM_OBJET,
 RECAP_ID_GROUPE_1 AS ID_GROUPE,
 COMPANY_ID ,
 ( SELECT  WKF_OPERATIONS.OP_LIBELLE FROM WKF_OPERATIONS WHERE META_WKF_OPERATION_ECRANS.OP_NUM = WKF_OPERATIONS.OP_NUM ) AS DESCRIPTION
 
 FROM META_WKF_OPERATION_ECRANS
 where RECAP_ID_GROUPE_1 is not null
 UNION ALL
 SELECT distinct
 
 'WORKFLOW RECAP 2' AS UTILISATION,
 ''||OP_NUM||' '||ECRAN_NOM_PAGE||'' AS NOM_OBJET,
 RECAP_ID_GROUPE_2 AS ID_GROUPE,
 COMPANY_ID ,
 ( SELECT  WKF_OPERATIONS.OP_LIBELLE FROM WKF_OPERATIONS WHERE META_WKF_OPERATION_ECRANS.OP_NUM = WKF_OPERATIONS.OP_NUM ) AS DESCRIPTION
 FROM META_WKF_OPERATION_ECRANS
 where RECAP_ID_GROUPE_2 is not null
 UNION ALL
 SELECT
 
 'NON UTILISE' AS UTILISATION,
 '' AS NOM_OBJET,
 ID_GROUPE AS ID_GROUPE,
 COMPANY_ID,
 '' AS DESCRIPTION
 
 FROM META_GROUPE_DONNEES_INFO
 
 WHERE ID_GROUPE NOT IN (
 
 SELECT DISTINCT(ID_GROUPE_ECRITURE) FROM META_WKF_OPERATION_ECRANS_INFO  WHERE META_GROUPE_DONNEES_INFO.COMPANY_ID = META_WKF_OPERATION_ECRANS_INFO.COMPANY_ID
 UNION ALL
 SELECT DISTINCT(SUFFIXE_OU_LIBELLE) FROM META_GROUPE_DONNEES WHERE NOM_DONNEE LIKE '#GROUPE%' AND META_GROUPE_DONNEES_INFO.COMPANY_ID = META_GROUPE_DONNEES.COMPANY_ID
 UNION ALL
 SELECT DISTINCT(ID_GROUPE_DONNEES) FROM META_ECRAN WHERE  META_GROUPE_DONNEES_INFO.COMPANY_ID = META_ECRAN.COMPANY_ID and ID_GROUPE_DONNEES is not null
 UNION ALL
 SELECT DISTINCT( RECHERCHE_ID_GROUPE_LECTURE) FROM META_WKF_OPERATION_ECRANS WHERE META_WKF_OPERATION_ECRANS.COMPANY_ID = META_GROUPE_DONNEES_INFO.COMPANY_ID  and RECHERCHE_ID_GROUPE_LECTURE is not null
 UNION ALL
 SELECT DISTINCT( RECAP_ID_GROUPE_1) FROM META_WKF_OPERATION_ECRANS WHERE META_WKF_OPERATION_ECRANS.COMPANY_ID = META_GROUPE_DONNEES_INFO.COMPANY_ID     and RECAP_ID_GROUPE_1 is not null
 UNION ALL
 SELECT DISTINCT( RECAP_ID_GROUPE_2) FROM META_WKF_OPERATION_ECRANS WHERE META_WKF_OPERATION_ECRANS.COMPANY_ID = META_GROUPE_DONNEES_INFO.COMPANY_ID   and RECAP_ID_GROUPE_2 is not null
 )
 
 
 )
 Z,
 META_GROUPE_DONNEES_INFO A
 WHERE
 Z.ID_GROUPE(+) = A.ID_GROUPE  AND A.COMPANY_ID= Z.COMPANY_ID  ORDER BY A.ID_GROUPE
##
META_LIEN_GROUPES_DONNEES
==
CREATE OR REPLACE FORCE VIEW "META_LIEN_GROUPES_DONNEES" ("COMPANY_ID", "ID_GROUPE", "NOM_DONNEE", "SUFFIXE_OU_LIBELLE", "ORDRE", "ID_GROUPE_DONNEES") AS   SELECT "COMPANY_ID","ID_GROUPE","NOM_DONNEE","SUFFIXE_OU_LIBELLE","ORDRE","ID_GROUPE_DONNEES" FROM META_LIEN_GROUPES_DONNEES_ALL WHERE nom_donnee NOT LIKE '#%'
##
META_LIEN_GROUPES_DONNEES_ALL
=SQL=
CREATE OR REPLACE FORCE VIEW "META_LIEN_GROUPES_DONNEES_ALL" ("COMPANY_ID", "ID_GROUPE", "NOM_DONNEE", "SUFFIXE_OU_LIBELLE", "ORDRE", "ID_GROUPE_DONNEES") 
AS   
WITH liensDonneesGroupes(company_id, id_groupe, nom_donnee, id_groupe_donnees, suffixe_ou_libelle) 
AS (
	SELECT gd.company_id, gd.id_groupe, CASE WHEN SUBSTR(gd.nom_donnee,1,1)='#' THEN gd.nom_donnee||'£'||gd.id_groupe ELSE gd.nom_donnee END AS nom_donnee, gd.id_groupe, gd.suffixe_ou_libelle 
	FROM meta_groupe_donnees gd 
	UNION ALL 
	SELECT l.company_id, l.id_groupe, CASE WHEN SUBSTR(gd.nom_donnee,1,1)='#' THEN gd.nom_donnee||'£'||gd.id_groupe ELSE gd.nom_donnee END AS nom_donnee, gd.id_groupe, gd.suffixe_ou_libelle 
	FROM meta_groupe_donnees gd, liensDonneesGroupes l 
	WHERE gd.company_id=l.company_id AND gd.id_groupe   =l.suffixe_ou_libelle AND l.nom_donnee LIKE '#GROUPE%' 
) 
SELECT company_id, id_groupe, CASE WHEN INSTR(nom_donnee,'£')=0 THEN nom_donnee ELSE SUBSTR(nom_donnee,1,INSTR(nom_donnee,'£')-1) END as nom_donnee, suffixe_ou_libelle, META_ORDRE_DONNEE_IN_GROUPE(company_id, id_groupe, nom_donnee) as ordre, id_groupe_donnees 
FROM liensDonneesGroupes
##
META_LIEN_GROUPE_DONNEE_LIGHT
=SQL=
CREATE OR REPLACE FORCE VIEW META_LIEN_GROUPE_DONNEE_LIGHT (COMPANY_ID, ID_GROUPE, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ID_GROUPE_DONNEES) AS
SELECT COMPANY_ID, CONNECT_BY_ROOT(ID_GROUPE) AS ID_GROUPE, NOM_DONNEE, SUFFIXE_OU_LIBELLE, ID_GROUPE AS ID_GROUPE_DONNEES
FROM META_GROUPE_DONNEES
START WITH 1=1
CONNECT BY NOCYCLE ID_GROUPE = PRIOR SUFFIXE_OU_LIBELLE AND COMPANY_ID = PRIOR COMPANY_ID AND PRIOR NOM_DONNEE LIKE '#GROUPE%'
##
META_LISTETABLES
==
CREATE OR REPLACE FORCE VIEW "META_LISTETABLES" ("TYPOBJ", "OBJ", "NOMTABLE", "NOMPAGE", "IDREQUETE") AS   ( select  'NOM_DONNEE' as typobj,nom_donnee as obj,NOMTABLE,sys_requetes_jsp.nompage,sys_requetes_jsp.idrequete from meta_donnee_ecran , sys_requetes_jsp where meta_donnee_ecran.appeltable_nompage = sys_requetes_jsp.nompage and meta_donnee_ecran.appeltable_idrequete = sys_requetes_jsp.idrequete union select  'REGLE' as typobj,id_reglegestion as obj,NOMTABLE,sys_requetes_jsp.nompage,sys_requetes_jsp.idrequete from sys_requetes_jsp,( select meta_reglegestion.id_reglegestion, SUBSTR(operande2, INSTR(operande2,'NOM_PAGE=VALEUR^')+16, INSTR(operande2,'§ID_REQUETE')-INSTR(operande2,'NOM_PAGE=VALEUR^')-16 ) as nompage,  SUBSTR(operande2, INSTR(operande2,'ID_REQUETE=VALEUR^')+18, INSTR(operande2,'§ID_COL')-INSTR(operande2,'ID_REQUETE=VALEUR^')-18 ) as idrequete from meta_reglegestion where operande2 like '%RETOURTABLE%') Z where Z.nompage = sys_requetes_jsp.nompage and Z.idrequete = sys_requetes_jsp.idrequete union select  'GROUPE_TABLEAU' as typobj,id_groupe as obj,NOMTABLE,sys_requetes_jsp.nompage,sys_requetes_jsp.idrequete from meta_groupe_donnees , sys_requetes_jsp where meta_groupe_donnees.tableau_requete_nompage = sys_requetes_jsp.nompage and meta_groupe_donnees.tableau_requete_idrequete = sys_requetes_jsp.idrequete )
##
META_REGLEGESTION_APPELTABLE
=SQL=
CREATE OR REPLACE FORCE VIEW "META_REGLEGESTION_APPELTABLE" ("ID_REGLEGESTION", "NOM_PAGE", "IDREQUETE")
AS
  SELECT DISTINCT id_reglegestion,
    SUBSTR(REPLACE(regexp_substr(SUBSTR(OPERANDE2,14),'[^§]*§?',1,1),'§'),17) AS nom_page ,
    SUBSTR(REPLACE(regexp_substr(SUBSTR(OPERANDE2,14),'[^§]*§?',1,2),'§'),19) AS idrequete
  FROM META_REGLEGESTION
  WHERE OPERATEUR='TAB'
  ##
META_REGLEGESTION_ERREUR
=SQL=
CREATE OR REPLACE FORCE VIEW META_REGLEGESTION_ERREUR ("ID_REGLEGESTION", "OPERATEUR", "CODERR", "CODMOD", "CODLANG", "NIV_DEFINITION", "LIBERR", "TYPERR")
AS
  SELECT id_reglegestion,
    operateur,
    sys_def_erreurs."CODERR",
    sys_def_erreurs."CODMOD",
    sys_def_erreurs."CODLANG",
    sys_def_erreurs."NIV_DEFINITION",
    sys_def_erreurs."LIBERR",
    sys_def_erreurs."TYPERR"
  FROM
    ( SELECT DISTINCT id_reglegestion,
      operateur,
      REPLACE(regexp_substr(SUBSTR(OPERANDE2,11),'[^£]*£?',1,2),'£') AS regerr
    FROM META_REGLEGESTION
    ),
    sys_def_erreurs
  WHERE operateur IN ('ERR','WAR','CONFIRM')
  AND regerr       =coderr
  ##
META_REGLES_CROISES
=SQL=
CREATE OR REPLACE VIEW META_REGLES_CROISES AS
  SELECT
    a.id_reglegestion,
    a.libelle,
    CASE
      WHEN a.flag_specif_type_regle = 'M'
      THEN 'Masque les données et les vide'
      WHEN a.flag_specif_type_regle = 'C'
      THEN 'Masque les données sans les vider'
      WHEN a.flag_specif_type_regle = 'V'
      THEN 'Rend les données non saisissables'
      WHEN a.flag_specif_type_regle = 'O'
      THEN 'Activée en temps réel'
      WHEN a.flag_specif_type_regle = 'N'
      THEN 'Non activée en temps réel'
      ELSE ''
    END TYPE_REGLE2 ,
    z.type_regle,
    NVL(z.TYPE_OBJET,'NON UTILISE') AS TYPE_OBJET,
    z.info1,
    z.type_objet2,
    z.info2 ,
    a.description,
    a.regle_synthetique,
    a.est_supprime
  FROM
    (
      SELECT
        'DONNEE'               AS TYPE_OBJET,
        'AUTOMATISME RD '      AS TYPE_REGLE,
        NOM_DONNEE             AS INFO1,
        'NOM_PAGE'             AS TYPE_OBJET2,
        NOM_PAGE               AS INFO2 ,
        ID_REGLEGESTION_AUT_RD AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'                AS TYPE_OBJET,
        'AUTOMATISME CLI '      AS TYPE_REGLE,
        NOM_DONNEE              AS INFO1,
        'NOM_PAGE'              AS TYPE_OBJET2,
        NOM_PAGE                AS INFO2 ,
        ID_REGLEGESTION_AUT_CLI AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'               AS TYPE_OBJET,
        'AFFICHAGE RD '        AS TYPE_REGLE,
        NOM_DONNEE             AS INFO1,
        'NOM_PAGE'             AS TYPE_OBJET2,
        NOM_PAGE               AS INFO2 ,
        ID_REGLEGESTION_AFF_RD AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'                AS TYPE_OBJET,
        'AFFICHAGE CLI '        AS TYPE_REGLE,
        NOM_DONNEE              AS INFO1,
        'NOM_PAGE'              AS TYPE_OBJET2,
        NOM_PAGE                AS INFO2 ,
        ID_REGLEGESTION_AFF_CLI AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'               AS TYPE_OBJET,
        'CONTROLE RD  '        AS TYPE_REGLE,
        NOM_DONNEE             AS INFO1,
        'NOM_PAGE'             AS TYPE_OBJET2,
        NOM_PAGE               AS INFO2 ,
        ID_REGLEGESTION_CTL_RD AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'                AS TYPE_OBJET,
        'CONTROLE CLI '         AS TYPE_REGLE,
        NOM_DONNEE              AS INFO1,
        'NOM_PAGE'              AS TYPE_OBJET2,
        NOM_PAGE                AS INFO2 ,
        ID_REGLEGESTION_CTL_CLI AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      UNION ALL
      SELECT
        'DONNEE'               AS TYPE_OBJET,
        'OBLIGATOIRE '        AS TYPE_REGLE,
        NOM_DONNEE             AS INFO1,
        'NOM_PAGE'             AS TYPE_OBJET2,
        NOM_PAGE               AS INFO2 ,
        SUBSTR(EST_OBLIGATOIRE,3) AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      WHERE
        EST_OBLIGATOIRE LIKE 'R_%'
      UNION ALL
      SELECT
        'DONNEE'               AS TYPE_OBJET,
        'VALEUR PAR DEFAUT '   AS TYPE_REGLE,
        NOM_DONNEE             AS INFO1,
        'NOM_PAGE'             AS TYPE_OBJET2,
        NOM_PAGE               AS INFO2 ,
        SUBSTR(VALEUR_DEFAUT,10) AS ID_REGLE
      FROM
        META_DONNEE_ECRAN
      WHERE
        VALEUR_DEFAUT LIKE 'ID_REGLE=%'
      UNION ALL
      SELECT
        'TABLEAU SUPP'              AS TYPE_OBJET,
        'CONTROLE RD  '             AS TYPE_REGLE,
        ID_GROUPE                   AS INFO1,
        ''                          AS TYPE_OBJET2,
        ''                          AS INFO2 ,
        ID_REGLEGESTION_CTL_RD_SUPP AS ID_REGLE
      FROM
        META_GROUPE_DONNEES
      WHERE
        NOM_DONNEE LIKE '#TABLEAU%'
      UNION ALL
      SELECT
        'TABLEAU SUPP'               AS TYPE_OBJET,
        'CONTROLE CLI '              AS TYPE_REGLE,
        ID_GROUPE                    AS INFO1,
        ''                           AS TYPE_OBJET2,
        ''                           AS INFO2 ,
        ID_REGLEGESTION_CTL_CLI_SUPP AS ID_REGLE
      FROM
        META_GROUPE_DONNEES
      WHERE
        NOM_DONNEE LIKE '#TABLEAU%'
      UNION ALL
      SELECT
        'AFF RECONDUCTION DONNEES'  AS TYPE_OBJET,
        'AFFICHAGE RD  '            AS TYPE_REGLE,
        ID_GROUPE                   AS INFO1,
        ''                          AS TYPE_OBJET2,
        ''                          AS INFO2 ,
        ID_REGLEGESTION_CTL_RD_SUPP AS ID_REGLE
      FROM
        META_GROUPE_DONNEES
      WHERE
        NOM_DONNEE LIKE '#RECONDUCTION_DONNEES%'
      UNION ALL
      SELECT
        'AFF RECONDUCTION DONNEES'   AS TYPE_OBJET,
        'AFFICHAGE CLI '             AS TYPE_REGLE,
        ID_GROUPE                    AS INFO1,
        ''                           AS TYPE_OBJET2,
        ''                           AS INFO2 ,
        ID_REGLEGESTION_CTL_CLI_SUPP AS ID_REGLE
      FROM
        META_GROUPE_DONNEES
      WHERE
        NOM_DONNEE LIKE '#RECONDUCTION_DONNEES%'
      UNION ALL
      SELECT
        'GROUPE'               AS TYPE_OBJET,
        'AFFICHAGE RD '        AS TYPE_REGLE,
        ID_GROUPE              AS INFO1,
        ''                     AS TYPE_OBJET2,
        ''                     AS INFO2 ,
        ID_REGLEGESTION_AFF_RD AS ID_REGLE
      FROM
        META_GROUPE_DONNEES_INFO
      UNION ALL
      SELECT
        'GROUPE'                AS TYPE_OBJET,
        'AFFICHAGE CLI '        AS TYPE_REGLE,
        ID_GROUPE               AS INFO1,
        ''                      AS TYPE_OBJET2,
        ''                      AS INFO2 ,
        ID_REGLEGESTION_AFF_CLI AS ID_REGLE
      FROM
        META_GROUPE_DONNEES_INFO
      UNION ALL
      SELECT
        'ECRAN'                    AS TYPE_OBJET,
        'CONDITION ECRAN WORKFLOW' AS TYPE_REGLE,
        ECRAN_NOM_PAGE             AS INFO1,
        'OP_NUM'                   AS TYPE_OBJET2,
        TO_CHAR(OP_NUM)
        ||' '
        ||
        (
          SELECT
            w.op_libelle
          FROM
            wkf_operations w
          WHERE
            w.op_num=META_WKF_OPERATION_ECRANS.op_num
          AND rownum=1
        )                          AS INFO2 ,
        ECRAN_ID_REGLEGESTION_COND AS ID_REGLE
      FROM
        META_WKF_OPERATION_ECRANS
      UNION ALL
      SELECT
        'ECRAN'             AS TYPE_OBJET,
        'CONTROLE WORKFLOW' AS TYPE_REGLE,
        ECRAN_NOM_PAGE      AS INFO1,
        'OP_NUM'            AS TYPE_OBJET2,
        TO_CHAR(OP_NUM)
        ||' '
        ||
        (
          SELECT
            w.op_libelle
          FROM
            wkf_operations w
          WHERE
            w.op_num=META_WKF_OPERATION_ECRANS.op_num
          AND rownum=1
        )                             AS INFO2 ,
        RECHERCHE_ID_REGLEGESTION_CTL AS ID_REGLE
      FROM
        META_WKF_OPERATION_ECRANS
      UNION ALL
      SELECT
        'ECRAN'                AS TYPE_OBJET,
        'AUTOMATISME RD '      AS TYPE_REGLE,
        NOM_PAGE               AS INFO1,
        ''                     AS TYPE_OBJET2,
        ''                     AS INFO2 ,
        ID_REGLEGESTION_AUT_RD AS ID_REGLE
      FROM
        META_ECRAN
      UNION ALL
      SELECT
        'ECRAN'                 AS TYPE_OBJET,
        'AUTOMATISME CLI '      AS TYPE_REGLE,
        NOM_PAGE                AS INFO1,
        ''                      AS TYPE_OBJET2,
        ''                      AS INFO2 ,
        ID_REGLEGESTION_AUT_CLI AS ID_REGLE
      FROM
        META_ECRAN
      UNION ALL
      SELECT
        'ECRAN'                AS TYPE_OBJET,
        'CONTROLE RD  '        AS TYPE_REGLE,
        NOM_PAGE               AS INFO1,
        ''                     AS TYPE_OBJET2,
        ''                     AS INFO2 ,
        ID_REGLEGESTION_CTL_RD AS ID_REGLE
      FROM
        META_ECRAN
      UNION ALL
      SELECT
        'ECRAN'                 AS TYPE_OBJET,
        'CONTROLE CLI '         AS TYPE_REGLE,
        NOM_PAGE                AS INFO1,
        ''                      AS TYPE_OBJET2,
        ''                      AS INFO2 ,
        ID_REGLEGESTION_CTL_CLI AS ID_REGLE
      FROM
        META_ECRAN
    )
    Z,
    meta_reglegestion_desc A
  WHERE
    Z.id_regle(+) = a.id_reglegestion
##
META_UTILISATION
=SQL=
CREATE OR REPLACE VIEW META_UTILISATION as
SELECT
  G.NOM_DONNEE,
  G.LIBELLE_DONNEE,
  G.NOM_DICTIONNAIRE,
  G.TYPE_DONNEE,
  G.LONGUEUR_MASQUE_NB_ENTIERS,
  G.NB_DECIMAUX,
  G.UTILISATION,
  G.ACTIF,
  G.ID_PROJET,
  NVL(U.TYPE_OBJET,'aucun') AS TYPE_OBJET,
  NVL(U.CODE_OBJET,'aucun') AS CODE_OBJET
FROM
  meta_donnee_generale G
LEFT JOIN
  (
    SELECT DISTINCT
      'GROUPE' AS TYPE_OBJET,
      dg.nom_donnee,
      gd.id_groupe AS CODE_OBJET
    FROM
      meta_donnee_generale dg,
      meta_groupe_donnees gd
    WHERE
      dg.company_id   ='*'
    AND gd.company_id =dg.company_id
    AND dg.nom_donnee =gd.nom_donnee
    UNION ALL
    SELECT DISTINCT
      'REGLE' AS TYPE_OBJET,
      dg.nom_donnee,
      rg.id_reglegestion AS CODE_OBJET
    FROM
      meta_donnee_generale dg,
      meta_reglegestion rg
    WHERE
      dg.company_id   ='*'
    AND rg.company_id =dg.company_id
    AND
      (
        upper(operande1) = 'DONNEE£'
        ||upper(nom_donnee)
        ||'£'
      OR upper(operande2) = 'DONNEE£'
        ||upper(nom_donnee)
        ||'£'
      OR upper(operateur) LIKE '%DONNEE£'
        ||upper(nom_donnee)
        ||'µ%'
      OR upper(operande2) LIKE '%=DONNEE^'
        ||upper(nom_donnee)
      OR upper(operande2) LIKE '%=DONNEE^'
        ||upper(nom_donnee)
        ||'§%'
      OR upper(resultat) = 'DONNEE£'
        ||upper(nom_donnee)
      OR upper(operateur) LIKE '%DONNEE£'
        ||upper(nom_donnee)
        ||'£%'
      OR upper(operateur) LIKE '%µDONNEE£'
        ||upper(nom_donnee)
        ||'£%'
      OR upper(operateur) LIKE '%=DONNEE^'
        ||upper(nom_donnee)
        ||'µ%'
      OR upper(operateur) LIKE '%=DONNEE^'
        ||upper(nom_donnee)
        ||'§%'
      )
    UNION ALL
    SELECT DISTINCT
      'APPELTABLE_PARAM' AS TYPE_OBJET,
      dg.nom_donnee,
      appeltable_parametres AS CODE_OBJET
    FROM
      meta_donnee_generale dg,
      meta_donnee_ecran de
    WHERE
      dg.company_id            ='*'
    AND de.company_id          =dg.company_id
    AND NOT dg.nom_donnee      =de.nom_donnee
    AND appeltable_parametres IS NOT NULL
    AND ','
      ||upper(REPLACE(appeltable_parametres,' ',''))
      ||',' LIKE '%,'
      ||upper(dg.nom_donnee)
      ||',%'
    UNION ALL
    SELECT DISTINCT
      'APPELTABLE_CHAMP' AS TYPE_OBJET,
      dg.nom_donnee,
      appeltable_listechamps AS CODE_OBJET
    FROM
      meta_donnee_generale dg,
      meta_donnee_ecran de
    WHERE
      dg.company_id             ='*'
    AND de.company_id           =dg.company_id
    AND NOT dg.nom_donnee       =de.nom_donnee
    AND appeltable_listechamps IS NOT NULL
    AND ','
      ||upper(REPLACE(appeltable_listechamps,' ',''))
      ||',' LIKE '%,'
      ||upper(dg.nom_donnee)
      ||',%'
  )
  U
ON
  G.nom_donnee = U.NOM_DONNEE
WHERE
  company_id='*'
##
METIER
==
CREATE OR REPLACE FORCE VIEW "METIER" ("CODFMET", "CODMETIER", "LIBMETIER") AS   SELECT CODFMET,CODMETIER,LIBMETIER FROM POS_METIER  
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_BUSINESSUNITS
=SQL=
CREATE OR REPLACE FORCE VIEW MP_CODELISTS_ESI_BUSINESSUNITS (CID, CODE, LIBELLE_REDUIT, LIBELLE) AS 
SELECT CID, CODE_ENTITE, LIBELLE_REDUIT, LIBELLE FROM TABLE(MP_CODELISTS_ESI_GET_TAB_ENTITES('', 'TYPE_ENTITE_BUSINESS_UNITS'))
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_DEPARTMENTS
=SQL=
CREATE OR REPLACE FORCE VIEW MP_CODELISTS_ESI_DEPARTMENTS (CID, CODE, LIBELLE_REDUIT, LIBELLE) AS 
SELECT CID, CODE_ENTITE, LIBELLE_REDUIT, LIBELLE FROM TABLE(MP_CODELISTS_ESI_GET_TAB_ENTITES('', 'TYPE_ENTITE_DEPARTMENTS'))
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_JOB_TITLES
=SQL=
CREATE OR REPLACE FORCE VIEW MP_CODELISTS_ESI_JOB_TITLES (CODE, LIBELLE) AS 
SELECT DISTINCT FILIERE||REGROUPEMENT_METIER||METIER||QUALIFICATION AS CODE, LIBELLE FROM GA_FILIERE WHERE QUALIFICATION IS NOT NULL AND NUMPAC IN ('*',(SELECT VALVAR FROM SYS_VARSYS WHERE CODVAR='NS_CODE_PAC'))
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_LOCATIONS
=SQL=
CREATE OR REPLACE FORCE VIEW MP_CODELISTS_ESI_LOCATIONS (CID, CODE, LIBELLE_REDUIT, LIBELLE) AS 
SELECT CID, CODE_ENTITE, LIBELLE_REDUIT, LIBELLE FROM TABLE(MP_CODELISTS_ESI_GET_TAB_ENTITES('', 'TYPE_ENTITE_ETABLISSEMENT'))
##
TAG_CHARSET=@€éèç
##
MP_CODELISTS_ESI_PAY_GRADES
=SQL=
CREATE OR REPLACE FORCE VIEW MP_CODELISTS_ESI_PAY_GRADES (CODE, LIBELLE) AS 
SELECT CODE_NIVECH, LIBELLE FROM GA_NIVECHEL
##
TAG_CHARSET=@€éèç
##
MP_DATA_IHM
=SQL=
CREATE OR REPLACE VIEW MP_DATA_IHM (NOM_DONNEE_UX, LIBELLE_DONNEE_UX, REGROUPEMENT)AS
select M.DATA_NAME_MP_ALP, NVL(D.LABEL,M.DATA_NAME_MP_ALP), M.REGROUPEMENT from MP_DATA M
left join  MP_REF_DATA_ALP A on A.DATA_NAME_MP_ALP =  M.DATA_NAME_MP_ALP
left join MP_REF_DATA D on  D.DATA_NAME_MP=A.DATA_NAME_MP
##
TAG_CHARSET=@€éèç
##
MP_MAPPING_EVENT_DATA_IHM
=SQL=
CREATE OR REPLACE VIEW MP_MAPPING_EVENT_DATA_IHM AS
SELECT EVENT, NOM_DONNEE_DEX_OU_EVENT FROM MP_MAPPING_EVENT_DATA WHERE TYPE='D'
UNION
SELECT EVENT, NOM_DONNEE_DEX_OU_EVENT FROM (
SELECT CONNECT_BY_ROOT(EVENT) AS EVENT, NOM_DONNEE_DEX_OU_EVENT, TYPE FROM MP_MAPPING_EVENT_DATA START WITH TYPE='E' CONNECT BY PRIOR NOM_DONNEE_DEX_OU_EVENT = EVENT
) WHERE TYPE='D'
##
TAG_CHARSET=@€éèç
##
MP_REF_API
==
CREATE OR REPLACE FORCE VIEW MP_REF_API AS SELECT * FROM MP_REF_API@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_APP_OWNER
==
CREATE OR REPLACE FORCE VIEW MP_REF_APP_OWNER AS SELECT * FROM MP_REF_APP_OWNER@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_CONSUMERAPPOID
==
CREATE OR REPLACE FORCE VIEW MP_REF_CONSUMERAPPOID AS SELECT * FROM MP_REF_CONSUMERAPPOID@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_DATA
==
CREATE  OR REPLACE FORCE VIEW MP_REF_DATA AS SELECT * FROM MP_REF_DATA@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_DATA_ALP_BY_URI
=SQL=
CREATE OR REPLACE VIEW MP_REF_DATA_ALP_BY_URI (DATA_NAME_MP, DATA_NAME_MP_ALP, JSON_PATH, URI_ID, URI, API_ID, API_LABEL) AS 
SELECT DA.DATA_NAME_MP, DA.DATA_NAME_MP_ALP, CASE WHEN D.SUFFIX_JSON_PATH LIKE DU.PREFIX_JSON_PATH||'%' THEN D.SUFFIX_JSON_PATH ELSE DU.PREFIX_JSON_PATH||D.SUFFIX_JSON_PATH END
, U.URI_ID, U.URI, A.API_ID, A.API_LABEL 
FROM MP_REF_DATA_BY_URI DU, MP_REF_DATA_ALP DA, MP_REF_DATA D, MP_REF_URI U, MP_REF_API A 
WHERE DU.DATA_NAME_MP=DA.DATA_NAME_MP 
AND D.DATA_NAME_MP=DA.DATA_NAME_MP 
AND DU.URI_ID=U.URI_ID 
AND U.API_ID=A.API_ID 
UNION ALL 
SELECT NULL, M.NOM_DONNEE_UX, CASE WHEN D.SUFFIX_JSON_PATH LIKE DU.PREFIX_JSON_PATH||'%' THEN D.SUFFIX_JSON_PATH ELSE DU.PREFIX_JSON_PATH||D.SUFFIX_JSON_PATH END
, U.URI_ID, U.URI, A.API_ID, A.API_LABEL 
FROM MP_REF_CUSTOMFIELD_BY_URI DU, REF_DONNEE_MAPPING_API_IHM M, MP_REF_CUSTOMFIELD D, MP_REF_URI U, MP_REF_API A   
WHERE M.NOM_DONNEE_UX LIKE DU.CUSTOMFIELD_PREFIX_MP||'%'
AND DU.CUSTOMFIELD_PREFIX_MP=D.CUSTOMFIELD_PREFIX_MP 
AND DU.URI_ID=U.URI_ID 
AND U.API_ID=A.API_ID
##
TAG_CHARSET=@€éèç
##
MP_REF_DATA_BY_URI
==
CREATE OR REPLACE FORCE VIEW MP_REF_DATA_BY_URI AS SELECT * FROM MP_REF_DATA_BY_URI@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_DATA_MAPPING
==
CREATE OR REPLACE FORCE VIEW MP_REF_DATA_MAPPING AS SELECT * FROM MP_REF_DATA_MAPPING@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_DATA_MAPPING_IHM
=SQL=
CREATE OR REPLACE VIEW MP_REF_DATA_MAPPING_IHM AS 
SELECT DATA_NAME, DS_VALUE, NUMPAC, EXTERNAL_ID, DS_TYPE, LABEL
FROM (
 SELECT C.DATA_NAME, C.DS_VALUE, C.NUMPAC FROM MP_REF_DATA_MAPPING_CLI C
 UNION
 SELECT R.DATA_NAME_MP, R.DS_VALUE, P.NUMPAC FROM MP_REF_DATA_MAPPING@GLOBAL_DATA R, TGE_REF_PAC P
 WHERE PRODUCT_ID = 'Alp'
 AND NOT EXISTS ( SELECT C.DATA_NAME FROM MP_REF_DATA_MAPPING_CLI C WHERE R.DATA_NAME_MP = C.DATA_NAME AND C.NUMPAC = P.NUMPAC)
 )S, MP_REF_DATA@GLOBAL_DATA M
WHERE M.DS_TYPE in ('Element', 'Rubrique') AND M.DATA_NAME_MP = S.DATA_NAME
##
TAG_CHARSET=@€éèç
##
MP_REF_LEVEL
==
CREATE OR REPLACE FORCE VIEW MP_REF_LEVEL AS SELECT * FROM MP_REF_LEVEL@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_SECU_DATA
==
CREATE OR REPLACE FORCE VIEW MP_REF_SECU_DATA AS SELECT * FROM MP_REF_SECU_DATA@GLOBAL_DATA 
##
TAG_CHARSET=@€éèç
##
MP_REF_SECU_URI
==
CREATE OR REPLACE FORCE VIEW MP_REF_SECU_URI AS SELECT * FROM MP_REF_SECU_URI@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_URI
==
CREATE OR REPLACE FORCE VIEW MP_REF_URI AS SELECT * FROM MP_REF_URI@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_USECASE
==
CREATE OR REPLACE FORCE VIEW MP_REF_USECASE AS SELECT * FROM MP_REF_USECASE@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_USECASE_DATA
==
CREATE OR REPLACE FORCE VIEW MP_REF_USECASE_DATA AS SELECT * FROM MP_REF_USECASE_DATA@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_REF_USECASE_URI
==
CREATE OR REPLACE FORCE VIEW MP_REF_USECASE_URI AS SELECT * FROM MP_REF_USECASE_URI@GLOBAL_DATA
##
TAG_CHARSET=@€éèç
##
MP_SECU_CONSUMER_USECASE
==
CREATE OR REPLACE FORCE VIEW MP_SECU_CONSUMER_USECASE AS SELECT * FROM MP_SECU_CONSUMER_USECASE@GLOBAL_DATA
##
ORG_RESPONSABLE_ETAT_CIV
==
CREATE OR REPLACE FORCE VIEW "ORG_RESPONSABLE_ETAT_CIV" ("MATRICFILS", "MATRICPERE", "CODORG", "NOM_PERE", "PRENOM_PERE") AS   (select org_subalterne.matricfils, org_subalterne.matricpere ,org_subalterne.codorg ,(select nom from secumatric where secumatric.matric=org_subalterne.matricpere ) as NOM_PERE,(select prenom from secumatric where secumatric.matric=org_subalterne.matricpere ) as PRENOM_PERE from org_subalterne where codorg='GENERAL' or codorg is null)  
##
POS_LIBREFERENTIEL
==
CREATE OR REPLACE FORCE VIEW "POS_LIBREFERENTIEL" ("CODFMET", "CODMETIER", "CODEMPLOI", "NUMPOSTE", "LIBFAM", "LIBMET", "LIBEMP", "LIBPOS", "NIVEAU") AS   select codfmet as CODFMET, '' AS CODMETIER, '' AS CODEMPLOI, 0 as NUMPOSTE , Libfmet as LIBFAM, '' as LIBMET, '' as LIBEMP, '' as LIBPOS, 1 as Niveau from pos_fammetier Union select M.CODFMET as CODFMET, M.CODMETIER as CODMETIER,'' as CODEMPLOI, 0 as NUMPOSTE , F.LibFmet as LIBFAM, M.Libmetier as LIBMET, '' as LIBEMP, '' as LIBPOS, 2 as Niveau from pos_fammetier F,pos_metier M where F.CODFMET = M.CODFMET Union select E.CODFMET as CODFMET, E.CODMETIER as CODMETIER, E.CODEMPLOI as CODEMPLOI ,0 as NUMPOSTE, F.LibFmet as LIBFAM, M.Libmetier as LIBMET, E.Libemploi as LIBEMP, '' as LIBPOS, 3 as Niveau from pos_fammetier F,pos_metier M,pos_emploi E where F.CODFMET = M.CODFMET and M.CODFMET = E.CODFMET and M.CODMETIER = E.CODMETIER Union select E.CODFMET as CODFMET, M.CODMETIER as CODMETIER, E.CODEMPLOI as CODEMPLOI ,P.NUMPOSTE as NUMPOSTE , F.LibFmet as LIBFAM, M.Libmetier as LIBMET, E.Libemploi as LIBEMP, P.LIBPOSTE as LIBPOS,4 as Niveau from pos_fammetier F,pos_metier M,pos_emploi E, pos_poste P where F.CODFMET = M.CODFMET and M.CODFMET = E.CODFMET and M.CODMETIER = E.CODMETIER and E.CODEMPLOI = P.CODEMPLOI  
##
RAGAFF_TEMP
==
CREATE OR REPLACE FORCE VIEW "RAGAFF_TEMP" ("MATRIC", "CODTS", "DATDEB", "DATFIN", "CODNIV6", "CODNIV5", "CODNIV4", "CODNIV3", "CODNIV2", "CODNIV1") AS   (select MATRIC,CODTS,DATDEB,DATFIN,CODNIV6,CODNIV5,CODNIV4,CODNIV3,CODNIV2,CODNIV1 from ragaff where ragaff.matric not like '00%')  
##
TAG_CHARSET=@€éèç
##
REF_DONNEE_MAPPING_API_IHM
=SQL=
CREATE OR REPLACE VIEW REF_DONNEE_MAPPING_API_IHM (NOM_DONNEE_UX, NOM_DONNEE, CONDITION, LIBELLE_DONNEE_DEFAUT) AS 
SELECT NOM_DONNEE_UX, NOM_DONNEE, CONDITION, NULL FROM REF_DONNEE_MAPPING_UX 
UNION ALL 
SELECT NOM_DONNEE_UX, NOM_DONNEE, CONDITION, NULL FROM REF_DONNEE_MAPPING_API_CLI 
WHERE NOM_DONNEE IS NOT NULL AND NOM_DONNEE_UX NOT IN (SELECT NOM_DONNEE_UX FROM REF_DONNEE_MAPPING_UX) 
UNION ALL 
SELECT 'managerId', 'MATRICPERE', NULL, 'Manager' FROM DUAL 
UNION ALL 
SELECT 'actualStartDate', 'DATE_EFF', NULL, 'Date d''effet' FROM DUAL 
UNION ALL 
SELECT 'payrollFileNumber', 'PACMAT', NULL, 'Date d''effet' FROM DUAL 
UNION ALL 
SELECT 'workerStatus', 'STATUT', NULL, 'Statut (actif / inactif)' FROM DUAL 
UNION ALL 
SELECT 'formattedName', 'NOM,PRENOM', NULL, 'Nom + Prénom' FROM DUAL 
UNION ALL 
SELECT 'strucAffectationId', 'CODE_ENTITE', NULL, 'Affectation hiérarchique' FROM DUAL 
UNION ALL 
SELECT 'weeklyHours', 'HORAIRE_HEBDO', NULL, 'Horaire hebdomadaire' FROM DUAL 
UNION ALL 
SELECT 'monthlyHours', 'HORAIRE_MENSUEL', NULL, 'Horaire mensuel' FROM DUAL 
##
TAG_CHARSET=@€éèç
##
REF_HISTO_PROJET
=SQL=
CREATE OR REPLACE FORCE VIEW "REF_HISTO_PROJET" ("COMPANY_ID", "NUM_DIT", "NUM_VERSION", "ID_PROJET", "LIBELLE_PROJET", "DATE_VERSION", "USER_VERSION", "DESCRIPTION", "DATE_CREATION", "TERMINE", "AFFICHEBTN", "ENATTENTE", "RAPPORT", "AFFICHEDLSCRIPT") AS
WITH LIST_PROJ_EN_COURS AS (
  SELECT * from BATCH_LIST where PARAM_LIST like '%ID_PROJET%' AND FAMILLE = 'BATCH_GEN')  
  SELECT P.COMPANY_ID,
  P.NUM_DIT,
 (SELECT M.NUM_VERSION
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS NUM_VERSION,
 P.ID_PROJET,
 P.LIBELLE_PROJET ,
 (SELECT M.DATE_VERSION
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS DATE_VERSION,
 (SELECT M.USER_VERSION
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS USER_VERSION ,
 P.DESCRIPTION ,
 P.DATE_CREATION,
 CASE P.TERMINE
 WHEN 'O'
 THEN 'Terminé'
 WHEN 'N'
 THEN ''
WHEN 'E' THEN 'En cours...'
 WHEN 'E1' THEN 'Etape 1/6 '
 WHEN 'E2' THEN 'Etape 2/6 '
 WHEN 'E3' THEN 'Etape 3/6 '
 WHEN 'E4' THEN 'Etape 4/6 '
 WHEN 'E5' THEN 'Etape 5/6 '
 WHEN 'E6' THEN 'Etape 6/6 '
 WHEN 'S'
 THEN 'Supprimé'
 END TERMINE,
 CASE WHEN P.TERMINE='N' THEN 'visible' ELSE 'invisible' END AFFICHEBTN,
 (SELECT
 CASE L.classe_name
 WHEN 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_bacASable'
 THEN 'Bac à Sable en attente...'
 WHEN 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_updateProduct'
 THEN 'Mise au produit en attente...'
 WHEN 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_deploiement'
 THEN 'Livraison en attente...'
 END
 FROM batch_list L,
 batch_queue B
 WHERE L.id_trt = B.id_trt
 AND L.famille  = B.famille
 AND L.famille  ='BATCH_GEN'
 AND L.id_trt in (SELECT id_trt FROM LIST_PROJ_EN_COURS)
 AND state='WAIT'
 ) AS ENATTENTE,
 (SELECT
 CASE
 WHEN NVL(LENGTH(M.RAPPORT),0) >0
 THEN 'Rapport'
 ELSE ''
 END RAPPORT
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS RAPPORT,
 CASE WHEN P.TERMINE='O' THEN 'visible' ELSE 'invisible' END AFFICHEDLSCRIPT
 FROM META_PROJET P
 WHERE P.COMPANY_ID ='*'
 ORDER BY DATE_VERSION DESC,
 NUM_VERSION DESC ,
 ID_PROJET DESC
##
TAG_CHARSET=@€éèç
##
REF_HISTO_PROJET_VIEW
=SQL=
CREATE OR REPLACE FORCE VIEW "REF_HISTO_PROJET_VIEW" ("COMPANY_ID", "NUM_DIT", "NUM_VERSION", "ID_PROJET", "LIBELLE_PROJET", "DATE_VERSION", "USER_VERSION", "DESCRIPTION", "DATE_CREATION", "TERMINE", "AFFICHEBTN", "ENATTENTE", "RAPPORT", "AFFICHEDLSCRIPT") AS
WITH LIST_PROJ_EN_COURS AS (
  SELECT * from BATCH_LIST where PARAM_LIST like '%ID_PROJET%' AND FAMILLE = 'BATCH_GEN')  
  SELECT P.COMPANY_ID,
  P.NUM_DIT,
 (SELECT M.NUM_VERSION
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS NUM_VERSION,
 P.ID_PROJET,
 P.LIBELLE_PROJET ,
 (SELECT TO_CHAR(to_date (M.DATE_VERSION, 'YYYYMMDDHH24MISS'),'DD.MM.YYYY HH24:MI:SS')
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS DATE_VERSION,
 (SELECT M.USER_VERSION
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS USER_VERSION ,
 P.DESCRIPTION ,
 TO_CHAR(to_date ( P.DATE_CREATION, 'YYYYMMDDHH24MISS'),'DD.MM.YYYY HH24:MI:SS'),
 CASE P.TERMINE
 WHEN 'O'
 THEN 'Terminé'
 WHEN 'N'
 THEN ''
WHEN 'E' THEN 'En cours...'
 WHEN 'E1' THEN 'Etape 1/6 '
 WHEN 'E2' THEN 'Etape 2/6 '
 WHEN 'E3' THEN 'Etape 3/6 '
 WHEN 'E4' THEN 'Etape 4/6 '
 WHEN 'E5' THEN 'Etape 5/6 '
 WHEN 'E6' THEN 'Etape 6/6 '
 WHEN 'S'
 THEN 'Supprimé'
 END TERMINE,
 CASE WHEN P.TERMINE='N' THEN 'visible' ELSE 'invisible' END AFFICHEBTN,
 CASE
 WHEN  EXISTS (select 1 from  batch_list L,
 batch_queue B
 WHERE L.id_trt = B.id_trt
 AND L.famille  = B.famille
 AND L.famille  ='BATCH_GEN' 
 and L.param_list like concat ('%ID_PROJET=',concat (P.ID_PROJET, ';%'))and B.state = 'WAIT' AND L.classe_name= 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_bacASable') THEN 'Bac à Sable en attente...'
 WHEN   EXISTS (select 1 from  batch_list L,
 batch_queue B
 WHERE L.id_trt = B.id_trt
 AND L.famille  = B.famille
 AND L.famille  ='BATCH_GEN' 
 and L.param_list like concat ('%ID_PROJET=',concat (P.ID_PROJET, ';%')) and B.state = 'WAIT' AND L.classe_name= 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_updateProduct') THEN 'Mise au produit en attente...'
 WHEN   EXISTS (select 1 from  batch_list L,
 batch_queue B
 WHERE L.id_trt = B.id_trt
 AND L.famille  = B.famille
 AND L.famille  ='BATCH_GEN' 
 and L.param_list like concat ('%ID_PROJET=',concat (P.ID_PROJET, ';%')) and B.state = 'WAIT' AND L.classe_name= 'fr.adp.com.gxp.std.mot_tech.lib.deploiement.Traitement_deploiement') THEN 'Livraison en attente...'
 else ''
 END 
 AS ENATTENTE,
 (SELECT
 CASE
 WHEN NVL(LENGTH(M.RAPPORT),0) >0
 THEN 'Rapport'
 ELSE ''
 END RAPPORT
 FROM REF_OBJ_MISEAUPRODUIT M
 WHERE M.COMPANY_ID = P.COMPANY_ID
 AND M.ID_PROJET    = P.ID_PROJET
 ) AS RAPPORT,
 CASE WHEN P.TERMINE='O' THEN 'visible' ELSE 'invisible' END AFFICHEDLSCRIPT
 FROM META_PROJET P
 WHERE P.COMPANY_ID ='*'
 ORDER BY DATE_VERSION DESC,
 NUM_VERSION DESC ,
 ID_PROJET DESC
##
REF_OBJ_LIVRABLES
=SQL=
CREATE OR REPLACE FORCE VIEW "REF_LIVRABLES" ("NUM_LIVRABLE", "COMPANY_ID", "DATE_LIVRABLE", "NOM_PRENOM",  "RAPPORT", "ETAPE", "DESCRIPTION","VERSION_MODELE") AS 
  (
SELECT LIV.NUM_LIVRABLE,
  COMPANY_ID,
  DATE_LIVRABLE,
  (SELECT PRENOM    ||' '    || NOM  FROM SYS_COLLABORATEURS  WHERE matric= USER_LIVRABLE  ) as NOM_PRENOM,
  CASE  WHEN RAPPORT IS NULL   THEN 'no' ELSE 'ok'  END AS RAPPORT,
  CASE
    WHEN STATUS ='E1'    THEN 'Etape 1/11'
    WHEN STATUS ='E2'    THEN 'Etape 2/11'
    WHEN STATUS ='E3'    THEN 'Etape 3/11'
    WHEN STATUS ='E4'    THEN 'Etape 4/11'
    WHEN STATUS ='E5'    THEN 'Etape 5/11'
    WHEN STATUS ='E6'    THEN 'Etape 6/11'
    WHEN STATUS ='E7'    THEN 'Etape 7/11'
    WHEN STATUS ='E8'    THEN 'Etape 8/11'
    WHEN STATUS ='E9'   THEN 'Etape 9/11'
    WHEN STATUS ='E10'   THEN 'Etape 10/11'
    WHEN STATUS ='F'    THEN 'Terminé'
    ELSE '...'
  END as ETAPE,
  DESCRIPTION,
  VERSION_MODELE
FROM REF_OBJ_LIVRABLES LIV)
##
REQUETESIMPLE_HELPDESK
==
CREATE OR REPLACE FORCE VIEW "REQUETESIMPLE_HELPDESK" ("NOMREQUETE", "UTILISATEUR", "APPLICATION", "REQUETE", "REQUETEECR_GSI", "REQUETESQL_GSI", "TYPE_REQUETE", "EST_VISIBLE") AS   select NOMREQUETE,UTILISATEUR,APPLICATION,REQUETE,REQUETEECR_GSI,REQUETESQL_GSI,TYPE_REQUETE,EST_VISIBLE from requetesimple where application='HELPDESK'      
##
REQ_LISTE_ENTITES_EXCEPTION
==
CREATE OR REPLACE VIEW REQ_LISTE_ENTITES_EXCEPTION AS SELECT * FROM SYS_SEC_RESOLUE_STRUCT_EXCEPT
##
REQ_POPULATION_EXCEPTION
==
CREATE OR REPLACE VIEW REQ_POPULATION_EXCEPTION AS SELECT * FROM SYS_SEC_RESOLUE_POP_EXCEPT
##
TAG_CHARSET=@€éèç
##
RETRO_ORIGINE
==
CREATE OR REPLACE FORCE VIEW RETRO_ORIGINE ("NUMPAC","PACMAT","PERIODE_RETRO","ORIGINE_MAJ","DATE_MAJ") AS SELECT numpac, pacmat, periode_retro, CASE WHEN table_maj = 'TGE_DONNEES_PAIE' THEN 'Données variables et rappels' WHEN table_maj = 'TGE_ELEMENTS_PAIE' THEN 'Eléments de paie' WHEN table_maj = 'TGE_INCIDENTS_PAIE' THEN 'Absences et Incidents' ELSE (select LIBELLE_DICTIONNAIRE from meta_dictionnaire_ihm where COMPANY_ID = '*' and NOM_DICTIONNAIRE = table_maj) END origine_maj, date_maj FROM tge_modif_pacmat_retro UNION ALL SELECT  numpac, pacmat, periode_retro, 'Manuelle ('  || aoid  || ')' origine_maj, date_maj FROM  gap_selection_retro
##
SECUMATRIC
==
CREATE OR REPLACE FORCE VIEW SECUMATRIC AS SELECT * FROM SECUPACMAT WHERE PRIORITE_SITUATION=0
##
SIM_TRT_AREALISER
=SQL=
CREATE OR REPLACE VIEW SIM_TRT_AREALISER AS
SELECT
    DISTINCT R.NUM_SIMU, R.NOM_PAGE,R.NUMPAC,R.PACMAT, R.NUMCNT,R.DATE_EFF, k.TERMINE,k.SIMULATION
  FROM
    (SELECT *    FROM SIM_SAISIES S    JOIN SIM_DONNEE_ECRAN D    ON D.NOM_DONNEE = S.NOM_DONNEE  ) R
  	JOIN
    (SELECT * FROM SIM_LISTE WHERE TERMINE NOT IN ('T','T'))K
  ON K.NUM_SIMU =R.NUM_SIMU
ORDER BY 
R.NUM_SIMU, R.NOM_PAGE,R.NUMPAC,R.PACMAT, R.NUMCNT,R.DATE_EFF
##
SITUATION_PAIE
=SQL=
CREATE OR REPLACE FORCE VIEW SITUATION_PAIE ("NUMPAC", "PACMAT", "NUMCNT", "PAIEZAD", "DSDSC", "DSFSC", "TYPE_CHANG_SITU", "CODE_CHRONO", "MATRIC", "IDPACMAT", "DATE_CREATION", "DATE_DERNIERE_MODIF", "PERIODEENCOURS", "RETRO_ENTREE", "RETRO_SORTIE") AS 
SELECT SITU.NUMPAC,
SITU.PACMAT,
SITU.NUMCNT,
SITU.PAIEZAD,
SITU.DSDSC,     
SITU.DSFSC,
SITU.TYPE_CHANG_SITU,
SITU.CODE_CHRONO,
SITU.MATRIC,
SITU.IDPACMAT,
SITU.DATE_CREATION,
SITU.DATE_DERNIERE_MODIF,
PAC.PERIODEENCOURS,
CASE WHEN SITU.DSDSC < TO_DATE(PER.DATE_DEBUT_MOIS,'yyyymmdd') 
  AND (P.PACMAT IS NULL 
  	OR NVL(P.DSDCN, TO_DATE('01.01.1700', 'dd.MM.yyyy')) != NVL(SITU.DSDSC, TO_DATE('01.01.1700', 'dd.MM.yyyy'))
  )
  THEN 'O' ELSE 'N' END AS RETRO_ENTREE,
  
CASE WHEN SITU.DSFSC < TO_DATE(PER.DATE_DEBUT_MOIS,'yyyymmdd') 
  AND (P.PACMAT IS NULL 
  	OR NVL(P.DSFCN, TO_DATE('01.01.1700', 'dd.MM.yyyy')) != NVL(SITU.DSFSC, TO_DATE('01.01.1700', 'dd.MM.yyyy'))
  )
  THEN 'O' ELSE 'N' END AS RETRO_SORTIE
 FROM DIC_ADM_CONTRAT_SITU SITU INNER JOIN TGE_REF_PAC PAC ON SITU.NUMPAC = PAC.NUMPAC 
  INNER JOIN TGE_REF_PER PER ON PER.NUMPAC = SITU.NUMPAC AND PER.PERIODEENCOURS = PAC.PERIODEENCOURS
  LEFT JOIN PHOTO_DIC_ADM_CONTRAT P
    ON SITU.NUMPAC  = P.NUMPAC
    AND SITU.PACMAT = P.PACMAT
    AND SITU.NUMCNT = P.NUMCNT
    ##
TAG_CHARSET=@€éèç
##
STD_ANNUAIRE
=SQL=
CREATE OR REPLACE FORCE VIEW "STD_ANNUAIRE" ("MATRICULE", "NOM", "PRENOM", "LOGIN", "MATRICRESP", "LABELRESP", "NOMRESP", "PRENOMRESP", "LOGINRESP",  "PHONE1EXT", "PHONE1NUM", "PHONE1LIB", "PHONE2EXT", "PHONE2NUM", "PHONE2LIB", "PHONE3EXT", "PHONE3NUM", "PHONE3LIB", "PHONE4EXT", "PHONE4NUM", "PHONE4LIB", "EMAIL1LIB", "EMAIL1ADRESSE", "EMAIL2LIB", "EMAIL2ADRESSE", "EMPLOILIB", "EMPLOI", "ETABLISSEMENTLIB", "ETABLISSEMENT", "INTITULE1", "VALEUR1", "INTITULE2", "VALEUR2", "INTITULE3", "VALEUR3", "INTITULE4", "VALEUR4", "INTITULE5", "VALEUR5", "INTITULE6", "VALEUR6", "INTITULE7", "VALEUR7", "INTITULE8", "VALEUR8", "INTITULE9", "VALEUR9") AS 
  (
SELECT
 DIC_ADM_PERSO.MATRIC AS MATRICULE,
 DIC_ADM_PERSO.NOM      AS NOM,
 DIC_ADM_PERSO.PRENOM      AS PRENOM,
 (SELECT MIN(LOGIN) FROM SYS_USR_CONFIG SUC1 
 WHERE SUC1.REQUETEMATRIC = SECUPACMAT.MATRIC AND 
(LOGIN LIKE '%-%' OR NOT EXISTS (SELECT 1 FROM SYS_USR_CONFIG SUC2 WHERE REQUETEMATRIC=SUC1.REQUETEMATRIC AND LOGIN LIKE '%-%'))) AS LOGIN,
 (
 SELECT MIN(MATRICPERE)
 FROM ORG_SUBALTERNE
 WHERE CODORG = 'GENERAL' AND ORG_SUBALTERNE.MATRICFILS=DIC_ADM_PERSO.MATRIC
 ) as MATRICRESP,
 'Responsable hiérarchique' as labelresp,
 (SELECT NOM
 FROM DIC_ADM_PERSO EORG
 WHERE EORG.MATRIC=
 (SELECT MIN(MATRICPERE)
 FROM ORG_SUBALTERNE
 WHERE CODORG = 'GENERAL' AND ORG_SUBALTERNE.MATRICFILS=DIC_ADM_PERSO.MATRIC
 )) AS NOMRESP,
 (SELECT PRENOM
 FROM DIC_ADM_PERSO EORG
 WHERE EORG.MATRIC=
 (SELECT MIN(MATRICPERE)
 FROM ORG_SUBALTERNE
 WHERE CODORG = 'GENERAL' AND ORG_SUBALTERNE.MATRICFILS=DIC_ADM_PERSO.MATRIC
 )) AS PRENOMRESP,
 ''                     AS LOGINRESP, 
 ''                     AS PHONE1EXT,
 DIC_ADM_PERSO.NOPRO    AS PHONE1NUM,
 'Bureau'               AS PHONE1LIB,  
 ''                     AS PHONE2EXT,
 DIC_ADM_PERSO.NOPORT   AS PHONE2NUM,
 'Mobile Pro'           AS PHONE2LIB,
 ''   					AS PHONE3EXT,
 DIC_ADM_PERSO.NOFAX    AS PHONE3NUM,
 'Fax'                  AS PHONE3LIB,  
 ''                     AS PHONE4EXT,
 DIC_ADM_PERSO.NOPORP   AS PHONE4NUM,
 'Mobile perso'         AS PHONE4LIB,
 'Email' 				AS EMAIL1LIB,
 DIC_ADM_PERSO.MELPRO   AS EMAIL1ADRESSE,
 'Email perso'     		AS EMAIL2LIB,
 DIC_ADM_PERSO.MELPER     AS EMAIL2ADRESSE,
 'Emploi'               AS emploilib,
 (SELECT F.LIBELLE
 FROM GA_FILIERE F
 WHERE
 SECUPACMAT.FILIR   =F.FILIERE
 AND SECUPACMAT.SSFIL   =F.REGROUPEMENT_METIER
 AND SECUPACMAT.METIER  =F.METIER
 AND SECUPACMAT.EMPLOI  =F.QUALIFICATION
 AND SECUPACMAT.NUMPAC  =F.NUMPAC
 )              AS emploi,
 'Etablissement' AS etablissementlib,
 (
 select max(ent.libelle) from std_struc_affectation aff, 
 std_struc_entite ent
 where aff.code_entite = ent.code_entite
  and  aff.date_eff between ent.date_eff and ent.date_fin
  and  aff.matric =  DIC_ADM_PERSO.MATRIC
  and sysdate between TO_DATE(aff.date_eff,'yyyymmdd') and to_date(aff.date_fin,'yyyymmdd')
  and aff.codts = 1
 ) AS etablissement,
 '' AS INTITULE1,
 '' AS VALEUR1,
 '' AS INTITULE2,
 '' AS VALEUR2,
 '' AS INTITULE3,
 '' AS VALEUR3,
 '' AS INTITULE4,
 '' AS VALEUR4,
 '' AS INTITULE5,
 '' AS VALEUR5,
 '' AS INTITULE6,
 '' AS VALEUR6,
 '' AS INTITULE7,
 '' AS VALEUR7,
 '' AS INTITULE8,
 '' AS VALEUR8,
 '' AS INTITULE9,
 '' AS VALEUR9
 FROM DIC_ADM_PERSO,SECUPACMAT WHERE PRIORITE_SITUATION = 0 AND DIC_ADM_PERSO.MATRIC = SECUPACMAT.MATRIC)
##
STD_CODPOST
==
CREATE OR REPLACE VIEW STD_CODPOST (CODE_POSTAL, CODE_INSEE, CODE_COMMUNE, BUREAU_DIST) AS SELECT CODE_POSTAL, CODE_INSEE, LOCALITE, ACHEMINEMENT FROM STD_HEXAPOSTE
##
TAG_CHARSET=@€éèç
##
STD_NIVEAUX
==
CREATE OR REPLACE FORCE VIEW "STD_NIVEAUX" ("NIV", "CODNIV1", "LIBNIV1", "CODNIV2", "LIBNIV2", "CODNIV3", "LIBNIV3", "CODNIV4", "LIBNIV4", "CODNIV5", "LIBNIV5", "CODNIV6", "LIBNIV6", "CODTS", "DATE_OUV", "DATE_FERM", "EST_PREV", "NUMV", "NOMV", "COM", "CP", "SIGLE", "DISTRI", "SIREN", "NIC", "BTQ", "TYPV", "ETAT") AS   ( SELECT '1' AS niv, n.CODNIV1 , n.libniv1 , '' AS codniv2 , '' AS libniv2 , '' AS codniv3 , '' AS libniv3 , '' AS codniv4 , '' AS libniv4 , '' AS codniv5 , '' AS libniv5 , '' AS codniv6 , '' AS libniv6 , n.CODTS , DATE_OUV , DATE_FERM , EST_PREV , (SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 IS NULL) AS TYPV , ( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv1 n UNION ALL SELECT '2' AS niv, n.CODNIV1 , (SELECT LIBNIV1 FROM niv1 WHERE niv1.codniv1=n.codniv1 AND niv1.codts = n.codts) AS libniv1 , n.CODNIV2 , n.libniv2 , '' AS codniv3, '' AS libniv3, '' AS codniv4, '' AS libniv4, '' AS codniv5, '' AS libniv5, '' AS codniv6, '' AS libniv6, n.CODTS , DATE_OUV , DATE_FERM , EST_PREV , (SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 IS NULL) AS TYPV , ( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv2 n UNION ALL SELECT '3' AS niv, n.CODNIV1 , (SELECT LIBNIV1 FROM niv1 WHERE niv1.codniv1=n.codniv1 AND niv1.codts = n.codts) AS libniv1, n.CODNIV2 , (SELECT LIBNIV2 FROM niv2 WHERE niv2.codniv1=n.codniv1 AND niv2.codniv2 = n.codniv2 AND niv2.codts = n.codts) AS libniv2 , n.CODNIV3 , n.libniv3 , '' AS codniv4, '' AS libniv4, '' AS codniv5, '' AS libniv5, '' AS codniv6, '' AS libniv6, n.CODTS , DATE_OUV , DATE_FERM , EST_PREV ,(SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 IS NULL) AS TYPV , ( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv3 n UNION ALL SELECT '4' AS niv, n.CODNIV1 , (SELECT LIBNIV1 FROM niv1 WHERE niv1.codniv1=n.codniv1 AND niv1.codts = n.codts) AS libniv1, n.CODNIV2 , (SELECT LIBNIV2 FROM niv2 WHERE niv2.codniv1=n.codniv1 AND niv2.codniv2 = n.codniv2 AND niv2.codts = n.codts) AS libniv2, n.CODNIV3 , (SELECT LIBNIV3 FROM niv3 WHERE niv3.codniv1=n.codniv1 AND niv3.codniv2 = n.codniv2 AND niv3.codniv3 = n.codniv3 AND niv3.codts = n.codts) AS libniv3 , n.CODNIV4 , n.libniv4 , '' AS codniv5, '' AS libniv5, '' AS codniv6, '' AS libniv6, n.CODTS , DATE_OUV , DATE_FERM , EST_PREV , (SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 IS NULL) AS TYPV ,( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv4 n UNION ALL SELECT '5' AS niv, n.CODNIV1 , (SELECT LIBNIV1 FROM niv1 WHERE niv1.codniv1=n.codniv1 AND niv1.codts = n.codts) AS libniv1, n.CODNIV2 , (SELECT LIBNIV2 FROM niv2 WHERE niv2.codniv1=n.codniv1 AND niv2.codniv2 = n.codniv2 AND niv2.codts = n.codts) AS libniv2, n.CODNIV3 , (SELECT LIBNIV3 FROM niv3 WHERE niv3.codniv1=n.codniv1 AND niv3.codniv2 = n.codniv2 AND niv3.codniv3 = n.codniv3 AND niv3.codts = n.codts) AS libniv3, n.CODNIV4 , (SELECT LIBNIV4 FROM niv4 WHERE niv4.codniv1=n.codniv1 AND niv4.codniv2 = n.codniv2 AND niv4.codniv3 = n.codniv3 AND niv4.codniv4 = n.codniv4 AND niv4.codts = n.codts) AS libniv4 , n.CODNIV5 , n.libniv5 , '' AS codniv6, '' AS libniv6, n.CODTS , DATE_OUV , DATE_FERM , EST_PREV ,(SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 IS NULL) AS TYPV ,( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv5 n UNION ALL SELECT '6' AS niv, n.CODNIV1 , (SELECT LIBNIV1 FROM niv1 WHERE niv1.codniv1=n.codniv1 AND niv1.codts = n.codts) AS libniv1, n.CODNIV2 , (SELECT LIBNIV2 FROM niv2 WHERE niv2.codniv1=n.codniv1 AND niv2.codniv2 = n.codniv2 AND niv2.codts = n.codts) AS libniv2, n.CODNIV3 , (SELECT LIBNIV3 FROM niv3 WHERE niv3.codniv1=n.codniv1 AND niv3.codniv2 = n.codniv2 AND niv3.codniv3 = n.codniv3 AND niv3.codts = n.codts) AS libniv3, n.CODNIV4 , (SELECT LIBNIV4 FROM niv4 WHERE niv4.codniv1=n.codniv1 AND niv4.codniv2 = n.codniv2 AND niv4.codniv3 = n.codniv3 AND niv4.codniv4 = n.codniv4 AND niv4.codts = n.codts) AS libniv4, n.CODNIV5 , (SELECT LIBNIV5 FROM niv5 WHERE niv5.codniv1=n.codniv1 AND niv5.codniv2 = n.codniv2 AND niv5.codniv3 = n.codniv3 AND niv5.codniv4 = n.codniv4 AND niv5.codniv5 = n.codniv5 AND niv5.codts = n.codts) AS libniv5, n.CODNIV6 , n.LIBNIV6 , n.CODTS , DATE_OUV , DATE_FERM , EST_PREV , (SELECT MAX(NUMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS NUMV, (SELECT MAX(NOMV) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS NOMV, (SELECT MAX(COM) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS COM, (SELECT MAX(CP) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS CP, (SELECT MAX(SIGLE) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS SIGLE, (SELECT MAX(DISTRI) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS DISTRI, (SELECT MAX(SIREN) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS SIREN, (SELECT MAX(NIC) FROM STD_ADRSTR ad WHERE ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS NIC, (SELECT LIB FROM BTQ b,STD_ADRSTR ad WHERE b.COD=ad.BTQ AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS BTQ , (SELECT t.LIBELLE FROM STD_TYPE_VOIE t,STD_ADRSTR ad WHERE t.CODE=ad.TYPV AND ad.CODTS = n.CODTS AND ad.codniv1 = n.CODNIV1 AND ad.CODNIV2 = n.CODNIV2 AND ad.CODNIV3 = n.CODNIV3 AND ad.CODNIV4 = n.CODNIV4 AND ad.CODNIV5 = n.CODNIV5 AND ad.CODNIV6 = n.CODNIV6) AS TYPV ,( CASE WHEN Date_ouv <TO_CHAR(sysdate,'yyyymmdd') AND (date_Ferm>TO_CHAR(sysdate,'yyyymmdd') OR date_ferm IS NULL) THEN 'O' ELSE 'F' END) AS Etat FROM niv6 n)
##
STD_NIVEAUX
==
drop view STD_NIVEAUX
##
STD_REQUETE
==
CREATE OR REPLACE FORCE VIEW STD_REQUETE (NOMREQUETE, UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, TYPEREQUETE, EST_VISIBLE, KEEP_AND_IN_REQ_STRUCT) AS SELECT NOMREQUETE, UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, 'S' AS TYPEREQUETE, EST_VISIBLE, KEEP_AND_IN_REQ_STRUCT FROM REQUETESIMPLE
##
STD_REQUETE
==
CREATE OR REPLACE FORCE VIEW STD_REQUETE (NOMREQUETE, UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, TYPEREQUETE, EST_VISIBLE, KEEP_AND_IN_REQ_STRUCT, NUMPAC) AS SELECT NOMREQUETE, UTILISATEUR, APPLICATION, REQUETE, REQUETEECR_GSI, REQUETESQL_GSI, TYPE_REQUETE, 'S' AS TYPEREQUETE, EST_VISIBLE, KEEP_AND_IN_REQ_STRUCT, NUMPAC FROM REQUETESIMPLE
##
STD_RUBEPS
==
CREATE OR REPLACE FORCE VIEW "STD_RUBEPS" ("CODRUB", "FAMILL", "LIBFAM", "LIBTOT", "SENS", "AJOUT", "NAJOUT", "TAJOUT", "MAJOUT", "MODIF", "NMODIF", "TMODIF", "MMODIF", "REGUL", "NREGUL", "TREGUL", "MREGUL", "RESUL", "RESULG", "RESULC", "TRAIT", "SSREGL", "LIBRED", "TYPREG", "NUSEQU", "ALGO", "LIBALGO", "TYPRUB", "NATRUB", "GRPRUB", "DOMRUB", "DETRUB", "F01RUB", "F02RUB", "EDITN", "EDITT", "EDITM", "EDABS", "FERUB", "TYPENR", "SSCODE", "ISRAP") AS WITH T1 AS (SELECT  STD_FRUBRIQ.*,'P' AS TYPENR FROM STD_FRUBRIQ UNION SELECT  STD_FRUBRIQ.* ,'C' AS TYPENR FROM STD_FRUBRIQ ) SELECT T1."CODRUB",T1."FAMILL",T1."LIBFAM",T1."LIBTOT",T1."SENS",T1."AJOUT",T1."NAJOUT",T1."TAJOUT",T1."MAJOUT",T1."MODIF",T1."NMODIF",T1."TMODIF",T1."MMODIF",T1."REGUL",T1."NREGUL",T1."TREGUL",T1."MREGUL",T1."RESUL",T1."RESULG",T1."RESULC",T1."TRAIT",T1."SSREGL",T1."LIBRED",T1."TYPREG",T1."NUSEQU",T1."ALGO",T1."LIBALGO",T1."TYPRUB",T1."NATRUB",T1."GRPRUB",T1."DOMRUB",T1."DETRUB",T1."F01RUB",T1."F02RUB",T1."EDITN",T1."EDITT",T1."EDITM",T1."EDABS",T1."FERUB",T1."TYPENR" ,GAP_PARAM_SSCODE.COD AS SSCODE ,( CASE WHEN (T1.CODRUB IN (SELECT STD_RUBRETRO.RETREC FROM STD_RUBRETRO)) THEN 1 ELSE 0 END)  AS ISRAP FROM T1, GAP_PARAM_SSCODE WHERE T1.FAMILL = '5' UNION SELECT T1."CODRUB",T1."FAMILL",T1."LIBFAM",T1."LIBTOT",T1."SENS",T1."AJOUT",T1."NAJOUT",T1."TAJOUT",T1."MAJOUT",T1."MODIF",T1."NMODIF",T1."TMODIF",T1."MMODIF",T1."REGUL",T1."NREGUL",T1."TREGUL",T1."MREGUL",T1."RESUL",T1."RESULG",T1."RESULC",T1."TRAIT",T1."SSREGL",T1."LIBRED",T1."TYPREG",T1."NUSEQU",T1."ALGO",T1."LIBALGO",T1."TYPRUB",T1."NATRUB",T1."GRPRUB",T1."DOMRUB",T1."DETRUB",T1."F01RUB",T1."F02RUB",T1."EDITN",T1."EDITT",T1."EDITM",T1."EDABS",T1."FERUB",T1."TYPENR" ,' ' AS SSCODE ,( CASE WHEN (T1.CODRUB IN (SELECT STD_RUBRETRO.RETREC FROM STD_RUBRETRO)) THEN 1 ELSE 0 END)  AS ISRAP FROM T1 WHERE T1.FAMILL != '5' 
##
STD_RUBRIQ
==
CREATE OR REPLACE FORCE VIEW "STD_RUBRIQ" ("CODRUB", "SSCODE", "FAMILL", "LIBFAM", "LIBTOT", "SENS", "AJOUT", "NAJOUT", "TAJOUT", "MAJOUT", "MODIF", "NMODIF", "TMODIF", "MMODIF", "REGUL", "NREGUL", "TREGUL", "MREGUL", "RESUL", "RESULG", "RESULC", "TRAIT", "SSREGL", "LIBRED", "TYPREG", "NUSEQU", "ALGO", "LIBALGO", "TYPRUB", "NATRUB", "GRPRUB", "DOMRUB", "DETRUB", "F01RUB", "F02RUB", "EDITN", "EDITT", "EDITM", "EDABS", "FERUB", "ISRAP") AS   SELECT STD_FRUBRIQ.CODRUB,GAP_PARAM_SSCODE.COD,STD_FRUBRIQ.FAMILL,STD_FRUBRIQ.LIBFAM,STD_FRUBRIQ.LIBTOT,STD_FRUBRIQ.SENS,STD_FRUBRIQ.AJOUT,STD_FRUBRIQ.NAJOUT,STD_FRUBRIQ.TAJOUT,STD_FRUBRIQ.MAJOUT,STD_FRUBRIQ.MODIF,STD_FRUBRIQ.NMODIF,STD_FRUBRIQ.TMODIF,STD_FRUBRIQ.MMODIF,STD_FRUBRIQ.REGUL,STD_FRUBRIQ.NREGUL,STD_FRUBRIQ.TREGUL,STD_FRUBRIQ.MREGUL,STD_FRUBRIQ.RESUL,STD_FRUBRIQ.RESULG,STD_FRUBRIQ.RESULC,STD_FRUBRIQ.TRAIT,STD_FRUBRIQ.SSREGL,STD_FRUBRIQ.LIBRED,STD_FRUBRIQ.TYPREG,STD_FRUBRIQ.NUSEQU,STD_FRUBRIQ.ALGO,STD_FRUBRIQ.LIBALGO,STD_FRUBRIQ.TYPRUB,STD_FRUBRIQ.NATRUB,STD_FRUBRIQ.GRPRUB,STD_FRUBRIQ.DOMRUB,STD_FRUBRIQ.DETRUB,STD_FRUBRIQ.F01RUB,STD_FRUBRIQ.F02RUB,STD_FRUBRIQ.EDITN,STD_FRUBRIQ.EDITT,STD_FRUBRIQ.EDITM,STD_FRUBRIQ.EDABS,STD_FRUBRIQ.FERUB,( CASE WHEN (STD_FRUBRIQ.CODRUB IN (SELECT STD_RUBRETRO.RETREC FROM STD_RUBRETRO)) THEN 1 ELSE 0 END) FROM STD_FRUBRIQ, GAP_PARAM_SSCODE WHERE STD_FRUBRIQ.FAMILL = '5' UNION SELECT STD_FRUBRIQ.CODRUB,' ',STD_FRUBRIQ.FAMILL,STD_FRUBRIQ.LIBFAM,STD_FRUBRIQ.LIBTOT,STD_FRUBRIQ.SENS,STD_FRUBRIQ.AJOUT,STD_FRUBRIQ.NAJOUT,STD_FRUBRIQ.TAJOUT,STD_FRUBRIQ.MAJOUT,STD_FRUBRIQ.MODIF,STD_FRUBRIQ.NMODIF,STD_FRUBRIQ.TMODIF,STD_FRUBRIQ.MMODIF,STD_FRUBRIQ.REGUL,STD_FRUBRIQ.NREGUL,STD_FRUBRIQ.TREGUL,STD_FRUBRIQ.MREGUL,STD_FRUBRIQ.RESUL,STD_FRUBRIQ.RESULG,STD_FRUBRIQ.RESULC,STD_FRUBRIQ.TRAIT,STD_FRUBRIQ.SSREGL,STD_FRUBRIQ.LIBRED,STD_FRUBRIQ.TYPREG,STD_FRUBRIQ.NUSEQU,STD_FRUBRIQ.ALGO,STD_FRUBRIQ.LIBALGO,STD_FRUBRIQ.TYPRUB,STD_FRUBRIQ.NATRUB,STD_FRUBRIQ.GRPRUB,STD_FRUBRIQ.DOMRUB,STD_FRUBRIQ.DETRUB,STD_FRUBRIQ.F01RUB,STD_FRUBRIQ.F02RUB,STD_FRUBRIQ.EDITN,STD_FRUBRIQ.EDITT,STD_FRUBRIQ.EDITM,STD_FRUBRIQ.EDABS,STD_FRUBRIQ.FERUB,( CASE WHEN (STD_FRUBRIQ.CODRUB IN (SELECT STD_RUBRETRO.RETREC FROM STD_RUBRETRO)) THEN 1 ELSE 0 END)FROM STD_FRUBRIQ WHERE STD_FRUBRIQ.FAMILL != '5'
##
TAG_CHARSET=@€éèç
##
STD_SITUATION_SALARIE_MAN
=SQL=
CREATE OR REPLACE FORCE VIEW STD_SITUATION_SALARIE_MAN ("MATRICULE", "NOM", "PRENOM", "TITRE", "INTITULE1", "VALEUR1", "INTITULE2", "VALEUR2", "INTITULE3", "VALEUR3", "INTITULE4", "VALEUR4", "INTITULE5", "VALEUR5", "INTITULE6", "VALEUR6", "INTITULE7", "VALEUR7", "INTITULE8", "VALEUR8", "INTITULE9", "VALEUR9", "INTITULE10", "VALEUR10", "INTITULE11", "VALEUR11", "INTITULE12", "VALEUR12", "INTITULE13", "VALEUR13")
AS
  (SELECT matric    AS matricule,
    nom             AS nom,
    prenom          AS prenom,
    titre           AS titre,
    'ETABLISSEMENT' AS intitule1,
    (SELECT LIBELLE_ENTITE AS libelle
    FROM std_struc_entite_view e
    WHERE e.CODE_ENTITE=CODETB and e.CID = (select GET_CID_FOR_NUMPAC(NUMPAC) from dual) 
    )       AS valeur1,
    'NUM_SS' AS intitule2,
    SEXESS
    ||ANNESS
    ||MOISSS
    ||DEPTSS
    ||SECTSS
    ||ORDRSS
    ||CLCTSS                                            AS valeur2,
    'DATE_NAISSANCE'                                 AS intitule3,
    TO_CHAR (TO_DATE (dsnai, 'yyyymmdd'), 'dd/mm/yyyy') AS valeur3,
    'DATE_ANCIENNETE_GROUPE'                         AS intitule4,
    TO_CHAR (TO_DATE (dsagp, 'yyyymmdd'), 'dd/mm/yyyy') AS valeur4,
    'DATE_ANCIENNETE'                                AS intitule5,
    TO_CHAR (TO_DATE (dsato, 'yyyymmdd'), 'dd/mm/yyyy') AS valeur5,
    'DEB_CNT'                          AS intitule6,
    TO_CHAR (TO_DATE (dsdcn, 'yyyymmdd'), 'dd/mm/yyyy') AS valeur6,
    'FIN_CNT'                            AS intitule7,
    TO_CHAR (TO_DATE (dsfcn, 'yyyymmdd'), 'dd/mm/yyyy') AS valeur7,
    'NAT_CNT'                                 AS intitule8,
	(SELECT libelle_long
	FROM GA_ZWNATURCNT
	WHERE GA_ZWNATURCNT.code_naturcnt = SECUMATRIC.ZT061
	)                 AS valeur8,
	'TYPE_CNT' AS intitule9,
	(SELECT max(libelle) FROM GA_ZWTYPCNT WHERE GA_ZWTYPCNT.code_type = SECUMATRIC.ZA700
	)        AS valeur9,

    'EMPLOI' AS intitule10,
    (SELECT LIBELLE
    FROM GA_FILIERE
    WHERE GA_FILIERE.FILIERE          =SECUMATRIC.FILIR
    AND GA_FILIERE.REGROUPEMENT_METIER=SECUMATRIC.SSFIL
    AND GA_FILIERE.METIER             =SECUMATRIC.METIER
    AND GA_FILIERE.QUALIFICATION      = SECUMATRIC.EMPLOI
     AND GA_FILIERE.NUMPAC      = SECUMATRIC.NUMPAC
    )                            AS valeur10,
    'CPN'                        AS intitule11,
    CODCPN                       AS valeur11,
    'AFFECTATION_ADMINISTRATIVE' AS intitule12,
    (SELECT LIBELLE_ENTITE AS libelle
    FROM std_struc_entite_view e
    WHERE e.CODE_ENTITE=AFFS02 and e.CID = (select GET_CID_FOR_NUMPAC(NUMPAC) from dual) 
    )                       AS valeur12,
    'TAUX_EMPLOI'        AS intitule13,
    TXACT
    ||'%' AS valeur13
  FROM SECUMATRIC
  )
##
STD_STRUCTLIB_LINEAIRE
==
CREATE OR REPLACE FORCE VIEW "STD_STRUCTLIB_LINEAIRE" ("CODNIV", "CODTS", "CODLANG", "LIB") AS   select '1' AS CODNIV, CODTS, CODLANG, LIBCOLNIV1 AS LIB from STD_STRUCTURES_LIB UNION ALL select '2' AS CODNIV, CODTS, CODLANG, LIBCOLNIV2 AS LIB from STD_STRUCTURES_LIB UNION ALL select '3' AS CODNIV, CODTS, CODLANG, LIBCOLNIV3 AS LIB from STD_STRUCTURES_LIB UNION ALL select '4' AS CODNIV, CODTS, CODLANG, LIBCOLNIV4 AS LIB from STD_STRUCTURES_LIB UNION ALL select '5' AS CODNIV, CODTS, CODLANG, LIBCOLNIV5 AS LIB from STD_STRUCTURES_LIB UNION ALL select '6' AS CODNIV, CODTS, CODLANG, LIBCOLNIV6 AS LIB from STD_STRUCTURES_LIB  
##
STD_STRUCT_DATEAFFJURIDIQUE
=SQL=
CREATE OR REPLACE VIEW STD_STRUCT_DATEAFFJURIDIQUE
AS
  (SELECT matric,
    MIN(aff.date_eff) AS DTDEBSOCIETE,
    MAX(AFF.date_fin) AS DTFINSOCIETE,
    niv1
  FROM std_struc_affectation AFF,
    --  TODO VRI : ZEU FE, il faudra gérer le CID lors du traitement de cette partie STD_STRUC_AFFECTATION
    std_struc_index IDX
  WHERE last_entite = code_entite
  AND IDX.codts     = AFF.codts
  AND IDX.codts    IN
    (SELECT valvar
    FROM SYS_VARSYS
    WHERE module = 'GPC'
    AND codvar   = 'STRUCTURE_JUR'
    )
  AND AFF.date_eff BETWEEN idx.DATE_EFF AND IDX.DATE_FIN
  AND to_char(sysdate,'YYYYMMDD') between AFF.date_eff and AFF.date_fin
  GROUP BY matric,
    niv1
  )
  ##
STD_STRUC_AFFECTATION_ALLNIV
=SQL=
CREATE OR REPLACE FORCE VIEW STD_STRUC_AFFECTATION_ALLNIV (MATRIC, CODTS, DATE_EFF, CODE_ENTITE, DATE_FIN, TYPE_ENTITE, DATE_EFF_AFFECT_DIRECTE, CODE_ENTITE_AFFECT_DIRECTE, DATE_FIN_AFFECT_DIRECTE, TYPE_ENTITE_AFFECT_DIRECTE, EST_AFFEC_PRINCIPAL, PROFONDEUR, NIV_TECH) AS 
  WITH affectations (matric, codts, date_eff, code_entite, date_fin, type_entite, date_eff_affec, code_entite_affec, date_fin_affec, type_entite_affec, est_affec_principal, profondeur, niv_tech) AS
  (SELECT af.matric,
    af.codts,
    af.date_eff,
    af.code_entite,
    af.date_fin,
    (SELECT type_entite
    FROM std_struc_entite e
    WHERE e.code_entite=af.code_entite
    AND af.date_eff BETWEEN e.date_eff AND e.date_fin
    ),
    af.date_eff,
    af.code_entite,
    af.date_fin,
    (SELECT type_entite
    FROM std_struc_entite e
    WHERE e.code_entite=af.code_entite
    AND af.date_eff BETWEEN e.date_eff AND e.date_fin
    ),
    af.est_affec_principal,
    0 AS profondeur,
	(
	  SELECT NVL(idx.niv_tech, -1) 
	  FROM std_struc_index idx
	  WHERE 
        af.codts = idx.codts
        -- TODO VRI : ZEU FE, il faudra gérer le CID lors du traitement de cette partie STD_STRUC_AFFECTATION
        AND af.code_entite = idx.last_entite
        AND af.date_eff BETWEEN idx.date_eff AND idx.date_fin
    ) AS niv_tech 	
  FROM std_struc_affectation af
  UNION ALL
  SELECT af.matric,
    ar.codts,
    CASE
      WHEN ar.date_eff<af.date_eff
      THEN af.date_eff
      ELSE ar.date_eff
    END AS date_eff,
    ar.code_ent_mere,
    CASE
      WHEN ar.date_fin<af.date_fin
      THEN ar.date_fin
      ELSE af.date_fin
    END AS date_fin,
    (SELECT type_entite
    FROM std_struc_entite e
    WHERE e.code_entite=ar.code_ent_mere
    AND ar.date_eff BETWEEN e.date_eff AND e.date_fin
    ),
    af.date_eff_affec,
    af.code_entite_affec,
    af.date_fin_affec,
    af.type_entite_affec,
    af.est_affec_principal,
    profondeur+1,
	(
	  SELECT NVL(idx.niv_tech, -1) 
	  FROM std_struc_index idx
	  WHERE 
        ar.codts = idx.codts
        -- TODO VRI : ZEU FE, il faudra gérer le CID lors du traitement de cette partie STD_STRUC_AFFECTATION
	    AND ar.code_ent_mere = idx.last_entite
	    AND ar.date_eff BETWEEN idx.date_eff AND idx.date_fin
    ) AS niv_tech
  FROM affectations af,
    std_struc_arbre ar
  WHERE af.codts        =ar.codts
  AND af.code_entite    =ar.code_entite
  AND ar.date_eff      <=af.date_fin
  AND ar.date_fin      >=af.date_eff
  AND ar.code_ent_mere IS NOT NULL
  )
SELECT MATRIC,
  CODTS,
  DATE_EFF,
  CODE_ENTITE,
  DATE_FIN,
  TYPE_ENTITE,
  DATE_EFF_AFFEC,
  CODE_ENTITE_AFFEC,
  DATE_FIN_AFFEC,
  TYPE_ENTITE_AFFEC,
  EST_AFFEC_PRINCIPAL,
  PROFONDEUR,
  NIV_TECH
FROM affectations
##
TAG_CHARSET=@€éèç
##
STD_STRUC_ARBRE_RATT_INDIRECT
==
CREATE OR REPLACE FORCE VIEW "STD_STRUC_ARBRE_RATT_INDIRECT" ("CID", "CODE_ENTITE", "TYPE_ENTITE", "CODTS", "DATE_EFF", "CODE_ENT_MERE", "DATE_FIN", "TYPE_ENT_MERE", "DATE_EFF_RATT_DIRECTE", "CODE_ENTITE_RATT_DIRECTE", "DATE_FIN_RATT_DIRECTE", "TYPE_ENTITE_RATT_DIRECTE", "PROFONDEUR") AS   WITH rattachements (cid, code_entite, type_entite, codts, date_eff, code_ent_mere, date_fin, type_ent_mere, date_eff_ratt, code_entite_ratt, date_fin_ratt, type_entite_ratt, profondeur) AS (SELECT ar.cid, ar.code_entite,(SELECT type_entite FROM std_struc_entite e WHERE e.cid = ar.cid and e.code_entite=ar.code_entite AND ar.date_eff BETWEEN e.date_eff AND e.date_fin),ar.codts,ar.date_eff,ar.code_ent_mere,ar.date_fin,(SELECT type_entite FROM std_struc_entite e WHERE e.cid = ar.cid and e.code_entite=ar.code_ent_mere AND ar.date_eff BETWEEN e.date_eff AND e.date_fin),ar.date_eff,ar.code_ent_mere,ar.date_fin,(SELECT type_entite FROM std_struc_entite e WHERE e.cid = ar.cid and e.code_entite=ar.code_ent_mere AND ar.date_eff BETWEEN e.date_eff AND e.date_fin),0 AS profondeur FROM std_struc_arbre ar WHERE ar.statut='1' UNION ALL SELECT rat.cid, rat.code_entite,(SELECT type_entite FROM std_struc_entite e WHERE e.cid = rat.cid and e.code_entite=rat.code_entite AND rat.date_eff BETWEEN e.date_eff AND e.date_fin),rat.codts,CASE WHEN ar.date_eff<rat.date_eff THEN rat.date_eff ELSE ar.date_eff END AS date_eff,ar.code_ent_mere,CASE WHEN ar.date_fin<rat.date_fin THEN ar.date_fin ELSE rat.date_fin END AS date_fin,(SELECT type_entite FROM std_struc_entite e WHERE e.cid = ar.cid and e.code_entite=ar.code_ent_mere AND ar.date_eff BETWEEN e.date_eff AND e.date_fin),rat.date_eff_ratt,rat.code_entite_ratt,rat.date_fin_ratt,rat.type_entite_ratt,profondeur+1 FROM rattachements rat,std_struc_arbre ar WHERE rat.cid = ar.cid and rat.codts =ar.codts AND rat.code_ent_mere =ar.code_entite AND ar.date_eff <=rat.date_fin AND ar.date_fin >=rat.date_eff) SELECT CID, CODE_ENTITE,TYPE_ENTITE,CODTS,DATE_EFF,CODE_ENT_MERE,DATE_FIN,TYPE_ENT_MERE,DATE_EFF_RATT,CODE_ENTITE_RATT,DATE_FIN_RATT,TYPE_ENTITE_RATT,PROFONDEUR FROM rattachements
##
TAG_CHARSET=@€éèç
##
STD_STRUC_ENTITE_BO
=SQL=
create or replace view std_struc_entite_bo
as(
select e.*, o.date_ouv, o.date_ferm, 
case when to_date(date_ouv,'yyyymmdd')>sysdate then 'P' when to_date(nvl(date_ferm,'20991231'),'yyyymmdd')<sysdate then 'F' else 'O' end as statut_open
from std_struc_entite e, std_struc_entite_open o 
where e.cid = o.cid and e.code_entite=o.code_entite
union all
select '@NON_AFFECTE@','19000101','20991231', null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,'O'
from dual
union all
select '@VIDE@','19000101','20991231', null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,
null,null,null,'O'
from dual)
##
TAG_CHARSET=@€éèç
##
STD_STRUC_ENTITE_VIEW
==
CREATE OR REPLACE FORCE VIEW "STD_STRUC_ENTITE_VIEW" ("CID", "CODE_ENTITE", "LIBELLE_ENTITE") AS (SELECT CID, CODE_ENTITE,LIBELLE FROM STD_STRUC_ENTITE WHERE TO_CHAR(SYSDATE,'yyyymmdd') BETWEEN DATE_EFF AND DATE_FIN)
##
STD_TYPSTR
==
CREATE OR REPLACE FORCE VIEW "STD_TYPSTR" ("CODTS", "LIBTS", "DESCRI", "ORDRE") AS   SELECT CODTS,LIBTS,DESCRI,ORDRE FROM STD_STRUCTURES  
##
STD_VARSYS
==
CREATE OR REPLACE FORCE VIEW "STD_VARSYS" ("MODULE", "CODVAR", "VALVAR", "TYPVAR", "DESCRIPTION") AS   select MODULE,CODVAR,VALVAR,TYPVAR,DESCRIPTION FROM SYS_VARSYS  
##
STD_VARSYS_USR
==
CREATE OR REPLACE FORCE VIEW "STD_VARSYS_USR" ("LOGIN", "CODVAR", "VALVAR_PERSO") AS   select LOGIN,CODVAR,VALVAR_PERSO FROM SYS_VARSYS_USR  
##
SYS_BATCH_LANCEMENT
=SQL=
CREATE OR REPLACE FORCE VIEW SYS_BATCH_LANCEMENT (ID_TRACE, STATUT, NOMCLIENT, NOMINTERFACE, ENVCLIENT, FICHIER, CONF, REQUESTED_GO, EFFECTIVE_GO, ENDED, TIME_ELAPSED, PARAMETRES) AS 
  SELECT
    ID_TRACE,
    STATUT,
    NOMCLIENT,
    NOMINTERFACE,
    ENVCLIENT,
    FICHIER,
    CONF,
    TO_CHAR(REQUESTED_GO, 'DD.MM.YYYY HH24:MI:SS') AS REQUESTED_GO,
    TO_CHAR(EFFECTIVE_GO, 'DD.MM.YYYY HH24:MI:SS') AS EFFECTIVE_GO,
    TO_CHAR(ENDED,'DD.MM.YYYY HH24:MI:SS') AS ENDED,
    CASE 
    WHEN ENDED IS NULL OR EFFECTIVE_GO IS NULL THEN 'N/A'
    ELSE
      LPAD(EXTRACT(DAY FROM (ENDED - EFFECTIVE_GO) ),2,'0') || 'd '||
      LPAD(EXTRACT(HOUR FROM (ENDED - EFFECTIVE_GO) ),2,'0') || 'h '||
      LPAD(EXTRACT(MINUTE FROM (ENDED - EFFECTIVE_GO) ),2,'0') || 'min '||
      LPAD(EXTRACT(SECOND FROM (ENDED - EFFECTIVE_GO) ),2,'0') || 's' 
    END AS TIME_ELAPSED,
    PARAMETRES
  FROM SYS_BATCH_TRACE_LANCEMENT T1
##
SYS_COLLABORATEURS
==
CREATE OR REPLACE FORCE VIEW "SYS_COLLABORATEURS" ("MATRIC", "NOM", "PRENOM", "EMAIL", "TYPE") AS   (SELECT s.matric,s.nom,s.prenom , '' AS email, 'I' AS TYPE FROM secuPACMAT s WHERE priorite_situation=0  UNION  SELECT e.login AS matric ,    e.nomfam     AS nom ,    e.prenom ,    e.email, 'E'  FROM sys_usr_externe e  )
##
SYS_PORTAIL_UID_ROLE
==
CREATE OR REPLACE FORCE VIEW "SYS_PORTAIL_UID_ROLE" ("HR_UID", "HR_ROLE") AS   (select UP.login as HR_UID,R.SHORT_role as HR_ROLE from SYS_SEC_PROFIL_ROLE PR, SYS_USR_PROFIL UP , SYS_DEF_ROLE R where UP.CODE_PROFIL=PR.CODE_PROFIL and R.CODE_ROLE=PR.CODE_ROLE and Up.login not in (select login from SYS_USR_ADMIN_ONLY) group by UP.login,R.SHORT_role ) order by HR_UID   
##
SYS_SCH_SCHEMA_FULL
==
CREATE OR REPLACE FORCE VIEW "SYS_SCH_SCHEMA_FULL" (ROLE,THEME,CLASSEUR,LIBELLE,NOM_PAGE, DESCRIPTION, CODE_ROLE, PROFILS ) as (select  E2.LIBELLE as ROLE,E3.LIBELLE as THEME, E4.LIBELLE as CLASSEUR,  E5.LIBELLE  as LIBELLE,E5.NOM_PAGE as NOM_PAGE, E5.DESCRIPTION AS DESCRIPTION, E5.CODE_ROLE as CODE_ROLE , ( SELECT LISTAGG(PO.libelle||'('||PO.code_profil||')', ',') WITHIN GROUP (ORDER BY PO.code_profil)  FROM (select p.code_profil, nvl((select libelle from sys_sch_profil s where s.code_profil=p.code_profil),'PROFIL SUPPRIME') as libelle, p.nom_page  from sys_sch_profil_p p ) PO where PO.NOM_PAGE = E5.NOM_PAGE)  as PROFILS from SYS_SCH_ELEMENT E1, SYS_SCH_ELEMENT E2, SYS_SCH_ELEMENT E3, SYS_SCH_ELEMENT E4, SYS_SCH_ELEMENT E5, SYS_SCHEMAS S1, SYS_SCHEMAS S2, SYS_SCHEMAS S3, SYS_SCHEMAS S4, SYS_SCHEMAS S5 where S5.CODE_SCHEMA = -1 and S4.CODE_SCHEMA = -1 and S3.CODE_SCHEMA = -1 and S2.CODE_SCHEMA = -1 and S1.CODE_SCHEMA = -1 and S5.CODE_ELT = E5.CODE_ELEMENT and S5.NIVEAU = E5.NIVEAU and S4.CODE_ELT = E4.CODE_ELEMENT and S4.NIVEAU = E4.NIVEAU and S3.CODE_ELT = E3.CODE_ELEMENT and S3.NIVEAU = E3.NIVEAU and S2.CODE_ELT = E2.CODE_ELEMENT and S2.NIVEAU = E2.NIVEAU and S1.CODE_ELT = E1.CODE_ELEMENT and S1.NIVEAU = E1.NIVEAU and S5.NIVEAU ='99' and S4.NIVEAU ='4' and S3.NIVEAU ='3' and S2.NIVEAU ='2' and S1.NIVEAU ='1' and S5.CODE_ASSO_PERE = S4.CODE_ASSO and S4.CODE_ASSO_PERE = S3.CODE_ASSO and S3.CODE_ASSO_PERE = S2.CODE_ASSO and S2.CODE_ASSO_PERE = S1.CODE_ASSO)
##
SYS_TGE_THEME_DETAILS_IHM
=SQL=
CREATE OR REPLACE FORCE VIEW SYS_TGE_THEME_DETAILS_IHM AS (SELECT T.numpac, T.id_theme, T.nom_theme, T.nom_ecran, D.nom_donnee, TGE_GAP_IS_DONNEE_RETRO(T.numpac,D.nom_donnee) AS IS_RETRO, D.NUM_ORDRE 
FROM SYS_TGE_THEME T, SYS_TGE_THEME_DETAILS D WHERE T.numpac = D.numpac AND t.id_theme = d.id_theme )
##
TAG_CHARSET=@€éèç
##
SYS_USR_AOID_MATRIC_UNIQUE
=SQL=
CREATE OR REPLACE FORCE VIEW SYS_USR_AOID_MATRIC_UNIQUE (AOID, MATRIC) AS 
SELECT DISTINCT FIRST_VALUE(AOID) OVER (PARTITION BY MATRIC ORDER BY CASE WHEN AOID LIKE '%-%' THEN 1 ELSE 2 END, AOID) AS AOID, MATRIC FROM (
  SELECT AOID, MATRIC FROM SYS_USR_AOID_MATRIC WHERE MATRIC IS NOT NULL 
  UNION ALL 
  SELECT LOGIN AS AOID, REQUETEMATRIC AS MATRIC FROM SYS_USR_CONFIG WHERE REQUETEMATRIC IS NOT NULL AND REQUETEMATRIC NOT IN (SELECT MATRIC FROM SYS_USR_AOID_MATRIC WHERE MATRIC IS NOT NULL)
)
##
SYS_USR_CONFIG_IHM
==
CREATE OR REPLACE FORCE VIEW "SYS_USR_CONFIG_IHM" ("LOGIN", "REQUETEMATRIC", "NOM", "PRENOM") AS   (select C.LOGIN, C.REQUETEMATRIC, NVL(S.NOM, E.NOMFAM), NVL(S.PRENOM, E.PRENOM) from SYS_USR_CONFIG C, SECUMATRIC S, (select * from SYS_USR_EXTERNE where substr(LOGON_HOST_WHEN_NS,2,1) <> '-' or LOGON_HOST_WHEN_NS is null) E where C.REQUETEMATRIC = S.MATRIC(+) and C.LOGIN = E.LOGIN(+))
##
TGE_CBE_FOR_LISTE
==
CREATE OR REPLACE FORCE VIEW "TGE_CBE_FOR_LISTE" ("NUMPAC", "CBE", "LIBELLECBE") AS   SELECT NUMPAC,CBE,LIBELLECBE FROM TGE_REF_CBE WHERE NUMPAC <> '*' UNION ALL SELECT P.NUMPAC,CBE,LIBELLECBE FROM TGE_REF_CBE C,TGE_REF_PAC P WHERE C.NUMPAC = '*' AND NOT EXISTS (SELECT NUMPAC FROM TGE_REF_CBE WHERE NUMPAC <> '*' AND NUMPAC = P.NUMPAC)  
##
TGE_REF_CARTE_29
==
create or replace view TGE_REF_CARTE_29 as select * from ( select 'B050' CODE_ELEMENT,'**' INDICATIF from dual union all select 'A275' CODE_ELEMENT,'**' INDICATIF from dual union all select 'BA50' CODE_ELEMENT,'**' INDICATIF from dual union all select 'A456' CODE_ELEMENT,'**' INDICATIF from TGE_REF_PAC where  MPE in ('O','S') union all select 'A457' CODE_ELEMENT,substr(enregistrement,1,2) INDICATIF from tge_ref_vrval where code_table like '%DFR%' and substr(enregistrement,35,1)='D' and substr(enregistrement,1,2)<>'99' union all select 'A458' CODE_ELEMENT,substr(enregistrement,1,2) INDICATIF from tge_ref_vrval where code_table like '%DFR%' and substr(enregistrement,35,1)='D' and substr(enregistrement,1,2)<>'99'order by CODE_ELEMENT ) 
##
TGE_REF_CARTE_29_IJEDI
==
create or replace view TGE_REF_CARTE_29_IJEDI as select * from (select 'A001' CODE_ELEMENT,'**' INDICATIF from dual union all select 'A275' CODE_ELEMENT,'**' INDICATIF from dual )
##
TAG_CHARSET=@€éèç
##
TGE_REF_MAPDO_RESOLVED
=SQL=
CREATE OR REPLACE FORCE VIEW TGE_REF_MAPDO_RESOLVED (NUMPAC,ELEMENT,OCCURENCE,DONNEEGXP,TABLEGXP,DONNFILTRE,OPERFILTRE,VALFILTRE,TRTPARTICULIER,ENVOI_SYSTEMATIQUE,FORCABLE_ECRAN_GENERE) 
AS  
SELECT P.NUMPAC,M.ELEMENT,M.OCCURENCE,M.DONNEEGXP,M.TABLEGXP,M.DONNFILTRE,M.OPERFILTRE,M.VALFILTRE,M.TRTPARTICULIER,M.ENVOI_SYSTEMATIQUE,M.FORCABLE_ECRAN_GENERE 
FROM TGE_REF_MAPDO M, TGE_REF_PAC P 
WHERE M.NUMPAC=P.NUMPAC OR (M.NUMPAC='*' AND NOT EXISTS (SELECT 1 FROM TGE_REF_MAPDO M2 WHERE M2.ELEMENT=M.ELEMENT AND M2.OCCURENCE=M.OCCURENCE AND M2.NUMPAC=P.NUMPAC)) 
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_CUMASO_IHM
=SQL=
CREATE OR REPLACE VIEW TGE_RESPAIE_CUMASO_IHM AS
SELECT 
  DTR.NUMPAC,
  DTR.PAIEZAD,
  DTR.PACMAT,
  DACS.NUMCNT,
  TO_CHAR(DTR.DTDEB_CUMASO,'DD.MM.YYYY') AS DTDEB_CUMASO,
  DTR.DTDEB_CUMASO AS DTDEB_CUMASO_FMT,
  TO_CHAR(DTR.DTDEB_CUMASO,'YYYYMMDD') AS DTDEB_CUMASO_TRI,
  DTR.BRUTRE,
  DTR.BRUTSS,
  DTR.BRUTIM,
  DTR.NETFIS,
  DTR.AVANTA,
  case 
  	when DACS.DSFSC=to_date('20991231','yyyymmdd') 
  	then 'A partir du '||to_char(DACS.DSDSC, 'DD.MM.YYYY') 
  	else 'Du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI,
  case 
    when DACS.DSFSC=to_date('20991231','yyyymmdd') 
    then to_char(DACS.DSDSC, 'DD.MM.YYYY') 
    else to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI_2
FROM
  DIC_TGE_RESPAIE_CUMASO DTR
  , DIC_ADM_CONTRAT_SITU DACS 
WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.DTDEB_CUMASO BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
)
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_CUMCOTM_IHM
=SQL=
CREATE OR REPLACE VIEW TGE_RESPAIE_CUMCOTM_IHM AS 
SELECT 
  DTR.NUMPAC,
  DTR.PAIEZAD,
  DTR.PACMAT,
  DACS.NUMCNT,
  TO_CHAR(DTR.DTDEB_CUMCOTM,'DD.MM.YYYY') AS DTDEB_CUMCOTM,
  DTR.DTDEB_CUMCOTM AS DTDEB_CUMCOTM_FMT,
  TO_CHAR(DTR.DTDEB_CUMCOTM,'YYYYMMDD') AS DTDEB_CUMCOTM_TRI,
  TO_CHAR(DTR.DTDEB_CUMCOTM,'YYYY') AS DTDEB_CUMCOTM_YYYY,
  REGEXP_REPLACE(TO_CHAR(DTR.DTDEB_CUMCOTM,'Month YYYY'),'[ ]+',' ') AS DTDEB_CUMCOTM_AFF,
  DTR.CAISSE_CUMCOTM,
  DTR.NBRT,
  DTR.NNBT,
  DTR.NBSA,
  DTR.NBSB,
  DTR.NBSC,
  DTR.MLB101_CUMCOTM,
  DTR.NBSD,
  DTR.NAPFA,
  DTR.NAPFB,
  DTR.NAPFC,
  DTR.NMTS,
  DTR.NMTP,
  DTR.NLB9,
  DTR.NBSIAC,
  DTR.NBSBSI,
  DTR.NBSCSI,
  case 
  	when DACS.DSFSC=to_date('20991231','yyyymmdd') 
  	then 'A partir du '||to_char(DACS.DSDSC, 'DD.MM.YYYY') 
  	else 'Du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI,
  case 
    when DACS.DSFSC=to_date('20991231','yyyymmdd') 
    then to_char(DACS.DSDSC, 'DD.MM.YYYY') 
    else to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI_2
FROM
  DIC_TGE_RESPAIE_CUMCOTM DTR
  , DIC_ADM_CONTRAT_SITU DACS 
WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.DTDEB_CUMCOTM BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
)
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_CUMCOTM_TAB
=SQL=
CREATE OR REPLACE VIEW TGE_RESPAIE_CUMCOTM_TAB AS
SELECT distinct
  DTR.CAISSE_CUMCOTM AS CODE ,
  DTR.CAISSE_CUMCOTM  ||' - '||TRC.LIBCAISSE AS LIBELLE ,
  TRC.LIBCAISSE  ,
  DTR.NUMPAC ,
  DTR.PAIEZAD ,
  DTR.PACMAT ,
  DACS.NUMCNT 
FROM 
  DIC_TGE_RESPAIE_CUMCOTM DTR
  LEFT OUTER JOIN TGE_REF_CAISSE TRC
    ON TRC.CODECAISSE=DTR.CAISSE_CUMCOTM
      AND (TRC.NUMPAC  =DTR.NUMPAC
      OR (NOT EXISTS
        (SELECT *
        FROM TGE_REF_CAISSE
        WHERE TGE_REF_CAISSE.CODECAISSE=DTR.CAISSE_CUMCOTM
        AND TGE_REF_CAISSE.NUMPAC      =DTR.NUMPAC
        )
      AND TRC.NUMPAC='*'))  
  , DIC_ADM_CONTRAT_SITU DACS 
WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.DTDEB_CUMCOTM BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
)
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_CUMCOT_IHM
=SQL=
CREATE OR REPLACE VIEW TGE_RESPAIE_CUMCOT_IHM AS 
SELECT 
  DTR.NUMPAC,
  DTR.PAIEZAD,
  DTR.PACMAT,
  DACS.NUMCNT,
  TO_CHAR(DTR.DTDEB_CUMCOT,'DD.MM.YYYY') AS DTDEB_CUMCOT,
  DTR.DTDEB_CUMCOT AS DTDEB_CUMCOT_FMT,
  TO_CHAR(DTR.DTDEB_CUMCOT,'YYYYMMDD') AS DTDEB_CUMCOT_TRI,
  TO_CHAR(DTR.DTDEB_CUMCOT,'YYYY') AS DTDEB_CUMCOT_YYYY,
  REGEXP_REPLACE(TO_CHAR(DTR.DTDEB_CUMCOT,'Month YYYY'),'[ ]+',' ') AS DTDEB_CUMCOT_AFF,
  DTR.CAISSE_CUMCOT,
  DTR.ABRT,
  DTR.ANBT,
  DTR.ABSA,
  DTR.ABSB,
  DTR.ABSC,
  DTR.ALB5,
  DTR.APFA,
  DTR.APFB,
  case 
  	when DACS.DSFSC=to_date('20991231','yyyymmdd') 
  	then 'A partir du '||to_char(DACS.DSDSC, 'DD.MM.YYYY') 
  	else 'Du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI,
  case 
    when DACS.DSFSC=to_date('20991231','yyyymmdd') 
    then to_char(DACS.DSDSC, 'DD.MM.YYYY') 
    else to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI_2
FROM
  DIC_TGE_RESPAIE_CUMCOT DTR
  , DIC_ADM_CONTRAT_SITU DACS 
WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.DTDEB_CUMCOT BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
)
##
create_view_tge_respaie_histo
=SQL=
CREATE OR REPLACE PROCEDURE create_view_tge_respaie_histo AS
    TYPE TypeColNameCountTable IS RECORD (COLUMN_NAME USER_TAB_COLUMNS.COLUMN_NAME%TYPE, COUNT_TABLE NUMBER,COLUMN_TYPE USER_TAB_COLUMNS.DATA_TYPE%TYPE);
    TYPE TYP_COL_NAME IS TABLE OF TypeColNameCountTable;
    v_reqcreate CLOB;
    TabColRespaie TYP_COL_NAME ;
BEGIN
    SELECT column_name,0,data_type BULK COLLECT  INTO TabColRespaie
    FROM   user_tab_columns
    WHERE  table_name = 'DIC_TGE_RESPAIE_HISTO'
    ORDER BY  column_name;
    
    v_reqCreate := 'CREATE OR REPLACE FORCE EDITIONABLE VIEW "TGE_RESPAIE_HISTO_IHM" AS ';
    v_reqCreate := v_reqCreate||' SELECT '; 
    v_reqCreate := v_reqCreate||' dacs.numcnt, '; 
    v_reqCreate := v_reqCreate||' dtr.dtdeb_histo AS dtdeb_histo_fmt, '; 
    v_reqCreate := v_reqCreate||' to_char(dtr.dtdeb_histo, ''DD.MM.YYYY'') AS dtdeb_histo, '; 
    v_reqCreate := v_reqCreate||' to_char(dtr.dtdeb_histo, ''YYYYMMDD'') AS dtdeb_histo_tri, '; 
    v_reqCreate := v_reqCreate||' CASE '; 
    v_reqCreate := v_reqCreate||' WHEN dacs.dsfsc = TO_DATE(''20991231'', ''yyyymmdd'') THEN ''A partir du ''|| to_char(dacs.dsdsc, ''DD.MM.YYYY'') '; 
    v_reqCreate := v_reqCreate||' ELSE ''Du ''|| to_char(dacs.dsdsc, ''DD.MM.YYYY'')|| '' au ''|| to_char(dacs.dsfsc, ''DD.MM.YYYY'') '; 
    v_reqCreate := v_reqCreate||' END AS lib_periode_emploi, '; 
    v_reqCreate := v_reqCreate||' CASE '; 
    v_reqCreate := v_reqCreate||' WHEN dacs.dsfsc = TO_DATE(''20991231'', ''yyyymmdd'') THEN '; 
    v_reqCreate := v_reqCreate||' to_char(dacs.dsdsc, ''DD.MM.YYYY'') '; 
    v_reqCreate := v_reqCreate||' ELSE '; 
    v_reqCreate := v_reqCreate||' to_char(dacs.dsdsc, ''DD.MM.YYYY'')|| '' au ''||to_char(dacs.dsfsc, ''DD.MM.YYYY'') '; 
    v_reqCreate := v_reqCreate||'  END AS lib_periode_emploi_2 '; 
    FOR i IN TabColRespaie.first..TabColRespaie.last
     LOOP
     IF TabColRespaie(i).COLUMN_NAME != 'DTDEB_HISTO' THEN
        v_reqCreate := v_reqCreate||', DTR.'||TabColRespaie(i).COLUMN_NAME;
     END IF;
     END LOOP;
    v_reqCreate := v_reqCreate||' FROM dic_tge_respaie_histo dtr,dic_adm_contrat_situ dacs'; 
    v_reqCreate := v_reqCreate||' WHERE '; 
    v_reqCreate := v_reqCreate||' dacs.numpac = dtr.numpac '; 
    v_reqCreate := v_reqCreate||' AND dacs.paiezad = dtr.paiezad '; 
    v_reqCreate := v_reqCreate||' AND dacs.numcnt = ( '; 
    v_reqCreate := v_reqCreate||' SELECT MAX(dach.numcnt) '; 
    v_reqCreate := v_reqCreate||' FROM dic_adm_contrat_histo dach '; 
    v_reqCreate := v_reqCreate||' WHERE dach.numpac = dtr.numpac '; 
    v_reqCreate := v_reqCreate||' AND dach.paiezad = dtr.paiezad '; 
    v_reqCreate := v_reqCreate||' AND dach.pacmat = dacs.pacmat '; 
    v_reqCreate := v_reqCreate||' AND dtr.dtdeb_histo BETWEEN trunc(dach.date_eff, ''mm'') AND dach.date_fin_bo )'; 
    
    EXECUTE_IMMEDIATE_STRING(v_reqCreate,0);
END create_view_tge_respaie_histo;
##
TGE_RESPAIE_HISTO_IHM
==
call CREATE_VIEW_TGE_RESPAIE_HISTO()
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_JRSIND_IHM
=SQL=
CREATE OR REPLACE VIEW TGE_RESPAIE_JRSIND_IHM AS 
SELECT 
  DTR.NUMPAC,
  DTR.PAIEZAD,
  DTR.PACMAT,
  DACS.NUMCNT,
  TO_CHAR(DTR.DTDEB_JRSIND,'DD.MM.YYYY') AS DTDEB_JRSIND,
  DTR.DTDEB_JRSIND AS DTDEB_JRSIND_FMT,
  TO_CHAR(DTR.DTDEB_JRSIND,'YYYYMMDD') AS DTDEB_JRSIND_TRI,
  (DTR.JATIT1+DTR.JATIT2+DTR.JATIT3+DTR.JATIT4) AS JRSIND_MAL,
  (DTR.JAT5+DTR.JAT6+DTR.ZD1+DTR.ZD2) AS JRSIND_ACC_TRAV,
  (DTR.ZD5+DTR.ZD6+DTR.ZD7+DTR.ZD8) AS JRSIND_ACC_TRAJ,
  (DTR.ZD3+DTR.ZD4) AS JRSIND_MAT,
  case 
  	when DACS.DSFSC=to_date('20991231','yyyymmdd') 
  	then 'A partir du '||to_char(DACS.DSDSC, 'DD.MM.YYYY') 
  	else 'Du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI,
  case 
    when DACS.DSFSC=to_date('20991231','yyyymmdd') 
    then to_char(DACS.DSDSC, 'DD.MM.YYYY') 
    else to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
  end as LIB_PERIODE_EMPLOI_2
FROM
  DIC_TGE_RESPAIE_JRSIND DTR
  , DIC_ADM_CONTRAT_SITU DACS 
WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.DTDEB_JRSIND BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
)
##
TAG_CHARSET=@€éèç
##
TGE_RESPAIE_RUBRIQUES_IHM
=SQL=
CREATE OR REPLACE FORCE VIEW "TGE_RESPAIE_RUBRIQUES_IHM" ("NUMPAC", "PAIEZAD", "PACMAT", "NUMCNT", "CODERUB", "CODERES", "IMPUTATION", "CODECAISSE", "LIBRUB", "NATURERUB", "NOMBRE", "TAUX", "MONTANT", "SENS", "ORDRE", "TYPE", "CLASSE", "PERIODEPAIE", "PERIODE_TRI", "PERIODE_DDMMYYYY", "PERIODE_AFF", "PERIODE_AFFECTATION", "PERIODE_RATTACH_DEB", "PERIODE_RATTACH_FIN", "DATE_DEB_ARRET", "LIB_PERIODE_EMPLOI", "LIB_PERIODE_EMPLOI_2") AS 
  SELECT
 DTR.NUMPAC,
 DTR.PAIEZAD,
 DTR.PACMAT,
 (select DACS.NUMCNT from DIC_ADM_CONTRAT_SITU DACS
 WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.PERIODEPAIE BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
 )) as NUMCNT,
 DTR.CODERUB,
 DTR.CODERES,
 DTR.IMPUTATION,
 CASE
 WHEN NVL(TRP.oldcot,'N')='N' AND DTR.CAISSE_RUB IS NOT NULL
 THEN DTR.CAISSE_RUB
 ELSE RUB.CODECAISSE
 END as CODECAISSE,
 NVL((case
 when nvl(TRP.oldcot,'N') = 'N' THEN (select LIB_RESOLU from TGE_REF_LIBRUB_COTIS cotlib where nvl(DTR.CAISSE_RUB,'*') =  cotlib.CODECAISSE and  cotlib.CODERUB = DTR.CODERUB and DTR.NUMPAC = cotlib.NUMPAC)
 ELSE (select LIB_RESOLU from TGE_REF_LIBRUB_COTIS cotlib where nvl(RUB.CODECAISSE,'*') = cotlib.CODECAISSE and  cotlib.CODERUB = RUB.CODERUB and RUB.NUMPAC = cotlib.NUMPAC)
 END), RUB.LIBRUB) as LIBRUB,
 RUB.NATURERUB,
 DTR.NOMBRE,
 DTR.TAUX,
 DTR.MONTANT,
 DTR.SENS,
 DTR.ORDRE,
 DTR.TYPE,
 DTR.CLASSE,
 DTR.PERIODEPAIE,
 to_char(DTR.PERIODEPAIE, 'YYYYMMDD') as PERIODE_TRI,
 to_char(DTR.PERIODEPAIE, 'DD.MM.YYYY') as PERIODE_DDMMYYYY,
 REGEXP_REPLACE(to_char(DTR.PERIODEPAIE, 'Month YYYY'),'[ ]+',' ') as PERIODE_AFF,
 DTR.PERIODE_AFFECTATION,
 DTR.PERIODE_RATTACH_DEB,
 DTR.PERIODE_RATTACH_FIN,
 DTR.DATE_DEB_ARRET,
 (select case
 when DACS.DSFSC=to_date('20991231','yyyymmdd')
 then 'A partir du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')
 else 'Du '||to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
 end from DIC_ADM_CONTRAT_SITU DACS
 WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.PERIODEPAIE BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
 )) as LIB_PERIODE_EMPLOI,
 (select case
 when DACS.DSFSC=to_date('20991231','yyyymmdd')
 then to_char(DACS.DSDSC, 'DD.MM.YYYY')
 else to_char(DACS.DSDSC, 'DD.MM.YYYY')||' au '||to_char(DACS.DSFSC, 'DD.MM.YYYY')
 end from DIC_ADM_CONTRAT_SITU DACS
 WHERE DACS.NUMPAC=DTR.NUMPAC AND DACS.PAIEZAD=DTR.PAIEZAD AND DACS.NUMCNT=(
 SELECT MAX(DACH.NUMCNT)
 FROM DIC_ADM_CONTRAT_HISTO DACH
 WHERE DACH.NUMPAC=DTR.NUMPAC AND DACH.PAIEZAD=DTR.PAIEZAD
 and DACH.PACMAT = DACS.PACMAT
 AND DTR.PERIODEPAIE BETWEEN TRUNC(DACH.DATE_EFF,'mm') AND DACH.DATE_FIN_BO
 )) as LIB_PERIODE_EMPLOI_2
 from
 DIC_TGE_RESPAIE_RUBRIQUE DTR
 left outer join TGE_REF_RUBRIQUE RUB
 on RUB.CODERUB=DTR.CODERUB
 and (
 RUB.NUMPAC=DTR.NUMPAC
 or (not exists (select 1 from TGE_REF_RUBRIQUE where TGE_REF_RUBRIQUE.NUMPAC=DTR.NUMPAC) and RUB.NUMPAC='*')
 )
 LEFT OUTER JOIN TGE_REF_PAC TRP
 ON TRP.numpac=DTR.numpac
##
TAG_CHARSET=@€éèç
##
TIERS_ENVOIS_MQ_VIEW
=SQL=
CREATE OR REPLACE FORCE EDITIONABLE VIEW TIERS_ENVOIS_MQ_VIEW ("NUMPAC", "NATURE", "PERIODE", "PAIEZAD", "CODE_CHRONO", "NOM", "PRENOM", "NUMERO", "REFERENCE", "MONTANT", "LIBELLE", "BENEFICIAIRE", "DOMICILIATION", "IBAN1", "IBAN2", "IBAN3", "BIC", "CODE_BQE", "DATE_PAIEMENT", "CODSTE", "CODETB", "POP_GFF", "TYPE") AS 
 SELECT TIERS_NUMPAC,
 RPAD(NAT_PAIEMENT,4,' '),
 TO_CHAR(TIERS_MOIS_PAIE,'YYYYMM'),
 TIERS_PAIEZAD,
 RPAD(NVL(TIERS_CODE_CHRONO,' '),6,' '),
 RPAD(NVL(TIERS_NOM,' '),30,' '),
 RPAD(NVL(TIERS_PRENOM,' '),20,' '),
 LPAD(TIERS_NUMERO,2,'0'),
 RPAD(NVL(TIERS_NUM_DOS,' '),15,' '),
 LPAD(TIERS_MONTANT*100,9,0),
 RPAD(NVL(TIERS_LIBELLE,' '),35,' '),
 RPAD(NVL(TIERS_BENEFICIAIRE,' '),30,' '),
 RPAD(NVL(TIERS_DOM_BQE,' '),24,' '),
 RPAD(NVL(SUBSTR(TIERS_IBAN, 0, 2),' '),2,' '),
 RPAD(NVL(SUBSTR(TIERS_IBAN, 3, 5),' '),2,' '),
 RPAD(NVL(SUBSTR(TIERS_IBAN, 5, 34),' '),30,' '),
 RPAD(NVL(TIERS_BIC,' '),11,' '),
 LPAD(NVL(TIERS_CODE_BQE,'0'),3,'0'),
 TO_CHAR(TIERS_DATE_VIREMENT,'YYYYMMDD'),
 RPAD(NVL(TIERS_CODSTE,' '),2,' '),
 RPAD(NVL(TIERS_CODETB,' '),5,' '),
 RPAD(NVL(TIERS_POP_GFF,' '),5,' '),
 TIERS_TYPE
 FROM DIC_PAIEMENT_TIERS
 JOIN TIERS_RUB_TRANSCO
 ON TIERS_NUMPAC   =NUMPAC
 AND TIERS_CODRUB  =CODRUB
 WHERE TIERS_ACTIF ='O'
 AND TIERS_STATUT IS NULL
##
TMPL_ECRAN_GROUPE_DONNEE_LIGHT
=SQL=
CREATE OR REPLACE FORCE VIEW "TMPL_ECRAN_GROUPE_DONNEE_LIGHT" (
"NUM_LIVRABLE",
"COMPANY_ID", 
"NOM_PAGE", 
"ID_GROUPE_ECRAN", 
"NOM_DONNEE", 
"SUFFIXE_OU_LIBELLE", 
"ID_GROUPE_DONNEES")
AS
  SELECT MLGD.NUM_LIVRABLE,
    MLGD.COMPANY_ID,
    ME.NOM_PAGE,
    ME.ID_GROUPE_DONNEES,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM TMPL_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    TMPL_ECRAN ME
  WHERE MLGD.COMPANY_ID   =ME.COMPANY_ID
  AND ME.ID_GROUPE_DONNEES=MLGD.ID_GROUPE
  AND ME.NUM_LIVRABLE     =MLGD.NUM_LIVRABLE
  UNION ALL
  SELECT MLGD.NUM_LIVRABLE,
    MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'
    ||MWOE.OP_NUM
    ||'_'
    ||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_1,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM TMPL_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    TMPL_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID     =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_1=MLGD.ID_GROUPE
  AND MWOE.NUM_LIVRABLE     =MLGD.NUM_LIVRABLE
  UNION ALL
  SELECT MLGD.NUM_LIVRABLE,
    MLGD.COMPANY_ID,
    'GEN_PAGE_RECAP_'
    ||MWOE.OP_NUM
    ||'_'
    ||MWOE.ID_GEN_PAGE,
    MWOE.RECAP_ID_GROUPE_2,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM TMPL_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    TMPL_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID     =MWOE.COMPANY_ID
  AND MWOE.RECAP_ID_GROUPE_2=MLGD.ID_GROUPE
  AND MWOE.NUM_LIVRABLE     =MLGD.NUM_LIVRABLE
  UNION ALL
  SELECT MLGD.NUM_LIVRABLE,
    MLGD.COMPANY_ID,
    'RAPPELSAISIE_'
    ||ME.NOM_PAGE,
    MWOE.RECHERCHE_ID_GROUPE_LECTURE,
    MLGD.NOM_DONNEE,
    MLGD.SUFFIXE_OU_LIBELLE,
    MLGD.ID_GROUPE_DONNEES
  FROM TMPL_LIEN_GROUPE_DONNEE_LIGHT MLGD,
    TMPL_ECRAN ME,
    TMPL_WKF_OPERATION_ECRANS MWOE
  WHERE MLGD.COMPANY_ID               =ME.COMPANY_ID
  AND MLGD.COMPANY_ID                 =MWOE.COMPANY_ID
  AND MWOE.RECHERCHE_ID_GROUPE_LECTURE=MLGD.ID_GROUPE
  AND ME.NOM_PAGE                     =MWOE.ECRAN_NOM_PAGE
  AND ME.NUM_LIVRABLE                 =MLGD.NUM_LIVRABLE
  AND MWOE.NUM_LIVRABLE               =MLGD.NUM_LIVRABLE
 ##
TMPL_LIEN_GROUPE_DONNEE_LIGHT
=SQL=
CREATE OR REPLACE FORCE VIEW "TMPL_LIEN_GROUPE_DONNEE_LIGHT" (
"NUM_LIVRABLE", 
"COMPANY_ID", 
"ID_GROUPE", 
"NOM_DONNEE", 
"SUFFIXE_OU_LIBELLE", 
"ID_GROUPE_DONNEES")
AS
  SELECT NUM_LIVRABLE,
    COMPANY_ID,
    CONNECT_BY_ROOT(ID_GROUPE) AS ID_GROUPE,
    NOM_DONNEE,
    SUFFIXE_OU_LIBELLE,
    ID_GROUPE AS ID_GROUPE_DONNEES
  FROM TMPL_GROUPE_DONNEES
    START WITH 1                 =1
    CONNECT BY NOCYCLE ID_GROUPE = PRIOR SUFFIXE_OU_LIBELLE
  AND COMPANY_ID                 = PRIOR COMPANY_ID
  AND NUM_LIVRABLE               = PRIOR NUM_LIVRABLE
  AND PRIOR NOM_DONNEE LIKE '#GROUPE%'
 ##
TMP_BATCH_TRACES
=SQL=
CREATE OR REPLACE VIEW TMP_BATCH_TRACES
AS
  (SELECT NOMINTERFACE,
    TRUNC(REQUESTED_GO) AS DATEDEB,
    TRUNC(ENDED)        AS DATEFIN,
    CASE
      WHEN STATUT='OK'
      THEN 'O'
      ELSE 'E'
    END AS STATUT
  FROM sys_batch_trace_lancement
  )
##
WKF_OP_ROLEALL
==
CREATE OR REPLACE FORCE VIEW "WKF_OP_ROLEALL" ("OP_NUM", "CODE_ROLE", "FCT_ROLE") AS SELECT OP_NUM,CODE_ROLE,FCT_ROLE FROM WKF_OP_ROLE UNION ALL (SELECT OP_NUM AS OP_NUM, -99 AS CODE_ROLE, '*' AS FCT_ROLE  FROM WKF_OPERATIONS WHERE OP_NUM NOT IN (SELECT DISTINCT OP_NUM FROM WKF_OP_ROLE )  )
##
WKF_PROCESSUS_EN_COURS_IHM
=SQL=
CREATE OR REPLACE FORCE VIEW WKF_PROCESSUS_EN_COURS_IHM AS (
	SELECT M.DOS_NUM, M.MATRIC, M.NUMPAC, M.PACMAT, M.PAIEZAD, M.NUMCNT, TO_CHAR(M.DATE_EFF,'dd.mm.yyyy') AS DATE_EFF, P.PROC_NUM, P.PROC_LIBELLE 
	FROM WKF_METIER_GENERIQUE M, WKF_TRACABILITE T, WKF_PROCESSUS P 
	WHERE M.DOS_NUM=T.DOS_NUM AND T.PROC_NUM=P.PROC_NUM
)
##
CAD_CALCUL_ERR_PK
=SQL IF_INDEX_NOTEXIST=CAD_CALCUL_ERR_PK=
CREATE UNIQUE INDEX "CAD_CALCUL_ERR_PK" ON "CAD_CALCUL_ERR" ("ID", "PROC") 
##
CAD_COMPTEUR_IDX
=SQL IF_INDEX_NOTEXIST=CAD_COMPTEUR_IDX=
CREATE INDEX "CAD_COMPTEUR_IDX" ON "CAD_COMPTEUR" ("CODE_COMPTEUR", "DJOUR") 
##
DIC_ADM_CONTRAT_HISTO_OP
=SQL IF_INDEX_NOTEXIST=DIC_ADM_CONTRAT_HISTO_OP=
CREATE INDEX "DIC_ADM_CONTRAT_HISTO_OP" ON  DIC_ADM_CONTRAT_HISTO ("NUMPAC", "PACMAT") 
##
TAG_CHARSET=@€éèç
##
DIC_ADM_CONTRAT_HIS_DT_FIN_BO
=SQL IF_INDEX_NOTEXIST=DIC_ADM_CONTRAT_HIS_DT_FIN_BO=
CREATE INDEX "DIC_ADM_CONTRAT_HIS_DT_FIN_BO" ON  DIC_ADM_CONTRAT_HISTO (NUMPAC,PACMAT,NUMCNT,DATE_FIN_BO) ONLINE COMPUTE STATISTICS
##
DIC_ADM_CONTRAT_PAIEZAD_IDX
=SQL IF_INDEX_NOTEXIST=DIC_ADM_CONTRAT_PAIEZAD_IDX=
CREATE INDEX "DIC_ADM_CONTRAT_PAIEZAD_IDX" ON  DIC_ADM_CONTRAT (CURRENT_PAIEZAD)
##
DIC_TGE_RESPAIE_HISTO_N1
=SQL IF_INDEX_NOTEXIST=DIC_TGE_RESPAIE_HISTO_N1=
CREATE INDEX "DIC_TGE_RESPAIE_HISTO_N1" ON  DIC_TGE_RESPAIE_HISTO ("MATRIC", "DTDEB_HISTO") 
##
DIF_FSED_HISTO_RETRO
=SQL IF_INDEX_NOTEXIST=DIF_FSED_HISTO_RETRO=
CREATE INDEX DIF_FSED_HISTO_RETRO ON DIF_FSED_HISTO (numpac,pacmat,paiezad,elem,occ,periode)  
##
DOC_CONTAINER_METADATA_PK 
=SQL IF_INDEX_NOTEXIST=DOC_CONTAINER_METADATA_PK=
CREATE  INDEX "DOC_CONTAINER_METADATA_PK" ON "DOC_CONTAINER_METADATA" ("PAC", "PERIODE_PAIE","NUM_ECH") 
##
EDI_BVRH_PK
=SQL IF_INDEX_NOTEXIST=EDI_BVRH_PK=
CREATE UNIQUE INDEX "EDI_BVRH_PK" ON "EDI_BVRH" ("ID_DOC", "DATE_DOC") 
##
EDI_SIGNATAIRE_PK
=SQL IF_INDEX_NOTEXIST=EDI_SIGNATAIRE_PK=
CREATE UNIQUE INDEX "EDI_SIGNATAIRE_PK" ON "EDI_SIGNATAIRE" ("CODE_ENTITE") 
##
EDI_TEXTE_MODELE_PLANNING_PK
=SQL IF_INDEX_NOTEXIST=EDI_TEXTE_MODELE_PLANNING_PK=
CREATE UNIQUE INDEX "EDI_TEXTE_MODELE_PLANNING_PK" ON "EDI_TEXTE_MODELE_PLANNING" ("CODE_T_MODELE") 
##
EVENTS_PK
=SQL IF_INDEX_NOTEXIST=EVENTS_PK=
CREATE UNIQUE INDEX "EVENTS_PK" ON "TGE_GESTIL_ERREUR_EVENTS" ("IDENT") 
##
EVTDETAIL_PK
=SQL IF_INDEX_NOTEXIST=EVTDETAIL_PK=
CREATE UNIQUE INDEX "EVTDETAIL_PK" ON "TGE_GESTIL_ERREUR_EVTDETAIL" ("IDENT", "NORDRE") 
##
EXTRACTION_PDF_PK
=SQL IF_INDEX_NOTEXIST=EXTRACTION_PDF_PK=
CREATE UNIQUE INDEX "EXTRACTION_PDF_PK" ON "EXTRACTION_PDF" ("UTILISATEUR", "FICHIER", "RECHERCHE", "DATE_RECHERCHE") 
##
GA_TITRE_PK
=SQL IF_INDEX_NOTEXIST=GA_TITRE_PK=
CREATE UNIQUE INDEX "GA_TITRE_PK" ON "GA_TITRE" ("CODE_LANGUE", "TITRE") 
##
GTA_PAR_MOIS_PK
=SQL IF_INDEX_NOTEXIST=GTA_PAR_MOIS_PK=
CREATE UNIQUE INDEX "GTA_PAR_MOIS_PK" ON "GTA_PAR_MOIS" ("JOUR") 
##
HELPDESK_COMMIT_PK
=SQL IF_INDEX_NOTEXIST=HELPDESK_COMMIT_PK=
CREATE UNIQUE INDEX "HELPDESK_COMMIT_PK" ON "HELPDESK_COMMIT" ("CODFICHE", "NUM_COMMIT") 
##
HELPDESK_FICHE_IDX
=SQL IF_INDEX_NOTEXIST=HELPDESK_FICHE_IDX=
CREATE INDEX "HELPDESK_FICHE_IDX" ON "HELPDESK_FICHE" ("CODSTA", "TYPFICHE") 
##
HPBSM_CHECK_PARTNER_PK
=SQL IF_INDEX_NOTEXIST=HPBSM_CHECK_PARTNER_PK=
CREATE UNIQUE INDEX "HPBSM_CHECK_PARTNER_PK" ON "HPBSM_CHECK_PARTNER" ("SERVEUR", "MIDDLE_WARE", "DATE_MODIF", "PARAMETRE") 
##
HUB_CHECKER_LINES_RESULT_PK
=SQL IF_INDEX_NOTEXIST=HUB_CHECKER_LINES_RESULT_PK=
CREATE UNIQUE INDEX "HUB_CHECKER_LINES_RESULT_PK" ON "HUB_CHECKER_LINES_RESULT" ("NUMSHEET", "SOURCE", "PERIOD", "CODERR", "NUMROW") 
##
HUB_EDIT_REQ_LISTE_EFFET_PK
=SQL IF_INDEX_NOTEXIST=HUB_EDIT_REQ_LISTE_EFFET_PK=
CREATE UNIQUE INDEX "HUB_EDIT_REQ_LISTE_EFFET_PK" ON "HUB_RELEASE" ("DTEFFET") 
##
HUB_PANEL_LIB_PK
=SQL IF_INDEX_NOTEXIST=HUB_PANEL_LIB_PK=
CREATE UNIQUE INDEX "HUB_PANEL_LIB_PK" ON "HUB_PANEL_LIB" ("CODEPANEL", "CODELANG") 
##
IDXBO_DT_FINBO
=SQL IF_INDEX_NOTEXIST=IDXBO_DT_FINBO=
CREATE INDEX "IDXBO_DT_FINBO" ON "DIC_ADM_CONTRAT_HISTO" ("MATRIC", "DATE_EFF", "DATE_FIN_BO") 
##
IDXBO_DT_SORSITBO
=SQL IF_INDEX_NOTEXIST=IDXBO_DT_SORSITBO=
CREATE INDEX "IDXBO_DT_SORSITBO" ON "DIC_ADM_CONTRAT_HISTO" ("MATRIC", "DATE_EFF", "DATE_SORTIE_SIT_BO") 
##
IDXBO_IDSECUPACREQ
=SQL IF_INDEX_NOTEXIST=IDXBO_IDSECUPACREQ=
CREATE INDEX "IDXBO_IDSECUPACREQ" ON "SYS_SEC_RESOLUE_PAC_REQ" ("LOGIN", "ID_SECU") 
##
IDXBO_IDSECUPOPREQ
=SQL IF_INDEX_NOTEXIST=IDXBO_IDSECUPOPREQ=
CREATE INDEX "IDXBO_IDSECUPOPREQ" ON "SYS_SEC_RESOLUE_POP_REQ" ("LOGIN", "ID_SECU") 
##
IDXBO_IDSECUSTRUCTREQ
=SQL IF_INDEX_NOTEXIST=IDXBO_IDSECUSTRUCTREQ=
CREATE INDEX "IDXBO_IDSECUSTRUCTREQ" ON "SYS_SEC_RESOLUE_STRUCT_REQ" ("LOGIN", "ID_SECU") 
##
IDXBO_RESPAIE_PACMAT_NUMPAC
=SQL IF_INDEX_NOTEXIST=IDXBO_RESPAIE_PACMAT_NUMPAC=
CREATE INDEX "IDXBO_RESPAIE_PACMAT_NUMPAC" ON  DIC_TGE_RESPAIE_HISTO ("NUMPAC", "PACMAT") 
##
IDX_ALERT_BATCH1
=SQL IF_INDEX_NOTEXIST=IDX_ALERT_BATCH1=
CREATE INDEX IDX_ALERT_BATCH1 ON ALERT_BATCH1 (ALERT_ID)
##
IDX_ALERT_BATCH2
=SQL IF_INDEX_NOTEXIST=IDX_ALERT_BATCH2=
CREATE INDEX IDX_ALERT_BATCH2 ON ALERT_BATCH2 (LOGIN,ALERT_ID)
##
IDX_ALERT_BATCH2_TMP
=SQL IF_INDEX_NOTEXIST=IDX_ALERT_BATCH2_TMP=
CREATE INDEX IDX_ALERT_BATCH2_TMP ON ALERT_BATCH2_TMP (LOGIN,ALERT_ID)
##
IDX_ALERT_BATCH_ERROR
=SQL IF_INDEX_NOTEXIST=IDX_ALERT_BATCH_ERROR=
CREATE INDEX IDX_ALERT_BATCH_ERROR ON ALERT_BATCH_ERROR (DATE_EXEC)
##
IDX_ALERT_PROFILE_1
=SQL IF_INDEX_NOTEXIST=IDX_ALERT_PROFILE_1=
CREATE INDEX IDX_ALERT_PROFILE_1 ON ALERT_PROFILE (PROFILE_ID)
##
IDX_ANNULATION_ORIGINE
=SQL IF_INDEX_NOTEXIST=IDX_ANNULATION_ORIGINE=
CREATE INDEX IDX_ANNULATION_ORIGINE ON TGE_IMPORT_ANNULATION (LOGIN, DATE_IMPORT, ORIGINE)
##
IDX_CONTRAT_SITU_PACMAT
=SQL IF_INDEX_NOTEXIST=IDX_CONTRAT_SITU_PACMAT=
CREATE INDEX IDX_CONTRAT_SITU_PACMAT ON DIC_ADM_CONTRAT_SITU (NUMPAC, PACMAT)
##
IDX_CONTRAT_SITU_PAIEZAD
=SQL IF_INDEX_NOTEXIST=IDX_CONTRAT_SITU_PAIEZAD=
CREATE INDEX IDX_CONTRAT_SITU_PAIEZAD ON DIC_ADM_CONTRAT_SITU (NUMPAC, PAIEZAD)
##
IDX_CUMCOTM_PACMAT_DTD_CAISSE
=SQL IF_INDEX_NOTEXIST=IDX_CUMCOTM_PACMAT_DTD_CAISSE=
CREATE INDEX IDX_CUMCOTM_PACMAT_DTD_CAISSE ON DIC_TGE_RESPAIE_CUMCOTM (NUMPAC,PACMAT,DTDEB_CUMCOTM,CAISSE_CUMCOTM)
##
IDX_CUMCOT_PACMAT
=SQL IF_INDEX_NOTEXIST=IDX_CUMCOT_PACMAT=
CREATE INDEX IDX_CUMCOT_PACMAT ON DIC_TGE_RESPAIE_CUMCOT (NUMPAC,PACMAT)
##
IDX_DIF_FSED_MODIF_RETRO
=SQL IF_INDEX_NOTEXIST=IDX_DIF_FSED_MODIF_RETRO=
CREATE INDEX IDX_DIF_FSED_MODIF_RETRO ON DIF_FSED_MODIF_RETRO (NUMPAC,PACMAT)
##
IDX_GAP_TRT_MOIS_RETRO
=SQL IF_INDEX_NOTEXIST=IDX_GAP_TRT_MOIS_RETRO=
CREATE INDEX IDX_GAP_TRT_MOIS_RETRO ON GAP_TRT_MOIS_RETRO (ID_TRT, NUMPAC)
##
IDX_GTA_BDG_POINTAGE_KMATRIC
=SQL IF_INDEX_NOTEXIST=IDX_GTA_BDG_POINTAGE_KMATRIC=
CREATE INDEX "IDX_GTA_BDG_POINTAGE_KMATRIC" ON "GTA_BDG_POINTAGE" ("MATRICULE") 
##
IDX_INCIDENTS_CLE_IMPORT
=SQL IF_INDEX_NOTEXIST=IDX_INCIDENTS_CLE_IMPORT=
CREATE INDEX IDX_INCIDENTS_CLE_IMPORT ON TGE_INCIDENTS_PAIE (CLE_IMPORT)
##
IDX_INCIDENTS_CODE_IP
=SQL IF_INDEX_NOTEXIST=IDX_INCIDENTS_CODE_IP=
CREATE INDEX IDX_INCIDENTS_CODE_IP ON TGE_INCIDENTS_PAIE ( NUMPAC,PAIEZAD,CODE_IP,DATE_EFFET,CLE_ABSENCE)
##
IDX_INCIDENTS_PAIE_CLE
=SQL IF_INDEX_NOTEXIST=IDX_INCIDENTS_PAIE_CLE=
CREATE INDEX IDX_INCIDENTS_PAIE_CLE ON TGE_INCIDENTS_PAIE (NUMPAC, ORIGINE, CLE_ABSENCE)
##
TAG_CHARSET=@€éèç
##
IDX_KEYS_SYS_TRC_MODIF
=SQL IF_INDEX_NOTEXIST=IDX_KEYS_SYS_TRC_MODIF=
CREATE INDEX IDX_KEYS_SYS_TRC_MODIF ON SYS_TRC_MODIF (NUMPAC, PACMAT, PAIEZAD, MATRIC)
##
TAG_CHARSET=@€éèç
##
IDX_KEYS_SYS_TRC_MODIF_2
=SQL IF_INDEX_NOTEXIST=IDX_KEYS_SYS_TRC_MODIF_2=
CREATE INDEX IDX_KEYS_SYS_TRC_MODIF_2 ON SYS_TRC_MODIF (KEYS_VALUES)
##
IDX_MATRICPERE
=SQL IF_INDEX_NOTEXIST=IDX_MATRICPERE=
CREATE INDEX "IDX_MATRICPERE" ON "ORG_SUBALTERNE" ("MATRICPERE") 
##
TAG_CHARSET=@€éèç
##
IDX_META_AT_IMPACT_RECHERCHE_GLOBALE
=SQL IF_INDEX_NOTEXIST=IDX_META_AT_IMPACT_RECHERCHE_GLOBALE=
CREATE INDEX "IDX_META_AT_IMPACT_RECHERCHE_GLOBALE" ON "META_AT_IMPACT_RECHERCHE_GLOBALE" ("THEME", "TYPE_OBJ", "OBJ")
##
TAG_CHARSET=@€éèç
##
IDX_META_AT_IMPACT_VAL_ZONE
=SQL IF_INDEX_NOTEXIST=IDX_META_AT_IMPACT_VAL_ZONE=
CREATE INDEX "IDX_META_AT_IMPACT_VAL_ZONE" ON "META_AT_IMPACT_VAL_ZONE" ("NOM_DONNEE")
##
IDX_REQ_LISTE_ENTITES
=SQL IF_INDEX_NOTEXIST=IDX_REQ_LISTE_ENTITES=
CREATE UNIQUE INDEX "IDX_REQ_LISTE_ENTITES" ON "REQ_LISTE_ENTITES" ("NUM", "CODE_ENTITE") 
##
IDX_REQ_POPULATION
=SQL IF_INDEX_NOTEXIST=IDX_REQ_POPULATION=
CREATE UNIQUE INDEX "IDX_REQ_POPULATION" ON "REQ_POPULATION" ("NUM", "MATRIC") 
##
IDX_RUB_NUMPAC_PAIEZAD
=SQL IF_INDEX_NOTEXIST=IDX_RUB_NUMPAC_PAIEZAD=
CREATE INDEX IDX_RUB_NUMPAC_PAIEZAD ON DIC_TGE_RESPAIE_RUBRIQUE (numpac, paiezad)
##
IDX_RUB_PACMAT_PERIODEPAIE
=SQL IF_INDEX_NOTEXIST=IDX_RUB_PACMAT_PERIODEPAIE=
CREATE INDEX IDX_RUB_PACMAT_PERIODEPAIE ON DIC_TGE_RESPAIE_RUBRIQUE (NUMPAC,PACMAT,PERIODEPAIE)
##
IDX_STD_DPAE_HISTORIQUE_1
=SQL IF_INDEX_NOTEXIST=IDX_STD_DPAE_HISTORIQUE_1=
CREATE INDEX IDX_STD_DPAE_HISTORIQUE_1 ON STD_DPAE_HISTORIQUE (DPAE_ID , DATE_MAJ)
##
IDX_STD_EPS_1
=SQL IF_INDEX_NOTEXIST=IDX_STD_EPS_1=
CREATE INDEX IDX_STD_EPS_1 ON STD_EPS(ANNEE,PERIODE,RUBRIQUE) LOCAL NOLOGGING COMPRESS 3
##
IDX_STD_EPS_2
=SQL IF_INDEX_NOTEXIST=IDX_STD_EPS_2=
CREATE INDEX IDX_STD_EPS_2 ON STD_EPS(ANNEE,PERIODE,MATRIC,SSPERIODE,RUPED,RUBRIQUE,TYPENR) LOCAL NOLOGGING COMPRESS 5
##
IDX_STD_STRUC_ENTITE_DATFIN
=SQL IF_INDEX_EXIST=IDX_STD_STRUC_ENTITE_DATFIN=
DROP INDEX IDX_STD_STRUC_ENTITE_DATFIN
##
IDX_STD_STRUC_ENTITE_DATFIN
=SQL IF_INDEX_NOTEXIST=IDX_STD_STRUC_ENTITE_DATFIN=
CREATE INDEX "IDX_STD_STRUC_ENTITE_DATFIN" ON "STD_STRUC_ENTITE" ("DATE_FIN" ) 
##
IDX_SYS_USR_CONFIG_RQMATRIC
=SQL IF_INDEX_NOTEXIST=IDX_SYS_USR_CONFIG_RQMATRIC=
CREATE INDEX "IDX_SYS_USR_CONFIG_RQMATRIC" ON "SYS_USR_CONFIG" ("REQUETEMATRIC") 
##
IDX_TGE_ANNULATION
=SQL IF_INDEX_NOTEXIST=IDX_TGE_ANNULATION=
CREATE INDEX IDX_TGE_ANNULATION ON TGE_IMPORT_ANNULATION (PERIODE, MATRICULE,PACMAT,ORIGINE)
##
TAG_CHARSET=@€éèç
##
IDX_TGE_DONNEES_CLE_IMPORT
=SQL IF_INDEX_NOTEXIST=IDX_TGE_DONNEES_CLE_IMPORT=
CREATE INDEX IDX_TGE_DONNEES_CLE_IMPORT ON TGE_DONNEES_PAIE (CLE_IMPORT)
##
TAG_CHARSET=@€éèç
##
IDX_TGE_ELEMENTS_CLE_IMPORT
=SQL IF_INDEX_NOTEXIST=IDX_TGE_ELEMENTS_CLE_IMPORT=
CREATE INDEX IDX_TGE_ELEMENTS_CLE_IMPORT ON TGE_ELEMENTS_PAIE (CLE_IMPORT)
##
TAG_CHARSET=@€éèç
##
IDX_TGE_GESTIL_MATEVE1
=SQL=
DECLARE
IDX_EXIST PLS_INTEGER := 0;
BEGIN
	SELECT COUNT(*) INTO IDX_EXIST FROM USER_INDEXES WHERE INDEX_NAME = 'IDX_TGE_GESTIL_MATEVE1';
	IF IDX_EXIST > 0 THEN
		EXECUTE IMMEDIATE 'DROP INDEX IDX_TGE_GESTIL_MATEVE1';
	END IF ;
	EXECUTE IMMEDIATE 'CREATE INDEX IDX_TGE_GESTIL_MATEVE1 ON TGE_GESTIL_MATEVE (NUMPAC , MAT , DAT_AFF , HRE_AFF , RANG) LOCAL NOLOGGING';
END;
##
TAG_CHARSET=@€éèç
##
IDX_TGE_GESTIL_MATPRE1
=SQL=
DECLARE
IDX_EXIST PLS_INTEGER := 0;
BEGIN
	SELECT COUNT(*) INTO IDX_EXIST FROM USER_INDEXES WHERE INDEX_NAME = 'IDX_TGE_GESTIL_MATPRE1';
	IF IDX_EXIST > 0 THEN
		EXECUTE IMMEDIATE 'DROP INDEX IDX_TGE_GESTIL_MATPRE1';
	END IF ;
	EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IDX_TGE_GESTIL_MATPRE1 ON TGE_GESTIL_MATPRE (NUMPAC , MAT , DAT_PRE) LOCAL NOLOGGING';
END;
##
IDX_TGE_IMPORT_FSED_30_5
=SQL IF_INDEX_NOTEXIST=IDX_TGE_IMPORT_FSED_30_5=
CREATE INDEX IDX_TGE_IMPORT_FSED_30_5 ON TGE_IMPORT_FSED_30 (ID_TRT,NUMPAC,PACMAT) COMPUTE STATISTICS
##
IDX_TRACABILITE_DOS_FINISHED
=SQL IF_INDEX_NOTEXIST=IDX_TRACABILITE_DOS_FINISHED=
CREATE INDEX "IDX_TRACABILITE_DOS_FINISHED" ON "WKF_TRACABILITE" ("DOS_FINISHED") 
##
IDX_WKFABPDEMANDE_ABSKEY
=SQL IF_INDEX_NOTEXIST=IDX_WKFABPDEMANDE_ABSKEY=
CREATE INDEX "IDX_WKFABPDEMANDE_ABSKEY" ON "WKFABP_DEMANDE" ("ABP_MATRIC", "ABP_CODRUB", "ABP_DTDEB", "NUMOCC") 
##
IDX_WKFTRACABILITE_DOSKEY
=SQL IF_INDEX_NOTEXIST=IDX_WKFTRACABILITE_DOSKEY=
CREATE INDEX "IDX_WKFTRACABILITE_DOSKEY" ON "WKF_TRACABILITE" ("DOS_KEY") 
##
IDX_WKFTRACABILITE_DOSNUM
=SQL IF_INDEX_NOTEXIST=IDX_WKFTRACABILITE_DOSNUM=
CREATE INDEX "IDX_WKFTRACABILITE_DOSNUM" ON "WKF_TRACABILITE" ("DOS_NUM") 
##
TAG_CHARSET=@€éèç
##
IDX_WKF_POSSESSION_POSSESS
=SQL IF_INDEX_NOTEXIST=IDX_WKF_POSSESSION_POSSESS=
CREATE INDEX "IDX_WKF_POSSESSION_POSSESS" ON "WKF_POSSESSION" ("POSSESS") 
##
JSP_STATS_DETAIL_ID_GEN_IDX
=SQL IF_INDEX_NOTEXIST=JSP_STATS_DETAIL_ID_GEN_IDX= 
CREATE INDEX JSP_STATS_DETAIL_ID_GEN_IDX ON SYS_JSP_STATS_DETAILS(ID_GENERATION) 
##
JSP_STATS_ID_GEN_IDX
=SQL IF_INDEX_NOTEXIST=JSP_STATS_ID_GEN_IDX=
CREATE INDEX JSP_STATS_ID_GEN_IDX ON SYS_JSP_STATS (ID_GENERATION)
##
MASS_SAISIES_LIGNE_IDX
=SQL IF_INDEX_NOTEXIST=MASS_SAISIES_LIGNE_IDX=
CREATE INDEX "MASS_SAISIES_LIGNE_IDX" ON "MASS_SAISIES_LIGNE" ("NUM_SAISIE") 
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX1
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX1=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX1" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_DONNEE", "ALP_ONGLET", "ALP_NOM_PAGE", "ALP_THEME", "ALP_REGROUPEMENT", "ALP_ESPACE")
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX2
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX2=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX2" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_ONGLET")
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX3
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX3=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX3" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_NOM_PAGE")
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX4
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX4=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX4" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_THEME")
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX5
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX5=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX5" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_REGROUPEMENT")
##
TAG_CHARSET=@€éèç
##
META_AT_IMPACT_MODELE_DONNEES_IDX6
=SQL IF_INDEX_NOTEXIST=META_AT_IMPACT_MODELE_DONNEES_IDX6=
CREATE INDEX "META_AT_IMPACT_MODELE_DONNEES_IDX6" ON "META_AT_IMPACT_MODELE_DONNEES" ("ALP_ESPACE")
##
TAG_CHARSET=@€éèç
##
DROP_DEX_EVENTS_PK
=SQL IF_INDEX_EXIST=DEX_EVENTS_PK=
DROP INDEX DEX_EVENTS_PK
##
CREATE_MP_EVENTS_PK
=SQL IF_INDEX_NOTEXIST=MP_EVENTS_PK=
CREATE INDEX MP_EVENTS_PK ON MP_EVENTS (ID_ENVOI)
##
PHOTO_DIC_BANQUE_CRYPTO
=SQL IF_INDEX_NOTEXIST=PHOTO_DIC_BANQUE_CRYPTO=
create index PHOTO_DIC_BANQUE_CRYPTO on PHOTO_DIC_BANQUE (MATRIC, SEQBQE) online compute statistics
##
PH_PH_DIC_BANQUE_CRYPTO
=SQL IF_INDEX_NOTEXIST=PH_PH_DIC_BANQUE_CRYPTO=
create index PH_PH_DIC_BANQUE_CRYPTO on PH_PH_DIC_BANQUE (MATRIC, SEQBQE) online compute statistics
##
PK_ALERT_BATCH
=SQL IF_INDEX_NOTEXIST=PK_ALERT_BATCH=
CREATE UNIQUE INDEX "PK_ALERT_BATCH" ON "ALERT_BATCH" ("DATE_EXEC") 
##
PK_ALERT_BATCH_EXEC
=SQL IF_INDEX_NOTEXIST=PK_ALERT_BATCH_EXEC=
CREATE UNIQUE INDEX "PK_ALERT_BATCH_EXEC" ON "ALERT_BATCH_EXEC" ("DATE_EXEC","ORDER_NB") 
##
PK_ALERT_BATCH_STATUS
=SQL IF_INDEX_NOTEXIST=PK_ALERT_BATCH_STATUS=
CREATE UNIQUE INDEX "PK_ALERT_BATCH_STATUS" ON "ALERT_BATCH_STATUS" ("STATUS_ID") 
##
PK_ALERT_BATCH_USER
=SQL IF_INDEX_NOTEXIST=PK_ALERT_BATCH_USER=
CREATE UNIQUE INDEX "PK_ALERT_BATCH_USER" ON "ALERT_BATCH_USER" ("LOGIN","DATE_EXEC") 
##
PK_ALERT_BATCH_USER_EXEC
=SQL IF_INDEX_NOTEXIST=PK_ALERT_BATCH_USER_EXEC=
CREATE UNIQUE INDEX "PK_ALERT_BATCH_USER_EXEC" ON "ALERT_BATCH_USER_EXEC" ("LOGIN","DATE_EXEC","ORDER_NB") 
##
PK_ALERT_CHAINING
=SQL IF_INDEX_NOTEXIST=PK_ALERT_CHAINING=
CREATE UNIQUE INDEX "PK_ALERT_CHAINING" ON "ALERT_CHAINING" ("ALERT_ID","CHAINING_ORDER") 
##
PK_ALERT_IDX_TREE
=SQL IF_INDEX_NOTEXIST=PK_ALERT_IDX_TREE=
CREATE UNIQUE INDEX "PK_ALERT_IDX_TREE" ON "ALERT_IDX_TREE" ("ALERT_ID","IDX_COL_ID") 
##
PK_ALERT_PROFILE
=SQL IF_INDEX_NOTEXIST=PK_ALERT_PROFILE=
CREATE UNIQUE INDEX "PK_ALERT_PROFILE" ON "ALERT_PROFILE" ("ALERT_ID","PROFILE_ORDER") 
##
PK_ALERT_PROP
=SQL IF_INDEX_NOTEXIST=PK_ALERT_PROP=
CREATE UNIQUE INDEX "PK_ALERT_PROP" ON "ALERT_PROP" ("ALERT_ID") 
##
PK_ALERT_REDIRECT
=SQL IF_INDEX_NOTEXIST=PK_ALERT_REDIRECT=
CREATE UNIQUE INDEX "PK_ALERT_REDIRECT" ON "ALERT_REDIRECT" ("ALERT_ID","PAGE_ORDER") 
##
PK_ALERT_TREE
=SQL IF_INDEX_NOTEXIST=PK_ALERT_TREE=
CREATE UNIQUE INDEX "PK_ALERT_TREE" ON "ALERT_TREE" ("ALERT_ID") 
##
PK_DIF_FSED
=SQL IF_INDEX_EXIST=PK_DIF_FSED=
DROP index PK_DIF_FSED
##
PK_DIF_FSED
=SQL IF_INDEX_NOTEXIST=PK_DIF_FSED=
CREATE UNIQUE INDEX PK_DIF_FSED ON DIF_FSED (ID_TRT, NUMPAC, CLE, PACMAT,PAIEZAD, ELEM, OCC) LOCAL
##
PK_EDI_TEMPLATE_DOCUMENT
=SQL IF_INDEX_NOTEXIST=PK_EDI_TEMPLATE_DOCUMENT=
CREATE UNIQUE INDEX "PK_EDI_TEMPLATE_DOCUMENT" ON "EDI_TEMPLATE_DOCUMENT" ("CODE_TEMPLATE") 
##
PK_STD_EXTJS_EDITOR
=SQL IF_INDEX_NOTEXIST=PK_STD_EXTJS_EDITOR=
CREATE UNIQUE INDEX "PK_STD_EXTJS_EDITOR" ON "STD_EXTJS_EDITOR" ("EDITOR_ID") 
##
PK_STD_EXTJS_RENDERER
=SQL IF_INDEX_NOTEXIST=PK_STD_EXTJS_RENDERER=
CREATE UNIQUE INDEX "PK_STD_EXTJS_RENDERER" ON "STD_EXTJS_RENDERER" ("RENDERER_ID") 
##
PK_SYS_VARSYS_CLIENT_REFERENCE
=SQL IF_INDEX_NOTEXIST=PK_SYS_VARSYS_CLIENT_REFERENCE=
CREATE UNIQUE INDEX "PK_SYS_VARSYS_CLIENT_REFERENCE" ON "SYS_VARSYS_CLIENT_REFERENCE" ("CLIENT_REFERENCE", "CODVAR") 
##
REF_OBJ_LIVRABLES_PK
=SQL IF_INDEX_NOTEXIST=REF_OBJ_LIVRABLES_PK=
CREATE UNIQUE INDEX "REF_OBJ_LIVRABLES_PK" ON "REF_OBJ_LIVRABLES" ("COMPANY_ID", "NUM_LIVRABLE") 
##
REGEXP_CLE_IMPORT
=SQL IF_INDEX_NOTEXIST=REGEXP_CLE_IMPORT=
CREATE INDEX REGEXP_CLE_IMPORT ON TGE_ABSENCES (SUBSTR(MY_REGEXP_REPLACE(CLE_IMPORT,'#\d+$',''),0,80)) COMPUTE STATISTICS
##
ROWID_U99
=SQL IF_INDEX_NOTEXIST=ROWID_U99=
CREATE UNIQUE INDEX "ROWID_U99" ON "FOR_TMPCOUTV_CTVENTIL_B_ROWID" ("FOR_ROWID") 
##
SECUPACMAT_MATRIC
=SQL IF_INDEX_NOTEXIST=SECUPACMAT_MATRIC=
CREATE INDEX SECUPACMAT_MATRIC ON SECUPACMAT (MATRIC)
##
SECUPACMAT_PERDIODE_RECYCL
=SQL IF_INDEX_NOTEXIST=SECUPACMAT_PERDIODE_RECYCL=
CREATE INDEX "SECUPACMAT_PERDIODE_RECYCL" ON SECUPACMAT (NUMPAC,PACMAT,MATRIC,PERIODE_RECYCLAGE)
##
SECUPACMAT_PRIO_SITU
=SQL IF_INDEX_NOTEXIST=SECUPACMAT_PRIO_SITU=
CREATE INDEX SECUPACMAT_PRIO_SITU ON SECUPACMAT (PRIORITE_SITUATION)
##
SECUPACMAT_TMP_MATRIC_IDX
=SQL IF_INDEX_NOTEXIST=SECUPACMAT_TMP_MATRIC_IDX=
CREATE INDEX SECUPACMAT_TMP_MATRIC_IDX ON SECUPACMAT_TMP (MATRIC)
##
SECUPACMAT_TMP_PRIO_SITU_IDX
=SQL IF_INDEX_NOTEXIST=SECUPACMAT_TMP_PRIO_SITU_IDX=
CREATE INDEX SECUPACMAT_TMP_PRIO_SITU_IDX ON SECUPACMAT_TMP (PRIORITE_SITUATION)
##
STD_STRUC_AFFECTATION_ENTITE
=SQL IF_INDEX_NOTEXIST=STD_STRUC_AFFECTATION_ENTITE=
CREATE INDEX STD_STRUC_AFFECTATION_ENTITE ON STD_STRUC_AFFECTATION (CODTS,CODE_ENTITE,DATE_EFF,DATE_FIN)
##
STD_STRUC_ARBRE_INDEX1
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ARBRE_INDEX1=
CREATE INDEX "STD_STRUC_ARBRE_INDEX1" ON "STD_STRUC_ARBRE" ("CODE_ENTITE") 
##
STD_STRUC_ARBRE_INDEX2
=SQL IF_INDEX_EXIST=STD_STRUC_ARBRE_INDEX2=
drop index STD_STRUC_ARBRE_INDEX2
##
STD_STRUC_ARBRE_INDEX2
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ARBRE_INDEX2=
CREATE INDEX "STD_STRUC_ARBRE_INDEX2" ON "STD_STRUC_ARBRE" ("DATE_EFF", "DATE_FIN") 
##
STD_STRUC_ARBRE_INDEX3
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ARBRE_INDEX3=
CREATE INDEX "STD_STRUC_ARBRE_INDEX3" ON "STD_STRUC_ARBRE" ("CODE_ENT_MERE", "CODTS") 
##
STD_STRUC_ARBRE_INDEX4
=SQL IF_INDEX_EXIST=STD_STRUC_ARBRE_INDEX4=
DROP INDEX STD_STRUC_ARBRE_INDEX4 
##
STD_STRUC_ARBRE_INDEX4
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ARBRE_INDEX4=
CREATE INDEX "STD_STRUC_ARBRE_INDEX4" ON "STD_STRUC_ARBRE" ("CODTS", "DATE_EFF", "DATE_FIN")
##
STD_STRUC_ARBRE_INDEX5
=SQL IF_INDEX_EXIST=STD_STRUC_ARBRE_INDEX5=
DROP INDEX STD_STRUC_ARBRE_INDEX5 
##
STD_STRUC_ARBRE_INDEX5
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ARBRE_INDEX5=
CREATE INDEX "STD_STRUC_ARBRE_INDEX5" ON "STD_STRUC_ARBRE" ("CODTS", "STATUT")
##
STD_STRUC_ENTITE_DATEFF
=SQL IF_INDEX_EXIST=STD_STRUC_ENTITE_DATEFF=
DROP INDEX STD_STRUC_ENTITE_DATEFF
##
STD_STRUC_ENTITE_DATEFF
=SQL IF_INDEX_NOTEXIST=STD_STRUC_ENTITE_DATEFF=
CREATE INDEX "STD_STRUC_ENTITE_DATEFF" ON "STD_STRUC_ENTITE" ("DATE_EFF", "DATE_FIN") 
##
STD_STRUC_INDEX_DATE_FIN
=SQL IF_INDEX_NOTEXIST=STD_STRUC_INDEX_DATE_FIN=
CREATE INDEX "STD_STRUC_INDEX_DATE_FIN" ON "STD_STRUC_INDEX" ("CODTS", "DATE_FIN") 
##
STD_TYPE_VOIE_PK
=SQL IF_INDEX_NOTEXIST=STD_TYPE_VOIE_PK=
CREATE UNIQUE INDEX "STD_TYPE_VOIE_PK" ON "STD_TYPE_VOIE" ("CODE") 
##
TAG_CHARSET=@€éèç
##
SYS_TRC_MODIF_PK
=IF_INDEX_EXIST=SYS_TRC_MODIF_PK=
DROP INDEX SYS_TRC_MODIF_PK;
##
SYS_TRC_MODIF_PK
=SQL IF_INDEX_EXIST=SYS_TRC_MODIF_PK=
DROP INDEX SYS_TRC_MODIF_PK
##
TAG_CHARSET=@€éèç
##
SYS_TRC_MODIF_PK4
=SQL=
DECLARE
     existIndex NUMBER;
     indexNameToDrop VARCHAR2(4000);
     req VARCHAR2(4000);
BEGIN
    -- Chez certains clients, l'index a été supprimé pour pouvoir enregistrer des doublons, il faut le remettre
    select count(*) into existIndex from all_constraints where constraint_name = 'SYS_TRC_MODIF_PK4';
    
    IF (existIndex = 0) THEN 
        -- Si l'index "SYS_TRC_MODIF_PK4" n'existe pas, il faut : 
        -- supprimer les doublons qui pourraient exister
        -- recréer l'index pour les clés primaires SYS_TRC_MODIF_PK4
        req := 'delete from SYS_TRC_MODIF';
        req:= req || ' where ROWID in (';
        req:= req ||   ' select ROWID';
        req:= req ||   ' from (';
        req:= req ||     ' select ROWID, LOGIN || DATEMAJ || KEYS_VALUES || ACTION, ROW_NUMBER ( ) OVER ( PARTITION BY LOGIN || DATEMAJ || KEYS_VALUES || ACTION ';
        req:= req ||       ' ORDER BY LOGIN || DATEMAJ || KEYS_VALUES || ACTION ) num_ligne';
        req:= req ||     ' from SYS_TRC_MODIF';
        req:= req ||   ') t2';
        req:= req ||   ' where num_ligne > 1';
        req:= req || ')';
        execute immediate req;
        
        -- Chez certains clients, un autre index non unique a été créé, on le supprime 
        BEGIN
            select index_name into indexNameToDrop from user_indexes i 
            -- Recherche d'un index sur la table SYS_TRC_MODIF
            where table_name='SYS_TRC_MODIF' 
            -- Qui porte sur 4 colonnes
            and (select count(*) from user_ind_columns ic where i.index_name=ic.index_name)=4 
            -- LOGIN
            and exists (select 1 from user_ind_columns ic where i.index_name=ic.index_name and column_name='LOGIN') 
            -- DATEMAJ
            and exists (select 1 from user_ind_columns ic where i.index_name=ic.index_name and column_name='DATEMAJ') 
            -- KEYS_VALUES
            and exists (select 1 from user_ind_columns ic where i.index_name=ic.index_name and column_name='KEYS_VALUES') 
            -- ACTION
            and exists (select 1 from user_ind_columns ic where i.index_name=ic.index_name and column_name='ACTION');
        EXCEPTION 
            WHEN OTHERS THEN indexNameToDrop:=NULL;
        END;
        IF indexNameToDrop IS NOT NULL THEN
            execute immediate 'drop index '||indexNameToDrop;
        END IF;
        
        -- Création de la pk
        execute immediate 'alter table SYS_TRC_MODIF add constraint SYS_TRC_MODIF_PK4 primary key (LOGIN, DATEMAJ, KEYS_VALUES, ACTION)';
    END IF;
END;
##
SYS_USR_HISTORIQUE_IDX
=SQL IF_INDEX_EXIST=SYS_USR_HISTORIQUE_IDX=
drop index SYS_USR_HISTORIQUE_IDX
##
SYS_USR_HISTORIQUE_IDX
=SQL IF_INDEX_NOTEXIST=SYS_USR_HISTORIQUE_IDX=
CREATE INDEX "SYS_USR_HISTORIQUE_IDX" ON "SYS_USR_HISTORIQUE" ("LOGIN", "CODE_REGROUP_OR_ROLE", "TYPE_HISTO","ID_ELEMENT")
##
TGE_ABSENCES_I2
=SQL IF_INDEX_NOTEXIST=TGE_ABSENCES_I2=
CREATE INDEX TGE_ABSENCES_I2 ON TGE_ABSENCES (CLE_IMPORT)
##
TGE_DONNEES_PAIE_INDX
=SQL IF_INDEX_NOTEXIST=TGE_DONNEES_PAIE_INDX=
CREATE INDEX TGE_DONNEES_PAIE_INDX ON TGE_DONNEES_PAIE (NUMPAC, PAIEZAD)
##
TGE_ELEMENTS_PAIE_INDX
=SQL IF_INDEX_NOTEXIST=TGE_ELEMENTS_PAIE_INDX=
CREATE INDEX TGE_ELEMENTS_PAIE_INDX ON TGE_ELEMENTS_PAIE (NUMPAC, PAIEZAD)
##
TAG_CHARSET=@€éèç
##
TGE_GESTIL_MATCPT
=SQL IF_INDEX_NOTEXIST=IDX_TGE_GESTIL_MATCPT1=
CREATE UNIQUE INDEX IDX_TGE_GESTIL_MATCPT1 ON TGE_GESTIL_MATCPT ( NUMPAC, MAT, DAT_CPT, CPT, PER ) ONLINE COMPUTE STATISTICS
##
TGE_GESTIL_MATCPT
=SQL IF_INDEX_NOTEXIST=IDX_TGE_GESTIL_MATCPT2=
CREATE UNIQUE INDEX IDX_TGE_GESTIL_MATCPT2 ON TGE_GESTIL_MATCPT ( NUMPAC, DAT_CPT ) ONLINE COMPUTE STATISTICS
##
TGE_GESTIL_MATCPT
=SQL IF_INDEX_NOTEXIST=IDX_TGE_GESTIL_MATCPT3=
CREATE UNIQUE INDEX IDX_TGE_GESTIL_MATCPT3 ON TGE_GESTIL_MATCPT ( NUMPAC, MAT, DAT_FIN_CPT ) ONLINE COMPUTE STATISTICS
##
TGE_IMPORT_ELEMENTS_IN
=SQL IF_INDEX_NOTEXIST=TGE_IMPORT_ELEMENTS_IN=
CREATE INDEX TGE_IMPORT_ELEMENTS_IN ON "TGE_IMPORT_ELEMENTS" (LOGIN, DATE_IMPORT, ERREURS,NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,CODE_ELEMENT,NVL(INDICATIF,'XyZ'),NVL(CODE_REMPLACEMENT,'*'))
##
TGE_IMPUTATIONS_INDX
=SQL IF_INDEX_NOTEXIST=TGE_IMPUTATIONS_INDX=
CREATE INDEX TGE_IMPUTATIONS_INDX ON TGE_IMPUTATIONS (NUMPAC, PAIEZAD)
##
TAG_CHARSET=@€éèç
##
TGE_INCIDENTS_PAIE_ABS
=SQL IF_INDEX_NOTEXIST=TGE_INCIDENTS_PAIE_ABS=
CREATE INDEX "TGE_INCIDENTS_PAIE_ABS" ON "TGE_INCIDENTS_PAIE" ("CLE_ABSENCE") 
##
TAG_CHARSET=@€éèç
##
TGE_INCIDENTS_PAIE_F1
=SQL IF_INDEX_NOTEXIST=TGE_INCIDENTS_PAIE_F1=
CREATE INDEX "TGE_INCIDENTS_PAIE_F1" ON "TGE_INCIDENTS_PAIE" (SUBSTR("MY_REGEXP_REPLACE"("CLE_IMPORT",'#\d+$',''),0,80)) 
##
TAG_CHARSET=@€éèç
##
TGE_INCIDENTS_PAIE_F2
=SQL IF_INDEX_NOTEXIST=TGE_INCIDENTS_PAIE_F2=
CREATE INDEX TGE_INCIDENTS_PAIE_F2 ON TGE_INCIDENTS_PAIE ( PAIEZAD,DATE_EFFET,CODE_IP,NUMPAC,SUBSTR(MY_REGEXP_REPLACE ("CLE_IMPORT",'#\d+$',''),0,80),CLE_ABSENCE) ONLINE
##
TGE_INCIDENTS_PAIE_INDX
=SQL IF_INDEX_NOTEXIST=TGE_INCIDENTS_PAIE_INDX=
CREATE INDEX TGE_INCIDENTS_PAIE_INDX ON TGE_INCIDENTS_PAIE (NUMPAC, PAIEZAD)
##
TGE_MODIF_PACMAT_TORESEND_INDX
=SQL IF_INDEX_NOTEXIST=TGE_MODIF_PACMAT_TORESEND_INDX=
CREATE INDEX TGE_MODIF_PACMAT_TORESEND_INDX ON TGE_MODIF_PACMAT_TORESEND (NUMPAC, PACMAT)
##
TGE_PERIODE_RECUEIL_PZAD_R_IDX
=SQL IF_INDEX_NOTEXIST=TGE_PERIODE_RECUEIL_PZAD_R_IDX=
CREATE INDEX "TGE_PERIODE_RECUEIL_PZAD_R_IDX" ON "TGE_PERIODE_RECUEIL_PAIEZAD_R" (NUMPAC,MOIS_PAIE, PAIEZAD,PACMAT) 
##
TGE_REF_CAISSE_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_CAISSE_PK=
CREATE UNIQUE INDEX "TGE_REF_CAISSE_PK" ON "TGE_REF_CAISSE" ("NUMPAC", "CODECAISSE") 
##
TGE_REF_CBE_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_CBE_PK=
CREATE UNIQUE INDEX "TGE_REF_CBE_PK" ON "TGE_REF_CBE" ("NUMPAC", "CBE") 
##
TGE_REF_IMPUTATION_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_IMPUTATION_PK=
CREATE UNIQUE INDEX "TGE_REF_IMPUTATION_PK" ON "TGE_REF_IMPUTATION" ("NUMPAC", "CODEIMP") 
##
TGE_REF_LSTCBE_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_LSTCBE_PK=
CREATE UNIQUE INDEX "TGE_REF_LSTCBE_PK" ON "TGE_REF_LST_CBE_VAL" ("LISTE", "NUMPAC", "CODCBE") 
##
TGE_REF_LST_CBE_LIB_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_LST_CBE_LIB_PK=
CREATE UNIQUE INDEX "TGE_REF_LST_CBE_LIB_PK" ON "TGE_REF_LST_CBE_LIB" ("LISTE") 
##
TGE_REF_RUBRIQUE_CONTEXTE_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_RUBRIQUE_CONTEXTE_PK=
CREATE UNIQUE INDEX "TGE_REF_RUBRIQUE_CONTEXTE_PK" ON "TGE_REF_RUBRIQUE_CONTEXTE" ("NUMPAC", "CODERUB", "NOSEQU") 
##
TGE_REF_RUBRIQUE_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_RUBRIQUE_PK=
CREATE UNIQUE INDEX "TGE_REF_RUBRIQUE_PK" ON "TGE_REF_RUBRIQUE" ("NUMPAC", "CODERUB") 
##
TGE_REF_STATUT_ZPP_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_STATUT_ZPP_PK=
CREATE UNIQUE INDEX "TGE_REF_STATUT_ZPP_PK" ON "TGE_REF_STATUT_ZPP" ("CODESTATUT") 
##
TGE_REF_STATUT_ZVB_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_STATUT_ZVB_PK=
CREATE UNIQUE INDEX "TGE_REF_STATUT_ZVB_PK" ON "TGE_REF_STATUT_ZVB" ("CODESTATUT") 
##
TGE_REF_TYPETRT_PK
=SQL IF_INDEX_NOTEXIST=TGE_REF_TYPETRT_PK=
CREATE UNIQUE INDEX "TGE_REF_TYPETRT_PK" ON "TGE_REF_TYPETRT" ("NUMPAC", "CODETYPTRT") 
##
THE_REF_PAC_PK
=SQL IF_INDEX_NOTEXIST=THE_REF_PAC_PK=
CREATE UNIQUE INDEX "THE_REF_PAC_PK" ON "TGE_REF_PAC" ("NUMPAC") 
##
TAG_CHARSET=@€éèç
##
WKF_POSS_CODEUSER
=SQL IF_INDEX_NOTEXIST=WKF_POSS_CODEUSER=
create index WKF_POSS_CODEUSER on wkf_possession (CODE_USER) online compute statistics
##
TAG_CHARSET=@€éèç
##
WKF_TRACABILITE_N1
=SQL IF_INDEX_NOTEXIST=WKF_TRACABILITE_N1=
CREATE INDEX WKF_TRACABILITE_N1 ON WKF_TRACABILITE("ETAT", "IS_VISIBLE", "DOS_FINISHED", "DATE_DEB_PREV") ONLINE COMPUTE STATISTICS
##
XLS_DOCMODEL_PK
=SQL IF_INDEX_NOTEXIST=XLS_DOCMODEL_PK=
CREATE UNIQUE INDEX "XLS_DOCMODEL_PK" ON "XLS_DOCMODEL" ("CODDOC", "DTEFFET") 
##
XLS_FILTER_SEARCHBY_PK
=SQL IF_INDEX_NOTEXIST=XLS_FILTER_SEARCHBY_PK=
CREATE UNIQUE INDEX "XLS_FILTER_SEARCHBY_PK" ON "HUB_MATCHING_FILTER" ("CODDOC", "DTEFFET", "NUM_SHEET", "NUM_COLUMN", "TYPEFILTER") 
##
XLS_MATCHING_DATA_PK
=SQL IF_INDEX_NOTEXIST=XLS_MATCHING_DATA_PK=
CREATE UNIQUE INDEX "XLS_MATCHING_DATA_PK" ON "XLS_MATCHING_DATA" ("CODDOC", "DTEFFET", "NUM_SHEET", "NUM_COLUMN") 
##
XLS_MATCHING_POPUP_EDIT_PK
=SQL IF_INDEX_NOTEXIST=XLS_MATCHING_POPUP_EDIT_PK=
CREATE UNIQUE INDEX "XLS_MATCHING_POPUP_EDIT_PK" ON "HUB_MATCHING_POPUP_EDIT" ("CODDOC", "DTEFFET", "NUM_SHEET", "NUM_COLUMN") 
##
XLS_MATCHING_TITLE_PK
=SQL IF_INDEX_NOTEXIST=XLS_MATCHING_TITLE_PK=
CREATE UNIQUE INDEX "XLS_MATCHING_TITLE_PK" ON "XLS_MATCHING_TITLE" ("DTEFFET", "NUM_COLUMN", "CODLANG", "CODDOC", "NUM_SHEET") 
##
XLS_SHEET_LIB_PK
=SQL IF_INDEX_NOTEXIST=XLS_SHEET_LIB_PK=
CREATE UNIQUE INDEX "XLS_SHEET_LIB_PK" ON "XLS_SHEET_LIB" ("CODE_SHEET", "CODLANG") 
##
XLS_SHEET_PK
=SQL IF_INDEX_NOTEXIST=XLS_SHEET_PK=
CREATE UNIQUE INDEX "XLS_SHEET_PK" ON "XLS_SHEET" ("CODDOC", "DTEFFET", "NUM_SHEET") 
##
Z2X_BATCH_GAP_LIBELLES_PK
=SQL IF_INDEX_NOTEXIST=Z2X_BATCH_GAP_LIBELLES_PK=
CREATE UNIQUE INDEX "Z2X_BATCH_GAP_LIBELLES_PK" ON "Z2X_BATCH_GAP_LIBELLES" ("CODLANG", "CODGROUP1", "CODGROUP2", "COD1", "COD2") 
##
CAD_DEBUG_MODE
=SQL IF_SEQUENCE_NOTEXIST=CAD_DEBUG_MODE=
CREATE SEQUENCE  "CAD_DEBUG_MODE"  MINVALUE 1 MAXVALUE 2 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  CYCLE 
##
CAD_SEQ_CALCUL
=SQL IF_SEQUENCE_NOTEXIST=CAD_SEQ_CALCUL=
CREATE SEQUENCE  "CAD_SEQ_CALCUL"  MINVALUE 1 MAXVALUE 999999999 INCREMENT BY 1 START WITH 3451 CACHE 20 NOORDER  CYCLE 
##
TAG_CHARSET=@€éèç
##
SEQ_CODE_DELEGATION
=SQL=
DECLARE
    lastSeq number;
    exist_seq number;
BEGIN
    SELECT COUNT(*) INTO exist_seq FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SEQ_CODE_DELEGATION';
    IF exist_seq = 1 then
        RETURN;
    END IF;

    SELECT MAX(CODE_DELEGATION) INTO lastSeq FROM DEL_DELEGATION;
    if lastSeq IS NULL then
      lastSeq := 1;
    end if;
    execute immediate 'CREATE SEQUENCE SEQ_CODE_DELEGATION MINVALUE 1 MAXVALUE 9999999999 INCREMENT BY 1 START WITH ' || lastSeq || ' NOCACHE NOORDER NOCYCLE';
END;
##
DEX_ID_ENVOI
=SQL IF_SEQUENCE_NOTEXIST=DEX_ID_ENVOI=
CREATE SEQUENCE "DEX_ID_ENVOI "  MINVALUE 1 MAXVALUE 99999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE 
##
DEX_ID_ENVOI
=SQL=
BEGIN
   execute immediate 'DROP SEQUENCE "DEX_ID_ENVOI "';
EXCEPTION
  WHEN OTHERS THEN
    NULL;
END;
##
DEX_ID_ENVOI
=SQL IF_SEQUENCE_NOTEXIST=DEX_ID_ENVOI=
CREATE SEQUENCE DEX_ID_ENVOI  MINVALUE 1 MAXVALUE 99999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE 
##
DPAE_ID
=SQL IF_SEQUENCE_NOTEXIST=DPAE_ID=
CREATE SEQUENCE DPAE_ID MINVALUE 1 MAXVALUE 9999999999 INCREMENT BY 1 START WITH 1 NOCACHE NOORDER NOCYCLE
##
TAG_CHARSET=@€éèç
##
EDI_HISTO_ID_LANCEMENT
=SQL IF_SEQUENCE_NOTEXIST=EDI_HISTO_ID_LANCEMENT=
create SEQUENCE EDI_HISTO_ID_LANCEMENT MINVALUE 1 MAXVALUE 9999999999 INCREMENT BY 1 START WITH 1 NOCACHE NOORDER NOCYCLE
##
GAP_TRT_SEQ_ID
=SQL IF_SEQUENCE_NOTEXIST=GAP_TRT_SEQ_ID=
CREATE SEQUENCE  "GAP_TRT_SEQ_ID"  MINVALUE 1 MAXVALUE 99999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  CYCLE 
##
GESTIL_MCT_INSERT_SEQUENCE
=SQL IF_SEQUENCE_NOTEXIST=GESTIL_MCT_INSERT_SEQUENCE=
CREATE SEQUENCE GESTIL_MCT_INSERT_SEQUENCE  MINVALUE 1 MAXVALUE 99999 INCREMENT BY 1 START WITH 2 NOCACHE  NOORDER  NOCYCLE
##
GTA_EXP_PLANSTRUC_UID
=SQL IF_SEQUENCE_NOTEXIST=GTA_EXP_PLANSTRUC_UID=
CREATE SEQUENCE  "GTA_EXP_PLANSTRUC_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1000000 CACHE 20 NOORDER  NOCYCLE 
##
GTA_PLANNING_POPULATION_UID
=SQL IF_SEQUENCE_NOTEXIST=GTA_PLANNING_POPULATION_UID=
CREATE SEQUENCE  "GTA_PLANNING_POPULATION_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 461 CACHE 20 NOORDER  NOCYCLE 
##
TAG_CHARSET=@€éèç
##
ID_TRACE_SEQUENCE
=SQL IF_SEQUENCE_NOTEXIST=ID_TRACE_SEQUENCE=
CREATE SEQUENCE ID_TRACE_SEQUENCE INCREMENT BY 1 START WITH 1 MINVALUE 1 MAXVALUE 999999999999999999999999999 NOCACHE NOCYCLE
##
IMP_TRT_SEQ_ID
=SQL IF_SEQUENCE_NOTEXIST=IMP_TRT_SEQ_ID=
CREATE SEQUENCE  "IMP_TRT_SEQ_ID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  CYCLE 
##
PACMAT_TMPPAC_UID
=SQL IF_SEQUENCE_NOTEXIST=PACMAT_TMPPAC_UID=
CREATE SEQUENCE  "PACMAT_TMPPAC_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE NOORDER  NOCYCLE 
##
PUB_DOC_GROUP
=SQL IF_SEQUENCE_NOTEXIST=PUB_DOC_GROUP=
CREATE SEQUENCE  "PUB_DOC_GROUP"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE 
##
REQ_UID
=SQL IF_SEQUENCE_NOTEXIST=REQ_UID=
CREATE SEQUENCE  "REQ_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 461 CACHE 20 NOORDER  NOCYCLE 
##
SEQ_DEL_FCTMETIER_LIB
=SQL IF_SEQUENCE_NOTEXIST=SEQ_DEL_FCTMETIER_LIB=
CREATE SEQUENCE  "SEQ_DEL_FCTMETIER_LIB"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE 
##
SEQ_ETAT_CALC_ATTENTE
=SQL IF_SEQUENCE_NOTEXIST=SEQ_ETAT_CALC_ATTENTE=
CREATE SEQUENCE SEQ_ETAT_CALC_ATTENTE MINVALUE 0 MAXVALUE 9999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE ORDER NOCYCLE
##
SEQ_FOR_OCC_COUT
=SQL IF_SEQUENCE_NOTEXIST=SEQ_FOR_OCC_COUT=
CREATE SEQUENCE  "SEQ_FOR_OCC_COUT"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1000000 CACHE 20 NOORDER  CYCLE 
##
SEQ_GAP_MASSE_ZS2_TRT
=SQL IF_SEQUENCE_NOTEXIST=SEQ_GAP_MASSE_ZS2_TRT=
CREATE SEQUENCE  "SEQ_GAP_MASSE_ZS2_TRT"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 5 NOORDER  NOCYCLE 
##
SEQ_HRO_REPRISE
=SQL IF_SEQUENCE_NOTEXIST=SEQ_HRO_REPRISE=
CREATE SEQUENCE  "SEQ_HRO_REPRISE"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 61 CACHE 20 NOORDER  NOCYCLE 
##
SEQ_IDENT_GXP
=SQL IF_SEQUENCE_NOTEXIST=SEQ_IDENT_GXP=
CREATE SEQUENCE  "SEQ_IDENT_GXP"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE 
##
SEQ_IDTEMP
=SQL IF_SEQUENCE_NOTEXIST=SEQ_IDTEMP=
CREATE SEQUENCE  "SEQ_IDTEMP"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  CYCLE 
##
TAG_CHARSET=@€éèç
##
SEQ_ID_BATCH_LIST_DELAYED
=SQL=
DECLARE
    START_SEQ INTEGER;
    EXIST_SEQ INTEGER;
BEGIN
   SELECT COUNT(*) INTO EXIST_SEQ FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SEQ_ID_BATCH_LIST_DELAYED';

   IF EXIST_SEQ = 0 THEN	
	   SELECT MAX(ID_TRT_DELAYED) + 1  
	   INTO   START_SEQ
	   FROM   BATCH_LIST_DELAYED;
IF START_SEQ is null THEN START_SEQ:=1; END IF ;
		EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_ID_BATCH_LIST_DELAYED
						   START WITH ' || START_SEQ ||
						   ' INCREMENT BY 1 ORDER NOCACHE' ;                       
   END IF;
END;
##
SEQ_ID_USER_IMPORT_GXP
=SQL IF_SEQUENCE_NOTEXIST=SEQ_ID_USER_IMPORT_GXP=
CREATE SEQUENCE  "SEQ_ID_USER_IMPORT_GXP"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE 
##
SEQ_LINK
=SQL IF_SEQUENCE_NOTEXIST=SEQ_LINK=
CREATE SEQUENCE  SEQ_LINK  MINVALUE 1 MAXVALUE 99999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  CYCLE
##
SEQ_MATRIC
=SQL IF_SEQUENCE_NOTEXIST=SEQ_MATRIC=
CREATE SEQUENCE  "SEQ_MATRIC"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 9001 NOCACHE  NOORDER  NOCYCLE 
##
SEQ_NUMSAISIE
=SQL IF_SEQUENCE_NOTEXIST=SEQ_NUMSAISIE=
CREATE SEQUENCE  SEQ_NUMSAISIE  MINVALUE 1 MAXVALUE 9999999999999999999999999 INCREMENT BY 1 START WITH 1000 CACHE 20 NOORDER  NOCYCLE 
##
SEQ_SYS_BATCH_TRACE
=SQL IF_SEQUENCE_NOTEXIST=SEQ_SYS_BATCH_TRACE=
CREATE SEQUENCE SEQ_SYS_BATCH_TRACE MINVALUE 0 MAXVALUE 9999999999999999999999999 INCREMENT BY 1 START WITH 0 NOCACHE ORDER NOCYCLE
##
SEQ_SYS_IMPORT_PHOTO
=SQL IF_SEQUENCE_NOTEXIST=SEQ_SYS_IMPORT_PHOTO=
CREATE SEQUENCE SEQ_SYS_IMPORT_PHOTO MINVALUE 1 MAXVALUE 9999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE ORDER NOCYCLE
##
SEQ_TGE_ABSENCES
=SQL IF_SEQUENCE_NOTEXIST=SEQ_TGE_ABSENCES=
CREATE SEQUENCE SEQ_TGE_ABSENCES MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE
##
SEQ_TGE_INCIDENTS_PAIE
=SQL IF_SEQUENCE_NOTEXIST=SEQ_TGE_INCIDENTS_PAIE=
CREATE SEQUENCE SEQ_TGE_INCIDENTS_PAIE MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE
##
SIM_SEQUENCE
=SQL IF_SEQUENCE_NOTEXIST=SIM_SEQUENCE=
CREATE SEQUENCE  SIM_SEQUENCE  MINVALUE 1 MAXVALUE 9999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE
##
SYS_REQUETES_ID_VUES_SEQ
=SQL IF_SEQUENCE_NOTEXIST=SYS_REQUETES_ID_VUES_SEQ=
CREATE SEQUENCE SYS_REQUETES_ID_VUES_SEQ  START WITH 1  INCREMENT BY 1 NOCACHE NOCYCLE
##
TAG_CHARSET=@€éèç
##
SYS_STATS_REST_API_DELAY_SEQUENCE
=SQL IF_SEQUENCE_NOTEXIST=SYS_STATS_REST_API_DELAY_SEQUENCE=
CREATE SEQUENCE SYS_STATS_REST_API_DELAY_SEQUENCE  START WITH 1  INCREMENT BY 1 NOCACHE NOCYCLE
##
TAG_CHARSET=@€éèç
##
SYS_TRC_API_SEQUENCE
=SQL=
DECLARE
    lastSeq number;
    exist_seq number;
BEGIN
    SELECT COUNT(*) INTO exist_seq FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SYS_TRC_API_SEQUENCE';
    IF exist_seq = 1 then
        RETURN;
    END IF;

    SELECT MAX(ID_TRACE) + 1 INTO lastSeq FROM SYS_STATS_REST_API_DELAY;
    if lastSeq IS NULL then
      lastSeq := 1;
    end if;
    execute immediate 'CREATE SEQUENCE SYS_TRC_API_SEQUENCE INCREMENT BY 1 START WITH ' || lastSeq || ' MINVALUE 1 NOCACHE';
END;
##
S_Z2X_BATCH_LOG
=SQL IF_SEQUENCE_NOTEXIST=S_Z2X_BATCH_LOG=
CREATE SEQUENCE  "S_Z2X_BATCH_LOG"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 61 CACHE 20 NOORDER  NOCYCLE 
##
TESTAUTO_ID_SCENARIO
=SQL IF_SEQUENCE_NOTEXIST=TESTAUTO_ID_SCENARIO=
CREATE SEQUENCE TESTAUTO_ID_SCENARIO MINVALUE 1 MAXVALUE 9999999999 START WITH 1 INCREMENT BY 1 NOCACHE NOORDER NOCYCLE
##
TESTAUTO_NUM_LANCEMENT
=SQL IF_SEQUENCE_NOTEXIST=TESTAUTO_NUM_LANCEMENT=
CREATE SEQUENCE TESTAUTO_NUM_LANCEMENT MINVALUE 1 MAXVALUE 9999999999 START WITH 1 INCREMENT BY 1 NOCACHE NOORDER NOCYCLE
##
WKF_DOSNUM_UID
=SQL IF_SEQUENCE_NOTEXIST=WKF_DOSNUM_UID=
CREATE SEQUENCE  "WKF_DOSNUM_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1000000 CACHE 20 NOORDER  NOCYCLE 
##
WKF_TRACENUM_UID
=SQL IF_SEQUENCE_NOTEXIST=WKF_TRACENUM_UID=
CREATE SEQUENCE  "WKF_TRACENUM_UID"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1000000 CACHE 20 NOORDER  NOCYCLE 
##
TAG_CHARSET=@€éèç
##
BUILD_ALLINDEX
=SQL=
call BUILD_ALLINDEX()
##
REFRESH_META_AT_IMPACT_ERREURS_PARAMETRAGES
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_ERREURS_PARAMETRAGES')
##
REFRESH_META_AT_IMPACT_MODELE_DONNEES
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_MODELE_DONNEES')
##
REFRESH_META_AT_IMPACT_RECHERCHE_GLOBALE
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_RECHERCHE_GLOBALE')
##
REFRESH_META_AT_IMPACT_VAL_ZONE
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_VAL_ZONE')
##
REFRESH_META_AT_IMPACT_WORKFLOWS
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_WORKFLOWS')
##
REFRESH_META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS
=SQL=
call DBMS_MVIEW.REFRESH('META_AT_IMPACT_WORKFLOWS_DETAILS_ECRANS')
