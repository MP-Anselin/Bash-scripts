##
TAG_CHARSET=@€éèç
##
TRG_TGE_INCIDENTS_PAIE
=SQL=
create or replace trigger trg_tge_incidents_paie FOR
  insert or
  update or
  delete on tge_incidents_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   number;
  v_numpac           varchar2(6);
  v_old_numpac       varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_old_paiezad      varchar2(8);
  v_date_effet       DATE; 
  v_periode_retro    VARCHAR2(6);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  dateFinRecueil DATE;
  --moisPaie  VARCHAR2(6);
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   DATE;
  date_effet_recycl   DATE;
  A520 VARCHAR2(32);
  A521 VARCHAR2(32);
  A523 VARCHAR2(32);
  activite VARCHAR2(32);
  etablissement VARCHAR2(32);
  categorie VARCHAR2(32);
  nomTablegxp VARCHAR2(32);
  requete CLOB;
  V_IS_T2           NUMBER;
  V_ORIGINE_CREATE  VARCHAR2(32);
  BEFORE STATEMENT IS BEGIN
    -- action de 'bypass' le trigger 
    select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;   
    v_old_numpac := 'X' ;
  END BEFORE STATEMENT;
BEFORE EACH ROW
IS
begin
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité
    v_numpac        := NVL(:new.numpac, :old.numpac);
    v_paiezad       := NVL(:new.paiezad, :old.paiezad);
    IF v_old_numpac != v_numpac THEN
     -- Récupération des info du pac    
     SELECT 
       PERIODEENCOURS,
       DEB_RETRO
     INTO
       V_PERIODEENCOURS,
       V_DEB_RETRO
     FROM TGE_REF_PAC
       WHERE NUMPAC = v_numpac; 
    end if;
    
    if deleting then
      v_type_writer := nvl(:old.type_writer, 'O');
    else
      v_type_writer := nvl(:new.type_writer, 'O');
      -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
      :new.type_writer := null;
    end if;

    if (v_type_writer <> 'N' AND v_type_writer <> 'M') then
      --La colonne PERIODE_INIT ne peut pas être modifiée, elle doit contenir la valeur initiale de la colonne PERIODE (avant tout recalcul).
      IF INSERTING THEN
        :NEW.PERIODE_INIT := :NEW.PERIODE;
      ELSIF UPDATING THEN 
        :NEW.PERIODE_INIT := :OLD.PERIODE_INIT;
      END IF;
    
      if INSERTING or UPDATING then
        BEGIN
          IF NVL(:new.code_ip, :old.code_ip) != 'HP'  AND V_DEB_RETRO IS NOT NULL AND V_DEB_RETRO <= V_PERIODEENCOURS THEN
            v_date_effet    := NVL(:new.date_effet, :old.date_effet);
            V_ORIGINE_CREATE := NVL(:new.ORIGINE_CREATE, :old.ORIGINE_CREATE);
            SELECT COUNT(*) INTO V_IS_T2 
            FROM DIC_ADM_CONTRAT_HISTO 
            WHERE V_ORIGINE_CREATE = 'BATCH' 
            AND NUMPAC = v_numpac 
            AND PAIEZAD = v_paiezad 
            AND ZA996 = 'A' 
            AND v_date_effet BETWEEN DATE_EFF AND DATE_SORTIE_SIT_BO;
            
            IF  V_IS_T2 = 0 THEN 
              SELECT MIN(MOIS_PAIE) 
              INTO v_periode_retro
              FROM TGE_PERIODE_RECUEIL_PAIEZAD
              WHERE numpac = v_numpac
              AND paiezad  = v_paiezad
              AND v_date_effet BETWEEN DEBUT_PERIODE_RECUEIL AND FIN_PERIODE_RECUEIL;
              
              IF v_periode_retro IS NOT NULL THEN
                :new.periode     := TO_DATE(v_periode_retro || 01, 'yyyyMMdd');
              END IF;
            END IF;
          END IF;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            -- Période de recueil non trouvé
            null;
        END;
      END IF;
  
      BEGIN
        SELECT t.pacmat,nvl(t.periode_recyclage,1),CODE_CHRONO
        INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
        from dic_adm_contrat_SITU d, secupacmat t
        where d.numpac = v_numpac
        and d.paiezad  = v_paiezad
        and d.numpac   = t.numpac
        and d.pacmat   = t.pacmat
        and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          null;
      END;
 	    if v_periode_recycl = 3 then
	      raise_application_error(-20001, 'CODERR=GENREC02');
	    elsif v_periode_recycl >= 10 then
	      raise_application_error(-20001, 'CODERR=GENREC01');
	    elsif v_periode_recycl = 1 then
        /** Test de mise en recyclage **/
        v_recycl            := 'N';
        --Période de recueil individuelle
        --select periodeencours into moisPaie from tge_ref_pac where numpac = v_numpac;
        BEGIN
          --Période de recueil individuelle
          SELECT FIN_PERIODE_RECUEIL INTO dateFinRecueil from tge_periode_recueil_paiezad where numpac=v_numpac 
          and MOIS_PAIE=V_PERIODEENCOURS and paiezad=v_paiezad ;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          dateFinRecueil:=null;
        END;
        --Période de recueil génèrique
        if(dateFinRecueil  is null) then  
          if v_old_numpac  !=  v_numpac OR ( v_old_numpac  =  v_numpac AND A520 is null  and A521 is  null and A523  is null) THEN 
            SELECT tablegxp ,
              A520_DONNEE ,
              A521_DONNEE ,
              A523_DONNEE into 
            nomTablegxp,A520,A521,A523
            FROM
            (
            SELECT DISTINCT c.element,
              c.tablegxp,
              c.DONNEEGXP
            FROM tge_ref_mapdo c
            WHERE C.numpac = v_numpac
            AND c.element IN ('A520','A521', 'A523')
            UNION ALL
            SELECT DISTINCT c.element,
              c.tablegxp,
              c.DONNEEGXP
            FROM tge_ref_mapdo c
            WHERE C.numpac                  ='*'
            AND c.element                  IN ('A520','A521', 'A523')
            AND (c.TABLEGXP,c.ELEMENT) NOT IN
            (SELECT a.TABLEGXP,
              a.element
            FROM tge_ref_mapdo a
            WHERE a.numpac = v_numpac
            AND A.ELEMENT IN ('A520','A521', 'A523')
            )
            ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element) IN('A520' AS A520,'A521' AS A521, 'A523' AS A523));
          end if; 
          if( A520 is  not null  and A521 is not null and A523  is not null) then
            requete:='select '||A520|| ','||A521||','||A523||'  from '||nomTablegxp||' d '; 
            requete:=requete || ' where numpac='''||v_numpac||''' and paiezad='''|| v_paiezad  || ''' and pacmat='''||v_pacmat||''''; 
            if( nomTablegxp='DIC_ADM_CONTRAT_HISTO') then
              requete:=requete || ' and sysdate BETWEEN date_eff and date_fin_bo AND rownum=1';
            end if;
            BEGIN
              EXECUTE IMMEDIATE requete into activite,etablissement,categorie;
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              dateFinRecueil:=null;
            END;
          end if;
          if(activite is not null and etablissement is not null and categorie is not null) then
            BEGIN
              select 
                max(to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 37, 8),'DDMMYYYY')) into  dateFinRecueil
              from tge_ref_vrval   
              WHERE numero_de_pac = v_numpac 
              AND SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 19 , 6 ) = to_char(to_date(V_PERIODEENCOURS,'YYYYMM'),'MMYYYY') 
              AND CODE_TABLE = 'LTP'  
              AND IS_BETWEEN_NLS_FRENCH(LPAD(activite,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,1 ,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,3,2),2) )  = 'TRUE' 
              AND IS_BETWEEN_NLS_FRENCH(LPAD(etablissement,5),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,5 ,5),5), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,10,5),5))  = 'TRUE' 
              AND IS_BETWEEN_NLS_FRENCH(LPAD(categorie,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,15,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,17,2),2) )  = 'TRUE' ;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                dateFinRecueil:=null;
            END;
          end if;
        end if;
        if (dateFinRecueil is null) then
          select LAST_DAY( to_date(V_PERIODEENCOURS,'YYYYMM') ) into dateFinRecueil from dual;
        end if;
        IF DELETING THEN
          date_test_recycl := :old.periode;
          date_effet_recycl :=:old.date_effet;
        ELSE
          date_test_recycl := :new.periode;
          IF updating THEN
            date_effet_recycl :=LEAST(:new.date_effet,:old.date_effet);
          ELSE
            date_effet_recycl :=:new.date_effet;
          END IF;
        END IF;
        IF  (NVL(TO_CHAR(date_effet_recycl,'yyyymm'),'000000') > to_char(dateFinRecueil,'YYYYMMDD' ) ) THEN
          date_test_recycl := TO_DATE('20991231','yyyymmdd');
        END IF;
        if (NVL(TO_CHAR(date_effet_recycl,'yyyymm'),'000000') <= to_char(dateFinRecueil,'YYYYMMDD' ) ) then
          if inserting or deleting then
            v_recycl := 'O';
          elsif updating then
            if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
              v_recycl                 := 'O';
            elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
              v_recycl                 := 'O';
            elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
              v_recycl                 := 'O';
            elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
              v_recycl                 := 'O';
            elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
              v_recycl                 := 'O';
            elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
              v_recycl                 := 'O';
            elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
              v_recycl                 := 'O';
            elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
              v_recycl                 := 'O';
            elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
              v_recycl                 := 'O';
            end if;
          end if;
          if v_recycl = 'O' then
            begin
              merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
            when not matched then
              insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
            exception
            when others then
              --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
              --FIXME utiliser la procédure trace_dbms_output()
              NULL;
            end;
          end if;
        end if;
      end if; /** Fin test de mise en recyclage **/
      -- Si TYPE_WRITER = 'R', on bypass la mise en rétro (le code appelant devra le faire lui-même si nécessaire)
      IF v_type_writer <> 'R' AND V_DEB_RETRO IS NOT NULL AND V_DEB_RETRO <= V_PERIODEENCOURS THEN
        /** Test de mise en rétro **/
        v_retro            := 'N';
        if inserting or deleting then
          v_retro := 'O';
        elsif updating then
          -- Les valeurs des colonnes clés ne peuvent pas être nulls 
          if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
            v_retro                 := 'O';
          elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
            v_retro                 := 'O';
          elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
            v_retro                 := 'O';
          elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
            v_retro                 := 'O';
          elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_retro                 := 'O';
          elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
            v_retro                 := 'O';
          elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
            v_retro                 := 'O';
          elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
            v_retro                 := 'O';
          elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_retro                 := 'O';
          end if;
        end if;
        if v_retro = 'O' then
          V_PERIODE := TO_CHAR(NVL(:NEW.PERIODE,:OLD.PERIODE),'YYYYMM');
          TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_INCIDENTS_PAIE');
        END IF;
      END IF; /** Fin test de mise en rétro **/
    end if; /** Fin test v_type_writer <> N et M **/
    v_old_numpac  :=  v_numpac; 
  end if; /** Fin test v_bypass_trigger **/
END BEFORE EACH ROW;
end trg_tge_incidents_paie;
