##
TAG_CHARSET=@€éèç
TAG_IMPORT=5.05.004.R038
##
TAG_CHARSET=@€éèç
##
ALIM_IDX_COMPARE_CONTRAT_HISTO
=SQL IF_PROCEDURE_EXIST=ALIM_IDX_COMPARE_CONTRAT_HISTO=
DROP PROCEDURE ALIM_IDX_COMPARE_CONTRAT_HISTO
##
ALIM_IDX_COMPARE_CONTRAT
=SQL IF_PROCEDURE_EXIST=ALIM_IDX_COMPARE_CONTRAT=
DROP PROCEDURE ALIM_IDX_COMPARE_CONTRAT
##
SYS_VARSYS
==
INSERT INTO SYS_VARSYS SELECT 'SYS', 'CID_REFERENCE_CHIFFREMENT', '', 'Texte', 'NE PAS VALORISER EN PROD !!! CID utilisé pour générer la clé de chiffrement (des données bancaires par exemple). Doit être valorisée avec le CID de prod sur tous les environnements des clients ayant un CID différent en recette interne, recette client...' FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM SYS_VARSYS WHERE MODULE='SYS' AND CODVAR='CID_REFERENCE_CHIFFREMENT')
##
TGE_IMPORT_30
=SQL=
create or replace PROCEDURE TGE_IMPORT_30
(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2 ,
    P_ROLE        IN VARCHAR2 ,
    -- Origine écran
    P_ORIGINE     IN VARCHAR2 ,
    P_VALIDATION  IN VARCHAR2 ,
    P_WITH30      IN VARCHAR2 ,
    P_CODLANG     IN VARCHAR2,
    -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
    P_TYPE_ACTION IN VARCHAR2 ,
    P_DATE_MAJ    IN SYS_TRC_MODIF.DATEMAJ%type )
AS
  w_err   VARCHAR2(2000);
  v_start NUMBER;
  v_stop  NUMBER;
  req CLOB;
  reqvalues CLOB;
  reqInsert CLOB;
  dateMaj SYS_TRC_MODIF.datemaj%type;
BEGIN
  v_start       := DBMS_UTILITY.GET_TIME;
  IF P_DATE_MAJ IS NULL THEN
    SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
  ELSE
    dateMaj:= P_DATE_MAJ;
  END IF;
  IF ( P_WITH30 =1) THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 30');
      TGE_CONTROLE_30 (p_login, p_date_import, NULL, p_codlang, P_TYPE_ACTION);
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  '||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_30 - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
  END IF;
  IF p_validation = 1 THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion TGE_ELEMENTS_PAIE');
      INSERT
      INTO TGE_ELEMENTS_PAIE
        (
          NUMPAC ,
          PAIEZAD ,
          PERIODE ,
          TYPE_TRAITEMENT ,
          CODE_ELEMENT ,
          INDICATIF ,
          ORIGINE ,
          SENS ,
          VALEUR ,
          DERNIER_CODE_OPE ,
          LOGIN_MAJ ,
          DATE_MAJ ,
          CLE_IMPORT ,
          IDPACMAT,
          type_writer,
          CODE_REMPLACEMENT,
          DATE_EFFET,
         ACTION_RETRO,
         ACTION_RETRO_DATE
        )
      SELECT E.NUMPAC ,
        PAIEZAD ,
        PERIODE ,
        TYPE_TRAITEMENT ,
        CODE_ELEMENT ,
        UPPER (NVL(INDICATIF,'*')) AS INDICATIF,
        ORIGINE ,
        SENS ,
        VALEUR ,
        'C' ,
        p_login ,
        TO_CHAR (sysdate, 'YYYYMMDDHH24MI') ,
        CASE
          WHEN 'VI' = P_TYPE_ACTION
          THEN P_LOGIN
            ||'#'
            ||P_DATE_IMPORT
            ||'#'
            ||NUMLIGNE
          ELSE NULL
        END AS CLE_IMPORT,
        CASE
          WHEN E.NUMPAC IS NOT NULL
          AND PACMAT    IS NOT NULL
          THEN RPAD(E.NUMPAC,6)
            || PACMAT
          ELSE ' '
        END AS IDPACMAT,
        CASE
          WHEN (SELECT O.MODE_T2
              ||'#'
              ||O.ENVOI_MODE_R
            FROM TGE_REF_ORIGINE_GTA O
            WHERE O.NUMPAC     = E.NUMPAC
            AND O.CODE_ORIGINE = E.ORIGINE) = 'R#N'
          THEN 'N'
          ELSE NULL
        END AS TYPE_WRITER,
        NVL(E.CODE_REMPLACEMENT,'*') AS CODE_REMPLACEMENT,
        TO_DATE(E.DATE_EFFET,'YYYYMMDD') AS DATE_EFFET,
        -- Gestion Action Retro : pour ne pas bousiller les perfs, on va positionner une valeur '*' dans actionRetro et null dans actionRetroDate
        -- et ensuite avec une requête d'update mettre à jour la valeur de actionRetro et actionRetroDate.
        -- On évite ainsi de faire 2 sous-select sur TGE_REF_PAC ou une jointure globale pour récupérer TGE_REF_PAC.PERIODEENCOURS
        case
        	when  E.PERIODE < (select PAC.PERIODEENCOURS from TGE_REF_PAC PAC where PAC.NUMPAC = E.NUMPAC)
         	then '*'
         	else NULL
        end as ACTION_RETRO,
        NULL as ACTION_RETRO_DATE
                             
      FROM TGE_IMPORT_ELEMENTS E
      WHERE LOGIN           =P_LOGIN
      AND CODE_ELEMENT NOT IN ('B690','B691')
      AND DATE_IMPORT       = p_date_import
      AND ((ERREURS        IS NULL
      AND STATUT            = 'TRAIT')
      OR (ERREURS          IS NOT NULL
      AND STATUT            = 'TRANS'));
      
      -- Gestion Action Retro : si création d'une ligne rétro, on sauvegarde qu'il s'agit d'une création comme première action et la date à laquelle elle a eu lieu
      update TGE_ELEMENTS_PAIE set 
      	ACTION_RETRO = 'C',
      	ACTION_RETRO_DATE = DATE_MAJ
      where ACTION_RETRO = '*';
      
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  ' ||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidElement - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH' or SQLCODE=-20001) THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
    
    IF P_TYPE_ACTION = 'VI' THEN
      --- Gestion de la trace : on enregistre une trace généréale lors d'un import car on ne peut pas gérer de trace individuelle 
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_ELEMENTS_PAIE');
      SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPORT_ELEMENT_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Batch/Web 30','C',NULL,NULL,NULL,NULL);
    ELSIF P_TYPE_ACTION = 'MP' THEN
    	--- Gestion de la trace : on enregistre une trace généréale lors d'une saisie depuis la Market Place car on ne peut pas gérer de trace individuelle 
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_ELEMENTS_PAIE');
      SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPORT_ELEMENT_PAIE_MP', 'LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Market Place 30','C',NULL,NULL,NULL,NULL);
    END IF;
    
    -- Mise à jour de la column RETRO_GC de la table TGE_PERIODE_RECUEIL_PAIEZAD
    -- si la "full" rétroactivité n'est pas activé sur le pac
    UPDATE TGE_PERIODE_RECUEIL_PAIEZAD R
    SET R.RETRO_GC =
      (SELECT E.VALEUR
      FROM TGE_ELEMENTS_PAIE E
      WHERE R.NUMPAC     = E.NUMPAC
      AND R.PAIEZAD      = E.PAIEZAD
      AND R.MOIS_PAIE    = E.PERIODE
      AND E.CODE_ELEMENT = 'WG96'
      )
    WHERE (R.NUMPAC, R.PAIEZAD, R.MOIS_PAIE) IN
      (SELECT e2.numpac,
        e2.paiezad,
        e2.periode
      FROM TGE_IMPORT_ELEMENTS E2
      WHERE e2.login     = P_LOGIN
      AND e2.date_import = p_date_import
      AND ((e2.ERREURS  IS NULL
      AND e2.STATUT     IN ('TRAIT','FIN'))
      OR (e2.ERREURS    IS NOT NULL
      AND e2.STATUT      = 'TRANS'))
      AND EXISTS (SELECT 'ACTIVE_RETRO_GC'
	 	FROM TGE_REF_PAC
	 	WHERE NUMPAC = e2.NUMPAC
	 		AND (DEB_RETRO IS NULL OR DEB_RETRO > e2.periode)
	 	)
      );
    ----------------------------------------------------------------------------
    
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPORT_ELEMENTS');
    UPDATE TGE_IMPORT_ELEMENTS
    SET ERREURS           ='',
      STATUT              ='FIN'
    WHERE LOGIN           = P_LOGIN
    AND DATE_IMPORT       = p_date_import
    AND ((ERREURS        IS NULL
    AND STATUT            = 'TRAIT')
    OR (ERREURS          IS NOT NULL
    AND STATUT            = 'TRANS'))
    AND CODE_ELEMENT NOT IN ('B690','B690');
    -- Suppression des lignes dans dans DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début DELETE FROM dic_tge_imputations_perm');
    DELETE
    FROM DIC_TGE_IMPUTATIONS_PERM A
    WHERE (A.NUMPAC,A.PAIEZAD) IN
      (SELECT B.NUMPAC,
        B.paiezad
      FROM TGE_IMPORT_ELEMENTS B
      WHERE B.CODE_ELEMENT >='B690'
      AND B.CODE_ELEMENT   <='B691'
      AND B.CODE_ELEMENT   IS NOT NULL
      AND B.ERREURS        IS NULL
      AND B.DATE_IMPORT     = p_date_import
      AND B.LOGIN           = P_LOGIN
      GROUP BY LOGIN,
        NUMPAC,
        PAIEZAD,
        DATE_IMPORT,
        INDICATIF
      HAVING COUNT(DISTINCT B.CODE_ELEMENT ) >1
      ) ;
    -- Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE');
    FOR b_numpac IN
    (SELECT DISTINCT numpac
    FROM TGE_IMPORT_ELEMENTS
    WHERE LOGIN       = P_LOGIN
    AND DATE_IMPORT   = p_date_import
    AND ERREURS      IS NULL
    AND code_ELEMENT IN ('B690','B691')
    )
    LOOP
      req      :='insert into DIC_TGE_IMPUTATIONS_PERM p(numpac,paiezad,MATRIC,pacmat';
      reqInsert:='select numpac,paiezad,MATRICULE,pacmat,';
      reqvalues:= ' from (select numpac,paiezad,MATRICULE,pacmat,code_element||''#''||indicatif as el, valeur';
      reqvalues:= reqvalues|| ' from TGE_IMPORT_ELEMENTS b where login='''||p_login||''' and date_import='''||P_DATE_IMPORT||''' and code_element in (''B690'',''B691'')  )';


      reqvalues:= reqvalues|| '  pivot (max(valeur)   for(el) in (';
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion DIC_TGE_IMPUTATIONS_PERM');
      FOR cur IN
      (SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     =b_numpac.numpac
      UNION
      SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     ='*'
      )
      LOOP
        req           :=req||','||cur.DONNEEGXP;
        reqvalues     := reqvalues||''''||cur.element||'#'||cur.occurence ||''' as '|| cur.DONNEEGXP||',';
        IF cur.element ='B690' THEN
          reqInsert   := reqInsert||cur.DONNEEGXP ||',';
        ELSE
          reqInsert:= reqInsert||' IS_NUMBER(replace('||cur.DONNEEGXP ||','','',''.'')) as '||cur.DONNEEGXP ||' ,';
        END IF;
        IF P_LOGIN = 'BATCH' THEN
          SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPUTATION_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE||'&ELEMENT='||cur.element||'&DONNEEGXP='||cur.DONNEEGXP, 'Import Batch 30 B690/B691','C',NULL,NULL,NULL,NULL);
        END IF;
      END LOOP;
      reqvalues:= SUBSTR(reqvalues,1,LENGTH(reqvalues)-1)||'))  ';
      reqvalues:= reqvalues|| ' b where   exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||'''  and c.date_import='''||P_DATE_IMPORT||'''  and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B690''   and ERREURs is  null)
      and  exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||''' and c.date_import='''||P_DATE_IMPORT||''' and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B691''  and ERREURs is  null) ';
      reqInsert:= SUBSTR(reqInsert,1,LENGTH(reqInsert)-1);
      req      :=req||')  ';
      req      :=req||reqInsert|| reqvalues;
       EXECUTE_IMMEDIATE_STRING( req,0);
    END LOOP;
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début UPDATE TGE_IMPORT_LISTE');
    UPDATE TGE_IMPORT_LISTE
    SET NBLIGNES_ERR =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NOT NULL
      ),
      NBLIGNES_IMP =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NULL
      ),
      STATUT        ='TRANS'
    WHERE LOGIN     = P_LOGIN
    AND DATE_IMPORT = p_date_import
    AND TYPE        = 2;
    -- Inscription en recyclage
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Inscription en recyclage');
  END IF;
END TGE_IMPORT_30;
##
SYS_DEF_ERREURS
==
DELETE FROM SYS_DEF_ERREURS WHERE CODERR = 'STD00112' AND CODLANG = 'fr_fr' AND NIV_DEFINITION = 0 AND CODMOD ='STD'
##
SYS_DEF_ERREURS
==
INSERT INTO SYS_DEF_ERREURS(CODERR, CODMOD, CODLANG, NIV_DEFINITION, LIBERR, TYPERR) VALUES('STD00112', 'STD', 'fr_fr', 0, 'Vous ne pouvez pas exporter plus de #1 ligne(s)', 1)
##
TGE_IMPORT_30
=SQL=
create or replace PROCEDURE TGE_IMPORT_30
(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2 ,
    P_ROLE        IN VARCHAR2 ,
    -- Origine écran
    P_ORIGINE     IN VARCHAR2 ,
    P_VALIDATION  IN VARCHAR2 ,
    P_WITH30      IN VARCHAR2 ,
    P_CODLANG     IN VARCHAR2,
    -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
    P_TYPE_ACTION IN VARCHAR2 ,
    P_DATE_MAJ    IN SYS_TRC_MODIF.DATEMAJ%type )
AS
  w_err   VARCHAR2(2000);
  v_start NUMBER;
  v_stop  NUMBER;
  req CLOB;
  reqvalues CLOB;
  reqInsert CLOB;
  dateMaj SYS_TRC_MODIF.datemaj%type;
BEGIN
  v_start       := DBMS_UTILITY.GET_TIME;
  IF P_DATE_MAJ IS NULL THEN
    SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
  ELSE
    dateMaj:= P_DATE_MAJ;
  END IF;
  IF ( P_WITH30 =1) THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 30');
      TGE_CONTROLE_30 (p_login, p_date_import, NULL, p_codlang, P_TYPE_ACTION);
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  '||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_30 - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
  END IF;
  IF p_validation = 1 THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion TGE_ELEMENTS_PAIE');
      INSERT
      INTO TGE_ELEMENTS_PAIE
        (
          NUMPAC ,
          PAIEZAD ,
          PERIODE ,
          TYPE_TRAITEMENT ,
          CODE_ELEMENT ,
          INDICATIF ,
          ORIGINE ,
          SENS ,
          VALEUR ,
          DERNIER_CODE_OPE ,
          LOGIN_MAJ ,
          DATE_MAJ ,
          CLE_IMPORT ,
          IDPACMAT,
          type_writer,
          CODE_REMPLACEMENT,
          DATE_EFFET,
         ACTION_RETRO,
         ACTION_RETRO_DATE
        )
      SELECT E.NUMPAC ,
        PAIEZAD ,
        PERIODE ,
        TYPE_TRAITEMENT ,
        CODE_ELEMENT ,
        UPPER (NVL(INDICATIF,'*')) AS INDICATIF,
        ORIGINE ,
        SENS ,
        VALEUR ,
        'C' ,
        p_login ,
        TO_CHAR (sysdate, 'YYYYMMDDHH24MI') ,
        CASE
          WHEN 'VI' = P_TYPE_ACTION
          THEN P_LOGIN
            ||'#'
            ||P_DATE_IMPORT
            ||'#'
            ||NUMLIGNE
          ELSE NULL
        END AS CLE_IMPORT,
        CASE
          WHEN E.NUMPAC IS NOT NULL
          AND PACMAT    IS NOT NULL
          THEN RPAD(E.NUMPAC,6)
            || PACMAT
          ELSE ' '
        END AS IDPACMAT,
        CASE
          WHEN (SELECT O.MODE_T2
              ||'#'
              ||O.ENVOI_MODE_R
            FROM TGE_REF_ORIGINE_GTA O
            WHERE O.NUMPAC     = E.NUMPAC
            AND O.CODE_ORIGINE = E.ORIGINE) = 'R#N'
          THEN 'N'
          ELSE NULL
        END AS TYPE_WRITER,
        NVL(E.CODE_REMPLACEMENT,'*') AS CODE_REMPLACEMENT,
        TO_DATE(E.DATE_EFFET,'YYYYMMDD') AS DATE_EFFET,
        -- Gestion Action Retro : pour ne pas bousiller les perfs, on va positionner une valeur '*' dans actionRetro et null dans actionRetroDate
        -- et ensuite avec une requête d'update mettre à jour la valeur de actionRetro et actionRetroDate.
        -- On évite ainsi de faire 2 sous-select sur TGE_REF_PAC ou une jointure globale pour récupérer TGE_REF_PAC.PERIODEENCOURS
        case
        	when  E.PERIODE < (select PAC.PERIODEENCOURS from TGE_REF_PAC PAC where PAC.NUMPAC = E.NUMPAC)
         	then '*'
         	else NULL
        end as ACTION_RETRO,
        NULL as ACTION_RETRO_DATE
                             
      FROM TGE_IMPORT_ELEMENTS E
      WHERE LOGIN           =P_LOGIN
      AND CODE_ELEMENT NOT IN ('B690','B691')
      AND DATE_IMPORT       = p_date_import
      AND ((ERREURS        IS NULL
      AND STATUT            = 'TRAIT')
      OR (ERREURS          IS NOT NULL
      AND STATUT            = 'TRANS'));
      
      -- Gestion Action Retro : si création d'une ligne rétro, on sauvegarde qu'il s'agit d'une création comme première action et la date à laquelle elle a eu lieu
      update TGE_ELEMENTS_PAIE set 
      	ACTION_RETRO = 'C',
      	ACTION_RETRO_DATE = DATE_MAJ
      where ACTION_RETRO = '*';
      
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  ' ||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidElement - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH' or SQLCODE=-20001) THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
    
    IF P_TYPE_ACTION = 'VI' THEN
      --- Gestion de la trace : on enregistre une trace généréale lors d'un import car on ne peut pas gérer de trace individuelle 
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_ELEMENTS_PAIE');
      SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPORT_ELEMENT_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Batch/Web 30','C',NULL,NULL,NULL,NULL);
    ELSIF P_TYPE_ACTION = 'MP' THEN
    	--- Gestion de la trace : on enregistre une trace généréale lors d'une saisie depuis la Market Place car on ne peut pas gérer de trace individuelle 
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_ELEMENTS_PAIE');
      SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPORT_ELEMENT_PAIE_MP', 'LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Market Place 30','C',NULL,NULL,NULL,NULL);
    END IF;
    
    -- Mise à jour de la column RETRO_GC de la table TGE_PERIODE_RECUEIL_PAIEZAD
    -- si la "full" rétroactivité n'est pas activé sur le pac
    UPDATE TGE_PERIODE_RECUEIL_PAIEZAD R
    SET R.RETRO_GC =
      (SELECT E.VALEUR
      FROM TGE_ELEMENTS_PAIE E
      WHERE R.NUMPAC     = E.NUMPAC
      AND R.PAIEZAD      = E.PAIEZAD
      AND R.MOIS_PAIE    = E.PERIODE
      AND E.CODE_ELEMENT = 'WG96'
      )
    WHERE (R.NUMPAC, R.PAIEZAD, R.MOIS_PAIE) IN
      (SELECT e2.numpac,
        e2.paiezad,
        e2.periode
      FROM TGE_IMPORT_ELEMENTS E2
      WHERE e2.login     = P_LOGIN
      AND e2.date_import = p_date_import
      AND ((e2.ERREURS  IS NULL
      AND e2.STATUT     IN ('TRAIT','FIN'))
      OR (e2.ERREURS    IS NOT NULL
      AND e2.STATUT      = 'TRANS'))
      AND EXISTS (SELECT 'ACTIVE_RETRO_GC'
	 	FROM TGE_REF_PAC
	 	WHERE NUMPAC = e2.NUMPAC
	 		AND (DEB_RETRO IS NULL OR DEB_RETRO > e2.periode)
	 	)
      );
    ----------------------------------------------------------------------------
    
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPORT_ELEMENTS');
    UPDATE TGE_IMPORT_ELEMENTS
    SET ERREURS           ='',
      STATUT              ='FIN'
    WHERE LOGIN           = P_LOGIN
    AND DATE_IMPORT       = p_date_import
    AND ((ERREURS        IS NULL
    AND STATUT            = 'TRAIT')
    OR (ERREURS          IS NOT NULL
    AND STATUT            = 'TRANS'))
    AND CODE_ELEMENT NOT IN ('B690','B690');
    -- Suppression des lignes dans dans DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début DELETE FROM dic_tge_imputations_perm');
    DELETE
    FROM DIC_TGE_IMPUTATIONS_PERM A
    WHERE (A.NUMPAC,A.PAIEZAD) IN
      (SELECT B.NUMPAC,
        B.paiezad
      FROM TGE_IMPORT_ELEMENTS B
      WHERE B.CODE_ELEMENT >='B690'
      AND B.CODE_ELEMENT   <='B691'
      AND B.CODE_ELEMENT   IS NOT NULL
      AND B.ERREURS        IS NULL
      AND B.DATE_IMPORT     = p_date_import
      AND B.LOGIN           = P_LOGIN
      GROUP BY LOGIN,
        NUMPAC,
        PAIEZAD,
        DATE_IMPORT,
        INDICATIF
      HAVING COUNT(DISTINCT B.CODE_ELEMENT ) >1
      ) ;
    -- Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE');
    FOR b_numpac IN
    (SELECT DISTINCT numpac
    FROM TGE_IMPORT_ELEMENTS
    WHERE LOGIN       = P_LOGIN
    AND DATE_IMPORT   = p_date_import
    AND ERREURS      IS NULL
    AND code_ELEMENT IN ('B690','B691')
    )
    LOOP
      req      :='insert into DIC_TGE_IMPUTATIONS_PERM p(numpac,paiezad,MATRIC,pacmat';
      reqInsert:='select numpac,paiezad,MATRICULE,pacmat,';
      reqvalues:= ' from (select numpac,paiezad,MATRICULE,pacmat,code_element||''#''||indicatif as el, valeur';
      reqvalues:= reqvalues|| ' from TGE_IMPORT_ELEMENTS b where login='''||p_login||''' and date_import='''||P_DATE_IMPORT||''' and code_element in (''B690'',''B691'')  )';


      reqvalues:= reqvalues|| '  pivot (max(valeur)   for(el) in (';
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion DIC_TGE_IMPUTATIONS_PERM');
      FOR cur IN
      (SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     =b_numpac.numpac
      UNION
      SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     ='*'
      )
      LOOP
        req           :=req||','||cur.DONNEEGXP;
        reqvalues     := reqvalues||''''||cur.element||'#'||cur.occurence ||''' as '|| cur.DONNEEGXP||',';
        IF cur.element ='B690' THEN
          reqInsert   := reqInsert||cur.DONNEEGXP ||',';
        ELSE
          reqInsert:= reqInsert||' IS_NUMBER(replace('||cur.DONNEEGXP ||','','',''.'')) as '||cur.DONNEEGXP ||' ,';
        END IF;
        IF P_LOGIN = 'BATCH' THEN
          SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPUTATION_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE||'&ELEMENT='||cur.element||'&DONNEEGXP='||cur.DONNEEGXP, 'Import Batch 30 B690/B691','C',NULL,NULL,NULL,NULL);
        END IF;
      END LOOP;
      reqvalues:= SUBSTR(reqvalues,1,LENGTH(reqvalues)-1)||'))  ';
      reqvalues:= reqvalues|| ' b where   exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||'''  and c.date_import='''||P_DATE_IMPORT||'''  and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B690''   and ERREURs is  null)
      and  exists (select 1 from TGE_IMPORT_ELEMENTS c where c.login='''||p_login||''' and c.date_import='''||P_DATE_IMPORT||''' and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B691''  and ERREURs is  null) ';
      reqInsert:= SUBSTR(reqInsert,1,LENGTH(reqInsert)-1);
      req      :=req||')  ';
      req      :=req||reqInsert|| reqvalues;
       EXECUTE_IMMEDIATE_STRING( req,0);
    END LOOP;
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début UPDATE TGE_IMPORT_LISTE');
    UPDATE TGE_IMPORT_LISTE
    SET NBLIGNES_ERR =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NOT NULL
      ),
      NBLIGNES_IMP =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NULL
      ),
      STATUT        ='TRANS'
    WHERE LOGIN     = P_LOGIN
    AND DATE_IMPORT = p_date_import
    AND TYPE        = 2;
    -- Inscription en recyclage
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Inscription en recyclage');
  END IF;
END TGE_IMPORT_30;
##
SYS_DEF_ERREURS
==
DELETE FROM SYS_DEF_ERREURS WHERE CODERR = 'STD00112' AND CODLANG = 'fr_fr' AND NIV_DEFINITION = 0 AND CODMOD ='STD'
##
SYS_DEF_ERREURS
==
INSERT INTO SYS_DEF_ERREURS(CODERR, CODMOD, CODLANG, NIV_DEFINITION, LIBERR, TYPERR) VALUES('STD00112', 'STD', 'fr_fr', 0, 'Vous ne pouvez pas exporter plus de #1 ligne(s)', 1)
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_HISTO_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_HISTO_AFTER_STMNT RETURN VARCHAR2 AS 
BEGIN
  RETURN '
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- Insère dans la table temporaire les NUMPAC/PACMAT/MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''CONTRAT_HISTO UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING (''INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_CONTRAT(''DO_MAJ'', 0, 1, 0);
    DELETE FROM SECUPACMAT_TMP_CONTRAT;
    IF INSERTING THEN
      v_actionIdx := ''I'';
    ELSIF UPDATING THEN
      v_actionIdx := ''U'';
    ELSIF DELETING THEN
      v_actionIdx := ''D'';
    END IF;
    DBMS_JOB.SUBMIT(v_jobIdx , ''BEGIN NULL; END;'' , sysdate+1);
 	DBMS_JOB.WHAT(v_jobIdx , ''ALIM_IDX.COMPARE_CONTRAT_HISTO_JOB(''||v_jobIdx||'', ''''''||v_actionIdx||'''''');'');
 	DBMS_JOB.NEXT_DATE(v_jobIdx ,  sysdate-1);
    INSERT INTO DIC_IDX_JOB_KEYS SELECT v_jobIdx, T.* FROM TABLE(v_cles_idx_contrat) T;
    IF INSERTING OR UPDATING THEN
      INSERT INTO DIC_IDX_JOB_OLD_DATAS VALUES (v_jobIdx, ANYDATA.CONVERTCOLLECTION(GET_DACH_MULTI_HORS_TRANSAC(v_cles_idx_contrat)));
    END IF;
  END IF;
  FOR i IN 1..paiezadTab.count
  LOOP
    TGE_ALIM_PERIODE_INDIV(0, numpacTab(i), periodeTab(i), paiezadTab(i));
  END LOOP ;
IF in_calc_hp.exists(''P_NUMPAC'') THEN
  CALC_HP.PRINCIPAL(
    in_calc_hp(''P_NUMPAC''),
    in_calc_hp(''P_PACMAT''),
    in_calc_hp(''P_PAIEZAD''),
    TO_NUMBER(in_calc_hp(''P_NUMCNT'')),
    in_calc_hp(''P_DATE_EFF''),
    in_calc_hp(''P_DATE_SORTIE_SIT_BO''),
    in_calc_hp(''P_LOGIN'') , 
    in_calc_hp(''p_isDeleting'') 
    
  );
 END IF;
  -- maj secupacmat.PRESENCE_FICHIER
  indexTabPresFicPacmat := tabPresenceFichierPacmat.FIRST;
  WHILE indexTabPresFicPacmat IS NOT NULL LOOP
    R_PRESENT_FICHIER_PAIE(tabPresenceFichierPacmat(indexTabPresFicPacmat).NUMPAC,tabPresenceFichierPacmat(indexTabPresFicPacmat).PACMAT);
    indexTabPresFicPacmat := tabPresenceFichierPacmat.NEXT(indexTabPresFicPacmat);
  end loop;
';
END TRG_CONTRAT_HISTO_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_HISTO_AFTER_ROW
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_HISTO_AFTER_ROW
  RETURN CLOB
AS
  v_retour CLOB;
  v_prec_donneegxp VARCHAR2(100);
  CURSOR cur_mapdo
  IS
    SELECT
      NUMPAC,
      ELEMENT,
      DONNEEGXP
    FROM
      TGE_REF_MAPDO
    WHERE
      ELEMENT IN
      (
        SELECT
          'A301'
        FROM
          dual
      UNION ALL
      SELECT
        'A302'
      FROM
        dual
      UNION
      SELECT
        nom_elt
      FROM
        tge_map_arg_elt
      WHERE
        code_table = 'LTP'
      )
    ORDER BY
      ELEMENT,
      NUMPAC DESC;
    lig_mapdo cur_mapdo%rowtype;
    lig_mapdo_prec cur_mapdo%rowtype := NULL;
  BEGIN
    v_retour :=
    ' 
v_numpac := NVL(:NEW.NUMPAC,:OLD.NUMPAC); 

v_pacmat :=NVL(:NEW.PACMAT,:OLD.PACMAT);
v_paiezad := NVL(:NEW.paiezad,:OLD.paiezad); 
v_periode := TO_CHAR(LEAST(NVL(:NEW.date_eff,:OLD.date_eff), NVL(:OLD.date_eff,:NEW.date_eff)), ''YYYYMM''); 
-- On ne traite que l''UPDATE, et on n''ajoute chaque couple NUMPAC/PAIEZAD qu''une seule fois 
IF NOT tabTrtPeriodesIndividuelles.exists(v_numpac||v_paiezad) THEN 
tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := ''O''; 
IF INSERTING OR DELETING THEN 
alimPeriodesIndiv := TRUE; 
ELSE 
alimPeriodesIndiv := FALSE; '
    ;
    OPEN cur_mapdo;
    LOOP
      FETCH
        cur_mapdo
      INTO
        lig_mapdo ;
        
      IF lig_mapdo_prec.element IS NOT NULL AND
        (
          cur_mapdo%NOTFOUND OR NOT lig_mapdo_prec.element=lig_mapdo.element
        )
        THEN
        -- La dernière ligne traitée était la dernière ligne de mapping pour l'
        -- élément précédent
        -- Si c'était le PAC *, c'est le cas par défaut (ELSE), sinon, on
        -- continue de tester le PAC
       
        IF lig_mapdo_prec.numpac='*' THEN
          v_retour             := v_retour||' 
ELSE ';
        ELSE
          v_retour := v_retour||' 
ELSIF v_numpac='''||lig_mapdo_prec.numpac||
          ''' THEN ';
        END IF;
        v_retour := v_retour||' 
tabValToCompare(''old'||lig_mapdo_prec.element
        ||''') := '||v_prec_donneegxp||'; 
tabValToCompare(''new'||
        lig_mapdo_prec.element||''') := '||REPLACE(v_prec_donneegxp,':old',':new')||'; 
END IF; ';
        IF NOT lig_mapdo_prec.numpac='*' THEN
          -- Pas de ligne avec un PAC * : cas par défaut --> NULL
          v_retour := v_retour||' 
ELSE 
tabValToCompare(''old'||
          lig_mapdo_prec.element||''') := NULL; 
tabValToCompare(''new'||
          lig_mapdo_prec.element||''') := NULL; 
END IF; ';
        END IF;
      END IF;
      EXIT
    WHEN cur_mapdo%NOTFOUND;
    
       SELECT
          ':old.'
          ||LISTAGG(donneegxp,'||:old.') WITHIN GROUP (
        ORDER BY
          donneegxp)
        INTO
          v_prec_donneegxp
        FROM
          (
            SELECT
              numpac,
              donneegxp
            FROM
              TABLE (get_gxp_trt_particulier_datas('DIC_ADM_CONTRAT_HISTO',lig_mapdo.element))
            UNION
            SELECT
              lig_mapdo.numpac,
              lig_mapdo.donneegxp
            FROM
              dual
          );  
    
    
      -- C'est la toute première ligne, ou bien la ligne précédente était la
      -- dernière ligne de mapping pour l'élément précédent
      -- On recommence un nouveau bloc IF
      IF lig_mapdo_prec.element IS NULL OR NOT lig_mapdo_prec.element=
        lig_mapdo.element THEN
        v_retour := v_retour||' 
tabValToCompare(''old'||lig_mapdo.element||
        ''') := NULL; 
tabValToCompare(''new'||lig_mapdo.element||
        ''') := NULL; 
IF v_numpac IS NULL THEN NULL; ';
      END IF;
      IF NOT lig_mapdo.numpac='*' THEN
        v_retour            := v_retour||' 
ELSIF v_numpac='''||
        lig_mapdo.numpac||''' THEN 
tabValToCompare(''old'||lig_mapdo.element||
        ''') := '||v_prec_donneegxp||'; 
tabValToCompare(''new'||
        lig_mapdo.element||''') := '||REPLACE(v_prec_donneegxp,':old',':new')||';  ';
      END IF;
      lig_mapdo_prec := lig_mapdo;
    END LOOP;
    CLOSE cur_mapdo;
    IF lig_mapdo_prec.element IS NOT NULL THEN
      -- On est passé au moins une fois dans la boucle
      lig_mapdo_prec := NULL;
      OPEN cur_mapdo;
      LOOP
        FETCH
          cur_mapdo
        INTO
          lig_mapdo ;
        EXIT
      WHEN cur_mapdo%NOTFOUND;
        -- C'est la toute première ligne, ou bien la ligne précédente était la
        -- dernière ligne de mapping pour l'élément précédent
        IF lig_mapdo_prec.element IS NULL OR NOT lig_mapdo_prec.element=
          lig_mapdo.element THEN
          v_retour := v_retour||' 
IF tabValToCompare(''new'||lig_mapdo.element
          ||''')<>tabValToCompare(''old'||lig_mapdo.element||
          ''') OR (tabValToCompare(''new'||lig_mapdo.element||
          ''') IS NOT NULL AND tabValToCompare(''old'||lig_mapdo.element||
          ''') IS NULL) OR (tabValToCompare(''new'||lig_mapdo.element||
          ''') IS NULL AND tabValToCompare(''old'||lig_mapdo.element||
          ''') IS NOT NULL) THEN 
alimPeriodesIndiv := TRUE; 
END IF; ';
        END IF;
        lig_mapdo_prec := lig_mapdo;
      END LOOP;
      CLOSE cur_mapdo;
    END IF;
    v_retour := v_retour||
    ' 
END IF; 
IF alimPeriodesIndiv THEN 
-- Modification de la date de début ou de fin de suspension : on met à jour la table des périodes individuelles 
idxPeriodesIndiv := null; 
FOR i IN 1..paiezadTab.count LOOP 
IF numpacTab(i) = v_numpac AND paiezadTab(i) = v_paiezad THEN 
idxPeriodesIndiv := i; 
EXIT; 
END IF; 
end LOOP ;  

IF idxPeriodesIndiv IS NOT NULL THEN 
periodeTab(idxPeriodesIndiv) := LEAST(periodeTab(idxPeriodesIndiv), v_periode); 
ELSE 
paiezadTab.EXTEND ; 
paiezadTab(paiezadTab.LAST) := v_paiezad; 
numpacTab.EXTEND ; 
numpacTab(numpacTab.LAST) := v_numpac; 
periodeTab.EXTEND ; 
periodeTab(periodeTab.LAST) := v_periode; 
END IF; 
END IF; 
END IF; 
IF NOT tabPresenceFichierPacmat.exists(v_numpac||v_pacmat) THEN
  tabPresenceFichierPacmat(v_numpac||v_pacmat).NUMPAC := v_numpac; 
  tabPresenceFichierPacmat(v_numpac||v_pacmat).PACMAT := v_pacmat;
END IF; 
IF  v_lanceRecalculHp THEN 
in_calc_hp(''P_NUMPAC''):=NVL(:NEW.NUMPAC,:OLD.NUMPAC); 
in_calc_hp(''P_PACMAT''):=NVL(:NEW.PACMAT,:OLD.PACMAT); 
in_calc_hp(''P_PAIEZAD''):=NVL(:NEW.PAIEZAD,:OLD.PAIEZAD); 
in_calc_hp(''P_NUMCNT''):=TO_CHAR(NVL(:NEW.NUMCNT,:OLD.NUMCNT)); 
in_calc_hp(''P_DATE_EFF''):=TO_CHAR(NVL(:NEW.DATE_EFF,:OLD.DATE_EFF),''DD/MM/YYYY''); 
in_calc_hp(''P_DATE_SORTIE_SIT_BO''):=TO_CHAR(NVL(:NEW.date_sortie_sit_bo,:OLD.date_sortie_sit_bo),''DD/MM/YYYY''); 
in_calc_hp(''P_LOGIN'') :=''TRIGGER''; 
in_calc_hp(''p_isDeleting'') :=v_isDeleting;
END IF; 
'
    ;
    RETURN v_retour;
  END TRG_CONTRAT_HISTO_AFTER_ROW;
##
TAG_CHARSET=@€éèç
##
SECUPACMAT
=SQL IFNOTEXIST=SECUPACMAT=PRESENT_FICHIER_PAIE=
ALTER TABLE SECUPACMAT ADD PRESENT_FICHIER_PAIE VARCHAR2(1)
##
LOAD_PRESENT_FICHIER_PAIE
=SQL=
DECLARE
BEGIN
  FOR current_numpac IN (select NUMPAC from TGE_REF_PAC )
  LOOP
    R_PRESENT_FICHIER_PAIE(current_numpac.NUMPAC, null);
  END LOOP;
END;
##
TAG_CHARSET=@€éèç
##
R_PRESENT_FICHIER_PAIE
=SQL=
create or replace PROCEDURE R_PRESENT_FICHIER_PAIE( NUMPAC_TRAITEMENT IN SECUPACMAT.NUMPAC%Type , PACMAT_TRAITEMENT IN SECUPACMAT.PACMAT%Type ) IS 
PERIODEENCOURS_TRAITEMENT TGE_REF_PAC.PERIODEENCOURS%type;
BEGIN
-- récupère la periode en cours du pac
  BEGIN 
   SELECT PERIODEENCOURS into PERIODEENCOURS_TRAITEMENT from TGE_REF_PAC where NUMPAC=NUMPAC_TRAITEMENT;
   EXCEPTION
   WHEN NO_DATA_FOUND then
    RETURN;
  END;
--fait le merge ds secupacmat
MERGE INTO SECUPACMAT A
USING (
  select NUMPAC,PACMAT, case when EXISTS (
    WITH table_dates_eff (pacmat,paiezad,date_eff) AS (
      SELECT DISTINCT dach2.pacmat,dach2.paiezad,MAX(date_eff) OVER(PARTITION BY dach2.pacmat,dach2.paiezad)
      FROM dic_adm_contrat_histo dach2
      WHERE
        dach2.numpac = NUMPAC_TRAITEMENT 
        AND dach2.pacmat = NVL(PACMAT_TRAITEMENT,dach2.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
        AND dach2.date_eff <= last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') )
        AND dach2.date_fin_bo >= add_months( (TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') ),-16)
    )
    SELECT 1
    FROM dic_tge_respaie_unique dtru,dic_adm_contrat_histo dach,table_dates_eff t
    WHERE
      dach.numpac = NUMPAC_TRAITEMENT 
      AND dach.pacmat = NVL(PACMAT_TRAITEMENT,dach.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
      AND dtru.numpac = NUMPAC_TRAITEMENT
      AND sec.pacmat = dach.pacmat
      AND dach.pacmat = t.pacmat
      AND dach.paiezad = t.paiezad
      AND dach.date_eff = t.date_eff
      AND dtru.pacmat = dach.pacmat
      AND dtru.paiezad = dach.paiezad
      AND (
        dtru.prfpai != 'A'
        OR 
        dtru.dtfpai > last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'YYYYMM') )
        OR (
          dach.ZREACT IS NOT NULL
          AND 
          dtru.dtfpai <= dach.zreact
          AND 
          EXTRACT(YEAR FROM dach.zreact) = substr(PERIODEENCOURS_TRAITEMENT,1,4)
        )
        OR 
        dtru.dtfpai < dach.dssad
      )
  )
  THEN 'O' ELSE 'N' end PRESENT_FICHIER_PAIE 
  from SECUPACMAT SEC 
  where numpac = NUMPAC_TRAITEMENT 
  AND pacmat = NVL(PACMAT_TRAITEMENT,pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
) B
ON (A.NUMPAC = B.NUMPAC and A.PACMAT = B.PACMAT)
WHEN MATCHED THEN UPDATE SET A.PRESENT_FICHIER_PAIE = B.PRESENT_FICHIER_PAIE ;

END R_PRESENT_FICHIER_PAIE;
##
DIC_GESTION_BACASABLE
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE( NOM_DICTIONNAIRE          IN VARCHAR2 ,
 NOM_DICTIONNAIRE_IDPROJET IN VARCHAR2 ,
 LISTKEYS                  IN VARCHAR2 ) AUTHID CURRENT_USER
 AS
 TYPE TYP_COL_NAME
 IS
 TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
 Tabcol TYP_COL_NAME ;
 req  VARCHAR2(512);
 lkey VARCHAR2(512);
 ListCle TYP_COL_NAME ;
 selectCle VARCHAR2(512);
 v_nbMatric NUMBER(10);
 BEGIN
 BEGIN
 EXECUTE_IMMEDIATE_STRING('DROP TABLE '||NOM_DICTIONNAIRE_IDPROJET ,0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('table absente '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
 BEGIN
    DIC_GESTION_BACASABLE_POP;
    END;
  SELECT cols.column_name BULK COLLECT INTO ListCle
  FROM USER_CONSTRAINTS cons, user_cons_columns cols
  WHERE cols.table_name = NOM_DICTIONNAIRE
  AND cons.constraint_type = 'P'
  AND cons.constraint_name = cols.constraint_name
  AND cols.column_name IN ('NUMPAC','PACMAT','PAIEZAD','MATRIC')
  AND cons.owner = cols.owner
  ORDER BY cols.table_name, cols.position;
  IF (ListCle.COUNT = 1 AND ListCle(1) = 'NUMPAC') OR ListCle.COUNT = 0 THEN
    BEGIN
   EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select * from '||NOM_DICTIONNAIRE,0) ;
   EXCEPTION
   WHEN OTHERS THEN
   --dbms_output.put('impossible de créer la table '||NOM_DICTIONNAIRE_IDPROJET);
   --FIXME utiliser la procédure trace_dbms_output()
   NULL;
    END ;
  ELSE
    selectCle := 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select '||NOM_DICTIONNAIRE||'.* from '||NOM_DICTIONNAIRE||',CLE_BAC_A_SABLE ';
    IF ListCle.count>0 THEN
       FOR i IN ListCle.first..ListCle.last
       LOOP
         IF i  = 1 THEN
         selectCle:=selectCle||' WHERE '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         ELSE 
         selectCle:=selectCle||' AND '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         END IF;
       END LOOP;
    END IF; 
    EXECUTE_IMMEDIATE_STRING( selectCle,0) ;
  END IF;

 IF LISTKEYS IS NULL THEN
 SELECT cols.column_name BULK COLLECT
 INTO Tabcol
 FROM user_constraints cons,
 user_cons_columns cols
 WHERE cols.table_name    = NOM_DICTIONNAIRE
 AND cons.constraint_type = 'P'
 AND cons.constraint_name = cols.constraint_name
 AND cons.owner           = cols.owner
 ORDER BY cols.table_name,
 cols.position ;
 IF Tabcol.count>0 THEN
 FOR i IN Tabcol.first..Tabcol.last
 LOOP
 IF i   > 1 THEN
 lkey:=lkey||',';
 END IF;
 lkey:=lkey||Tabcol(i);
 END LOOP;
 END IF;
 IF LENGTH(lkey)>0 THEN
 req         :='ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||lkey||')';
 dbms_output.put_line('lkey : '||lkey);
 EXECUTE_IMMEDIATE_STRING (req,0);
 END IF ;
 ELSE
 BEGIN
 EXECUTE_IMMEDIATE_STRING('ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||LISTKEYS||')',0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('impossible de positionner les clés '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
 END IF;
 END DIC_GESTION_BACASABLE;
##
DIC_GESTION_PHOTO
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE_POP AS
v_nbMatric NUMBER(10);
 BEGIN
 DELETE FROM CLE_BAC_A_SABLE;
 SELECT COUNT(MATRIC) into v_nbMatric from MATRIC_BAC_A_SABLE;
 IF v_nbMatric = 0 then
  INSERT INTO MATRIC_BAC_A_SABLE SELECT MATRIC FROM (select MATRIC from secupacmat ORDER BY MATRIC DESC) WHERE ROWNUM < 500;
 END IF;
 INSERT INTO CLE_BAC_A_SABLE (NUMPAC,PACMAT,PAIEZAD,MATRIC) SELECT DISTINCT DACH.NUMPAC,DACH.PACMAT,DACH.PAIEZAD,DACH.MATRIC FROM DIC_ADM_CONTRAT_HISTO DACH,MATRIC_BAC_A_SABLE WHERE DACH.MATRIC = MATRIC_BAC_A_SABLE.MATRIC;
 END DIC_GESTION_BACASABLE_POP;
##
CLE_BAC_A_SABLE
=SQL IFNOTEXIST=CLE_BAC_A_SABLE=
CREATE TABLE CLE_BAC_A_SABLE (NUMPAC VARCHAR2(8),PACMAT VARCHAR2(10),PAIEZAD VARCHAR2(10),MATRIC VARCHAR2(32))
##
MATRIC_BAC_A_SABLE
=SQL IFNOTEXIST=MATRIC_BAC_A_SABLE=
CREATE TABLE MATRIC_BAC_A_SABLE (MATRIC VARCHAR2(32), PRIMARY KEY(MATRIC))
##
TRG_DIC_ADM_CONTRAT_SITU
=SQL=
CREATE OR REPLACE TRIGGER TRG_DIC_ADM_CONTRAT_SITU FOR INSERT OR UPDATE OR DELETE ON DIC_ADM_CONTRAT_SITU COMPOUND TRIGGER 
  codeChrono NUMBER;
  TYPE T_MPE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.MPE%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabMpeByNumpac T_MPE_BY_NUMPAC;
  
  TYPE T_TRAITEMENT_PERIODES_INDIV IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(100);
  -- Ce tableau indexé contient plusieurs chose :
  -- + Une entrée avec un code PAC + un PAIEZAD --> Un flag permettant de savoir si le couple NUMPAC/PAIEZAD a déjà été traité
  -- + Une entrée avec un code PAC --> La période en cours du PAC
  tabTrtPeriodesIndividuelles T_TRAITEMENT_PERIODES_INDIV;
  
  v_numpac DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE;
  v_pacmat DIC_ADM_CONTRAT_SITU.PACMAT%TYPE;
  v_numcnt DIC_ADM_CONTRAT_SITU.NUMCNT%TYPE;
  v_paiezad DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE;
  v_codeChrono DIC_ADM_CONTRAT_SITU.CODE_CHRONO%TYPE;
  V_DE_SSAAMM VARCHAR2(6);
  periode_deb_histo_retro VARCHAR2(6);
  periode_paie_en_cours   VARCHAR2(6);
  periode_deb_retro       VARCHAR2(6);
  nb_mois_retro           NUMBER;
  TYPE paiezadTabType is table of DIC_ADM_CONTRAT_SITU.PAIEZAD%TYPE ;
  TYPE numpacTabType is  table of DIC_ADM_CONTRAT_SITU.NUMPAC%TYPE ;
  paiezadTab paiezadTabType := paiezadTabType();
  numpacTab numpacTabType := numpacTabType();
  mpe TGE_REF_PAC.MPE%TYPE;
  auMoinsUnPacMpe BOOLEAN;
  v_countSecNav    NUMBER := -1;
  prefixeCodeChrono VARCHAR2(5);
  quantiemeCodeChrono NUMBER;
  suffixeCodeChrono NUMBER;
  existeCodeChrono NUMBER;
   v_jobIdx          NUMBER;
  BEFORE STATEMENT IS BEGIN
    SELECT COUNT(*) INTO v_countSecNav FROM SECUPACMAT_TMP WHERE MATRIC='SECNAV';
    IF v_countSecNav>0 THEN
      RAISE_APPLICATION_ERROR(-20000,'CODERR=GENREC03');
    END IF;
  END BEFORE STATEMENT;
  BEFORE EACH ROW IS BEGIN
    v_numpac := NVL(:NEW.NUMPAC,:OLD.NUMPAC);
    v_pacmat := NVL(:NEW.PACMAT,:OLD.PACMAT);
    v_numcnt := NVL(:NEW.NUMCNT,:OLD.NUMCNT);
    IF NOT tabMpeByNumpac.exists(v_numpac) THEN
      BEGIN
        SELECT NVL(MPE,'N') INTO mpe FROM TGE_REF_PAC WHERE NUMPAC=v_numpac;
      EXCEPTION WHEN OTHERS THEN mpe := 'N'; END;
      tabMpeByNumpac(v_numpac) := mpe;
    END IF; 
    -- On vérifie qu'on ne modifie ni le NUMPAC, ni le PACMAT, ni le NUMCNT, ni le PAIEZAD
    IF UPDATING AND (NOT :OLD.NUMPAC=:NEW.NUMPAC OR NOT :OLD.PACMAT=:NEW.PACMAT OR NOT :OLD.NUMCNT=:NEW.NUMCNT OR NOT :OLD.PAIEZAD=:NEW.PAIEZAD) THEN
      -- Message d'erreur --> On interdit la mise à jour du NUMPAC, du PACMAT, du NUMCNT et du PAIEZAD : il faut faire un delete puis un insert
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour des colonnes NUMPAC, PACMAT, NUMCNT et PAIEZAD n''est pas autorisée : vous devez supprimer puis recréer la situation');
    END IF;
    -- On vérifie qu'on ne modifie pas le RHID et qu'il n'est pas vide
    IF (INSERTING OR UPDATING) AND :NEW.MATRIC IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'La colonne MATRIC doit être renseignée dans DIC_ADM_CONTRAT_SITU');
    END IF;
    IF UPDATING AND NOT :OLD.MATRIC=:NEW.MATRIC THEN
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne MATRIC n''est pas autorisée');
    END IF;
    -- On vérifie qu'on ne modifie pas le RHID et qu'il n'est pas vide
    IF (INSERTING OR UPDATING) AND :NEW.DSDSC IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'La colonne DSDSC doit être renseignée dans DIC_ADM_CONTRAT_SITU');
    END IF;
    IF UPDATING AND NOT :OLD.DSDSC=:NEW.DSDSC THEN
      RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne DSDSC n''est pas autorisée');
    END IF;
    
    IF INSERTING AND :NEW.CODE_CHRONO IS NULL THEN
      IF tabMpeByNumpac(v_numpac)='N' THEN
        -- CODE CHRONO à 000000 si pac non mpe
        :NEW.CODE_CHRONO := '000000';
      ELSE
        -- si pac en MPE CODE_CHRONO calculée à partir de la date de début de situation : Année (sans le siècle) + quantième de jour (3 caractères) + '0'
        prefixeCodeChrono := SUBSTR(TO_CHAR(:NEW.DSDSC,'yyyy'),3);
        quantiemeCodeChrono := :NEW.DSDSC- trunc(:NEW.DSDSC,'yyyy')+1;
        -- Le suffix est toujours à 0
        suffixeCodeChrono := 0;
        -- On va vérifier que le code chrono n'existe pas pour le PACMAT (cas d'une modification de date d'embauche qui aurait gardé le même code chrono)
        -- ou bien d'autres cas, voir la fonction EXISTS_CODE_CHRONO
        LOOP
          :NEW.CODE_CHRONO := prefixeCodeChrono || LPAD(quantiemeCodeChrono,3,'0') || suffixeCodeChrono;
          existeCodeChrono := EXISTS_CODE_CHRONO(:NEW.NUMPAC, :NEW.PACMAT, :NEW.CODE_CHRONO);
          EXIT WHEN existeCodeChrono=0;
          quantiemeCodeChrono := quantiemeCodeChrono + 1;
          EXIT WHEN quantiemeCodeChrono=1000;
        END LOOP;
        IF quantiemeCodeChrono=1000 THEN
          -- On ne peut plus créer de CODE_CHRONO pour cette date de début de situation : on lance une erreur
          RAISE_APPLICATION_ERROR(-20000,'Nombre maximum de codes chrono atteint pour une situation de contrat débutant le '||TO_CHAR(:NEW.DSDSC,'dd.mm.yyyy')||' pour le matricule paie '||:NEW.PACMAT||' du PAC '||:NEW.NUMPAC);
        END IF;
        auMoinsUnPacMpe := TRUE;
      END IF;
    ELSE
      IF UPDATING AND NOT :OLD.CODE_CHRONO=:NEW.CODE_CHRONO THEN
        RAISE_APPLICATION_ERROR(-20000,'La mise à jour de la colonne CODE_CHRONO n''est pas autorisée');
      END IF;
      IF DELETING AND NOT tabMpeByNumpac(v_numpac)='N' THEN
        auMoinsUnPacMpe := TRUE;
        MERGE INTO DELETED_PAIEZAD C USING (SELECT :OLD.NUMPAC AS NUMPAC, :OLD.PACMAT AS PACMAT, :OLD.NUMCNT AS NUMCNT, :OLD.PAIEZAD AS PAIEZAD, :OLD.CODE_CHRONO as CODE_CHRONO FROM DUAL) Z ON (C.NUMPAC=Z.NUMPAC AND C.PACMAT=Z.PACMAT AND C.NUMCNT=Z.NUMCNT AND C.PAIEZAD=Z.PAIEZAD)
        WHEN NOT MATCHED THEN INSERT (NUMPAC, PACMAT, NUMCNT, MATRIC, PAIEZAD, DATE_SUPPRESSION, CODE_CHRONO) VALUES (:OLD.NUMPAC, :OLD.PACMAT, :OLD.NUMCNT, :OLD.MATRIC, :OLD.PAIEZAD, SYSDATE, :OLD.CODE_CHRONO);
      END IF;
    END IF;
    UPDATE DIC_ADM_CONTRAT SET TYPE_WRITER='N', CURRENT_PAIEZAD=(SELECT PAIEZAD FROM DIC_ADM_CONTRAT_HISTO WHERE DIC_ADM_CONTRAT_HISTO.NUMPAC=DIC_ADM_CONTRAT.NUMPAC AND DIC_ADM_CONTRAT_HISTO.PACMAT=DIC_ADM_CONTRAT.PACMAT AND DIC_ADM_CONTRAT_HISTO.NUMCNT=DIC_ADM_CONTRAT.NUMCNT AND DIC_ADM_CONTRAT_HISTO.DATE_EFF=DIC_ADM_CONTRAT.DATE_EFF_CONTRAT) WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat AND NUMCNT=v_numcnt;
  END BEFORE EACH ROW;
  
  AFTER EACH ROW IS BEGIN
    v_numpac := NVL(:NEW.NUMPAC,:OLD.NUMPAC);
    v_paiezad :=NVL(:NEW.paiezad,:OLD.paiezad);
    -- On ne traite chaque couple NUMPAC/PAIEZAD qu'une seule fois
    IF (INSERTING OR DELETING OR (UPDATING('DSFSC') AND NOT :NEW.DSFSC=:OLD.DSFSC)) AND NOT tabTrtPeriodesIndividuelles.exists(v_numpac||v_paiezad) THEN
        SELECT DEB_HISTO_RETRO,
	      PERIODEENCOURS,
	      DEB_RETRO,
	      NB_MOIS_RETRO
	    INTO periode_deb_histo_retro,
	      periode_paie_en_cours,
	      periode_deb_retro,
	      nb_mois_retro
	    FROM TGE_REF_PAC
	    WHERE NUMPAC = v_numpac;
	    tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := periode_paie_en_cours;
	    IF(periode_deb_histo_retro IS NOT NULL AND periode_paie_en_cours >= periode_deb_histo_retro) THEN
	      tabTrtPeriodesIndividuelles(v_numpac||v_paiezad) := TO_CHAR(NVL(:NEW.dsdsc,:OLD.dsdsc), 'YYYYMM');
	    END IF;
      IF DELETING THEN
        -- Suppression : on supprime de la table des périodes individuelles
        DELETE FROM TGE_PERIODE_RECUEIL_PAIEZAD WHERE NUMPAC = v_numpac AND PAIEZAD = v_paiezad;
        -- Inscription Retro
        IF(periode_paie_en_cours >= periode_deb_retro AND periode_deb_retro IS NOT NULL) THEN
        	-- La période rétro doit être >= à :
            -- - La date de début des histos de rétro
            -- - La période en cours - le nombre de mois de rétro
            -- On prend donc la plus grande de ces 2 dates + la date d'effet
            V_DE_SSAAMM := GREATEST(TO_CHAR(LEAST(NVL(:NEW.DSDSC,:OLD.DSDSC), NVL(:OLD.DSDSC,:NEW.DSDSC)) ,'YYYYMM'),periode_deb_histo_retro,TO_CHAR(ADD_MONTHS(to_date(periode_paie_en_cours,'YYYYMM'),-nb_mois_retro),'YYYYMM'));
            IF(V_DE_SSAAMM < periode_paie_en_cours) THEN
    			v_pacmat := NVL(:NEW.PACMAT,:OLD.PACMAT);
            	v_codeChrono := NVL(:NEW.CODE_CHRONO,:OLD.CODE_CHRONO);
            	
            	TGE_RETRO_INSCRIPTION(v_numpac, v_pacmat, V_DE_SSAAMM, v_codeChrono, v_paiezad, 'DIC_ADM_CONTRAT_SITU');
            END IF;
        END IF;
      ELSE
        -- Création ou modification de la date de fin : on met à jour la table des périodes individuelles
        paiezadTab.EXTEND ;
        paiezadTab(paiezadTab.LAST) := v_paiezad;
        numpacTab.EXTEND ;
        numpacTab(numpacTab.LAST) :=v_numpac;
      END IF;
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS BEGIN
    IF (INSERTING OR DELETING) AND auMoinsUnPacMpe THEN
      -- On supprime de la table DELETED_PAIEZAD les situations qui n'ont pas lieu d'y être (situations recréés avec le même PAIEZAD)
      DELETE FROM DELETED_PAIEZAD WHERE (NUMPAC,PACMAT,CODE_CHRONO) IN (SELECT NUMPAC,PACMAT,CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU);
    END IF;
    FOR i IN 1..numpacTab.count LOOP
    	DBMS_JOB.SUBMIT(v_jobIdx , 'TGE_ALIM_PERIODE_INDIV(0, '''||numpacTab(i)||''', '''|| tabTrtPeriodesIndividuelles(numpacTab(i)||paiezadTab(i)) ||''', '''|| paiezadTab(i) ||''');' , sysdate-1);
   END LOOP ;
  END AFTER STATEMENT;
END;
##
TRG_CONTRAT_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_AFTER_STMNT RETURN VARCHAR2 AS 
BEGIN
  RETURN '
  IF DELETING THEN
    -- On a supprimé des lignes : on va parcourir les couples NUMPAC/PACMAT supprimés pour voir si c''était le seul contrat du couple
    IF v_TAB_NUMPAC_PACMAT IS NOT NULL THEN
      FOR i IN v_TAB_NUMPAC_PACMAT.first..v_TAB_NUMPAC_PACMAT.last LOOP
        SELECT COUNT(*) INTO v_nbLig FROM DIC_ADM_CONTRAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
        IF v_nbLig=0 THEN
          -- On vient de supprimer le dernier contrat du couple NUMPAC/PACMAT : on va vérifier s''il faut le supprimer de SECUPACMAT
          SELECT COUNT(*) INTO v_nbLig FROM SECUPACMAT WHERE MATRIC=v_TAB_NUMPAC_PACMAT(i).MATRIC AND NOT (NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT);
          IF v_nbLig>0 THEN
            -- Il existe dans SECUPACMAT au moins une ligne pour le MATRIC, avec un autre couple NUMPAC/PACMAT que celui dont on vient de supprimer le dernier contrat : on supprime ce couple de SECUPACMAT
            DELETE FROM SECUPACMAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
          END IF;
        END IF;
        IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_TAB_NUMPAC_PACMAT(i).MATRIC)<=0 THEN
          -- On stocke la liste des NUMPAC/PACMAT modifiés
          IF v_nbMatricToUpdate=1000 THEN
            v_nbMatricToUpdate := 0;
            v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
          ELSIF v_nbMatricToUpdate>0 THEN
            v_listMatricToUpdate := v_listMatricToUpdate||'','';
          END IF;
          v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_TAB_NUMPAC_PACMAT(i).MATRIC||'''''''';
          v_nbMatricToUpdate := v_nbMatricToUpdate+1;
        END IF;
      END LOOP;
    END IF;
  ELSIF INSERTING THEN
    UPDATE DEX_EVENTS SET DATE_ENVOI=DATE_MODIF-1, ACTION=''C'' WHERE ACTION=''Z'' AND (SELECT COUNT(*) FROM DIC_ADM_CONTRAT WHERE DIC_ADM_CONTRAT.MATRIC=DEX_EVENTS.MATRIC)>1;
    UPDATE DEX_EVENTS SET ACTION=''C'' WHERE ACTION=''Z'';
  END IF;
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- On insère dans la table temporaire les NUMPAC/PACMAT/MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''CONTRAT UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_CONTRAT(''DO_MAJ'', 1, 0, 0);
    DELETE FROM SECUPACMAT_TMP_CONTRAT;
    IF INSERTING THEN
      v_actionIdx := ''I'';
    ELSIF UPDATING THEN
      v_actionIdx := ''U'';
    ELSIF DELETING THEN
      v_actionIdx := ''D'';
    END IF;
    DBMS_JOB.SUBMIT(v_jobIdx , ''BEGIN NULL; END;'' , sysdate+1);
    DBMS_JOB.WHAT(v_jobIdx , ''ALIM_IDX.COMPARE_CONTRAT_JOB(''||v_jobIdx||'', ''''''||v_actionIdx||'''''');'');
 	DBMS_JOB.NEXT_DATE(v_jobIdx ,  sysdate-1);
    INSERT INTO DIC_IDX_JOB_KEYS SELECT v_jobIdx, T.* FROM TABLE(v_cles_idx_contrat) T;
    IF INSERTING OR UPDATING THEN
      INSERT INTO DIC_IDX_JOB_OLD_DATAS VALUES (v_jobIdx, ANYDATA.CONVERTCOLLECTION(GET_DAC_MULTI_HORS_TRANSAC(v_cles_idx_contrat)));
    END IF;
    IF v_doMajPerso=1 THEN
      EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
      SECNAV_MAJ_CURRENT_PERSO(''DO_MAJ'', 1, 1, 0);
      DELETE FROM SECUPACMAT_TMP_PERSO;
    END IF;
  END IF;
';
END TRG_CONTRAT_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
MATRIC_BAC_A_SABLE
=SQL IFNOTEXIST=MATRIC_BAC_A_SABLE=
CREATE TABLE MATRIC_BAC_A_SABLE (MATRIC VARCHAR2(32), PRIMARY KEY(MATRIC))
##
TAG_CHARSET=@€éèç
##
CLE_BAC_A_SABLE
=SQL IFNOTEXIST=CLE_BAC_A_SABLE=
CREATE TABLE CLE_BAC_A_SABLE (NUMPAC VARCHAR2(8),PACMAT VARCHAR2(10),PAIEZAD VARCHAR2(10),MATRIC VARCHAR2(32))
##
DIC_GESTION_BACASABLE
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE( NOM_DICTIONNAIRE          IN VARCHAR2 ,
 NOM_DICTIONNAIRE_IDPROJET IN VARCHAR2 ,
 LISTKEYS                  IN VARCHAR2 ) AUTHID CURRENT_USER
 AS
 TYPE TYP_COL_NAME
 IS
 TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
 Tabcol TYP_COL_NAME ;
 req  VARCHAR2(512);
 lkey VARCHAR2(512);
 ListCle TYP_COL_NAME ;
 selectCle VARCHAR2(512);
 v_nbMatric NUMBER(10);
 BEGIN
 BEGIN
 EXECUTE_IMMEDIATE_STRING('DROP TABLE '||NOM_DICTIONNAIRE_IDPROJET ,0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('table absente '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
  SELECT cols.column_name BULK COLLECT INTO ListCle
  FROM USER_CONSTRAINTS cons, user_cons_columns cols
  WHERE cols.table_name = NOM_DICTIONNAIRE
  AND cons.constraint_type = 'P'
  AND cons.constraint_name = cols.constraint_name
  AND cols.column_name IN ('NUMPAC','PACMAT','PAIEZAD','MATRIC')
  AND cons.owner = cols.owner
  ORDER BY cols.table_name, cols.position;
  IF (ListCle.COUNT = 1 AND ListCle(1) = 'NUMPAC') OR ListCle.COUNT = 0 THEN
    BEGIN
   EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select * from '||NOM_DICTIONNAIRE,0) ;
   EXCEPTION
   WHEN OTHERS THEN
   --dbms_output.put('impossible de créer la table '||NOM_DICTIONNAIRE_IDPROJET);
   --FIXME utiliser la procédure trace_dbms_output()
   NULL;
    END ;
  ELSE
    selectCle := 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select '||NOM_DICTIONNAIRE||'.* from '||NOM_DICTIONNAIRE||',CLE_BAC_A_SABLE ';
    IF ListCle.count>0 THEN
       FOR i IN ListCle.first..ListCle.last
       LOOP
         IF i  = 1 THEN
         selectCle:=selectCle||' WHERE '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         ELSE 
         selectCle:=selectCle||' AND '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         END IF;
       END LOOP;
    END IF; 
    EXECUTE_IMMEDIATE_STRING( selectCle,0) ;
  END IF;

 IF LISTKEYS IS NULL THEN
 SELECT cols.column_name BULK COLLECT
 INTO Tabcol
 FROM user_constraints cons,
 user_cons_columns cols
 WHERE cols.table_name    = NOM_DICTIONNAIRE
 AND cons.constraint_type = 'P'
 AND cons.constraint_name = cols.constraint_name
 AND cons.owner           = cols.owner
 ORDER BY cols.table_name,
 cols.position ;
 IF Tabcol.count>0 THEN
 FOR i IN Tabcol.first..Tabcol.last
 LOOP
 IF i   > 1 THEN
 lkey:=lkey||',';
 END IF;
 lkey:=lkey||Tabcol(i);
 END LOOP;
 END IF;
 IF LENGTH(lkey)>0 THEN
 req         :='ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||lkey||')';
 dbms_output.put_line('lkey : '||lkey);
 EXECUTE_IMMEDIATE_STRING (req,0);
 END IF ;
 ELSE
 BEGIN
 EXECUTE_IMMEDIATE_STRING('ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||LISTKEYS||')',0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('impossible de positionner les clés '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
 END IF;
 END DIC_GESTION_BACASABLE;
##
DIC_GESTION_BACASABLE_POP
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE_POP AS
v_nbMatric NUMBER(10);
 BEGIN
 DELETE FROM CLE_BAC_A_SABLE;
 SELECT COUNT(MATRIC) into v_nbMatric from MATRIC_BAC_A_SABLE;
 IF v_nbMatric = 0 then
  INSERT INTO MATRIC_BAC_A_SABLE SELECT MATRIC FROM (select MATRIC from secupacmat ORDER BY MATRIC DESC) WHERE ROWNUM < 500;
 END IF;
 INSERT INTO CLE_BAC_A_SABLE (NUMPAC,PACMAT,PAIEZAD,MATRIC) SELECT DISTINCT DACH.NUMPAC,DACH.PACMAT,DACH.PAIEZAD,DACH.MATRIC FROM DIC_ADM_CONTRAT_HISTO DACH,MATRIC_BAC_A_SABLE WHERE DACH.MATRIC = MATRIC_BAC_A_SABLE.MATRIC;
 END DIC_GESTION_BACASABLE_POP;
##
TAG_CHARSET=@€éèç
##
TGE_IMPORT_3040
=SQL=
create or replace PROCEDURE TGE_IMPORT_3040( P_LOGIN       IN VARCHAR2 , P_DATE_IMPORT IN VARCHAR2 , P_ROLE        IN VARCHAR2 ,
 P_ORIGINE     IN VARCHAR2 ,
 P_VALIDATION  IN NUMBER ,
 P_WITH30      IN NUMBER ,
 P_WITH40      IN NUMBER ,
 P_WITH60      IN NUMBER ,
 P_WITH70      IN NUMBER ,
 P_ISFSED      IN NUMBER ,
 P_CODLANG     IN VARCHAR2,
 -- Valeurs attendues : VI -> pour la validation des imports Web ou Batch, MP -> pour la validation depuis le Market Place
 P_TYPE_ACTION IN VARCHAR2)
 AS
 /********************************************************************************
 Version     : V5.05.004
 *********************************************************************************/
 w_err   VARCHAR2(2000);
 v_start NUMBER;
 v_stop  NUMBER;
 id_trt number ;
 dateMaj SYS_TRC_MODIF.datemaj%type;
 doRollback boolean;
 desactiveTraitements   VARCHAR2(1000);

 BEGIN
 doRollback:=false;
 v_start := DBMS_UTILITY.GET_TIME;
 id_trt := IMP_TRT_SEQ_ID.nextval;
 -- FVI on peut lire le pac une seule fois
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'TGE_IMPORT_3040 début');
 -- Mise à jour des donnees ID collab
 select CURRENT_TIMESTAMP into dateMaj from dual;
 -- Cartes d'annulation
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début delete pour gérer annulation  ');
 DELETE
 FROM TGE_ABSENCES ABS
 WHERE EXISTS
 (SELECT 1
 FROM TGE_INCIDENTS_PAIE  P,
 TGE_REF_TYPES_GTA   GTA,
 TGE_REF_ORIGINE_GTA  ori,
 TGE_IMPORT_ANNULATION A,DIC_ADM_CONTRAT_SITU C
 WHERE ABS.NUMPAC = A.NUMPAC
 AND   P.NUMPAC   = A.NUMPAC
 AND   C.NUMPAC   = A.NUMPAC
 AND   GTA.NUMPAC = A.NUMPAC
 AND   ori.NUMPAC = A.NUMPAC
 AND A.LOGIN       =P_LOGIN
 AND A.DATE_IMPORT =P_DATE_IMPORT
 AND NVL(GTA.MATRIC_GTA,'PAIEZAD')='PACMAT'
 AND GTA.CODE_GTA    = ori.CODE_GTA
 AND ori.CODE_ORIGINE =P.ORIGINE
 AND ABS.MATRIC                  =A.MATRICULE
 AND C.PACMAT   = A.PACMAT
 AND C.MATRIC = A.MATRICULE
 AND P.PAIEZAD = C.PAIEZAD
 AND A.ORIGINE                    =P.ORIGINE
 AND TO_DATE(A.PERIODE,'yyyymm')  =P.PERIODE
 AND P.CLE_ABSENCE               IS NOT NULL
 AND ABS.ID = P.CLE_ABSENCE
 );
 
 DELETE
 FROM TGE_ABSENCES ABS
 WHERE EXISTS
 (SELECT 1
 FROM TGE_INCIDENTS_PAIE p,TGE_REF_TYPES_GTA gta
 WHERE p.numpac = abs.numpac
 AND p.cle_absence IS NOT NULL
 AND p.cle_absence = abs.id
 and p.numpac = gta.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =p.numpac and code_origine =p.origine )
 AND EXISTS
 (SELECT *
 FROM TGE_IMPORT_ANNULATION a
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 AND a.matricule                 = abs.matric
 AND ( NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD' AND a.paiezad = p.paiezad )
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 )
 );
 
 DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 );
 
 DELETE
 FROM TGE_INCIDENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN                   =P_LOGIN
 AND a.DATE_IMPORT               =P_DATE_IMPORT
 AND a.numpac                    =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND   NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD'
 AND a.paiezad = p.paiezad
 AND a.origine                   =p.origine
 AND to_date(a.periode,'yyyymm') =p.periode
 );
 
 DELETE
 FROM TGE_ELEMENTS_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')AND p.code_remplacement ='R')
 OR p.code_remplacement ='*');
 
 DELETE
 FROM TGE_ELEMENTS_PAIE p
 WHERE EXISTS
 (SELECT *
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD'
 AND a.paiezad = p.paiezad
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')AND p.code_remplacement ='R')
 OR p.code_remplacement ='*');
 
 DELETE
 FROM TGE_DONNEES_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD')='PACMAT'
 AND( EXISTS (
 SELECT c.paiezad
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC  =a.NUMPAC
 AND   C.NUMPAC    = p.numpac
 AND   C.paiezad   = p.paiezad
 AND   c.PACMAT    = a.PACMAT
 ) )
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')AND p.code_remplacement ='R')
 OR p.code_remplacement is null);
 
 DELETE
 FROM TGE_DONNEES_PAIE p
 WHERE EXISTS
 (SELECT 1
 FROM TGE_IMPORT_ANNULATION a,TGE_REF_TYPES_GTA gta
 WHERE a.LOGIN    =P_LOGIN
 AND a.DATE_IMPORT=P_DATE_IMPORT
 AND a.numpac     =p.numpac
 and gta.numpac   = p.numpac
 and gta.code_gta =(select code_gta from TGE_REF_ORIGINE_GTA where numpac =a.numpac and code_origine = a.origine )
 AND  NVL(gta.matric_gta,'PAIEZAD') ='PAIEZAD' AND a.paiezad = p.paiezad
 AND a.origine    =p.origine
 AND a.periode    =p.periode
 )
 AND (( p.origine in (select code_origine
 from tge_ref_origine_gta
 where numpac=p.numpac
 and code_origine=p.origine
 and  mode_3060 !='F')AND p.code_remplacement ='R')
 OR p.code_remplacement is null);
 
 IF P_WITH30 =1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 30');
 TGE_IMPORT_30 (P_LOGIN , P_DATE_IMPORT , P_ROLE , P_ORIGINE , P_VALIDATION , P_WITH30 , P_CODLANG, P_TYPE_ACTION, datemaj );
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 FSED.FSED_ERREUR( id_trt , ' imp:TGE_IMPORT_30 ' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30, w_err );
--UN TRAITEMENT DE PAIE EST EN COURS
 if(SQLCODE='-20001') then 
  doRollback:=true;
  GOTO end_proc;
 end if ; 
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 
 IF P_WITH60 =1 OR P_WITH70 =1 THEN
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 60');
 TGE_IMPORT_6070 (P_LOGIN , P_DATE_IMPORT , P_ROLE , P_ORIGINE , P_VALIDATION , P_WITH60 , P_WITH70 , P_CODLANG, P_TYPE_ACTION );
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  '||sqlerrm;
 FSED.FSED_ERREUR( id_trt , ' imp:TGE_IMPORT_6070 ' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH60 ||','|| P_WITH70 , w_err );
 if(SQLCODE='-20001') then 
   doRollback:=true;
   GOTO end_proc;
  end if ;
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 END IF;
 
 IF P_WITH40 =1 THEN
 
 
 --Supprimer les absences sur le mois de paie M-1 si le flag Retro GC = 'O'
 DELETE from
 TGE_ABSENCES A
 WHERE exists
 (
 SELECT ABS.ID FROM TGE_ABSENCES ABS
 INNER JOIN TGE_IMPORT_INCIDENTS t on ( ABS.MATRIC = T.MATRICULE and T.numpac=ABS.NUMPAC)
 INNER JOIN TGE_INCIDENTS_PAIE INC ON ABS.ID = INC.CLE_ABSENCE
 INNER JOIN TGE_REF_PAC PAC ON INC.NUMPAC = PAC.NUMPAC
 INNER JOIN TGE_REF_PER PER ON PER.NUMPAC = INC.NUMPAC AND PER.PERIODEENCOURS = TO_CHAR(ADD_MONTHS(TO_DATE(PAC.PERIODEENCOURS,'yyyymm'),-1),'YYYYMM')
 INNER JOIN TGE_PERIODE_RECUEIL_PAIEZAD REC ON INC.NUMPAC = REC.NUMPAC AND INC.PAIEZAD = REC.PAIEZAD AND REC.MOIS_PAIE = PAC.PERIODEENCOURS
 WHERE INC.DATE_EFFET BETWEEN DEBUT_PER_RECUEIL_RETRO AND FIN_PER_RECUEIL_RETRO
 AND REC.RETRO_GC = '1'
 AND A.ID=ABS.ID
 AND T.LOGIN=P_LOGIN
 AND T.DATE_IMPORT=P_DATE_IMPORT
 );
 
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 40');
 TGE_CONTROLE_40 (p_login,p_date_import,NULL,p_codlang , P_ISFSED);
 
 -- activer ou non les nouveaux traitements de l'import 3040
 select NVL(upper(VALVAR), ' ') into desactiveTraitements from sys_varsys where module='STD' and codvar='DESACTIVE_TRAITEMENTS_IMPORT_3040';
 IF INSTR(desactiveTraitements, 'TGE_CONTROLE_40_CHEVAUCHEMENT') < 1 THEN
	 --controle chevauchement
	 TGE_CONTROLE_40_CHEVAUCHEMENT(P_LOGIN, P_DATE_IMPORT ,null , P_CODLANG );
 END IF;
 
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'imp:TGE_CONTROLE_40' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 BEGIN
 --Controle Abscence
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Controle Abscence');
 
 TGE_CONTROLE_ABSENCES (p_login,p_date_import,NULL,p_codlang);
 EXCEPTION
 WHEN OTHERS THEN
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'imp:TGE_CONTROLE_ABSENCES' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 IF P_VALIDATION = 1 THEN
 --Creation Abscence
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : Creation Abscence');
 
 INSERT
 INTO TGE_ABSENCES
 (
 ID,
 MATRIC ,
 MOTIF ,
 NUMPAC ,
 DATE_DEBUT ,
 DEBUT_MA ,
 DATE_FIN ,
 FIN_MA ,
 DUREE ,
 DATE_IJEDI ,
 LOGIN_CREATE ,
 DATE_CREATE ,
 ROLE_CREATE ,
 ORIGINE_CREATE ,
 LOGIN_MAJ ,
 DATE_MAJ ,
 ROLE_MAJ ,
 ORIGINE_MAJ ,
 CLE_IMPORT,
 STATUT
 )
 SELECT SEQ_TGE_ABSENCES.NEXTVAL ,
 ABSENCES.MATRIC ,
 ABSENCES.MOTIF ,
 ABSENCES.NUMPAC ,
 ABSENCES.DATE_DEBUT ,
 ABSENCES.DEBUT_MA ,
 ABSENCES.DATE_FIN ,
 ABSENCES.FIN_MA ,
 ABSENCES.DUREE ,
 ABSENCES.DATE_IJEDI ,
 ABSENCES.LOGIN_CREATE ,
 ABSENCES.DATE_CREATE ,
 ABSENCES.ROLE_CREATE ,
 ABSENCES.ORIGINE_CREATE ,
 ABSENCES.LOGIN_MAJ ,
 ABSENCES.DATE_MAJ ,
 ABSENCES.ROLE_MAJ ,
 ABSENCES.ORIGINE_MAJ ,
 ABSENCES.CLE_IMPORT,
 ABSENCES.STATUT
 FROM
 (SELECT
 (SELECT C.MATRIC
 FROM DIC_ADM_CONTRAT_SITU C
 WHERE C.NUMPAC = INCI.NUMPAC
 AND C.PAIEZAD  =INCI.PAIEZAD
 AND rownum     = 1
 )                                   AS MATRIC,--matricule
 INCI.CODE_IP                        AS MOTIF, --motif
 INCI.NUMPAC                         AS NUMPAC,
 to_date(INCI.DATE_DEBUT,'yyyyMMdd') AS DATE_DEBUT, --date debut
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 THEN DECODE (INCI.HEURES_IP,'1.00','J',DECODE(IS_NUMBER(INCI.HEURES_IP),0.5,'M','J'))
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
 THEN DECODE (INCI.HEURES_IP ,NULL,'J','D')
 END                               AS DEBUT_MA , --debutma
 to_date(INCI.DATE_FIN,'yyyyMMdd') AS DATE_FIN,  --date fin
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 THEN DECODE (INCI.HEURES_IP,'1.00','J',DECODE(IS_NUMBER(INCI.HEURES_IP),0.5,'M','J'))
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
 THEN DECODE (INCI.HEURES_IP ,NULL,'J','D')
 END AS FIN_MA, --Fin ma
 CASE
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'J'
 AND ((SELECT pre.demi_journee
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 )                       = 1 
 OR IS_NUMBER(INCI.HEURES_IP) = 0.5
)
 THEN NVL(is_number(REPLACE(INCI.HEURES_IP,'.',',')) *8*3600,NULL) 
 WHEN UPPER(
 (SELECT pre.unite
 FROM tge_ref_pre pre
 WHERE pre.CODE_INCIDENT = INCI.CODE_IP
 AND pre.numpac          = inci.NUMPAC
 ))                      = 'H'
THEN NVL(is_number(REPLACE(INCI.HEURES_IP,'.',',')) *3600,NULL) 
ELSE NULL
 END        AS DUREE,        --duree
 NULL       AS DATE_IJEDI,   --date_ijedi
 INCI.LOGIN AS LOGIN_CREATE, --login create
 sysdate    AS DATE_CREATE,  --date_create
 P_ROLE     AS ROLE_CREATE,
 P_ORIGINE  AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create :ToolsTge.ORI_ECRAN_IMPORT_INCIDENT
 INCI.LOGIN AS LOGIN_MAJ,      --login maj
 sysdate    AS DATE_MAJ,       -- date_maj
 P_ROLE     AS ROLE_MAJ,
 P_ORIGINE  AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj   :ToolsTge.ORI_ECRAN_IMPORT_INCIDENT
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 'Q' AS STATUT
 FROM TGE_IMPORT_INCIDENTS INCI
 WHERE EXISTS (
 (SELECT ri.CODE_INCIDENT
 FROM TGE_REF_PRE ri
 WHERE ri.numpac             = INCI.numpac
 AND ri.code_incident        =inci.code_ip
 AND ri.OPTION_CONSERV_HISTO = 'A'
 )
 UNION
 (SELECT ri.CODE_INCIDENT
 FROM TGE_REF_PRE ri
 WHERE ri.numpac             ='*'
 AND ri.code_incident        =inci.code_ip
 AND ri.OPTION_CONSERV_HISTO = 'A'
 AND NOT EXISTS
 (SELECT *
 FROM TGE_REF_PRE rt2
 WHERE rt2.numpac      =iNCI.numpac
 AND rt2.code_incident =ri.code_incident
 )
 ))
 AND INCI.LOGIN       = P_LOGIN
 AND INCI.DATE_IMPORT = P_DATE_IMPORT
 AND ((INCI.ERREURS  IS NULL
 AND INCI.STATUT      = 'TRAIT')
 OR (INCI.ERREURS    IS NOT NULL
 AND INCI.STATUT      = 'TRANS'))
 ) ABSENCES ;
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'ValidAbsences' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 --insertion des incidents
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion des incidents');
 
 INSERT
 INTO TGE_INCIDENTS_PAIE
 (
 ID ,
 NUMPAC,
 PAIEZAD,
 PERIODE,
 TYPE_TRAITEMENT,
 TYPE_IP,
 CODE_IP,
 DATE_EFFET,
 CODE_IMPUTATION,
 HEURES,
 ORIGINE,
 LOGIN_CREATE,
 DATE_CREATE,
 ROLE_CREATE,
 ORIGINE_CREATE,
 LOGIN_MAJ,
 DATE_MAJ,
 ROLE_MAJ,
 ORIGINE_MAJ,
 CLE_IMPORT,
 CLE_ABSENCE,
 IDPACMAT,
 ENVOYE,
 type_writer,
 ACTION_RETRO,
 ACTION_RETRO_DATE,
 DERNIER_CODE_OPE 
 )
 SELECT SEQ_TGE_INCIDENTS_PAIE.NEXTVAL ,
 INCIDENTS.NUMPAC,
 INCIDENTS.PAIEZAD,
 INCIDENTS.PERIODE,
 INCIDENTS.TYPE_TRAITEMENT,
 INCIDENTS.TYPE_IP,
 INCIDENTS.CODE_IP,
 INCIDENTS.DATE_EFFET,
 INCIDENTS.CODE_IMPUTATION,
 INCIDENTS.HEURES,
 INCIDENTS.ORIGINE,
 INCIDENTS.LOGIN_CREATE,
 INCIDENTS.DATE_CREATE,
 INCIDENTS.ROLE_CREATE,
 INCIDENTS.ORIGINE_CREATE,
 INCIDENTS.LOGIN_MAJ,
 INCIDENTS.DATE_MAJ,
 INCIDENTS.ROLE_MAJ,
 INCIDENTS.ORIGINE_MAJ,
 INCIDENTS.CLE_IMPORT,
 INCIDENTS.CLE_ABSENCE,
 INCIDENTS.IDPACMAT,
 INCIDENTS.ENVOYE,
 CASE
 WHEN TGE_REF_ORIGINE_GTA.MODE_T2    ='R'
 AND TGE_REF_ORIGINE_GTA.ENVOI_MODE_R='N'
 THEN 'N'
 ELSE NULL
 END AS TYPE_writer,
  CASE WHEN pac.DEB_RETRO IS NOT NULL AND TO_char(incidents.periode,'YYYYMM') < pac.PERIODEENCOURS
 THEN 'C' ELSE NULL
 END as ACTION_RETRO,
 CASE WHEN pac.DEB_RETRO IS NOT NULL AND TO_char(incidents.periode,'YYYYMM') < pac.PERIODEENCOURS
 THEN sysdate ELSE NULL
 END as ACTION_RETRO_DATE,
 'C' as DERNIER_CODE_OPE
 FROM
 (SELECT INCI.numpac              AS NUMPAC,          --numpac
 INCI.paiezad                   AS PAIEZAD,         --paiezad
 to_date(INCI.periode,'YYYYMM') AS PERIODE,         --periode
 INCI.type_traitement           AS TYPE_TRAITEMENT, --type_traitement
 CASE
 WHEN (INCI.heures_ip IS NOT NULL
 OR INCI.code_ip      IS NOT NULL )
 THEN DECODE (INCI.code_ip,'HP','T',
 (SELECT p.option_conserv_histo
 FROM TGE_REF_PRE p
 WHERE p.numpac     =inci.numpac
 AND p.code_incident=inci.code_ip
 ))
 WHEN INCI.type_heure IN ('T','R')
 THEN INCI.type_heure
 END AS type_ip ,--DIT 37186 type_ip
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN INCI.CODE_IP
 WHEN INCI.type_heure IN ('T','R')
 THEN DECODE ( INCI.TYPE_HEURE,'R','HT','HP')
 END                                           AS CODE_IP,  ---code_ip DIT 37186
 to_date(INCI.date_debut,'yyyymmdd')-1 +a.jour AS DATE_EFFET,--date effet
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.code_ip     IS NOT NULL
 AND INCI.domaine_imp ='1'
 THEN INCI.code_imputation
 WHEN INCI.type_heure IN ('T','R')
 AND INCI.domaine_imp  ='H'
 THEN INCI.code_imputation
 END AS code_imputation,-- code_imputation DIT 37186
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN is_number(INCI.heures_ip)
 WHEN INCI.type_heure IN ('T','R')
 THEN is_number(INCI.heures_trav)
 END          AS heures,       -- heures DIT 37186
 INCI.origine AS ORIGINE,      --origine
 INCI.LOGIN   AS LOGIN_CREATE, --login create
 sysdate      AS DATE_CREATE,  --date_create
 P_ROLE       AS ROLE_CREATE,
 P_ORIGINE    AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create
 INCI.LOGIN   AS LOGIN_MAJ,      --login maj
 sysdate      AS DATE_MAJ,       -- date_maj
 P_ROLE       AS ROLE_MAJ,
 P_ORIGINE    AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 CASE
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN
 (SELECT id
 FROM tge_absences
 WHERE cle_import =P_LOGIN
 ||'#'
 ||INCI.DATE_IMPORT
 ||'#'
 ||INCI.NUMLIGNE
 )
 WHEN INCI.type_heure IN ('T','R')
 THEN NULL
 END AS CLE_ABSENCE ,--cleAbsence
 CASE
 WHEN INCI.NUMPAC IS NOT NULL
 AND INCI.PACMAT  IS NOT NULL
 THEN RPAD(INCI.NUMPAC,6)
 || INCI.PACMAT
 ELSE ' '
 END  AS IDPACMAT, --idpacmat
 NULL AS ENVOYE    --envoye
 FROM TGE_IMPORT_INCIDENTS INCI,
 -- FVI modif GTA_PAR_ANNEE
 (
 SELECT LEVEL "JOUR" FROM dual CONNECT BY LEVEL <=
 (SELECT MAX(to_number(to_date(date_fin,'YYYYMMDD') - to_date(date_debut,'YYYYMMDD') )) + 1
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN    =P_LOGIN
 AND DATE_IMPORT=P_DATE_IMPORT
 AND ((ERREURS IS NULL
 AND STATUT     = 'TRAIT')
 OR (ERREURS   IS NULL
 AND STATUT     = 'TRANS'))
 )
 ) a
 WHERE INCI.LOGIN                                      =P_LOGIN
 AND INCI.DATE_IMPORT                                  =P_DATE_IMPORT
 AND IS_DATE(INCI.date_debut,'yyyymmdd')               =1
 AND IS_DATE(INCI.date_fin,'yyyymmdd')                 =1
 AND (to_date(INCI.date_debut,'yyyymmdd')-1 + a.jour )<=to_date(INCI.date_fin,'yyyymmdd')
 AND ((INCI.ERREURS                                   IS NULL
 AND INCI.STATUT                                       = 'TRAIT')
 OR (INCI.ERREURS                                     IS NULL
 AND INCI.STATUT                                       = 'TRANS'))
 UNION ALL
 SELECT INCI.numpac               AS NUMPAC,          --numpac
 INCI.paiezad                   AS PAIEZAD,         --paiezad
 to_date(INCI.periode,'YYYYMM') AS PERIODE,         --periode
 INCI.type_traitement           AS TYPE_TRAITEMENT, --type_traitement
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN INCI.type_heure
 WHEN (INCI.heures_ip IS NOT NULL
 OR INCI.code_ip      IS NOT NULL )
 THEN DECODE (INCI.code_ip,'HP','T',
 (SELECT p.option_conserv_histo
 FROM TGE_REF_PRE p
 WHERE p.numpac     =inci.numpac
 AND p.code_incident=inci.code_ip
 ))
 END AS type_ip ,--DIT 37186 type_ip
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN DECODE ( INCI.TYPE_HEURE,'R','HT','HP')
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN INCI.CODE_IP
 END                                           AS CODE_IP,  ---code_ip DIT 37186
 to_date(INCI.date_debut,'yyyymmdd')-1 +a.jour AS DATE_EFFET,--date effet
 CASE
 WHEN INCI.type_heure IN ('T','R')
 AND INCI.domaine_imp  ='H'
 THEN INCI.code_imputation
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.code_ip     IS NOT NULL
 AND INCI.domaine_imp ='1'
 THEN INCI.code_imputation
 END AS code_imputation,-- code_imputation DIT 37186
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN is_number(INCI.heures_trav)
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN is_number(INCI.heures_ip)
 END          AS heures,       -- heures DIT 37186
 INCI.origine AS ORIGINE,      --origine
 INCI.LOGIN   AS LOGIN_CREATE, --login create
 sysdate      AS DATE_CREATE,  --date_create
 P_ROLE       AS ROLE_CREATE,
 P_ORIGINE    AS ORIGINE_CREATE, --'IMPORT_INCIDENT',--origine_create
 INCI.LOGIN   AS LOGIN_MAJ,      --login maj
 sysdate      AS DATE_MAJ,       -- date_maj
 P_ROLE       AS ROLE_MAJ,
 P_ORIGINE    AS ORIGINE_MAJ,--'IMPORT_INCIDENT',--origine_maj
 P_LOGIN
 || '#'
 ||INCI.DATE_IMPORT
 || '#'
 ||INCI.NUMLIGNE AS CLE_IMPORT,--cle_import
 CASE
 WHEN INCI.type_heure IN ('T','R')
 THEN NULL
 WHEN INCI.heures_ip IS NOT NULL
 OR INCI.CODE_IP     IS NOT NULL
 THEN
 (SELECT id
 FROM tge_absences
 WHERE cle_import =P_LOGIN
 ||'#'
 ||INCI.DATE_IMPORT
 ||'#'
 ||INCI.NUMLIGNE
 )
 END AS CLE_ABSENCE ,--cleAbsence
 CASE
 WHEN INCI.NUMPAC IS NOT NULL
 AND INCI.PACMAT  IS NOT NULL
 THEN RPAD(INCI.NUMPAC,6)
 || INCI.PACMAT
 ELSE ' '
 END  AS IDPACMAT, --idpacmat
 NULL AS ENVOYE    --envoye
 FROM TGE_IMPORT_INCIDENTS INCI,
 -- FVI modif GTA_PAR_ANNEE
 (
 SELECT LEVEL "JOUR" FROM dual CONNECT BY LEVEL <=
 (SELECT MAX(to_number(to_date(date_fin,'YYYYMMDD') - to_date(date_debut,'YYYYMMDD') )) + 1
 FROM TGE_IMPORT_INCIDENTS
 WHERE LOGIN    =P_LOGIN
 AND DATE_IMPORT=P_DATE_IMPORT
 AND ((ERREURS IS NULL
 AND STATUT     = 'TRAIT')
 OR (ERREURS   IS NULL
 AND STATUT     = 'TRANS'))
 )
 ) a
 WHERE INCI.LOGIN                                      =P_LOGIN
 AND INCI.DATE_IMPORT                                  =P_DATE_IMPORT
 AND IS_DATE(INCI.date_debut,'yyyymmdd')               =1
 AND IS_DATE(INCI.date_fin,'yyyymmdd')                 =1
 AND (to_date(INCI.date_debut,'yyyymmdd')-1 + a.jour )<=to_date(INCI.date_fin,'yyyymmdd')
 AND ( (INCI.heures_ip                                IS NOT NULL
 OR INCI.code_ip                                      IS NOT NULL)
 AND INCI.type_heure                                  IS NOT NULL)
 AND ((INCI.ERREURS                                   IS NULL
 AND INCI.STATUT                                       = 'TRAIT')
 OR (INCI.ERREURS                                     IS NULL
 AND INCI.STATUT                                       = 'TRANS'))
 )INCIDENTS,
 TGE_REF_PAC pac,
 TGE_REF_ORIGINE_GTA
 WHERE INCIDENTS.numpac=TGE_REF_ORIGINE_GTA.numpac
 AND INCIDENTS.ORIGINE =TGE_REF_ORIGINE_GTA.CODE_ORIGINE
 AND pac.numpac = incidents.numpac;
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := w_err||'  ' ||sqlerrm;
 FSED.FSED_ERREUR( id_trt , 'ValidIncidents' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
--UN TRAITEMENT DE PAIE EST EN COURS
 if(SQLCODE='-20000') then 
  doRollback:=true;
  GOTO end_proc;
 end if ;
 IF (P_LOGIN != 'BATCH') THEN
 -- On remonte l'erreur à l'application
 raise;
 END IF;
 END ;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_INCIDENTS_PAIE');
 SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','SAISIE_IND_INCIDENT',
 'CARTE=40&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE,
 'Import Batch 40','C',null,null,null,null);
 -- Mise à jour des lignes d'import qui sont encore en erreur après validation, statut prend TRANS
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,' UPDATE TGE_IMPORT_INCIDENTS');
 UPDATE TGE_IMPORT_INCIDENTS
 SET STATUT      ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND (ERREURS   IS NOT NULL
 AND STATUT      = 'TRAIT');
 
 IF INSTR(desactiveTraitements, 'TGE_REGROUPE_ABS') < 1 THEN
 	-- Regroupement des absences importé
 	TGE_REGROUPE_ABS(P_LOGIN||'#'||P_DATE_IMPORT);
 END IF;
 
 -- Mise à jour des lignes d'import qui ne sont plus en erreur après validation, statut prend FIN
 UPDATE TGE_IMPORT_INCIDENTS
 SET ERREURS     ='',
 STATUT        ='FIN'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ((ERREURS  IS NULL
 AND STATUT      = 'TRAIT')
 OR (ERREURS    IS NULL
 AND STATUT      = 'TRANS'));
 UPDATE TGE_IMPORT_LISTE
 SET NBLIGNES_ERR =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_ELEMENTS
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND ERREURS    IS NOT NULL
 ),
 NBLIGNES_IMP =
 (SELECT COUNT(*)
 FROM TGE_IMPORT_ELEMENTS
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 ),
 STATUT        ='TRANS'
 WHERE LOGIN     = P_LOGIN
 AND DATE_IMPORT = p_date_import
 AND TYPE        = 5;
 END IF;
 END IF ;

 v_stop := DBMS_UTILITY.GET_TIME;
 --DBMS_OUTPUT.PUT_LINE(((v_stop-v_start)*10) || ' ms');
 --FIXME utiliser la procédure trace_dbms_output()
 <<end_proc>> 
 if(doRollback) then
  ROLLBACK;
  if(P_WITH30=1) then
    UPDATE TGE_IMPORT_ELEMENTS
    SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
    WHERE LOGIN      = P_LOGIN
    AND DATE_IMPORT  = p_date_import ;
    end if;
  if(P_WITH40=1) then
    UPDATE TGE_IMPORT_INCIDENTS
    SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
    WHERE LOGIN      = P_LOGIN
    AND DATE_IMPORT  = p_date_import ;
  end if;
  if(P_WITH60=1 or P_WITH70=1) then
  UPDATE TGE_IMPORT_DONNEES
  SET ERREURS =TGE_GET_MESSAGE_ERREUR(ERREURS,replace(get_message_erreur('TGE','TGE00352',p_codlang),'',''),NULL,p_codlang)
  WHERE LOGIN      = P_LOGIN
  AND DATE_IMPORT  = p_date_import ;
  
  end if;
  TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Rollback de l''import suite à une détection d''un traitement de paie en cours.');
  FSED.FSED_ERREUR( id_trt , 'TGE3040' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , 'Une paie est en cours d''exécution.' );
 
  end if;

 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'fin TGE_IMPORT_3040 OK');
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := 'TGE3040 '||w_err|| sqlerrm;
 TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'fin TGE_IMPORT_3040 KO : '||w_err);
 FSED.FSED_ERREUR( id_trt , 'TGE3040' , P_LOGIN ||','|| P_DATE_IMPORT ||','|| P_ROLE ||','|| P_ORIGINE ||','|| P_VALIDATION||','|| P_WITH30 ||','|| P_WITH40 , w_err );
 raise;
 END TGE_IMPORT_3040;
##
SYS_VARSYS
==
DELETE SYS_VARSYS WHERE  MODULE='STD' and CODVAR='DESACTIVE_TRAITEMENTS_IMPORT_3040'
'STD','DESACTIVE_TRAITEMENTS_IMPORT_3040',NULL,'Texte','Liste des traitements de l''import 3040 à désactiver : - TGE_CONTROLE_40_CHEVAUCHEMENT: le traitement de contrôle de chevauchement des absences - TGE_REGROUPE_ABS : le traitement de regroupement des absences'
##
SYS_VARSYS
==
INSERT INTO SYS_VARSYS SELECT 'SYS', 'EMB_AOID_CREATION_ACTIVATED', 'true', 'Booleen', 'Indique si la création d''un AOID à l''embauche d''un nouveau salarié est activée. Cette VarSys ne doit être positionnée à false que si un autre traitement prend en charge cette création (contrainte GSO : un salarié dans le S.I. ADP = un AOID)' FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM SYS_VARSYS WHERE MODULE='SYS' AND CODVAR='EMB_AOID_CREATION_ACTIVATED')
##
DIC_ADM_CONTRAT
=SQL IFNOTEXIST=DIC_ADM_CONTRAT=TYPE_REEMBAUCHE=
ALTER TABLE DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE VARCHAR2(2)
##
DIC_ADM_CONTRAT
=SQL IFNOTEXIST=DIC_ADM_CONTRAT=TYPE_REEMBAUCHE_PREV=
ALTER TABLE DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE_PREV VARCHAR2(2)
##
PHOTO_DIC_ADM_CONTRAT
=SQL IFNOTEXIST=PHOTO_DIC_ADM_CONTRAT=TYPE_REEMBAUCHE=
ALTER TABLE PHOTO_DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE VARCHAR2(2)
##
PHOTO_DIC_ADM_CONTRAT
=SQL IFNOTEXIST=PHOTO_DIC_ADM_CONTRAT=TYPE_REEMBAUCHE_PREV=
ALTER TABLE PHOTO_DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE_PREV VARCHAR2(2)
##
PH_PH_DIC_ADM_CONTRAT
=SQL IFNOTEXIST=PH_PH_DIC_ADM_CONTRAT=TYPE_REEMBAUCHE=
ALTER TABLE PH_PH_DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE VARCHAR2(2)
##
PH_PH_DIC_ADM_CONTRAT
=SQL IFNOTEXIST=PH_PH_DIC_ADM_CONTRAT=TYPE_REEMBAUCHE_PREV=
ALTER TABLE PH_PH_DIC_ADM_CONTRAT ADD TYPE_REEMBAUCHE_PREV VARCHAR2(2)
##
DIC_GESTION_BACASABLE_POP
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE_POP AS
v_nbMatric NUMBER(10);
 BEGIN
 DELETE FROM CLE_BAC_A_SABLE;
 SELECT COUNT(MATRIC) into v_nbMatric from MATRIC_BAC_A_SABLE;
 IF v_nbMatric = 0 then
  INSERT INTO MATRIC_BAC_A_SABLE SELECT MATRIC FROM (select DISTINCT MATRIC from secupacmat ORDER BY MATRIC DESC) WHERE ROWNUM < 500;
 END IF;
 INSERT INTO CLE_BAC_A_SABLE (NUMPAC,PACMAT,PAIEZAD,MATRIC) SELECT DISTINCT DACH.NUMPAC,DACH.PACMAT,DACH.PAIEZAD,DACH.MATRIC FROM DIC_ADM_CONTRAT_HISTO DACH,MATRIC_BAC_A_SABLE WHERE DACH.MATRIC = MATRIC_BAC_A_SABLE.MATRIC;
 END DIC_GESTION_BACASABLE_POP;
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
DELETE FROM UX_EVENTS WHERE EVENT in ('/events/hr/v1/worker.work-assignment.assigned-work-location.change','/events/benefits/v1/benefit-coverages-enrollment.modify')
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
insert into UX_EVENTS values ('/events/hr/v1/worker.work-assignment.assigned-work-location.change','16','Modification du numéro de bureau',null,'Employee - Work Location','O')
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
insert into UX_EVENTS values ('/events/benefits/v1/benefit-coverages-enrollment.modify','130','Souscription à une mutuelle','55300','Employee - Benefit Coverages','O')
##
UX_EVENTS (EVENT,EVENT_ID,LIBELLE,OP_NUM,UX_EVENTNAME,IS_NOTIFICATION)
=SQL IFEXIST=UX_EVENTS=
DELETE FROM UX_EVENTS WHERE EVENT IN ('/events/hr/v1/worker.immigration-document.remove','/events/hr/v1/worker.immigration-document.add','/events/hr/v1/worker.immigration-document.change')
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
insert into UX_EVENTS values ('/events/hr/v1/worker.immigration-document.remove',NULL,'suppression Carte salarié étranger','40203',NULL,NULL)
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
insert into UX_EVENTS values ('/events/hr/v1/worker.immigration-document.add',NULL,'ajout Carte salarié étranger','40203',NULL,NULL)
##
UX_EVENTS
=SQL IFEXIST=UX_EVENTS=
insert into UX_EVENTS values ('/events/hr/v1/worker.immigration-document.change',NULL,'Modification Carte salarié étranger','40203',NULL,NULL)
##
MP_EVENTS
=SQL IFEXIST=DEX_EVENTS=
RENAME DEX_EVENTS TO MP_EVENTS
##
TAG_CHARSET=@€éèç
##
MP_MAPPING_EVENT_DATA
=SQL IFEXIST=DEX_MAPPING_EVENT_DATA=
RENAME DEX_MAPPING_EVENT_DATA TO MP_MAPPING_EVENT_DATA
##
TAG_CHARSET=@€éèç
##
MP_REFERENTIEL
=SQL IFEXIST=DEX_REFERENTIEL=
RENAME DEX_REFERENTIEL TO MP_REFERENTIEL
##
TAG_CHARSET=@€éèç
##
MP_REF_EVENTS
=SQL IFEXIST=UX_EVENTS=
RENAME UX_EVENTS TO MP_REF_EVENTS
##
TGE_CREATE_TRIGGER_MP_NOTIF
=SQL=
CREATE OR REPLACE FUNCTION TGE_CREATE_TRIGGER_MP_NOTIF(NOM_TABLE IN VARCHAR2, VAR_OR_BODY IN VARCHAR2 DEFAULT 'BODY')
RETURN CLOB
AS
  v_retour CLOB;

  v_typeTable VARCHAR(1);
  date_eff_exists NUMBER;
  PROC_DEX_UPDATING CLOB;
  PROC_DEX_UPDATING_TMP CLOB;
  PROC_DEX_CONDITION CLOB;
  v_existeDonneeDex boolean;
  v_eventDexPrec VARCHAR(100);
  v_cleSecondaireDex VARCHAR(200);
  v_action_acr varchar2(3);
  v_event_sans_acr MP_MAPPING_EVENT_DATA.EVENT%TYPE; 
  v_condition_acr_old_vide CLOB;
  v_condition_acr_new_vide CLOB;
  v_condition_donnee CLOB;
  v_condition_donnee_sql CLOB;
  -- Ce tableau indexé contient l'association entre un couple NOM_DONNEE/EVENT et le SOUS_EVENT à générer
  TYPE T_MAPPING_SPECIF_SOUS_EVENT IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(150);
  mappingSubEventByEventAndData T_MAPPING_SPECIF_SOUS_EVENT;
  -- Ce tableau indexé contient l'association entre un SOUS_EVENT et le IF qui conditionne sa génération
  TYPE T_SUB_EVENT_CONDITION IS TABLE OF CLOB INDEX BY VARCHAR2(100);
  subEventToGenWithCond T_SUB_EVENT_CONDITION;
  subEventToGen VARCHAR2(100);
  -- Ce tableau indexé contient l'association entre un EVENT et la liste des SOUS_EVENT de cet EVENT, et le IF qui conditionne sa génération
  TYPE T_SUB_EVENT_CONDITION_BY_EVENT IS TABLE OF T_SUB_EVENT_CONDITION INDEX BY VARCHAR2(100);
  subEventToGenWithCondByEvent T_SUB_EVENT_CONDITION_BY_EVENT;
  -- Ce tableau indexé contient l'association entre un couple EVENT(de type ACR)/CONDITION et la clause SQL de cette condition
  TYPE T_CONDITION_EVENT_ACR IS TABLE OF CLOB INDEX BY VARCHAR2(4000);
  conditionForEventAcr T_CONDITION_EVENT_ACR;

  CURSOR cur_donneesDex IS
    SELECT DISTINCT DMED.EVENT, RDMU.NOM_DONNEE, RDMU.CONDITION, DMED.NOM_DONNEE_DEX_OU_EVENT, LTRIM(REGEXP_SUBSTR(DMED.EVENT, '\.[acr]{1,3}$'),'.') ACTION_ACR, REGEXP_REPLACE(DMED.EVENT, '\.[acr]{1,3}$','') EVENT_SANS_ACR 
    FROM MP_MAPPING_EVENT_DATA DMED, REF_DONNEE_MAPPING_UX RDMU, REF_DONNEE_GEN_MODEL RDGM 
    WHERE 
      DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX 
      AND RDMU.NOM_DONNEE=RDGM.NOM_DONNEE 
      AND DMED.UTILISE_TRIGGER='O' 
      AND DMED.TYPE='D' 
      AND RDGM.NOM_DICTIONNAIRE=NOM_TABLE 
    ORDER BY DMED.EVENT, RDMU.NOM_DONNEE;
  lig_donneeDex cur_donneesDex%rowtype;

  CURSOR cur_eventsDex IS
    SELECT DISTINCT DMED.EVENT, RDMU.CONDITION, LTRIM(REGEXP_SUBSTR(DMED.EVENT, '\.[acr]{1,3}$'),'.') ACTION_ACR, REGEXP_REPLACE(DMED.EVENT, '\.[acr]{1,3}$','') EVENT_SANS_ACR 
    FROM MP_MAPPING_EVENT_DATA DMED, REF_DONNEE_MAPPING_UX RDMU, REF_DONNEE_GEN_MODEL RDGM 
    WHERE 
      DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX 
      AND RDMU.NOM_DONNEE=RDGM.NOM_DONNEE 
      AND DMED.UTILISE_TRIGGER='O' 
      AND DMED.TYPE='D' 
      AND RDGM.NOM_DICTIONNAIRE=NOM_TABLE;
  lig_eventDex cur_eventsDex%rowtype;

  CURSOR cur_subEventsDex IS
    SELECT NOM_DONNEE, EVENT, SOUS_EVENT
    FROM MP_SPECIF_MAP_SOUS_EVENT_DATA
    WHERE 
      NOM_DONNEE IN (
        SELECT COLUMN_NAME 
        FROM USER_TAB_COLS 
        WHERE TABLE_NAME=NOM_TABLE
      );
  lig_subEventDex cur_subEventsDex%rowtype;

BEGIN
  v_retour := NULL;

  -- On vérifie si la table va générer des évènements pour DEX (au moins une donnée mappée, ou dictionnaire DIC_ADM_CONTRAT qui gère l'embauche et le départ)
  IF nom_table='DIC_ADM_CONTRAT' THEN
    v_existeDonneeDex := TRUE;
  ELSE
    OPEN cur_donneesDex;
    LOOP FETCH cur_donneesDex INTO lig_donneeDex ;
      EXIT WHEN cur_donneesDex%NOTFOUND OR v_existeDonneeDex;
      v_existeDonneeDex := true;
    END LOOP;
    CLOSE cur_donneesDex;
  END IF;

  IF NOT v_existeDonneeDex THEN
    RETURN NULL;
  END IF;

IF VAR_OR_BODY = 'VAR' THEN

  v_retour := v_retour||'
-- DEBUT VARIABLES DEX
v_dexaction varchar2(1);
v_dexCleSecondaire VARCHAR2(100);
exist_contrat_for_matric NUMBER ;
TYPE eventsTabType is  table of MP_EVENTS%ROWTYPE ;
eventsTab eventsTabType := eventsTabType();
TYPE subEventsTabType is  table of MP_SPECIF_SOUS_EVENT%ROWTYPE ;
subEventsTab subEventsTabType := subEventsTabType();
v_processEventDex boolean;
v_processEventDexTypeAcr varchar2(3);
v_toutesLesNouvelleValVides boolean;
v_toutesLesAnciennesValVides boolean;
';

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    v_retour := v_retour||'
v_ligDACHPrec DIC_ADM_CONTRAT_HISTO%ROWTYPE;
';
  END IF;

  v_retour := v_retour||'
-- FIN VARIABLES DEX
';

ELSE

  v_retour := v_retour||'
-- DEBUT TRAITEMENT DEX
';

  v_typeTable := fsed.getTypeTable(NOM_TABLE);

  date_eff_exists := 0;
  IF nom_table <> 'DIC_ADM_PERSO' AND nom_table <> 'DIC_ADM_CONTRAT' THEN
    SELECT COUNT(*)
    INTO date_eff_exists
    FROM user_tab_cols
    WHERE column_name     = 'DATE_EFF'
    AND table_name        = NOM_TABLE;
  END IF;

  -- Au moins une donnée DEX = on va vérifier si le traitement pour DEX doit être effectué
  IF date_eff_exists>0 THEN
    -- Date d'effet = traitement DEX seulement si modification à date du jour ou dans le futur (à revoir pour DACH ?)
    v_retour := v_retour||' 
IF TRUNC(SYSDATE,''dd'') <= nvl(:NEW.DATE_FIN,:OLD.DATE_FIN) THEN
';
  END IF;
  -- Si traitement DEX sur une table de type PAIEZAD ou PACMAT, si on n'a pas de MATRIC, on le récupère
  IF v_typeTable ='z' THEN
    v_retour := v_retour||' 
IF v_matric IS NULL THEN
 SELECT MAX(MATRIC) INTO v_matric FROM DIC_ADM_CONTRAT_SITU WHERE NUMPAC=v_numpac AND PAIEZAD=v_paiezad; 
END IF;
';
  ELSIF v_typeTable ='p' THEN
    v_retour := v_retour||' 
IF v_matric IS NULL THEN
 BEGIN
  SELECT MATRIC INTO v_matric FROM SECUPACMAT WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat;
 EXCEPTION 
  WHEN NO_DATA_FOUND THEN NULL; 
 END;
END IF;
';
  END IF;

  -- Le traitement en lui-même : certains évènements nécessitent d'avoir une clé secondaire spécifique, sinon on positionne '*'
  v_cleSecondaireDex := '''*''';

  -- On boucle sur les données générant un sous-événement (paramétrage spécifique)
  OPEN cur_subEventsDex;
  LOOP FETCH cur_subEventsDex INTO lig_subEventDex ;
    EXIT WHEN cur_subEventsDex%NOTFOUND;
    mappingSubEventByEventAndData(lig_subEventDex.NOM_DONNEE||'#'||lig_subEventDex.EVENT) := lig_subEventDex.SOUS_EVENT;
  END LOOP;
  CLOSE cur_subEventsDex;

  -- On boucle sur les données de l'évènement afin de calculer la CLE_SECONDAIRE si besoin 
  -- On en profite pour construire une partir du code de la partie UPDATING
  OPEN cur_donneesDex;
  LOOP FETCH cur_donneesDex INTO lig_donneeDex ;
    IF v_eventDexPrec IS NULL AND cur_donneesDex%NOTFOUND THEN
      PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
NULL;
';
    ELSIF v_eventDexPrec IS NOT NULL AND (cur_donneesDex%NOTFOUND OR NOT v_eventDexPrec=lig_donneeDex.EVENT) THEN
      -- Dernière donnée pour l'event
      PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
-- gestion evenement dex ' || v_eventDexPrec || '
v_processEventDex := FALSE; 
';
      IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF UPDATING THEN
';
      END IF;

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF FALSE THEN -- DEBUT :NEW<>:OLD
 NULL;
'||PROC_DEX_UPDATING_TMP||' 
END IF; -- FIN :NEW<>:OLD
';

      IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
        -- Pour DIC_ADM_CONTRAT_HISTO, on gère :
        -- - L'UPDATE, en comparant NEW et OLD
        -- - L'INSERT, en comparant NEW et v_ligDACHPrec
        -- - L'UPDATE, en comparant v_ligDACHPrec et OLD
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF INSERTING THEN
 IF FALSE THEN -- DEBUT :NEW<>:OLD
  NULL;
 '||REPLACE(PROC_DEX_UPDATING_TMP,':OLD.','v_ligDACHPrec.')||' 
 END IF; -- FIN :NEW<>:OLD
ELSIF DELETING THEN
 IF FALSE THEN -- DEBUT :NEW<>:OLD
  NULL;
 '||REPLACE(PROC_DEX_UPDATING_TMP,':NEW.','v_ligDACHPrec.')||' 
 END IF; -- FIN :NEW<>:OLD
END IF; -- FIN UPDATING / INSERTING / DELETING
';
      END IF;

      conditionForEventAcr(v_eventDexPrec||'#'||v_condition_donnee||'#OLD') := v_condition_acr_old_vide;
      conditionForEventAcr(v_eventDexPrec||'#'||v_condition_donnee||'#NEW') := v_condition_acr_new_vide;

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF v_processEventDex THEN
';

      IF v_action_acr IS NULL THEN
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
eventsTab.EXTEND ;
eventsTab(eventsTab.LAST).EVENT :='''||v_eventDexPrec||''';
eventsTab(eventsTab.LAST).ACTION :=''M'';
';
      ELSE
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
v_toutesLesAnciennesValVides := '||v_condition_acr_old_vide||v_condition_donnee_sql||';
v_toutesLesNouvelleValVides := '||v_condition_acr_new_vide||v_condition_donnee_sql||';
IF FALSE THEN
 v_processEventDex := FALSE; 
';
        IF INSTR(v_action_acr,'a') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF v_toutesLesAnciennesValVides AND NOT v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.add''; -- gestion add
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'a'

        IF INSTR(v_action_acr,'c') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF NOT v_toutesLesAnciennesValVides AND NOT v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.change''; -- gestion change
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'c'

        IF INSTR(v_action_acr,'r') > 0 THEN
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
ELSIF NOT v_toutesLesAnciennesValVides AND v_toutesLesNouvelleValVides THEN
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := ''' || v_event_sans_acr || '.remove'';  -- gestion remove
 eventsTab(eventsTab.LAST).ACTION :=''M'';
';
        END IF; -- FIN v_action_acr = 'r'

        PROC_DEX_UPDATING := PROC_DEX_UPDATING||' 
ELSE
 v_processEventDex := FALSE;
END IF;
';
      END IF; -- FIN v_action_acr IS NULL

      -- On boucle sur les sous-événements à générer (paramétrage spécifique)
      subEventToGen := subEventToGenWithCond.first;
      LOOP
        EXIT WHEN subEventToGen IS NULL;
        -- On concatène la condition, puis le sous-événements (si la condition est vérifiée)
        PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
IF v_processEventDex AND '; 

        IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
          -- Pour DIC_ADM_CONTRAT_HISTO, on gère :
          -- - L'UPDATE, en comparant NEW et OLD
          -- - L'INSERT, en comparant NEW et v_ligDACHPrec
          -- - L'UPDATE, en comparant v_ligDACHPrec et OLD
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||'( (UPDATING AND ('||subEventToGenWithCond(subEventToGen)||')) OR (INSERTING AND ('||REPLACE(subEventToGenWithCond(subEventToGen),':OLD.','v_ligDACHPrec.')||')) OR (DELETING AND ('||REPLACE(subEventToGenWithCond(subEventToGen),':NEW.','v_ligDACHPrec.')||')) )';
        ELSE
          PROC_DEX_UPDATING := PROC_DEX_UPDATING||' ('||subEventToGenWithCond(subEventToGen)||') ';
        END IF;

        PROC_DEX_UPDATING := PROC_DEX_UPDATING||' THEN 
 subEventsTab.EXTEND;
 subEventsTab(subEventsTab.LAST).EVENT := eventsTab(eventsTab.LAST).EVENT; 
 subEventsTab(subEventsTab.LAST).SOUS_EVENT :='''||subEventToGen||''';
END IF; -- FIN test génération sous-événement
';
        subEventToGen := subEventToGenWithCond.next(subEventToGen);
      END LOOP;

      PROC_DEX_UPDATING := PROC_DEX_UPDATING||'
END IF; -- FIN v_processEventDex
';

      -- On vide le tableau pour recommencer un nouvel événément (on le sauvegarde avant, en l'associant à l'event)
      subEventToGenWithCondByEvent(v_eventDexPrec) := subEventToGenWithCond;
      subEventToGenWithCond.delete;
    END IF;

    -- Traitement spécifique à certains évènements qui stocke une CLE_SECONDAIRE
    IF nom_table ='DIC_ADM_CONTRAT' THEN
      -- Si le nom de table est DIC_ADM_CONTRAT on stocke la date de début de contrat (DSDCN) dans la colonne CLE_SECONDAIRE 
      v_cleSecondaireDex := '''DSDCN;'' || TO_CHAR(nvl(:NEW.DSDCN, :OLD.DSDCN), ''YYYY-MM-DD'')';

    ELSIF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
      -- Si le nom de table est DIC_ADM_CONTRAT_HISTO on stocke la date d'effet (DATE_EFF) dans la colonne CLE_SECONDAIRE 
      v_cleSecondaireDex := '''DATE_EFF;''|| TO_CHAR(nvl(:NEW.DATE_EFF, :OLD.DATE_EFF), ''YYYY-MM-DD'')';

    END IF;

    EXIT WHEN cur_donneesDex%NOTFOUND;

    IF v_eventDexPrec IS NULL OR NOT v_eventDexPrec=lig_donneeDex.EVENT THEN
      -- Première donnée pour l'event
      v_action_acr := lig_donneeDex.ACTION_ACR;
      v_event_sans_acr := lig_donneeDex.EVENT_SANS_ACR;
      PROC_DEX_UPDATING_TMP := NULL;
      v_condition_acr_old_vide := null;
      v_condition_acr_new_vide := null;
    END IF;

    -- Traitement spécifique à certains évènements qui stocke une CLE_SECONDAIRE
    IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'precedenceOrdCompteBancaire' THEN
      -- BANQUE : On parcourt les données de l'event et trouver celle qui correspond à la cle dont on a besoin
      v_cleSecondaireDex := 'nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||')';

    ELSIF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentConjointBirthOrder' THEN
      -- CONJOINT : Dans le cas où une donnée 'dependentConjointBirthOrder' a été paramétrée, 
      -- c'est cette valeur qui va être prise
      v_cleSecondaireDex := '''C;''||nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||')';

    ELSIF INSTR(lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT, 'dependentConjoint') = 1 AND INSTR(v_cleSecondaireDex, 'C;') = 0 THEN
      -- CONJOINT : La première fois que l'on trouve une donnée commençant par 'dependentConjoint', on positionne la clé secondaire
      -- avec comme valeur "01" pour le "BirthOrder"
      v_cleSecondaireDex := '''C;01''';

    ELSIF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' OR lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthDate' THEN
      -- ENFANT : La clé secondaire pour les enfants est composée de 2 éléments à mettre dans un certain ordre : E;BirthOrder;BirthDate
      IF v_cleSecondaireDex = '''*''' THEN
        IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' THEN
          v_cleSecondaireDex := '''E;''||nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||')';
        ELSE
          v_cleSecondaireDex := '||TO_CHAR(nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||'), ''YYYY-MM-DD'')';
        END IF;
      ELSE
        IF lig_donneeDex.NOM_DONNEE_DEX_OU_EVENT = 'dependentEnfantBirthOrder' THEN
          v_cleSecondaireDex := '''E;''||nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||')||'';''' || v_cleSecondaireDex;
        ELSE
          v_cleSecondaireDex := v_cleSecondaireDex || '||'';''||TO_CHAR(nvl(:NEW.'||lig_donneeDex.NOM_DONNEE||', :OLD.'||lig_donneeDex.NOM_DONNEE||'), ''YYYY-MM-DD'')';
        END IF;
      END IF;
    END IF;

    PROC_DEX_CONDITION := '(:NEW.'||lig_donneeDex.NOM_DONNEE||'<>:OLD.'||lig_donneeDex.NOM_DONNEE||' OR (:NEW.'||lig_donneeDex.NOM_DONNEE||' IS NOT NULL AND :OLD.'||lig_donneeDex.NOM_DONNEE||' IS NULL) OR (:NEW.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND :OLD.'||lig_donneeDex.NOM_DONNEE||' IS NOT NULL))';
    v_condition_donnee_sql := '1=1';
    v_condition_donnee := lig_donneeDex.CONDITION;
    IF v_condition_donnee IS NOT NULL THEN
      v_condition_donnee_sql := regexp_replace(regexp_replace(v_condition_donnee, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(:new.\1,:old.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(:new.\2,:old.\2)=\1');
      PROC_DEX_CONDITION := PROC_DEX_CONDITION||' AND '||v_condition_donnee_sql;
    END IF;

    PROC_DEX_UPDATING_TMP :=PROC_DEX_UPDATING_TMP||'
ELSIF '||PROC_DEX_CONDITION||' THEN
v_processEventDex := TRUE;
';

    v_condition_acr_old_vide := v_condition_acr_old_vide||':OLD.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND ';
    v_condition_acr_new_vide := v_condition_acr_new_vide||':NEW.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND ';

    IF mappingSubEventByEventAndData.exists(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT) THEN
      IF NOT subEventToGenWithCond.exists(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) THEN
        subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) := '1=2';
      END IF;
      subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT)) := subEventToGenWithCond(mappingSubEventByEventAndData(lig_donneeDex.NOM_DONNEE||'#'||lig_donneeDex.EVENT))||' OR ('||PROC_DEX_CONDITION||') ';
    END IF;

    v_eventDexPrec:=lig_donneeDex.EVENT;
  END LOOP;
  CLOSE cur_donneesDex;        

  v_retour := v_retour||' 
v_dexCleSecondaire := '||v_cleSecondaireDex||';
eventsTab.delete;
subEventsTab.delete;
';

  IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
    -- Pour DIC_ADM_CONTRAT_HISTO :
    -- - On considère un INSERT comme un UPDATE dont le OLD est la ligne précédente
    -- - On considère un DELETE comme un UPDATE dont le NEW est la ligne précédente
    v_retour := v_retour||'
IF INSERTING OR DELETING THEN
 v_ligDACHPrec := GET_CONTRAT_HISTO_HORS_TRANSAC(v_numpac, NVL(:NEW.PACMAT,:OLD.PACMAT), NVL(:NEW.NUMCNT,:OLD.NUMCNT), NVL(:NEW.DATE_EFF,:OLD.DATE_EFF)-1, TRUE);
END IF;
IF UPDATING OR v_ligDACHPrec.NUMPAC IS NOT NULL THEN
';
  ELSIF nom_table   ='DIC_ADM_CONTRAT' THEN
    -- Pour DIC_ADM_CONTRAT, on gère en spécifique 
    -- - La création --> Evènement worker.hire ou worker.rehire
    -- - La suppression --> Evènement worker.terminate ???
    -- - La mise à jour de DSFCN --> Evènement worker.terminate (ou autre pour la modification ou l'annulation de départ ???)
    v_retour := v_retour||' 
IF INSERTING THEN
 -- On vérifie si c''est une embauche ou bien réembauche : s''il existe déja  un contrat pour le MATRIC c''est un réembauche. 
 exist_contrat_for_matric := COUNT_CONTRAT_HORS_TRANSAC ( v_matric ) ;
 IF exist_contrat_for_matric>0 THEN
  -- Réembauche  --> Evénement worker.rehire
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.rehire'';
  eventsTab(eventsTab.LAST).ACTION :=''Z''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:NEW.DSDCN;
 ELSE
  --  Embauche -->  Evénement worker.hire
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.hire'';
  eventsTab(eventsTab.LAST).ACTION :=''Z''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:NEW.DSDCN;
 END IF ;
ELSIF DELETING THEN
 exist_contrat_for_matric := COUNT_CONTRAT_HORS_TRANSAC ( v_matric ) ;
 IF exist_contrat_for_matric>1 THEN
  -- Annulation Réembauche  --> Evénement workerRehire.cancel 
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerRehire.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:OLD.DSDCN;
 ELSE
  -- Annulation Embauche -->  Evénement workerHire.cancel
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerHire.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:OLD.DSDCN;
 END IF ;
ELSIF :NEW.DSFCN<>:OLD.DSFCN OR (:NEW.DSFCN IS NOT NULL AND :OLD.DSFCN IS NULL) OR (:NEW.DSFCN IS NULL AND :OLD.DSFCN IS NOT NULL) THEN
 IF :NEW.DSFCN IS NOT NULL AND :OLD.DSFCN IS NULL THEN
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.terminate'';
  eventsTab(eventsTab.LAST).ACTION :=''M''; 
  -- On n''envoie le départ que le jour où il devient effectif
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:NEW.DSFCN;
 ELSIF :NEW.DSFCN<>:OLD.DSFCN THEN 
  -- mise à jour de DSFCN --> EVENEMENT worker.workerTerminationDate.change
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''worker.workerTerminationDate.change'';
  eventsTab(eventsTab.LAST).ACTION :=''M'';
  -- On garde la date de départ initiale comme date d''envoi de la notif, comme ça le partenaire aura le départ et la modif de départ en même temps
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:OLD.DSFCN;
 ELSIF :NEW.DSFCN IS NULL AND :OLD.DSFCN IS NOT NULL THEN
 -- Annulation Départ --> EVENEMENT workerTermination.cancel 
  eventsTab.EXTEND ;
  eventsTab(eventsTab.LAST).EVENT :=''workerTermination.cancel'';
  eventsTab(eventsTab.LAST).ACTION :=''S''; 
  -- On garde la date de départ initiale comme date d''envoi de la notif, comme ça le partenaire aura le départ et l''annulation de départ en même temps
  eventsTab(eventsTab.LAST).DATE_ENVOI_MIN :=:OLD.DSFCN;
 ELSE
  NULL;
 END IF;
ELSE
';
  ELSE
    -- Partie insert pour les autres tables
    -- Pour les autres tables, en création et suppression, on insère une ligne par évènement potentiellement généré par la table, avec le bon code action
    v_retour := v_retour||' 
-- DEBUT INSERTING / DELETING
IF INSERTING OR DELETING THEN
 IF INSERTING THEN
  v_dexaction := ''C'';
 ELSE
  v_dexaction := ''S'';
 END IF;
';

    OPEN cur_eventsDex;
    LOOP FETCH cur_eventsDex INTO lig_eventDex ;
      EXIT WHEN cur_eventsDex%NOTFOUND;
      v_retour := v_retour||'-- gestion evenement dex ' || lig_eventDex.EVENT || '
';
      v_action_acr := lig_eventDex.ACTION_ACR;
      v_condition_donnee_sql := '1=1';
      IF lig_eventDex.CONDITION IS NOT NULL THEN
        v_condition_donnee_sql := regexp_replace(regexp_replace(lig_eventDex.CONDITION, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(:new.\1,:old.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(:new.\2,:old.\2)=\1');
        v_retour := v_retour||'
IF '||v_condition_donnee_sql||' THEN
';
      END IF;

      v_retour := v_retour||'
v_processEventDex := FALSE;
v_toutesLesAnciennesValVides := '||conditionForEventAcr(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#OLD')||'1=1;
v_toutesLesNouvelleValVides := '||conditionForEventAcr(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#NEW')||'1=1;
';
      IF v_action_acr IS NULL THEN
        v_retour := v_retour||'
IF (INSERTING AND NOT v_toutesLesNouvelleValVides) OR (DELETING AND NOT v_toutesLesAnciennesValVides) THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT :='''||lig_eventDex.EVENT||''';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction;
END IF; 
';
      ELSIF conditionForEventAcr.exists(lig_eventDex.EVENT||'#'||lig_eventDex.CONDITION||'#OLD') THEN
        v_retour := v_retour||'
IF FALSE THEN NULL; 
';

        IF INSTR(v_action_acr,'a') > 0 THEN
          v_retour := v_retour||'
ELSIF INSERTING AND NOT v_toutesLesNouvelleValVides THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := '''||lig_eventDex.EVENT_SANS_ACR||'.add'';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction; 
';
        END IF; -- FIN v_action_acr = 'a'

        IF INSTR(v_action_acr,'r') > 0 THEN
          v_retour := v_retour||'
ELSIF DELETING AND NOT v_toutesLesAnciennesValVides THEN
 v_processEventDex := TRUE;
 eventsTab.EXTEND ;
 eventsTab(eventsTab.LAST).EVENT := '''||lig_eventDex.EVENT_SANS_ACR||'.remove'';
 eventsTab(eventsTab.LAST).ACTION :=v_dexaction; 
';
        END IF; -- FIN v_action_acr = 'r'

        v_retour := v_retour||'
END IF;
';
      END IF;

      IF lig_eventDex.CONDITION IS NOT NULL THEN
        v_retour := v_retour||'
END IF; -- FIN '||v_condition_donnee_sql||'
';
      END IF;

      IF subEventToGenWithCondByEvent.exists(lig_eventDex.EVENT) THEN
        subEventToGenWithCond := subEventToGenWithCondByEvent(lig_eventDex.EVENT);
        -- On boucle sur les sous-événements à générer (paramétrage spécifique) pour l'événement courant
        subEventToGen := subEventToGenWithCond.first;
        LOOP
          EXIT WHEN subEventToGen IS NULL;
          -- On concatène la condition, puis le sous-événements (si la condition est vérifiée)
          v_retour := v_retour||'
IF v_processEventDex AND ('||subEventToGenWithCond(subEventToGen)||') THEN
 subEventsTab.EXTEND;
 subEventsTab(subEventsTab.LAST).EVENT := eventsTab(eventsTab.LAST).EVENT; 
 subEventsTab(subEventsTab.LAST).SOUS_EVENT :='''||subEventToGen||''';
END IF;
';
          subEventToGen := subEventToGenWithCond.next(subEventToGen);
        END LOOP;
      END IF;
    END LOOP;
    CLOSE cur_eventsDex;
    v_retour := v_retour||'
-- FIN INSERTING / DELETING
ELSE -- DEBUT UPDATING
 v_dexaction := ''M'';
';
  END IF;
  -- Début de l'updating commun à toutes les tables

  v_eventDexPrec := NULL;
  -- On rajoute ce qui a été calculé plus haut
  v_retour := v_retour||PROC_DEX_UPDATING||'
END IF; -- FIN UPDATING
';

  v_retour := v_retour||' 
 IF eventsTab.count>0 THEN
  for i in 1..eventsTab.count loop
';

  IF date_eff_exists>0 THEN
    v_retour := v_retour||' 
eventsTab(i).DATE_ENVOI_MIN :=NVL(:NEW.DATE_EFF,:OLD.DATE_EFF);
';
  END IF;

  v_retour := v_retour||' 
   MERGE INTO MP_EVENTS DE 
    USING (SELECT v_matric AS MATRIC,eventsTab(i).EVENT AS EVENT, v_dexCleSecondaire AS CLE_SECONDAIRE FROM DUAL) Z 
    ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT AND Z.CLE_SECONDAIRE=DE.CLE_SECONDAIRE)
    WHEN MATCHED THEN UPDATE SET ACTION=eventsTab(i).ACTION,DATE_MODIF=CURRENT_TIMESTAMP,DATE_ENVOI_MIN=eventsTab(i).DATE_ENVOI_MIN
    WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,CLE_SECONDAIRE,ACTION,DATE_MODIF,DATE_ENVOI_MIN) VALUES (v_matric,eventsTab(i).EVENT,v_dexCleSecondaire,eventsTab(i).ACTION,CURRENT_TIMESTAMP,eventsTab(i).DATE_ENVOI_MIN);
  end loop;
 END IF; -- FIN eventsTab.count>0

 IF subEventsTab.count>0 THEN
  for i in 1..subEventsTab.count loop
   MERGE INTO MP_SPECIF_SOUS_EVENT DE 
    USING (SELECT v_matric AS MATRIC, subEventsTab(i).EVENT AS EVENT, v_dexCleSecondaire AS CLE_SECONDAIRE, subEventsTab(i).SOUS_EVENT AS SOUS_EVENT FROM DUAL) Z 
    ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT AND Z.CLE_SECONDAIRE=DE.CLE_SECONDAIRE AND Z.SOUS_EVENT=DE.SOUS_EVENT)
    WHEN MATCHED THEN UPDATE SET DATE_MODIF=CURRENT_TIMESTAMP, STATUT_TRT=NULL, DATE_TRT=NULL
    WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,CLE_SECONDAIRE,SOUS_EVENT,DATE_MODIF) VALUES (v_matric,subEventsTab(i).EVENT,v_dexCleSecondaire,subEventsTab(i).SOUS_EVENT,CURRENT_TIMESTAMP);
  end loop;
 END IF; -- FIN subEventsTab.count>0
';
  IF date_eff_exists>0 THEN
    v_retour := v_retour||' 
END IF; -- FIN SYSDATE BETWEEN DATE_EFF AND DATE_FIN
';
  END IF;
  v_retour := v_retour||'
-- FIN TRAITEMENT DEX
'; 

END IF;
  return v_retour;
END TGE_CREATE_TRIGGER_MP_NOTIF;
##
TAG_CHARSET=@€éèç
##
TRG_CONTRAT_AFTER_STMNT
=SQL=
CREATE OR REPLACE FUNCTION TRG_CONTRAT_AFTER_STMNT RETURN VARCHAR2 AS 
BEGIN
  RETURN '
  IF DELETING THEN
    -- On a supprimé des lignes : on va parcourir les couples NUMPAC/PACMAT supprimés pour voir si c''était le seul contrat du couple
    IF v_TAB_NUMPAC_PACMAT IS NOT NULL THEN
      FOR i IN v_TAB_NUMPAC_PACMAT.first..v_TAB_NUMPAC_PACMAT.last LOOP
        SELECT COUNT(*) INTO v_nbLig FROM DIC_ADM_CONTRAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
        IF v_nbLig=0 THEN
          -- On vient de supprimer le dernier contrat du couple NUMPAC/PACMAT : on va vérifier s''il faut le supprimer de SECUPACMAT
          SELECT COUNT(*) INTO v_nbLig FROM SECUPACMAT WHERE MATRIC=v_TAB_NUMPAC_PACMAT(i).MATRIC AND NOT (NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT);
          IF v_nbLig>0 THEN
            -- Il existe dans SECUPACMAT au moins une ligne pour le MATRIC, avec un autre couple NUMPAC/PACMAT que celui dont on vient de supprimer le dernier contrat : on supprime ce couple de SECUPACMAT
            DELETE FROM SECUPACMAT WHERE NUMPAC=v_TAB_NUMPAC_PACMAT(i).NUMPAC AND PACMAT=v_TAB_NUMPAC_PACMAT(i).PACMAT;
          END IF;
        END IF;
        IF v_listMatricToUpdate IS NULL OR INSTR(v_listMatricToUpdate,v_TAB_NUMPAC_PACMAT(i).MATRIC)<=0 THEN
          -- On stocke la liste des NUMPAC/PACMAT modifiés
          IF v_nbMatricToUpdate=1000 THEN
            v_nbMatricToUpdate := 0;
            v_listMatricToUpdate := v_listMatricToUpdate||'') OR MATRIC IN ('';
          ELSIF v_nbMatricToUpdate>0 THEN
            v_listMatricToUpdate := v_listMatricToUpdate||'','';
          END IF;
          v_listMatricToUpdate := v_listMatricToUpdate||''''''''||v_TAB_NUMPAC_PACMAT(i).MATRIC||'''''''';
          v_nbMatricToUpdate := v_nbMatricToUpdate+1;
        END IF;
      END LOOP;
    END IF;
  END IF;
  IF v_listMatricToUpdate IS NOT NULL THEN
    -- On insère dans la table temporaire les NUMPAC/PACMAT/MATRIC à mettre à jour
    --DBMS_OUTPUT.PUT_LINE(''CONTRAT UPDATING ''||v_listMatricToUpdate);
    --FIXME utiliser la procédure trace_dbms_output()
    EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_CONTRAT (NUMPAC, PACMAT, MATRIC) SELECT DISTINCT NUMPAC, PACMAT, MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
    SECNAV_MAJ_CURRENT_CONTRAT(''DO_MAJ'', 1, 0, 0);
    DELETE FROM SECUPACMAT_TMP_CONTRAT;
    IF INSERTING THEN
      v_actionIdx := ''I'';
    ELSIF UPDATING THEN
      v_actionIdx := ''U'';
    ELSIF DELETING THEN
      v_actionIdx := ''D'';
    END IF;
    DBMS_JOB.SUBMIT(v_jobIdx , ''BEGIN NULL; END;'' , sysdate+1);
    DBMS_JOB.WHAT(v_jobIdx , ''ALIM_IDX.COMPARE_CONTRAT_JOB(''||v_jobIdx||'', ''''''||v_actionIdx||'''''');'');
 	DBMS_JOB.NEXT_DATE(v_jobIdx ,  sysdate-1);
    INSERT INTO DIC_IDX_JOB_KEYS SELECT v_jobIdx, T.* FROM TABLE(v_cles_idx_contrat) T;
    IF INSERTING OR UPDATING THEN
      INSERT INTO DIC_IDX_JOB_OLD_DATAS VALUES (v_jobIdx, ANYDATA.CONVERTCOLLECTION(GET_DAC_MULTI_HORS_TRANSAC(v_cles_idx_contrat)));
    END IF;
    IF v_doMajPerso=1 THEN
      EXECUTE_IMMEDIATE_STRING( ''INSERT INTO SECUPACMAT_TMP_PERSO (MATRIC) SELECT DISTINCT MATRIC FROM SECUPACMAT WHERE MATRIC IN (''||v_listMatricToUpdate||'')'',0);
      SECNAV_MAJ_CURRENT_PERSO(''DO_MAJ'', 1, 1, 0);
      DELETE FROM SECUPACMAT_TMP_PERSO;
    END IF;
  END IF;
';
END TRG_CONTRAT_AFTER_STMNT;
##
TAG_CHARSET=@€éèç
##
R_CREATE_TRIGGER
=SQL=
CREATE OR REPLACE PROCEDURE R_CREATE_TRIGGER AS 
  w_err VARCHAR2(2000);
  --Curseur sur les tables codées dans MAPTA
  CURSOR cur_table IS
    SELECT DISTINCT TABLEPHY
    FROM TGE_REF_MAPTA
    WHERE ALLERRETOUR IN ('A','2','I')
    ORDER BY TABLEPHY;
  lig_table cur_table%ROWTYPE;

BEGIN
  TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','*** Début *** Fabrication de tous les triggers');
  OPEN cur_table;
  --Boucle sur les tables codées dans MAPTA
  LOOP 
    FETCH cur_table INTO lig_table;
    EXIT WHEN cur_table%NOTFOUND ;
    TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','TGE_CREATE_TRIGGER('||lig_table.tablephy||')');
    BEGIN
      --Génération du trigger d'une table
      TGE_CREATE_TRIGGER(lig_table.tablephy);
    EXCEPTION
      WHEN OTHERS THEN
        w_err := SQLCODE;
        w_err := '*** ERREUR *** '||lig_table.tablephy||' : '||w_err|| SQLERRM;
        TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER', SUBSTR(w_err,1,2000));
    END;
  END LOOP;
  CLOSE cur_table;
  TGE_IMPORT_AVANCEMENT_PROC('R_CREATE_TRIGGER','*** Fin ***');
  COMMIT;
END R_CREATE_TRIGGER;
##
TAG_CHARSET=@€éèç
##
TGE_ALIM_PERIODE_INDIV_MAIN
=SQL=
create or replace PROCEDURE TGE_ALIM_PERIODE_INDIV_MAIN( p_id            IN NUMBER, p_numpac        IN VARCHAR2, p_periode_paie  IN VARCHAR2,
 p_paiezad       IN VARCHAR2,
 p_dosNumForSimu IN NUMBER DEFAULT NULL )
 IS
 w_err    VARCHAR2(2000);
 w_pacmat VARCHAR2(20);
 w_audit_alim_periode_tab AUDIT_ALIM_PERIODE_TAB;
 w_debut_recueil_retro DATE;
 w_fin_recueil_retro   DATE;
 id_trt                NUMBER;
 id_CALCUL_TGE_PERIODE_RECUEIL    NUMBER;
 pacmat_found          BOOLEAN;
 reqTempInfo		   CLOB;
 req                   CLOB;
 BEGIN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN début (' || p_numpac || ',' || p_periode_paie || ',' || p_paiezad || ')');
 --Alimentation id procédure
 IF p_id   = 0 OR p_id IS NULL THEN
 id_trt := IMP_TRT_SEQ_ID.nextval;
 ELSE
 id_trt := p_id;
 END IF;
 id_CALCUL_TGE_PERIODE_RECUEIL:= IMP_TRT_SEQ_ID.nextval;
 --Récupération du pacmat
 pacmat_found := true;
 IF p_paiezad IS NOT NULL THEN
 BEGIN
 SELECT PACMAT
 INTO w_pacmat
 FROM DIC_ADM_CONTRAT_SITU
 WHERE NUMPAC = p_numpac
 AND PAIEZAD  = p_paiezad
 AND rownum   =1;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 pacmat_found := false;
 req := 'DELETE FROM ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
 ELSE
 req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
 END IF;
 req := req||' WHERE NUMPAC = '''||p_numpac||'''';
 req := req||' AND MOIS_PAIE >= '''||p_periode_paie||'''';
 req := req||' AND PAIEZAD = '''||p_paiezad||'''';
 IF p_dosNumForSimu IS NOT NULL THEN
 req := req||' AND DOS_NUM = '||p_dosNumForSimu;
 END IF;
 EXECUTE_IMMEDIATE_STRING (req,0);
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs dans DIC_ADM_CONTRAT_SITU AUCUN PACMAT trouvé pour le PAIEZAD = ''' || p_paiezad || '''');
 raise;
 END;
 END IF;
 IF pacmat_found THEN
 --Vérification des données à traiter
 w_audit_alim_periode_tab := AUDIT_ALIM_PERIODE_INDIV(id_trt, p_numpac, p_periode_paie, w_pacmat);
 IF w_audit_alim_periode_tab.exists(1) THEN
 FOR i IN w_audit_alim_periode_tab.first..w_audit_alim_periode_tab.last
 LOOP
 w_err := w_err || '(' || w_audit_alim_periode_tab(i).paiezad || ',' || w_audit_alim_periode_tab(i).debut_recueil_force || ',' || w_audit_alim_periode_tab(i).fin_recueil_force || ')';
 END LOOP;
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs de configuration des periodes de recueil pour les paiezad suivant (paiezad,debut_recueil_force,fin_recueil_force) : ' || w_err);
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN KO');
 RETURN;
 END IF;
 --Récupération de la période de recueil retro issu de la table LTP (TGE_REF_LTP)
 BEGIN
 SELECT DEBUT_PERIODE,
 FIN_PERIODE
 INTO w_debut_recueil_retro,
 w_fin_recueil_retro
 FROM TGE_REF_LTP
 WHERE NUMPAC  = p_numpac
 AND MOIS_PAIE = TO_CHAR(ADD_MONTHS(TO_DATE(p_periode_paie,'yyyymm'),-1),'YYYYMM');
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','TGE_ALIM_PERIODE_INDIV_MAIN ERR : Erreurs de configuration des periodes de recueil M-1 dans TGE_REF_LTP : NUMPAC = ''' || p_numpac || ''' AND MOIS_PAIE = ' || TO_CHAR(ADD_MONTHS(TO_DATE(p_periode_paie,'yyyymm'),-1),'YYYYMM'));
 raise;
 END;

 --Récupération requête des informations
 TGE_ALIM_PERIODE_INDIV_TEMP(id_trt, p_numpac, w_pacmat, p_periode_paie, reqTempInfo);
 
 --Nettoyage avant d'insérer dans TGE_PERIODE_RECUEIL_PAIEZAD_R
 IF p_dosNumForSimu IS NULL THEN
 DELETE  TGE_PERIODE_RECUEIL_PAIEZAD_R WHERE ID_TRT= ''''||id_CALCUL_TGE_PERIODE_RECUEIL||'''';
 req         := 'INSERT  INTO TGE_PERIODE_RECUEIL_PAIEZAD_R ';
 req         := req||'SELECT '||''''||id_CALCUL_TGE_PERIODE_RECUEIL||'''' || ' ,TGE_PERIODE_RECUEIL_PAIEZAD.* FROM TGE_PERIODE_RECUEIL_PAIEZAD ';
 req         := req||' WHERE NUMPAC = '''||p_numpac||'''';
 req         := req||' AND MOIS_PAIE = '''||p_periode_paie||'''';
 IF w_pacmat IS NOT NULL THEN
 req       := req||' AND PACMAT = '''||w_pacmat||'''';
 END IF;
 EXECUTE_IMMEDIATE_STRING ( req,0);
 END IF;
 --Nettoyage avant d'insérer dans TGE_PERIODE_RECUEIL_PAIEZAD
 req := 'DELETE FROM ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
 ELSE
 req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
 END IF;
 req := req||' WHERE NUMPAC = '''||p_numpac||'''';
 req := req||' AND MOIS_PAIE >= '''||p_periode_paie||'''';
 IF w_pacmat IS NOT NULL THEN
 req := req||' AND PACMAT = '''||w_pacmat||'''';
 END IF;
 IF p_dosNumForSimu IS NOT NULL THEN
 req := req||' AND DOS_NUM = '||p_dosNumForSimu;
 END IF;
 EXECUTE_IMMEDIATE_STRING ( req,0);
 
 --Insertion des données dans TGE_PERIODE_RECUEIL_PAIEZAD
 req := 'INSERT INTO ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, on alimente la table SIMU
 req := req||'SIMU_TGE_PERIODE_RECUEIL_PZAD';
 ELSE
 req := req||'TGE_PERIODE_RECUEIL_PAIEZAD';
 END IF;
 req := req||' (';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, il faut alimenter la colonne DOS_NUM
 req := req||'    DOS_NUM,';
 END IF;
 req := req||'    NUMPAC, 
 			      MOIS_PAIE, 
 			      PAIEZAD, 
 			      PACMAT, 
 			      RETRO_GC, 
 			      DEBUT_PERIODE_PAIE, 
 			      FIN_PERIODE_PAIE, 
 			      DEBUT_PERIODE_RECUEIL, 
 			      FIN_PERIODE_RECUEIL, 
 			      ENTREE, 
 			      SORTIE, 
 			      DEBUT_PER_RECUEIL_RETRO, 
 			      FIN_PER_RECUEIL_RETRO, 
 			      DEPART_SUSPENSION, 
 			      RETOUR_SUSPENSION, 
 			      DEBUT_PER_GENERATION_HP, 
 			      FIN_PER_GENERATION_HP,
 				  DEBUT_PERIODE_RECUEIL_LTP,
 				  FIN_PERIODE_RECUEIL_LTP
 			    ) 
 			  SELECT * FROM ( SELECT   ';
 IF p_dosNumForSimu IS NOT NULL THEN
 -- Si un dos_num est passé en paramètre, il faut alimenter la colonne DOS_NUM
 req := req||p_dosNumForSimu||',';
 END IF;
 req := req||'  NUMPAC, 
 			    MOIS_PAIE, 
 			    PAIEZAD, 
 			    PACMAT, 
 			    RETRO_GC, 
 			    DATE_DEB_PERIODE, 
 			    DATE_FIN_PERIODE, 
 			    debut_recueil, 
 			    fin_recueil, 
 			    debut_situ, 
 			    CASE 
 			      WHEN fin_situ > DATE_FIN_PERIODE 
 			        THEN TO_DATE(''31.12.2099'',''dd.mm.yyyy'') 
 			      ELSE fin_situ 
 			    END AS fin_situation, 
 			    TO_DATE('||TO_CHAR(w_debut_recueil_retro,'yyyymmdd')||',''yyyymmdd''), 
 			    TO_DATE('||TO_CHAR(w_fin_recueil_retro,'yyyymmdd')||',''yyyymmdd''), 
 			    DEPART_SUSP, 
 			    RETOUR_SUSP, 
 			    CASE 
 			      WHEN SORTIE_PRECEDENTE BETWEEN DATE_DEB_PERIODE AND DATE_FIN_PERIODE 
 			        THEN debut_situ 
 			      WHEN debut_recueil IS NOT NULL 
 			        THEN TRUNC(TRUNC(debut_recueil,''MONTH''),''DAY'') 
 			      WHEN debut_recueil IS NULL 
 			        AND entree       IS NOT NULL 
 			        AND entree         <= DATE_FIN_PERIODE 
 			        AND sortie        IS NOT NULL 
 			        AND sortie         >= dt_recueil_deb 
 			        THEN DATE_DEB_PERIODE 
 			      WHEN debut_recueil IS NULL
                  AND ((entree       IS NOT NULL
                  AND entree          > DATE_FIN_PERIODE)
                  OR (sortie         IS NOT NULL
                  AND sortie          < dt_recueil_deb))
                  THEN NULL 
 			    END AS debut_HP , 
 			    CASE 
 			        WHEN fin_recueil IS NOT NULL 
 			          THEN LEAST(TRUNC(LAST_DAY(DATE_FIN_PERIODE),''DAY'')+6,NVL(ENTREE_SUIVANTE,TRUNC(LAST_DAY(DATE_FIN_PERIODE),''DAY'')+6)) 
 			        WHEN fin_recueil IS NULL 
 			          AND entree     IS NOT NULL 
 			          AND entree       <= DATE_FIN_PERIODE 
 			          AND sortie      IS NOT NULL 
 			          AND sortie       >= dt_recueil_deb 
 			          THEN DATE_FIN_PERIODE
 			           WHEN fin_recueil IS NULL
                    AND ((entree     IS NOT NULL
                    AND entree        > DATE_FIN_PERIODE)
                    OR (sortie       IS NOT NULL
                    AND sortie        < dt_recueil_deb))
                    THEN NULL 
 			      END AS fin_HP,
 			      DT_RECUEIL_DEB,
 				  DT_RECUEIL_FIN 
 			    FROM 
 			      (SELECT lead(ENTREE,1) over(partition BY NUMPAC,PACMAT order by ENTREE)-1 ENTREE_SUIVANTE, 
 			        lag(SORTIE,1) over(partition BY NUMPAC,PACMAT order by SORTIE) SORTIE_PRECEDENTE, 
 			        NUMPAC, 
 			        PACMAT, 
 			        PAIEZAD, 
 			        RETRO_GC, 
 			        MOIS_PAIE,
 			        DATE_DEB_PERIODE,
 			        DATE_FIN_PERIODE,
 			        IS_RETRO, 
 			        DEBUT_FORCEE, 
 			        FIN_FORCEE, 
 			        ENTREE, 
 			        SORTIE, 
 			        RETOUR_SUSP, 
 			        DEPART_SUSP, 
 			        DEBUT_SITU, 
 			        FIN_SITU, 
 			        debut_recueil, 
 			        DT_RECUEIL_DEB, 
 			        DT_RECUEIL_FIN, 
 			        CASE 
 			          WHEN fin_forcee IS NOT NULL 
 			            THEN fin_forcee 
 			          WHEN debut_recueil IS NULL 
 			            THEN NULL 
 			          WHEN sortie      IS NULL 
 			            OR sortie      > DATE_FIN_PERIODE 
 			            THEN dt_recueil_fin 
 			          WHEN sortie      >= dt_recueil_deb 
 			            THEN sortie  
 			          ELSE TO_DATE(''01/01/1900'',''dd/mm/yyyy'')  
 			        END AS fin_recueil 
 			      FROM 
 			        (SELECT NUMPAC, 
 			          PACMAT, 
 			          PAIEZAD, 
 			          RETRO_GC, 
 			          MOIS_PAIE,
 			          DATE_DEB_PERIODE,
 			          DATE_FIN_PERIODE,
 			          IS_RETRO, 
 			          DEBUT_FORCEE, 
 			          FIN_FORCEE, 
 			          ENTREE, 
 			          SORTIE, 
 			          RETOUR_SUSP, 
 			          DEPART_SUSP, 
 			          DEBUT_SITU, 
 			          FIN_SITU, 
 			          DT_RECUEIL_DEB, 
 			          DT_RECUEIL_FIN, 
 			          CASE 
 			            WHEN debut_forcee IS NOT NULL 
 			              THEN debut_forcee 
 			            WHEN entree IS NULL  
 			              THEN null 
 			            WHEN entree        <= dt_recueil_fin 
 			              AND (sortie IS NULL 
 			              OR (sortie        >= dt_recueil_deb 
 			              AND (sortie > DATE_FIN_PERIODE  
 			              	OR NOT EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD rec_ind WHERE rec_ind.NUMPAC = rec_temp.numpac AND rec_ind.PAIEZAD = rec_temp.paiezad AND rec_ind.FIN_PERIODE_RECUEIL >= rec_temp.sortie) ) ))  
 
 			              THEN GREATEST(entree, NVL(dt_recueil_deb, entree)) 
 			            WHEN entree        <= dt_recueil_fin	
						AND (sortie        < dt_recueil_deb  
							OR ( sortie        >= dt_recueil_deb AND (sortie < DATE_FIN_PERIODE 
								AND EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD rec_ind WHERE rec_ind.NUMPAC = rec_temp.numpac AND rec_ind.PAIEZAD = rec_temp.paiezad AND rec_ind.FIN_PERIODE_RECUEIL >= rec_temp.sortie))))
						THEN TO_DATE(''01/01/1900'',''dd/mm/yyyy'')
						WHEN (sortie        IS NOT NULL
                          AND entree         > dt_recueil_fin
                          AND sortie        <= DATE_FIN_PERIODE)
                          THEN entree						
                        ELSE NULL
 			          END AS debut_recueil 
 			        FROM (' || reqTempInfo || ') rec_temp 
 			        ) 
 			      ) ) WHERE (debut_recueil IS NULL OR TO_CHAR(debut_recueil,''dd/mm/yyyy'') != ''01/01/1900'') AND (fin_recueil IS NULL OR  TO_CHAR(fin_recueil,''dd/mm/yyyy'')  != ''01/01/1900'') AND debut_HP IS NOT NULL AND fin_HP IS NOT NULL';
 			      

 EXECUTE_IMMEDIATE_STRING  (req,0);
 --Mise à jour des incidents qui on changé période de paie
 IF p_dosNumForSimu IS NULL THEN
 req              := 'UPDATE TGE_INCIDENTS_PAIE SET PERIODE = TO_DATE(''01.01.1900'', ''dd.MM.yyyy'') ';
 req              := req||' WHERE ID IN ( ';
 req              := req||' SELECT I.ID FROM TGE_INCIDENTS_PAIE I  ';
 req              := req||' INNER JOIN TGE_PERIODE_RECUEIL_PAIEZAD P  ';
 req              := req||' ON P.NUMPAC = I.NUMPAC ';
 req              := req||' AND P.PAIEZAD = I.PAIEZAD ';
 req              := req||' AND I.DATE_EFFET BETWEEN P.DEBUT_PERIODE_RECUEIL AND P.FIN_PERIODE_RECUEIL ';
 req              := req||' LEFT JOIN TGE_PERIODE_RECUEIL_PAIEZAD_R R  ';
 req              := req||' ON P. NUMPAC = R.NUMPAC  ';
 req              := req||' AND P.MOIS_PAIE = R.MOIS_PAIE ';
 req              := req||' AND P.PAIEZAD = R.PAIEZAD ';
 req              := req||' AND P.PACMAT = R.PACMAT ';
 req              := req||' AND R.ID_TRT = '''||id_CALCUL_TGE_PERIODE_RECUEIL||'''';
 
 req              := req||' WHERE I.NUMPAC = '''||p_numpac||''' ';
 req              := req||' AND (P.MOIS_PAIE = '''||p_periode_paie||''' OR R.MOIS_PAIE = '''||p_periode_paie||''') ';
 IF w_pacmat      IS NOT NULL THEN
 req            := req||' AND (P.PACMAT = '''||w_pacmat||''' OR R.PACMAT = '''||w_pacmat||''') ';
 END IF;
 req := req||' AND (P.MOIS_PAIE IS NULL OR R.MOIS_PAIE IS NULL ';
 req := req||' OR P.DEBUT_PERIODE_RECUEIL != R.DEBUT_PERIODE_RECUEIL  ';
 req := req||' OR P.FIN_PERIODE_RECUEIL != R.FIN_PERIODE_RECUEIL)) ';
 EXECUTE_IMMEDIATE_STRING(req, 0);
 DELETE  TGE_PERIODE_RECUEIL_PAIEZAD_R WHERE ID_TRT= id_CALCUL_TGE_PERIODE_RECUEIL;
 END IF;
 END IF;
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN OK');
 EXCEPTION
 WHEN OTHERS THEN
 w_err := SQLCODE;
 w_err := 'TGE_ALIM_PERIODE_INDIV_MAIN '||w_err|| sqlerrm;
 TGE_IMPORT_AVANCEMENT_proc('TGE_ALIM_PER','fin TGE_ALIM_PERIODE_INDIV_MAIN KO : '||w_err);
 END TGE_ALIM_PERIODE_INDIV_MAIN;
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_30
=SQL=
create or replace PROCEDURE TGE_CONTROLE_30 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 -- Valeurs attendues : EC/ECS -> écran création (S en mode SimuPaie),  EM/EMS -> écran modification (S en mode SimuPaie), GAP -> création en sous-marin,
 -- I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch, MP -> création depuis la Market Place
 , P_TYPE_ACTION IN VARCHAR2
 ) AS
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 clWhere varchar2(1000);
 -- Pour les merge, la clause where ne doit pas inclure la colonne ERREURS, on gère des clauses spécifiques
 clWhereMerge varchar2(1000);
 clWhereMergeErreur varchar2(250);
 
 req varchar2(2000);
 w_exist_element NUMBER ;
 w_err VARCHAR2(2000);
 w_param_longueur VARCHAR2(10);
 w_id_natcol varchar2(4000);
 
 BEGIN
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||''' and EI.code_element not in (''B690'',''B691'') ';
 
 if p_numligne is not null then
 	clwhere:=clwhere||' AND EI.NUMLIGNE='||p_numligne;
 end if;

 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controlées 
 clwhere:=clwhere || ' AND (EI.STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR EI.STATUT = ''TRANS'') ';
  
 clWhereMerge := clwhere;
 clWhereMergeErreur := '';
 
 IF p_type_action = 'VI' and p_login <> 'BATCH' then
   -- A la validation d'import Web, on ne va passer que sur les lignes qui ne sont pas déjà en erreur.
   -- Certaines lignes sont déjà en erreur et on ne veut pas les retraiter (sinon double message)
   clwhere := clwhere || ' and EI.ERREURS is null';
   clWhereMergeErreur := ' where EI.ERREURS is null';
 END IF;
 
 IF p_login ='BATCH' THEN 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées. Seulement pour le BATCH, car dans les autres cas il y a des contrôles
 -- qui sont fait en amont des contrôles PL/SQL (côté Java)
 	req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS = '''' WHERE '||clwhere;
 	EXECUTE_IMMEDIATE_STRING( req,0);
 	
 -- Contrôle que le collaborateur est cohérent : date effet / paiezad. En Batch, on n'utilise pas IdentifiantCollab pour récupérer les informations
 -- du collaborateur, on prend juste ce qui est dans le fichier. On doit donc contrôler que le collab existe
  	req:= 'update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS, '''||replace(get_message_erreur('STD', 'STD00046', p_codlang),'''','''''')||''',EI.MATRICULE||''|''||EI.NUMPAC||''|''||EI.PACMAT||''|''||EI.PAIEZAD||''|''||EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere;
  	req:= req || ' and EI.NUMPAC is not null and EI.PAIEZAD is not null';
  	req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=EI.NUMPAC and DACS.PAIEZAD=EI.PAIEZAD';
  	req:= req || ' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
  	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Met une erreur sur les lignes en doublon dans le fichier d'import
 IF p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00032',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' AND  P.LOGIN='''||p_login||''' ';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*'') )in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*'') from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- On conserve la ligne dont le numLigne est le max dans la liste des doublons (on enlève le message d'erreur)
 IF p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=null WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' AND  P.LOGIN='''||p_login||''' ';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*''),numligne) in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*''),max(numligne) as numligne from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 IF p_type_action = 'EC' or p_type_action = 'ECS' or p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
   -- Non existe EZ (seulement en création ou import. Les tests d'existence en modification sont exécutés en Java)
   -- Si l'élément existant a comme DERNIER_CODE_OPE = 'S', alors message ZEZ00040
   -- sinon ZEZ00030
   req :='merge into TGE_IMPORT_ELEMENTS EI using TGE_ELEMENTS_PAIE E on (';
   req := req || clwhereMerge;
   req := req ||' and E.NUMPAC = EI.NUMPAC and E.PAIEZAD = EI.PAIEZAD and E.PERIODE = EI.PERIODE';
   req := req ||' and E.TYPE_TRAITEMENT = EI.TYPE_TRAITEMENT and E.CODE_ELEMENT = EI.CODE_ELEMENT and E.INDICATIF = EI.INDICATIF AND E.CODE_REMPLACEMENT=NVL(EI.CODE_REMPLACEMENT,''*''))';
   req := req ||' when matched then update set ERREURS ='; 
   req := req ||' case';
   req := req ||' when E.DERNIER_CODE_OPE = ''S'' then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00040',p_codlang),'''','''''')||''',EI.CODE_ELEMENT||''|''||TGE_IMPORT_FORMATE_DATE(EI.PERIODE, EI.LOGIN, ''YYYYMM'', ''MM.YYYY'')||''|''||EI.INDICATIF,'''||p_codlang||''')';
   req := req ||' else TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00030',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF||''|''||TGE_IMPORT_FORMATE_DATE(PERIODE, LOGIN, ''YYYYMM'', ''MM.YYYY''),'''||p_codlang||''')';
   req := req ||' end';
   req:= req || clWhereMergeErreur;
   EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Numpac non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PaieZad non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Periode non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Type Traitement non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Code_element non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00016',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_ELEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Date d'effet non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00314',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_EFFET is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Longueur Matricule
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00089',p_codlang),'''','''''')||''',MATRICULE,'''||p_codlang||''') where '||clwhere||' AND MATRICULE is NOT null AND LENGTH (MATRICULE)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Origine
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',ORIGINE,'''||p_codlang||''') where '||clwhere||' AND ORIGINE is NOT null AND LENGTH (ORIGINE)>1 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --
 -- Longueur LOGIN (sauf pour le Batch)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00107',p_codlang),'''','''''')||''',LOGIN,'''||p_codlang||''') where '||clwhere||' AND LOGIN!=''BATCH'' AND LENGTH (LOGIN)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie TGE00310
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00310',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 -- permet de gérer les cas où DATE_EFFET ou PERIODE ne sont pas des dates valides
 req:= req ||' and (select case when to_date(EI.DATE_EFFET,''YYYYMMDD'') > last_day(to_date(EI.PERIODE,''YYYYMM'')) then ''O'' else ''N'' end from dual where is_date(EI.DATE_EFFET, ''YYYYMMDD'')=1 and is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_type_action = 'ECS' or p_type_action = 'EMS' then
	-- En SimuPaie, on contrôle seulement l'interdiction de la saisie dans la passé : TGE00311 (il n'y a pas de passé, rétro) 
	req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	req:= req ||' where '||clwhere || ' ';
	-- permet de gérer les cas où PERIODE n'est pas une date valide 
	req:= req ||' and (select case when to_date(EI.PERIODE,''YYYYMM'') < (select to_date(P.PERIODEENCOURS,''YYYYMM'') from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC) then ''O'' else ''N'' end from dual where is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
	EXECUTE_IMMEDIATE_STRING( req,0);
 ELSE
	 -- période de paie pour les EZ : TGE00311 / ZEZ00037 / TGE00336 / TGE00337
	 req:='merge into TGE_IMPORT_ELEMENTS EI using';
	 req:= req ||' (select P1.NUMPAC, P1.PERIODEENCOURS, P1.DEB_RETRO, P1.DEB_HISTO_RETRO, P1.NB_MOIS_RETRO, ';
	 -- Pour le calcul de la limite rétro, on ne tient pas compte du max entre DEB_HISTO_RETRO et PERIODEENCOURS - NB_MOIS
	 -- car c'est le test sur la DEB_HISTO_RETRO et le message TGE00336 qui sera pris en compte
	 req:= req ||' TO_CHAR(ADD_MONTHS(TO_DATE(P1.PERIODEENCOURS, ''YYYYMM''), - P1.NB_MOIS_RETRO), ''YYYYMM'') AS LIMITE_RETRO '; 
	 req:= req ||' from TGE_REF_PAC P1) P';
	 req:= req ||' on (';
	 req:= req || clwhereMerge;
	 req:= req ||' and EI.PERIODE < P.PERIODEENCOURS';
	 req:= req ||' and ( P.DEB_RETRO IS NULL or P.PERIODEENCOURS < P.DEB_RETRO';
	 IF not p_type_action = 'GAP' then
	   -- Pour les éléments créés en sous-marin depuis la GAP, on ne teste pas le caractère CALCUL_RETRO de l'élément, ni la cohérence entre la période et la date d'effet
	   req:= req ||' or EI.PERIODE <> substr(EI.DATE_EFFET, 0, 6)';
	 END IF;
	 req:= req ||' or EI.PERIODE < P.DEB_HISTO_RETRO or EI.PERIODE < P.LIMITE_RETRO)';
	 req:= req ||' and EI.NUMPAC = P.NUMPAC)'; 
	 req:= req ||' when matched then update set EI.ERREURS = case';
	 req:= req ||' when P.DEB_RETRO is null or P.PERIODEENCOURS < P.DEB_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 IF not p_type_action = 'GAP' then
	   req:= req ||' when EI.PERIODE <> substr(EI.DATE_EFFET, 0, 6) then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00041',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
	 END IF;
	 req:= req ||' when EI.PERIODE < P.DEB_HISTO_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',to_char(to_date(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' when EI.PERIODE < P.LIMITE_RETRO then TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.LIMITE_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
	 req:= req ||' end';
	 req:= req || clWhereMergeErreur;
	 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Format date d'effet TGE00315
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00315',p_codlang),'''','''''')||''',EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere||' AND EI.DATE_EFFET is not null and IS_DATE(EI.DATE_EFFET,''YYYYMMDD'')=0';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- IdPacMat non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00102',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND (RPAD(NUMPAC,6) || PACMAT) is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur NumPac
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',numpac,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(NUMPAC),0)>6 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur PaieZad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',NULL,PAIEZAD) where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format Periode
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00328',p_codlang),'''','''''')||''',PERIODE,'''||p_codlang||''') WHERE '||clwhere||' AND PERIODE is NOT null AND IS_DATE(PERIODE,''YYYYMM'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Cle_import
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00099',p_codlang),'''','''''')||''',LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE,'''||p_codlang||''') WHERE '||clwhere||' AND LOGIN IS NOT NULL AND DATE_IMPORT IS NOT NULL AND NUMLIGNE IS NOT NULL AND  LENGTH(LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE) >70 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur IdPacMat
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00103',p_codlang),'''','''''')||''',RPAD(NUMPAC,6) || PACMAT,'''||p_codlang||''') WHERE '||clwhere||' AND NUMPAC   IS NOT NULL AND PACMAT IS NOT NULL AND  LENGTH(RPAD(NUMPAC,6) || PACMAT) >14 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- controle NATCOL doit avoir la valeur SAL ou STA TGE00027
 select VALVAR into w_id_natcol from sys_varsys where module='STD' and codvar='ID_NATCOL';
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00027',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 req := req ||' and (select DAC.'||w_id_natcol||' from DIC_ADM_CONTRAT DAC inner join DIC_ADM_CONTRAT_SITU DACS on (DACS.NUMPAC = DAC.NUMPAC and DACS.PACMAT = DAC.PACMAT and DACS.NUMCNT = DAC.NUMCNT) where DACS.PAIEZAD = EI.PAIEZAD and DAC.NUMPAC = EI.NUMPAC';
-- Si le PAC n'est pas MPE, le couple NUMPAC/PAIEZAD ne suffit pas à déterminer un contrat, on utilise la date d'effet
 req := req ||' and case when ((select MPE from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC) = ''N'' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DAC.DSDCN and nvl(DAC.DSFCN, to_date(''20991231'', ''YYYYMMDD'')))';
 req := req ||' or (select MPE from TGE_REF_PAC P2 where P2.NUMPAC = EI.NUMPAC) <> ''N'' then 1 else 0 end = 1) not in (''SAL'', ''STA'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_login = 'BATCH' THEN
 -- Autorisation paiezad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.paiezad IS NOT NULL AND EI.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Chez les clients, ils n'ont pas de pac * dans TGE_DICOZ, par contre en recette interne ils n'ont que celui là (pac *). 
 -- Du coup on conserve la complexité de choisir les éléments du pac *, mais en gros, il n'y a pas de cohabitation entre les 2 gestions 
 -- (sauf en dev ce qui peut provoquer des incohérences sur les contrôles : 
 --  - Elément U101 existe sur le pac *, mais s'il y a d'autres éléments sur le pac TLSE01 mais pas U101
 --  - L'appel table va proposer U101 mais le contrôle ici va bloquer en disant que U101 n'existe pas
 
 -- Existe code_element
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00017',p_codlang),'''','''''')||''',code_element,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND EI.code_element is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT= EI.CODE_ELEMENT)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Existe type_traitement
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND  EI.type_traitement is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_TYPETRT TT where TT.CODETYPTRT = EI.TYPE_TRAITEMENT';
 req:= req || ' and (';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT = EI.TYPE_TRAITEMENT) > 0 and TT.NUMPAC = EI.NUMPAC)';
 req:= req ||   ' or';
 req:= req ||   ' ((select count(*) from TGE_REF_TYPETRT TT2 where TT2.NUMPAC = EI.NUMPAC and TT2.CODETYPTRT= EI.TYPE_TRAITEMENT) = 0 and TT.NUMPAC=''*'')';
 req:= req || ' ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format sens
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00038',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND sens IS NOT NULL AND sens NOT IN (''+'',''-'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Autorisation sens (Valeur 'Aucun' attendue pour les TYPE = 'A')
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00015',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' and EI.SENS is not null and EI.SENS in (''+'',''-'') ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT= EI.CODE_ELEMENT and DZ.TYPE = ''A'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 /** Début des tests sur l'INDICATIF */
 -- On fait les tests sur l'indicatif qu'en création ou import. En modification, l'indicatif ne change pas.
 IF p_type_action = 'EC' or p_type_action = 'I' or p_type_action = 'VI' or p_type_action = 'MP' THEN
 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null AND EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''COT'',''CZR'',''CTM'',''CRA''))';
 req:= req || ' and not exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = EI.INDICATIF)';
 EXECUTE_IMMEDIATE_STRING( req,0);

  -- OCC1 > 0 et GROUPE = TXR : Existe code_rubrique
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00334',p_codlang),'''','''''')||''',EI.INDICATIF,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null AND EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''TXR''))';
 req:= req || ' and not exists (select 1 from TGE_REF_RUBRIQUE R where R.NUMPAC = EI.NUMPAC and R.CODERUB = EI.INDICATIF)';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Caisse référence interdite si on est NewCot (TGE_REF_PAC.OLDCOT = 'N')
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND EI.INDICATIF is not null and EI.NUMPAC is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''COT'',''CZR'',''CTM'',''CRA''))';
 req:= req || ' and exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = EI.INDICATIF and RC.CODEGROUP = ''R'')';
 req:= req || ' and nvl((select P.OLDCOT from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC), ''N'') != ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - longueur attendue 6
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''MM:CCC'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null  and length(EI.INDICATIF) != 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - MM doit correspondre à un mois
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00011',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null AND EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and (IS_NUMBER(substr(EI.INDICATIF, 0, 2)) is null or IS_DATE(substr(EI.INDICATIF,0, 2),''MM'') !=1)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null and EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE = ''HCO'')';
 req:= req || ' and not exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = substr(EI.INDICATIF, 4))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Caisse référence interdite
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.INDICATIF is not null and EI.NUMPAC is not null and length(EI.INDICATIF) = 6';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.NUMPAC = EI.NUMPAC and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.OCC1 > 0 and DZ.GROUPE in (''HCO''))';
 req:= req || ' and exists (select 1 from TGE_REF_CAISSE RC where RC.NUMPAC = EI.NUMPAC and RC.CODECAISSE = substr(EI.INDICATIF, 4) and RC.CODEGROUP = ''R'')';
 req:= req || ' and nvl((select P.OLDCOT from TGE_REF_PAC P where P.NUMPAC = EI.NUMPAC), ''N'') != ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) != 7 or IS_NUMBER(substr(EI.INDICATIF,7,1)) is null or IS_DATE(substr(EI.INDICATIF, 0, 6),''YYYYMM'') !=1 )';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 = 0 and DZ.GROUPE = ''HIS'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere;
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 = 0 and DZ.GROUPE = ''HIS'')';
 -- On gère avec un "exist/from dual" pour effectuer les tests > 1 et < 9 sans que ça plante si la valeur de "N" n'est pas un nombre valide
 req:= req || ' and exists (select 1 from dual where length(EI.INDICATIF) = 7 and (IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or to_number(substr(EI.INDICATIF, 7, 1)) < 1 or to_number(substr(EI.INDICATIF, 7, 1)) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN:XX'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) != 10 or IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or IS_DATE(substr(EI.INDICATIF, 0, 6),''YYYYMM'') !=1 ';
 req:= req || ' or substr(EI.INDICATIF,8,1) != '':'' or IS_NUMBER(substr(EI.INDICATIF,9,2)) is null)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere;
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'')';
 -- On gère avec un "exist/from dual" pour effectuer les tests > 1 et < 9 sans que ça plante si la valeur de "N" n'est pas un nombre valide
 req:= req || ' and exists (select 1 from dual where length(EI.INDICATIF) = 10 and (IS_NUMBER(substr(EI.INDICATIF, 7, 1)) is null or to_number(substr(EI.INDICATIF, 7, 1)) < 1 or to_number(substr(EI.INDICATIF, 7, 1)) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - XX doit être compris entre 01 et TGE_REF_DICOZ.OCC2
 -- Utilisation d'un merge afin de pouvoir utiliser DZ.OCC2 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 AND DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'' ';
 req:= req || ' and (length(EI.INDICATIF)) = 10 and IS_NUMBER(substr(EI.INDICATIF,7,1)) is not null and IS_DATE(substr(EI.INDICATIF,0,6),''YYYYMM'') !=0 and (IS_NUMBER(substr(EI.INDICATIF,9,2)) is null ';
 req:= req || ' or to_number(substr(EI.INDICATIF,9,2)) < 1 or to_number(substr(EI.INDICATIF,9,2)) > DZ.OCC2 )) ';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00013',p_codlang),'''','''''')||''',DZ.OCC2,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur; 
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''AAMM+Code Chrono'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) !=10 ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, partie AAMM non valide
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00035',p_codlang),'''','''''')||''',''AAMM+Code Chrono|AAMM'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) = 10 and IS_DATE(substr(EI.INDICATIF, 0, 4),''YYMM'') != 1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, Code chrono n'existe pas pour le collaborateur
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00034',p_codlang),'''','''''')||''',substr(Ei.indicatif,5),'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and length(EI.INDICATIF) = 10 and IS_DATE(substr(EI.INDICATIF, 0, 4),''YYMM'') = 1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.GROUPE in (''HCP'',''HC2''))';
 req:= req || ' and not exists (select 1 from DIC_ADM_CONTRAT_SITU where NUMPAC = EI.NUMPAC and PACMAT = EI.PACMAT and CODE_CHRONO  = substr(EI.INDICATIF, 5))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu SSAAMM
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMM'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and IS_DATE(EI.INDICATIF,''YYYYMM'') !=1';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC2 = 0 and DZ.OCC1 = 13 and DZ.GROUPE not in (''COT'',''CZR'',''CTM'',''CRA'',''HCO'',''HIS'',''HCP'',''HC2'',''TXR'',''CRF'',''CAA'',''CPP''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_ELEMENT commence par 'R' et OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR /CRF / CAA / CPP: Format indicatif attendu compris entre (PERIODE -12 mois) et (PERIODE - 1 mois)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00035',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.CODE_ELEMENT is not null and length(EI.CODE_ELEMENT) = 4 and EI.CODE_ELEMENT like ''R%'' ';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC2 = 0 and DZ.OCC1 = 13 and DZ.GROUPE not in (''COT'',''CZR'',''CTM'',''CRA'',''HCO'',''HIS'',''HCP'',''HC2'',''TXR'',''CRF'',''CAA'',''CPP''))';
 -- permet de gérer les cas où INDICATIF n'est pas une date valide
 req:= req || ' and (select case when (to_date(EI.INDICATIF,''YYYYMM'') > add_months(to_date(EI.PERIODE,''YYYYMM''),-1) or to_date(EI.INDICATIF,''YYYYMM'') < add_months(to_date(EI.PERIODE,''YYYYMM''),-12)) then ''O'' else ''N'' end from dual where IS_DATE(EI.INDICATIF, ''YYYYMM'')=1) = ''O'' ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et OCC1 <> 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu entre 1 et OCC1 
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.OCC1 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.OCC1 > 0 and DZ.OCC1 <> 13';
 req:= req || ' and DZ.GROUPE not in (''HIS'',''HCO'',''COT'',''CZR'',''CTM'',''CRA'',''DFR'', ''HCP'', ''HC2'', ''TXR'',''CRF'',''CAA'',''CPP'')';
 req:= req || ' and (is_number(EI.INDICATIF) is null or to_number(EI.INDICATIF) < 1 or to_number(EI.INDICATIF) > DZ.OCC1))';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00014',p_codlang),'''','''''')||''',DZ.OCC1,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- GROUPE in CRF / CAA / CPP : Format indicatif attendu alphanumerique <= 2 Caractères
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00343',p_codlang),'''','''''')||''',''XX=alphanumérique'','''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and (length(EI.INDICATIF) > 2 or not regexp_like(EI.INDICATIF, ''^[a-zA-Z0-9]+$''))';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.GROUPE in (''CRF'',''CAA'',''CPP''))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 -- Fin tests sur l'indicatif
 
 -- Format valeur : longueur valide (TYPE = A ou N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00006',p_codlang),'''','''''')||''',(select distinct(oz.longueur) from tge_ref_dicoz oz where oz.element = ei.code_element and ei.numpac =oz.numpac and oz.type in (''A'',''N'',''B'')),'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req ||   ' and (';
 req:= req ||   ' ((DZ.TYPE = ''A'' or DZ.TYPE = ''B'') and length(EI.VALEUR) > DZ.LONGUEUR)';
 req:= req ||   ' or (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16) and length(EI.VALEUR) > DZ.LONGUEUR)';
 req:= req ||   ')';
 req:= req || ' )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : nombre signé(TYPE = N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR04',p_codlang),'''','''''')||''',EI.VALEUR,'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req ||   ' and ( (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16)) or (DZ.TYPE = ''B'')) ';
 req:= req ||   ' and (regexp_like(EI.VALEUR, ''^[-+]+.*''))';
 req:= req || ' )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : partie entière <= TGE_REF_DICOZ.LONGUEUR (TYPE =P)
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC ';
 req:= req || ' and (DZ.TYPE = ''P'' and is_number(EI.VALEUR) is not null and (((INSTR(replace(EI.VALEUR,''.'','',''),'','')-1)> DZ.LONGUEUR) or (INSTR(replace(EI.VALEUR,''.'','',''),'','')= 0 and length(EI.VALEUR) > DZ.LONGUEUR))  ) ';
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR02',p_codlang),'''','''''')||''', EI.VALEUR||''|''||DZ.LONGUEUR,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : partie décimale <= TGE_REF_DICOZ.NBDECI (TYPE =P)
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC ';
 req:= req || ' and (DZ.TYPE = ''P'' and INSTR(replace(EI.VALEUR,''.'','',''),'','') > 0 and length(EI.VALEUR)-INSTR(replace(EI.VALEUR,''.'','',''),'','')> DZ.NBDECI)'; 
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('STD','STDERR01',p_codlang),'''','''''')||''', EI.VALEUR||''|''||(DZ.NBDECI),'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- Format valeur : nombre non décimal (TYPE = N ou B)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00007',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere|| ' and EI.VALEUR is not null and (is_number(EI.VALEUR) is null or instr(EI.VALEUR, '','') > 0 or instr(EI.VALEUR, ''.'') > 0)';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC'; 
 req:= req ||   ' and (DZ.TYPE = ''B'' or (DZ.TYPE = ''N'' and (DZ.MASQUE < 1 or DZ.MASQUE > 16))))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : date ne respectant pas la longueur (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.LONGUEUR dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS EI using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC';
 req:= req || ' and EI.VALEUR is not null and DZ.TYPE = ''N'' and DZ.MASQUE>=1 AND DZ.MASQUE<=16';
 req:= req || ' and length(EI.VALEUR) != DZ.LONGUEUR';
 req:= req || ' )';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00008',p_codlang),'''','''''')||''',DZ.LONGUEUR,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : date pas dans bon format (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.MASQUE dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC'; 
 req:= req || ' and DZ.TYPE = ''N'' AND DZ.MASQUE >= 1 AND DZ.MASQUE <= 16';
 req:= req || ' and length(EI.VALEUR) = DZ.LONGUEUR and (';
 req:= req || ' (DZ.MASQUE =1 AND (IS_DATE(EI.VALEUR,''DDMMYYYY'')!=1 AND EI.VALEUR<>''00000000'')) OR';
 req:= req || ' (DZ.MASQUE =2 AND (IS_DATE(EI.VALEUR,''MMYYYY'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =3 AND (IS_DATE(EI.VALEUR,''YYYYMM'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =4 AND (IS_DATE(EI.VALEUR,''DD'')!=1 AND EI.VALEUR<>''00'' ) ) OR';
 req:= req || ' (DZ.MASQUE =5 AND (IS_DATE(EI.VALEUR,''MM'')!=1 AND EI.VALEUR<>''00'')) OR';
 req:= req || ' (DZ.MASQUE =6 AND (IS_DATE(EI.VALEUR,''YYYY'')!=1 AND EI.VALEUR<>''0000'' )) OR';
 req:= req || ' (DZ.MASQUE =7 AND (IS_DATE(EI.VALEUR,''YYYYMMDD'')!=1 AND EI.VALEUR<>''00000000'')) OR';
 req:= req || ' (DZ.MASQUE =8 AND (IS_DATE(EI.VALEUR,''DDMMYY'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =9 AND (IS_DATE(EI.VALEUR,''MMYY'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =10 AND (IS_DATE(EI.VALEUR,''YYMM'')!=1 AND EI.VALEUR<>''0000'' )) OR';
 req:= req || ' (DZ.MASQUE =11 AND (IS_DATE(EI.VALEUR,''YY'')!=1 AND EI.VALEUR<>''00'')) OR';
 req:= req || ' (DZ.MASQUE =12 AND (IS_DATE(EI.VALEUR,''YYMMDD'')!=1 AND EI.VALEUR<>''000000'')) OR';
 req:= req || ' (DZ.MASQUE =13 AND( IS_DATE(EI.VALEUR,''DDYY'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =14 AND (IS_DATE(EI.VALEUR,''DDMM'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =15 AND (IS_DATE(EI.VALEUR,''MMDD'')!=1 AND EI.VALEUR<>''0000'')) OR';
 req:= req || ' (DZ.MASQUE =16 AND (IS_DATE(EI.VALEUR,''MMDDYYYY'')!=1 AND EI.VALEUR<>''00000000''))';
 req:= req || '))';
 req:= req || ' when matched then update set EI.ERREURS = TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00024',p_codlang),'''','''''')||''',TGE_VALEUR_FORMAT_DATE(DZ.MASQUE),'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : nombre attendu (TYPE = P)
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00009',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' and EI.VALEUR is not null and is_number(EI.VALEUR) is null';
 req:= req || ' and exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.NUMPAC = EI.NUMPAC and DZ.TYPE = ''P'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Controle Origine et mode_3060 : TGE00317
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00317',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and EI.CODE_REMPLACEMENT = ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''R'' and G.MODE_3060 <> ''F'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF P_TYPE_ACTION = 'EM' or p_type_action = 'EMS' THEN
 -- Ce test n'est à faire qu'en modification (EM), mais pas à la création (EC ou I)
 -- Controle Origine et mode_3060 : TGE00318
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00318',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and nvl(EI.CODE_REMPLACEMENT, ''*'') <> ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''W'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Mise à jour de l'élément autorisée ZEZ00005 seulement si on n'est pas en simulation
 /*      
  	 	 - Si on est en simulation
  	 	 - Si l'élément a une ORIGINE = '&'
         - sinon CODEMODIF doit être égale à 2 et :
            - soit l'élément n'est pas présent dans MAPDO
            - soit il est présent dans TGE_REF_MAPDO et il doit avoir TGE_REF_MAPDO.OCCURRENCE like '%!%' ou TGE_REF_MAPTA.ALLERRETOUR = 'R'
 */
 IF p_type_action <> 'ECS' and p_type_action <> 'EMS' then
 	req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00005',p_codlang),'''','''''')||''',EI.CODE_ELEMENT ,'''||p_codlang||''') where '||clwhere;
 	req:= req || ' and EI.CODE_ELEMENT is not null and (EI.ORIGINE is null or EI.ORIGINE <> ''&'') and not exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.CODEMODIF =''2'' ';
 	req:= req || ' and EI.NUMPAC = DZ.NUMPAC ';
 	-- L'élément n'est pas présent dans MAPDO (pour le numpac ou le pac *)
 	req:= req || ' and (DZ.ELEMENT not in (select ELEMENT from TGE_REF_MAPDO DO2 where (((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO2.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO2.NUMPAC = ''*''))) ';
 	-- Si l'élément est présent dans MAPDO alors TGE_REF_MAPDO.OCCURENCE doit contenir '!'
 	-- ou TGE_REF_MAPTA.ALLERRETOUR = 'R' pour être modifiable
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO DO left outer join TGE_REF_MAPTA TA on DO.TABLEGXP = TA.TABLEPARAM where DO.ELEMENT = DZ.ELEMENT ';
 	req:= req || ' and (((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = DZ.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO.NUMPAC = ''*'')) ';
 	req:= req || ' and (((select count(*) from TGE_REF_MAPTA where NUMPAC = DZ.NUMPAC and TABLEPARAM = DO.TABLEGXP ) > 0 and TA.NUMPAC = DZ.NUMPAC) ';
 	req:= req || ' or ((select count(*) from TGE_REF_MAPTA where NUMPAC = DZ.NUMPAC and TABLEPARAM = DO.TABLEGXP ) = 0 and TA.NUMPAC = ''*'')) ';
 	req:= req || ' and (DO.OCCURENCE like ''%!%'' or TA.ALLERRETOUR = ''R'')) > 0 )) ';
 	req:= req || ' )';
 	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Contrôle Origine existe pour le numPac TGE00331
 -- Ce test devra être supprimé lorsque celui associé au message TGE00321(origine est cohérente avec la GTA du collaborateur)
 -- sera intégré au contrôle PL/SQL (pour le moment fait en Java pour les saisies écrans et imports Web)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00331',p_codlang),'''','''''')||''',EI.ORIGINE||''|''||EI.NUMPAC ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC)';
 EXECUTE_IMMEDIATE_STRING( req,0);
  
 -- Ecrasement de la clause Where
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||'''';
 -- Controles pour les éléments B691 et B690
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00195',p_codlang),'''','''''')||''',ei.valeur,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element=''B690'' and not exists(select * from   TGE_REF_IMPUTATION
 Ei2 where ei2.numpac in (Ei.numpac,''*'') and ei2.codeimp=ei.valeur )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS EI set EI.ERREURS=TGE_GET_MESSAGE_ERREUR(EI.ERREURS,'''||replace(get_message_erreur('TGE','TGE00193',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element=''B691'' and exists(select * from
 (select date_import,login,numpac,paiezad, code_element, sum(to_number(replace(valeur,''.'','',''))) as somme from TGE_IMPORT_ELEMENTS Ei2 where code_element=''B691'' AND IS_NUMBER(VALEUR) is not null  group by  date_import,login,numpac,paiezad, code_element) tmp where   ei.date_import  =tmp.date_import  AND ei.login =tmp.login and somme<>100 and ei.numpac =tmp.numpac
 AND ei.paiezad  =tmp.paiezad)  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00194',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF,'''||p_codlang||''')';
 req:= req || ' where '||clwhere||' AND code_element in (''B90'',''B691'') and not exists(select * from TGE_REF_MAPDO d where code_element=ELEMENT and indicatif=occurence and (d.numpac=Ei.numpac or d.numpac=''*''))  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
    	-- On remonte l'erreur à l'application
 		raise;
	END IF;
 END TGE_CONTROLE_30;
 
##
TAG_CHARSET=@€éèç
##
TGE_CONTROLE_40
=SQL=
create or replace PROCEDURE TGE_CONTROLE_40 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 , P_ISFSED in NUMBER
 ) AS
/********************************************************************************
Version     : V5.05.000
*********************************************************************************/
 cNumeric_Characters varchar2(40);
 cNLS_NUMERIC_CHARACTERS varchar2(40);
 clWhere varchar2(1000);
 req varchar2(2000);
 w_exist_incident VARCHAR2(2000);
 w_err VARCHAR2(2000);
 
 /* Objets utilisés pour le contrôle sur la somme des heures réalisées */
 -- Objet contenant un tableau des lignes par collaborateur par jour avec les sommes des heures réalisées déjà créées (TGE_INCIDENTS_PAIE) et des heures réalisées ajoutées par l'import
 TYPE T_REC IS RECORD (
 numpac varchar2(6),
 paiezad varchar2(8),
 date_effet date,
 somme_heures number,
 somme_heures_trav_import number);
 TYPE typ_tab IS table of T_REC;
 tab typ_tab ;
 -- Plus petite et plus grande date de l'import
 v_dateMinImport varchar2(8);
 v_dateMaxImport varchar2(8);
 varsys varchar2(100);
 
 BEGIN
 
 SELECT substr(TRIM(VALUE),length(TRIM(VALUE)))  INTO cNLS_NUMERIC_CHARACTERS FROM nls_session_parameters where PARAMETER = 'NLS_NUMERIC_CHARACTERS';
 
 clwhere:='login='''||p_login||''' and date_import='''||p_date_import||'''';
 if p_numligne is not null then
 clwhere:=clwhere||' AND NUMLIGNE='||p_numligne;
 end if;
 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controler
 clwhere:=clwhere || ' AND (STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR STATUT = ''TRANS'')';
 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées
 IF p_login='BATCH' THEN
 req:='update TGE_IMPORT_INCIDENTS I SET ERREURS = '''' WHERE '||clwhere;
EXECUTE_IMMEDIATE_STRING (req,0);
 END IF;
 
 -- Numpac non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PAIEZAD non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PERIODE non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- TYPE_TRAITEMENT non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_DEBUT non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00108',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_DEBUT is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_FIN non vide
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00109',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_FIN is null  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- NUMPAC controle format
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',NUMPAC,'''||p_codlang||''') where '||clwhere||' AND  NVL(LENGTH(NUMPAC),0)>6 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 ---controleLigneImportIncidentVide(TGE_IMPORT_INCIDENTS_sgbd p_importIncident, ArrayList<GxpErreurWithParams> p_arrErreurs)INCI0025
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','INCI0025',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_IP is null AND HEURES_IP IS NULL AND HEURES_TRAV IS NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PAIEZAD >8 cara
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',PAIEZAD,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8  ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PERIODE format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00083',p_codlang),'''','''''')||''',PERIODE||''|yyyyMM'','''||p_codlang||''') WHERE '||clwhere||' AND (IS_DATE(PERIODE ,''yyyyMM'') =0)' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_DEBUT format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00110',p_codlang),'''','''''')||''',DATE_DEBUT||''|yyyyMMdd'','''||p_codlang||''') WHERE '||clwhere||' AND (IS_DATE(DATE_DEBUT ,''yyyyMMdd'') =0) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- DATE_FIN format date OK
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00111',p_codlang),'''','''''')||''',DATE_FIN||''|yyyyMMdd'','''||p_codlang||''') WHERE '||clwhere||' AND IS_DATE(DATE_FIN ,''yyyyMMdd'') =0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- HEURES_TRAV controle 1 numerique
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00112',p_codlang),'''','''''')||''',HEURES_TRAV,'''||p_codlang||''') WHERE '||clwhere||' AND TGE_CONTROLE_HEURE_TRAV ( HEURES_TRAV, 3, 2,'''||cNLS_NUMERIC_CHARACTERS||''')=0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- HEURES_IP controle 1 numerique
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00113',p_codlang),'''','''''')||''',HEURES_IP,'''||p_codlang||''') WHERE '||clwhere||' AND TGE_CONTROLE_HEURE_TRAV ( HEURES_IP, 3, 2,'''||cNLS_NUMERIC_CHARACTERS||''')=0 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ORIGINE (lig 1968)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND (ORIGINE IS NOT NULL AND LENGTH(ORIGINE) >1) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ORIGINE
  IF P_LOGIN ='BATCH' THEN 
  req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00225',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND ((ORIGINE IS NOT NULL AND ORIGINE = ''T'') OR (ORIGINE is null)) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
  else if P_ISFSED=1 then
  req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00225',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND ((ORIGINE IS NOT NULL AND ORIGINE = ''T'') ) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
  END IF;
  END IF;
 
 -- CONTROLES EXISTENCES
 -- TYPE_TRAITEMENT (Lig 1971)
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND ii.TYPE_TRAITEMENT IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   '( exists  (SELECT RT.CODETYPTRT FROM TGE_REF_TYPETRT RT WHERE rt.numpac=ii.numpac and ii.type_traitement =RT.CODETYPTRT) )';
 req:= req || ' OR ';
 req:= req ||   '( exists (SELECT RT.CODETYPTRT FROM TGE_REF_TYPETRT RT WHERE rt.numpac=''*'' AND RT.codetyptrt= ii.type_traitement and ii.type_traitement =RT.CODETYPTRT AND NOT EXISTS (SELECT 1 FROM TGE_REF_TYPETRT RT2 WHERE RT2.NUMPAC=ii.numpac)))';
 req:= req || ')  ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_IMPUTATION (Lig 1972)
 
 select valvar into varsys from sys_varsys where module='TGE' and CODVAR='CTRL_CODE_IMPUTATION_EXISTE';
 if upper(varsys)<>'FALSE' then
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00012',p_codlang),'''','''''')||''',ii.code_imputation||''|''||ii.numPac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' and ii.code_imputation<>''*'' AND  ii.code_imputation IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   '( exists (SELECT ri.codeimp FROM TGE_REF_IMPUTATION ri WHERE ri.numpac = ii.numpac and ri.codeimp=ii.code_imputation))';
 req:= req || ' OR ';
 req:= req ||   '(exists  (SELECT ri.codeimp FROM TGE_REF_IMPUTATION ri WHERE ri.numpac=''*'' AND  ri.codeimp=ii.code_imputation and ri.codeimp= ii.code_imputation AND NOT EXISTS (SELECT 1 FROM TGE_REF_IMPUTATION rt2 WHERE rt2.numpac=ii.numpac and rt2.codeimp= ii.code_imputation)))';
 req:= req || ')  ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 end if;
 
 -- CODE_IP (Lig 1973)INCI0012
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','INCI0012',p_codlang),'''','''''')||''',code_ip,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND ii.code_ip IS NOT NULL AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac ) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac=''*'' AND rp.code_incident=ii.code_ip AND NOT EXISTS (SELECT 1 FROM TGE_REF_PRE rp2 WHERE rp2.numpac=ii.numpac and ii.code_ip=rp2.code_incident)))';
 req:= req || ') ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Contrôles spécifiques
 -- Date_Debut Date_Fin (lig 1977)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00118',p_codlang),'''','''''')||''',to_char(to_date(date_debut, ''yyyymmdd''), ''dd.mm.yyyy'')||''|''||to_char(to_date(date_fin, ''yyyymmdd''), ''dd.mm.yyyy''),'''||p_codlang||''') WHERE '||clwhere||' AND  date_debut > date_fin ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 
 -- HEURES_TRAV TYPE_HEURE (lig 1978)
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00114',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') WHERE '||clwhere||' AND heures_trav IS NOT NULL AND type_heure NOT IN (''T'',''R'') ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00115',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') WHERE '||clwhere||' AND heures_trav IS NULL AND type_heure IS NOT NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_IP HEURE_IP (lig 1979)
 /*req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00138',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_ip IS NOT NULL AND heures_ip IS NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);*/
 
 -- DOMAINE_IMP ligne 1980
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00119',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND (DOMAINE_IMP IS NOT NULL AND CODE_IMPUTATION IS NULL) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00120',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NOT NULL AND heures_ip IS NOT NULL AND domaine_imp != ''H'' AND domaine_imp !=''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00121',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NOT NULL AND heures_ip IS NULL AND domaine_imp != ''H'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00122',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_ip IS NOT NULL AND heures_trav IS NULL AND domaine_imp != ''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 req:='update TGE_IMPORT_INCIDENTS SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00136',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND code_imputation IS NOT NULL AND heures_trav IS NULL AND heures_ip IS NULL AND domaine_imp != ''1'' ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ctrl if heure contenuHeures(String p_heures, String p_type_ip, ArrayList<GxpErreurWithParams> p_arrErreurs) INCI0024
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0024',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND (((Ii.heures_ip IS NOT NULL OR Ii.code_ip is not null ) AND Ii.code_ip = ''HP'' AND II.heures_ip is null)
     OR (ii.HEURES_TRAV is null  AND ii.type_heure  in (''T'',''R''))
     ) ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --ToolsTge_controles.controleAutorisationPaieZad(p_loginUserOrDelegator, p_unIncident.numPac, p_unIncident.paieZad, arrErreurs);STD00049
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad||''|''||numpac,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND ii.paiezad IS NOT NULL AND ii.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =ii.numpac and C.CURRENT_PAIEZAD =ii.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =ii.numpac and C.CURRENT_PAIEZAD =ii.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleHoraireTheorique(p_unIncident, arrErreurs, p_transac); INCI0020 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0020',p_codlang),'''','''''')||''',type_heure,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.code_IP =''HP'' AND ii.code_imputation IS NOT NULL ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleDateDebutFin(p_code_ip,p_date_debut,p_date_fin,p_arrErreurs); TGE00226 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','TGE00226',p_codlang),'''','''''')||''',to_char(to_date(date_debut, ''yyyymmdd''), ''dd.mm.yyyy'')||''|''||to_char(to_date(date_fin, ''yyyymmdd''), ''dd.mm.yyyy''),'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.code_IP =''HP'' AND ii.DATE_FIN !=  ii.DATE_DEBUT ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 --controleCode_ip; INCI0027 DIT 37186
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||REPLACE(get_message_erreur('TGE','INCI0027',p_codlang),'''','''''')||''',code_ip,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  ii.type_heure != ''T'' AND  ii.type_heure != ''R''  AND (ii.CODE_IP =''HP'' OR ii.CODE_IP =''HT'') ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- controle saisie en demi journée DIT 42237
 req:='update TGE_IMPORT_INCIDENTS ii SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00264',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' where '||clwhere||' AND ii.CODE_IP  IS NOT NULL AND ii.CODE_IP != ''HP'' AND ii.DATE_DEBUT is not null and ii.DATE_FIN is not null  and ii.DATE_DEBUT!=ii.DATE_FIN ';
 req := req || 'AND ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac AND rp.OPTION_CONSERV_HISTO =''A'' AND rp.UNITE=''J'') ) AND is_number(ii.HEURES_IP)=0.5 ';
 
  EXECUTE_IMMEDIATE_STRING( req,0);
 
  -- controle saisie du volume different de 0 ou 1 DIT 42237
 req:='update TGE_IMPORT_INCIDENTS ii  SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00265',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')'; 
 req:= req || ' where '||clwhere||' AND ii.CODE_IP  IS NOT NULL AND ii.CODE_IP != ''HP'' ';
 req := req || 'AND ( exists (SELECT * FROM TGE_REF_PRE rp WHERE ii.code_ip=rp.code_incident and rp.numpac = ii.numpac AND rp.OPTION_CONSERV_HISTO =''A'' AND rp.UNITE=''J'') ) AND is_number(ii.HEURES_IP)!=0 AND is_number(ii.HEURES_IP)!=1  AND is_number(ii.HEURES_IP)!=0.5 ';
  EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Bloquer les imports carte 40 sur des périodes antérieures à la date de limite de rétro
 req:='MERGE INTO TGE_IMPORT_INCIDENTS II USING ';
 req:= req ||' (SELECT NUMPAC, PERIODEENCOURS, DEB_RETRO, DEB_HISTO_RETRO, NB_MOIS_RETRO, ';
 req:= req ||'  GREATEST(NVL(DEB_HISTO_RETRO, ''190001''), (TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS, ''YYYYMM''), -NB_MOIS_RETRO), ''YYYYMM''))) AS LIMITE_RETRO ';
 req:= req ||' FROM TGE_REF_PAC ) P';
 req:= req ||' ON (';
 req:= req || clwhere;
 req:= req ||' AND II.NUMPAC = P.NUMPAC';
 req:= req ||' AND II.PERIODE < P.PERIODEENCOURS';
 req:= req ||' AND ( P.DEB_RETRO IS NOT NULL AND P.DEB_RETRO <= P.PERIODEENCOURS';
 req:= req ||' ) ) WHEN MATCHED THEN UPDATE SET II.ERREURS = CASE';
 req:= req ||' WHEN II.PERIODE < P.DEB_HISTO_RETRO THEN TGE_GET_MESSAGE_ERREUR(II.ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' WHEN II.PERIODE < P.LIMITE_RETRO THEN TGE_GET_MESSAGE_ERREUR(II.ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',TO_CHAR(TO_DATE(P.LIMITE_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' END WHERE II.ERREURS IS NULL';
 EXECUTE_IMMEDIATE_STRING(req, 0);
 
 -- Bloquer en mode non rétro les imports carte 40 sur des périodes antérieures à la période en cours
 req := 'MERGE INTO TGE_IMPORT_INCIDENTS II USING TGE_REF_PAC P ON( '|| clwhere;
 req := req || ' AND II.NUMPAC = P.NUMPAC';
 req := req || ' AND P.PERIODEENCOURS IS NOT NULL ';
 req := req || ' AND (P.DEB_RETRO > P.PERIODEENCOURS OR P.DEB_RETRO IS NULL) ';
 req := req || ' AND II.PERIODE < P.PERIODEENCOURS) ';
 req := req || ' WHEN MATCHED THEN UPDATE ';
 req := req || ' SET II.ERREURS = TGE_GET_MESSAGE_ERREUR(II.ERREURS, ''' || replace(get_message_erreur('TGE', 'TGE00351', p_codlang), '''', '''''') || ''', NULL, ''' || p_codlang || ''')';
 req := req || ' WHERE II.ERREURS IS NULL';
 EXECUTE_IMMEDIATE_STRING(req, 0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
 		-- On remonte l'erreur à l'application
  		raise;
  	END IF;
 END TGE_CONTROLE_40;
##
TAG_CHARSET=@€éèç
##
TRG_TGE_INCIDENTS_PAIE
=SQL=
create or replace trigger trg_tge_incidents_paie FOR
  insert or
  update or
  delete on tge_incidents_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   varchar2(1);
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_date_effet       DATE; 
  v_periode_retro    VARCHAR2(6);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  dateFinRecueil DATE;
  moisPaie  VARCHAR2(6);
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   DATE;
  date_effet_recycl   DATE;
  A520 VARCHAR2(32);
  A521 VARCHAR2(32);
  A523 VARCHAR2(32);
  activite VARCHAR2(32);
  etablissement VARCHAR2(32);
  categorie VARCHAR2(32);
  nomTablegxp VARCHAR2(32);
  requete CLOB;
  V_IS_T2           NUMBER;
  V_ORIGINE_CREATE  VARCHAR2(32);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
    BEGIN
        v_numpac        := NVL(:new.numpac, :old.numpac);
        v_paiezad       := NVL(:new.paiezad, :old.paiezad);
        v_date_effet    := NVL(:new.date_effet, :old.date_effet);
        V_ORIGINE_CREATE := NVL(:new.ORIGINE_CREATE, :old.ORIGINE_CREATE);
        SELECT COUNT(*) INTO V_IS_T2 
        FROM DIC_ADM_CONTRAT_HISTO 
        WHERE V_ORIGINE_CREATE = 'BATCH' 
        AND NUMPAC = v_numpac 
        AND PAIEZAD = v_paiezad 
        AND ZA996 = 'A' 
        AND v_date_effet BETWEEN DATE_EFF AND DATE_SORTIE_SIT_BO;
        IF  V_IS_T2 = 0 THEN 
	        SELECT MIN(MOIS_PAIE) 
	        INTO v_periode_retro
	        FROM TGE_PERIODE_RECUEIL_PAIEZAD
	        WHERE numpac = v_numpac
	        AND paiezad  = v_paiezad
	        AND v_date_effet BETWEEN DEBUT_PERIODE_RECUEIL AND FIN_PERIODE_RECUEIL;
	        IF v_periode_retro IS NOT NULL THEN
	          :new.periode     := TO_DATE(v_periode_retro || 01, 'yyyyMMdd');
	        END IF;
	    END IF;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Période de recueil non trouvé
        null;
    END;
  end if;

  if (v_type_writer <> 'N') then
    v_numpac      := nvl(:new.numpac, :old.numpac);
    v_paiezad     := nvl(:new.paiezad, :old.paiezad);
    BEGIN
        SELECT t.pacmat,nvl(t.periode_recyclage,'1'),CODE_CHRONO
        INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
        from dic_adm_contrat_SITU d, secupacmat t
        where d.numpac = v_numpac
        and d.paiezad  = v_paiezad
        and d.numpac   = t.numpac
        and d.pacmat   = t.pacmat
        and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        null;
    END;
    if v_periode_recycl = '3' then
      raise_application_error(-20000, 'CODERR=GENREC02');
    elsif v_periode_recycl = '2' then
      raise_application_error(-20000, 'CODERR=GENREC01');
    elsif v_periode_recycl = '1' then
      v_recycl            := 'N';
      --Période de recueil individuelle
 select periodeencours into moisPaie from tge_ref_pac where numpac = v_numpac;
 BEGIN
 --Période de recueil individuelle
 SELECT FIN_PERIODE_RECUEIL INTO dateFinRecueil from tge_periode_recueil_paiezad where numpac=v_numpac 
 and MOIS_PAIE=moisPaie and paiezad=v_paiezad ;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
 
 dateFinRecueil:=null;
 END;
 --Période de recueil génèrique
 if(dateFinRecueil  is null) then
   SELECT tablegxp ,
    A520_DONNEE ,
    A521_DONNEE ,
    A523_DONNEE into 
    nomTablegxp,A520,A521,A523
  FROM
  (
  SELECT DISTINCT c.element,
    c.tablegxp,
    c.DONNEEGXP
  FROM tge_ref_mapdo c
  WHERE C.numpac = v_numpac
  AND c.element IN ('A520','A521', 'A523')
  UNION ALL
  SELECT DISTINCT c.element,
    c.tablegxp,
    c.DONNEEGXP
  FROM tge_ref_mapdo c
  WHERE C.numpac                  ='*'
  AND c.element                  IN ('A520','A521', 'A523')
  AND (c.TABLEGXP,c.ELEMENT) NOT IN
    (SELECT a.TABLEGXP,
      a.element
    FROM tge_ref_mapdo a
    WHERE a.numpac = v_numpac
    AND A.ELEMENT IN ('A520','A521', 'A523')
    )
  ) pivot ( MAX(DONNEEGXP) AS DONNEE FOR (element) IN('A520' AS A520,'A521' AS A521, 'A523' AS A523));
  if( A520 is  not null  and A521 is not null and A523  is not null) then
    requete:='select '||A520|| ','||A521||','||A523||'  from '||nomTablegxp||' d '; 
    requete:=requete || ' where numpac='''||v_numpac||''' and paiezad='''|| v_paiezad  || ''' and pacmat='''||v_pacmat||''''; 
    if( nomTablegxp='DIC_ADM_CONTRAT_HISTO') then
 		requete:=requete || ' and sysdate BETWEEN date_eff and date_fin_bo AND rownum=1';
 	end if;
    BEGIN
    EXECUTE IMMEDIATE requete into activite,etablissement,categorie;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      dateFinRecueil:=null;
    END;
  end if;
  if(activite is not null and etablissement is not null and categorie is not null) then
    BEGIN
    select 
    max(to_date(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 37, 8),'DDMMYYYY')) into  dateFinRecueil
    from tge_ref_vrval   
    WHERE numero_de_pac = v_numpac 
    AND SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT, 19 , 6 ) = to_char(to_date(moisPaie,'YYYYMM'),'MMYYYY') 
    AND CODE_TABLE = 'LTP'  
    AND IS_BETWEEN_NLS_FRENCH(LPAD(activite,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,1 ,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,3,2),2) )  = 'TRUE' 
    AND IS_BETWEEN_NLS_FRENCH(LPAD(etablissement,5),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,5 ,5),5), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,10,5),5))  = 'TRUE' 
    AND IS_BETWEEN_NLS_FRENCH(LPAD(categorie,2),LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,15,2),2), LPAD(SUBSTR(TGE_REF_VRVAL.ENREGISTREMENT,17,2),2) )  = 'TRUE' ;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      dateFinRecueil:=null;
    END;
  end if;
 end if;
 if (dateFinRecueil is null) then
    select LAST_DAY( to_date(moisPaie,'YYYYMM') ) into dateFinRecueil from dual;
 end if;
      IF DELETING THEN
        date_test_recycl := :old.periode;
		date_effet_recycl :=:old.date_effet;
      ELSE
        date_test_recycl := :new.periode;
		 IF updating THEN
		 	date_effet_recycl :=LEAST(:new.date_effet,:old.date_effet);
		 ELSE
		 	date_effet_recycl :=:new.date_effet;
		 END IF;
	  END IF;
	    IF  (NVL(TO_CHAR(date_effet_recycl,'yyyymm'),'000000') > to_char(dateFinRecueil,'YYYYMMDD' ) ) THEN
		 date_test_recycl := TO_DATE('20991231','yyyymmdd');
      END IF;
 		if (NVL(TO_CHAR(date_test_recycl,'yyyymm'),'000000') <= to_char(dateFinRecueil,'YYYYMMDD' ) ) then
        if inserting or deleting then
          v_recycl := 'O';
        elsif updating then
          if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
            v_recycl                 := 'O';
          elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
            v_recycl                 := 'O';
          elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
            v_recycl                 := 'O';
          elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
            v_recycl                 := 'O';
          elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_recycl                 := 'O';
          elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
            v_recycl                 := 'O';
          elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
            v_recycl                 := 'O';
          elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
            v_recycl                 := 'O';
          elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_recycl                 := 'O';
          end if;
        end if;
        if v_recycl = 'O' then
          begin
            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
          when not matched then
            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
          exception
          when others then
            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;
          end;
        end if;
      end if;
    end if;
    /** Test de mise en rétro **/
    v_retro            := 'N';
    if inserting or deleting then
      v_retro := 'O';
    elsif updating then
      -- Les valeurs des colonnes clés ne peuvent pas être nulls 
      if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
        v_retro                 := 'O';
      elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
        v_retro                 := 'O';
      elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
        v_retro                 := 'O';
      elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
        v_retro                 := 'O';
      elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
        v_retro                 := 'O';
      elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
        v_retro                 := 'O';
      elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
        v_retro                 := 'O';
      elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
        v_retro                 := 'O';
      elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
        v_retro                 := 'O';
      end if;
    end if;
    if v_retro = 'O' then
      V_PERIODE := TO_CHAR(NVL(:NEW.PERIODE,:OLD.PERIODE),'YYYYMM');
      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_INCIDENTS_PAIE');
    END IF;
  /** Fin test de mise en rétro **/
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_incidents_paie;
##
TAG_CHARSET=@€éèç
##
MP_DATA_IHM
=SQL=
CREATE OR REPLACE VIEW MP_DATA_IHM (NOM_DONNEE_UX, LIBELLE_DONNEE_UX, REGROUPEMENT)AS
select M.DATA_NAME_MP_ALP, D.LABEL, M.REGROUPEMENT from MP_DATA M
inner join  MP_REF_DATA_ALP A on A.DATA_NAME_MP_ALP =  M.DATA_NAME_MP_ALP
inner join MP_REF_DATA D on  D.DATA_NAME_MP=A.DATA_NAME_MP
##
TAG_CHARSET=@€éèç
##
MP_MAPPING_EVENT_DATA_IHM
=SQL=
CREATE OR REPLACE VIEW MP_MAPPING_EVENT_DATA_IHM AS
SELECT EVENT, NOM_DONNEE_DEX_OU_EVENT FROM MP_MAPPING_EVENT_DATA WHERE TYPE='D'
UNION
SELECT EVENT, NOM_DONNEE_DEX_OU_EVENT FROM (
SELECT CONNECT_BY_ROOT(EVENT) AS EVENT, NOM_DONNEE_DEX_OU_EVENT, TYPE FROM MP_MAPPING_EVENT_DATA START WITH TYPE='E' CONNECT BY PRIOR NOM_DONNEE_DEX_OU_EVENT = EVENT
) WHERE TYPE='D'
##
TAG_CHARSET=@€éèç
##
ADR_APPELJOUR
=SQL IFNOTEXIST=ADR_APPELJOUR=
CREATE TABLE ADR_AppelJour(Api VARCHAR2 (50) NOT NULL,  Date_appel DATE  NOT NULL, Nbr_appel  NUMBER(10,0) NOT NULL, CONSTRAINT ADR_AppelJour_PK PRIMARY KEY (Api,Date_appel))
##
TAG_CHARSET=@€éèç
##
ADR_LIEU
=SQL IFNOTEXIST=ADR_LIEU=
CREATE TABLE ADR_Lieu(adresse VARCHAR2 (100) NOT NULL, pays VARCHAR2 (50) NOT NULL, ville VARCHAR2 (50) NOT NULL, region VARCHAR2 (50) NOT NULL, codePostal VARCHAR2 (50) NOT NULL, Latitude VARCHAR2 (50) NOT NULL, Longitude VARCHAR2 (50) NOT NULL, DateCreation  DATE  NOT NULL, DateMaj DATE  NOT NULL, CONSTRAINT ADR_Lieu_PK PRIMARY KEY (adresse))
##
TAG_CHARSET=@€éèç
##
ADR_TRAJET
=SQL IFNOTEXIST=ADR_TRAJET=
CREATE TABLE ADR_Trajet(Id_LieuA VARCHAR2(100) NOT NULL, Id_LieuB VARCHAR2(100) NOT NULL, Api VARCHAR2 (50) NOT NULL, DistanceRouteAB VARCHAR2 (50) NOT NULL, DistanceRouteBA VARCHAR2 (50) NOT NULL, DistanceOiseau VARCHAR2 (50) NOT NULL, DateCreation DATE  NOT NULL, DateMaj DATE  NOT NULL, CONSTRAINT ADR_Trajet_PK PRIMARY KEY (Id_LieuA,Id_LieuB), CONSTRAINT ADR_Trajet_ADR_LieuA_FK FOREIGN KEY (Id_LieuA) REFERENCES ADR_Lieu(adresse), CONSTRAINT ADR_Trajet_ADR_LieuB_FK FOREIGN KEY (Id_LieuB) REFERENCES ADR_Lieu(adresse))
##
EDI_REQ_SQL_CF
==
DELETE FROM EDI_REQ_SQL_CF where nomreq = 'EXPORT_RUBRIQUE'
'EXPORT_RUBRIQUE','Col1','''Classification''',null,1,'T','Col1',0
'EXPORT_RUBRIQUE','Col11','''Horaire''',null,11,'T','Col11',0
'EXPORT_RUBRIQUE','Col12','H.OTT||'' - ''||(SELECT LIBELLE FROM GA_ZOTT ZO WHERE ZO.CODE = H.OTT AND ZO.NUMPAC = H.NUMPAC)',null,12,'T','Col12',0
'EXPORT_RUBRIQUE','Col13','''Coefficient''',null,13,'T','Col13',0
'EXPORT_RUBRIQUE','Col14','H.COEFF',null,14,'T','Col14',0
'EXPORT_RUBRIQUE','Col15','''Service''',null,15,'T','Col15',0
'EXPORT_RUBRIQUE','Col2','H.ZA557||'' - ''||(SELECT LIBELLE FROM GA_ZCLA Z WHERE Z.CODE = H.ZA557 AND Z.NUMPAC = H.NUMPAC)',null,2,'T','Col2',0
'EXPORT_RUBRIQUE','Col3','''Etablissement''','null''',3,'T','Col3',0
'EXPORT_RUBRIQUE','Col4','H.CODETB||'' - ''||(SELECT LIBELLE FROM STD_STRUC_ENTITE E WHERE E.CODE_ENTITE= H.CODETB AND TO_CHAR(SYSDATE, ''YYYYMMDD'') BETWEEN E.DATE_EFF AND E.DATE_FIN)',null,4,'T','Col4',0
'EXPORT_RUBRIQUE','Col5','''Salaire''',null,5,'T','Col5',0
'EXPORT_RUBRIQUE','Col6','H.SAFBA',null,6,'T','Col6',0
'EXPORT_RUBRIQUE','Col7','''Emploi''',null,7,'T','Col7',0
'EXPORT_RUBRIQUE','Col8','H.QUALPE',null,8,'T','Col8',0
'EXPORT_RUBRIQUE','Col9','''Direction''',null,9,'T','Col9',0
'EXPORT_RUBRIQUE','Col10','(SELECT CODE_ENTITE||'' - ''||LIBELLE_ENTITE FROM STD_STRUC_ENTITE_VIEW ENT WHERE ENT.CODE_ENTITE = niv2.ent2)',null,10,'T','Col10',0
'EXPORT_RUBRIQUE','Col16','(SELECT CODE_ENTITE||'' - ''||LIBELLE_ENTITE FROM STD_STRUC_ENTITE_VIEW ENT WHERE ENT.CODE_ENTITE = niv3.ent3)',null,16,'T','Col16',0
##
EDI_REQ_SQL_CF
==
DELETE FROM EDI_REQ_SQL_CF WHERE NOMREQ ='HELPDESK_CLIENT' AND NOMCHAMPFUSION = 'COMARBITRAGE' 
##
EDI_REQ_SQL_CF
==
DELETE FROM EDI_REQ_SQL_CF WHERE NOMREQ ='HELPDESK_REQUEST' AND NOMCHAMPFUSION = 'COMARBITRAGE'
##
EDI_REQ_SQL_CF
==
DELETE FROM EDI_REQ_SQL_CF WHERE NOMREQ ='HELPDESK_CLIENT' AND NOMCHAMPFUSION = 'DATEFICHE'
'HELPDESK_CLIENT','DATEFICHE','to_char(DATEFICHE,''dd.mm.yyyy'')',null,'7','D','DATEFICHE','0'
##
EDI_REQ_SQL_CF
==
DELETE FROM EDI_REQ_SQL_CF WHERE NOMREQ ='HELPDESK_REQUEST' AND NOMCHAMPFUSION = 'DATEFICHE'
'HELPDESK_REQUEST','DATEFICHE','to_char(DATEFICHE,''dd.mm.yyyy'')',null,'9','D','DATEFICHE','0'
##
HELPDESK_FICHE
=SQL IFNOTEXIST=HELPDESK_FICHE=ISUX=
ALTER TABLE HELPDESK_FICHE ADD ISUX varchar2(2)
##
HELPDESK_FICHE
=SQL IFNOTEXIST=HELPDESK_FICHE=MATRIC_ESCALADE=
ALTER TABLE HELPDESK_FICHE ADD MATRIC_ESCALADE varchar2(32)
##
HELPDESK_FICHE
=SQL IFNOTEXIST=HELPDESK_FICHE=COMRRH=
ALTER TABLE HELPDESK_FICHE ADD COMRRH varchar2(4000)
##
HELPDESK_FICHE
=SQL=
DECLARE
DATEFICHE_TYPE varchar2(60);
DATEMODIF_TYPE varchar2(60);
BEGIN
EXECUTE IMMEDIATE 'SELECT data_type  FROM user_tab_cols WHERE table_name = ''HELPDESK_FICHE'' AND column_name = ''DATEFICHE''' into DATEFICHE_TYPE ;
EXECUTE IMMEDIATE 'SELECT data_type  FROM user_tab_cols WHERE table_name = ''HELPDESK_FICHE'' AND column_name = ''DATEMODIF''' into DATEMODIF_TYPE ;
IF(DATEFICHE_TYPE='VARCHAR2' AND DATEMODIF_TYPE='VARCHAR2') THEN
 EXECUTE IMMEDIATE 'CREATE TABLE HELPDESK_FICHE_2
   ( CODFICHE NUMBER NOT NULL ENABLE, 
	LIBFICHE VARCHAR2(400), 
	DATEFICHE DATE, 
	AUTEURFICHE VARCHAR2(100), 
	TYPFICHE VARCHAR2(1), 
	GRAVFICHE VARCHAR2(1), 
	DATBUTFICHE VARCHAR2(8), 
	ENJEUFICHE VARCHAR2(4000), 
	CODCLIENT NUMBER, 
	TYPDOM VARCHAR2(3), 
	CODMOD NUMBER, 
	VERSION VARCHAR2(20), 
	DESCFICHE VARCHAR2(4000), 
	CODSTA NUMBER, 
	DATEPLANIFINIT VARCHAR2(10), 
	DATEPLANIFACT VARCHAR2(8), 
	CODPRJT VARCHAR2(10), 
	NUMDIT VARCHAR2(10), 
	COMARBITRAGE VARCHAR2(4000), 
	COMRD VARCHAR2(4000), 
	TRIMPLANIFACT VARCHAR2(20), 
	VERREA VARCHAR2(20), 
	MACROANA NUMBER(*,3), 
	MACRODEV NUMBER(*,3), 
	FILEJOIN VARCHAR2(255), 
	INDICATEURPLANIF VARCHAR2(20), 
	NUMPTS VARCHAR2(50), 
	RESPNIV1 VARCHAR2(150), 
	CODEUSER VARCHAR2(100), 
	MATRIC VARCHAR2(32), 
	DATEMODIF DATE, 
	MATRICBENEFICIAIRE VARCHAR2(32), 
	DADP VARCHAR2(1), 
	DADPNUMBER VARCHAR2(25), 
	MACROSUP NUMBER, 
	LASTUSER VARCHAR2(200), 
	COMANALYSE VARCHAR2(4000), 
	CODFICHELIEE NUMBER, 
	RAF NUMBER, 
	CODTST NUMBER DEFAULT 0, 
	TSTBPI NUMBER DEFAULT 0, 
	IMPACT NUMBER DEFAULT 0, 
	FICHEORIGINE VARCHAR2(1), 
	FICHEIMPACTAIDE VARCHAR2(1), 
	PRIORITE VARCHAR2(1), 
	RELEASE VARCHAR2(20), 
	L31 VARCHAR2(1), 
	L50 VARCHAR2(1), 
	L71 VARCHAR2(1), 
	NUMFICHE_ESERVICE VARCHAR2(13), 
	NUMPAC VARCHAR2(10), 
	ISUX VARCHAR2(2), 
	MATRIC_ESCALADE VARCHAR2(32), 
	COMRRH VARCHAR2(4000), 
	PRIMARY KEY (CODFICHE))';
	 
 EXECUTE IMMEDIATE 'INSERT INTO HELPDESK_FICHE_2( CODFICHE, 
 LIBFICHE ,
	 DATEFICHE, 
	 AUTEURFICHE, 
	 TYPFICHE ,
	 GRAVFICHE ,
	 DATBUTFICHE, 
	 ENJEUFICHE ,
	 CODCLIENT, 
	 TYPDOM ,
	 CODMOD, 
	 VERSION ,
	 DESCFICHE, 
	 CODSTA, 
	 DATEPLANIFINIT, 
	 DATEPLANIFACT ,
	 CODPRJT ,
	 NUMDIT ,
	 COMARBITRAGE, 
	 COMRD ,
	 TRIMPLANIFACT, 
	 VERREA ,
	 MACROANA , 
	 MACRODEV , 
	 FILEJOIN, 
	 INDICATEURPLANIF, 
	 NUMPTS ,
	 RESPNIV1, 
	 CODEUSER ,
	 MATRIC ,
	 DATEMODIF, 
	 MATRICBENEFICIAIRE, 
	 DADP ,
	 DADPNUMBER, 
	 MACROSUP, 
	 LASTUSER ,
	 COMANALYSE, 
	 CODFICHELIEE, 
	 RAF, 
	 CODTST, 
	 TSTBPI, 
	 IMPACT, 
	 FICHEORIGINE ,
	 FICHEIMPACTAIDE ,
	 PRIORITE ,
	 RELEASE ,
	 L31, 
	 L50, 
	 L71 ,
	 NUMFICHE_ESERVICE ,
	 NUMPAC ,
	 ISUX ,
	 MATRIC_ESCALADE ,
	 COMRRH ) (SELECT CODFICHE, 
 LIBFICHE ,
	 TO_DATE(DATEFICHE,''yyyy/mm/dd''), 
	 AUTEURFICHE, 
	 TYPFICHE ,
	 GRAVFICHE ,
	 DATBUTFICHE, 
	 ENJEUFICHE ,
	 CODCLIENT, 
	 TYPDOM ,
	 CODMOD, 
	 VERSION ,
	 DESCFICHE, 
	 CODSTA, 
	 DATEPLANIFINIT, 
	 DATEPLANIFACT ,
	 CODPRJT ,
	 NUMDIT ,
	 COMARBITRAGE, 
	 COMRD ,
	 TRIMPLANIFACT, 
	 VERREA ,
	 MACROANA , 
	 MACRODEV , 
	 FILEJOIN, 
	 INDICATEURPLANIF, 
	 NUMPTS ,
	 RESPNIV1, 
	 CODEUSER ,
	 MATRIC ,
   TO_DATE(DATEMODIF,''yyyy/mm/dd''),
	 MATRICBENEFICIAIRE, 
	 DADP ,
	 DADPNUMBER, 
	 MACROSUP, 
	 LASTUSER ,
	 COMANALYSE, 
	 CODFICHELIEE, 
	 RAF, 
	 CODTST, 
	 TSTBPI, 
	 IMPACT, 
	 FICHEORIGINE ,
	 FICHEIMPACTAIDE ,
	 PRIORITE ,
	 RELEASE ,
	 L31, 
	 L50, 
	 L71 ,
	 NUMFICHE_ESERVICE ,
	 NUMPAC ,
	 ISUX ,
	 MATRIC_ESCALADE ,
	 COMRRH from HELPDESK_FICHE)' ;
	 
  EXECUTE IMMEDIATE 'RENAME  HELPDESK_FICHE TO  HELPDESK_FICHE_tmp' ;
  EXECUTE IMMEDIATE 'RENAME HELPDESK_FICHE_2  to  HELPDESK_FICHE' ;
  EXECUTE IMMEDIATE 'DROP TABLE HELPDESK_FICHE_tmp';
  EXECUTE IMMEDIATE 'COMMIT';
END IF ;
END;
##
HELPDESK_FICHE
=SQL=
BEGIN
EXECUTE IMMEDIATE 'CREATE TABLE HELPDESK_FICHE_inter
  (
    CODFICHE           NUMBER NOT NULL ENABLE,
    LIBFICHE           VARCHAR2(400),
    DATEFICHE          DATE,
    AUTEURFICHE        VARCHAR2(100),
    TYPFICHE           VARCHAR2(1),
    GRAVFICHE          VARCHAR2(1),
    DATBUTFICHE        VARCHAR2(8),
    TYPDOM             VARCHAR2(3),
    CODMOD             NUMBER,
    DESCFICHE          VARCHAR2(4000),
    CODSTA             NUMBER,
    DATEPLANIFINIT     VARCHAR2(10),
    DATEPLANIFACT      VARCHAR2(8),
    COMRD              VARCHAR2(4000),
    FILEJOIN           VARCHAR2(255),
    INDICATEURPLANIF   VARCHAR2(20),
    RESPNIV1           VARCHAR2(150),
    CODEUSER           VARCHAR2(100),
    MATRIC             VARCHAR2(32),
    DATEMODIF          DATE,
    MATRICBENEFICIAIRE VARCHAR2(32),
    LASTUSER           VARCHAR2(200),
    CODFICHELIEE       NUMBER,
    FICHEORIGINE       VARCHAR2(1),
    PRIORITE           VARCHAR2(1),
    NUMFICHE_ESERVICE  VARCHAR2(13),
    NUMPAC             VARCHAR2(10),
    ISUX               VARCHAR2(2),
    MATRIC_ESCALADE    VARCHAR2(32),
    COMRRH             VARCHAR2(4000),
    PRIMARY KEY (CODFICHE)
  )';
 
 EXECUTE IMMEDIATE 'INSERT
INTO HELPDESK_FICHE_inter
  (
    CODFICHE,
    LIBFICHE ,
    DATEFICHE,
    AUTEURFICHE,
    TYPFICHE ,
    GRAVFICHE ,
    DATBUTFICHE,
    TYPDOM ,
    CODMOD,
    DESCFICHE,
    CODSTA,
    DATEPLANIFINIT,
    DATEPLANIFACT ,
    COMRD ,
    FILEJOIN,
    INDICATEURPLANIF,
    RESPNIV1,
    CODEUSER ,
    MATRIC ,
    DATEMODIF,
    MATRICBENEFICIAIRE,
    LASTUSER ,
    CODFICHELIEE,
    FICHEORIGINE ,
    PRIORITE ,
    NUMFICHE_ESERVICE ,
    NUMPAC ,
    ISUX ,
    MATRIC_ESCALADE ,
    COMRRH
  )
  (SELECT CODFICHE,
      LIBFICHE ,
      DATEFICHE,
      AUTEURFICHE,
      TYPFICHE ,
      GRAVFICHE ,
      DATBUTFICHE,
      TYPDOM ,
      CODMOD,
      DESCFICHE,
      CODSTA,
      DATEPLANIFINIT,
      DATEPLANIFACT ,
      COMRD ,
      FILEJOIN,
      INDICATEURPLANIF,
      RESPNIV1,
      CODEUSER ,
      MATRIC ,
      DATEMODIF,
      MATRICBENEFICIAIRE,
      LASTUSER ,
      CODFICHELIEE,
      FICHEORIGINE ,
      PRIORITE ,
      NUMFICHE_ESERVICE ,
      NUMPAC ,
      ISUX ,
      MATRIC_ESCALADE ,
      COMRRH
    FROM HELPDESK_FICHE)';
    
    EXECUTE IMMEDIATE 'rename HELPDESK_FICHE to HELPDESK_FICHE_tmp';
    EXECUTE IMMEDIATE 'rename HELPDESK_FICHE_inter to HELPDESK_FICHE';
    
    EXECUTE IMMEDIATE 'DROP TABLE HELPDESK_FICHE_tmp';
    EXECUTE IMMEDIATE 'COMMIT' ;
   
END;
##
HELPDESK_FICHE
=SQL IFNOTEXIST=HELPDESK_FICHE=NOTIFICATIONINDICATOR=
ALTER TABLE HELPDESK_FICHE ADD NOTIFICATIONINDICATOR VARCHAR(5)
##
HELPDESK_MESSAGE
=SQL IFNOTEXIST=HELPDESK_MESSAGE=MESSAGE_UX=
ALTER TABLE HELPDESK_MESSAGE ADD MESSAGE_UX varchar2(4000)
##
HELPDESK_TYPE
=SQL IFNOTEXIST=HELPDESK_TYPE=VALDEFAUTCOLLAB=
ALTER TABLE HELPDESK_TYPE ADD VALDEFAUTCOLLAB VARCHAR2(1) DEFAULT 'O'
##
HELPDESK_TYPE
==
UPDATE HELPDESK_TYPE SET VALDEFAUTCOLLAB='N' WHERE TYPFICHE='E'
##
HELPDESK_TYPE
==
DELETE FROM HELPDESK_TYPE WHERE TYPFICHE in ('A','E','Q','D')
'A','Anomalie rencontrée',1,'Report an Issue','O','Anomalie / Incident','O'
'E','Evolution',2,'Request For Change','O','Changement / Evolution','N'
'Q','Demande d''information',3,'Request for Information','O','Assistance / Question','O'
'D','Demande de service',4,'Process Request','O','Demande de service','O'
##
TAG_CHARSET=@€éèç
##
MATRIC_TRAITEMENT_BATCH_CAD
=SQL IFNOTEXIST=MATRIC_TRAITEMENT_BATCH_CAD=
CREATE TABLE MATRIC_TRAITEMENT_BATCH_CAD (DATE_EFF VARCHAR2(16),MATRIC VARCHAR2(32),DATE_DEB VARCHAR2(16),DATE_FIN VARCHAR2(16),LOGIN VARCHAR2(32),LOGIN_HOST VARCHAR2(32),LANGUE VARCHAR(32),DATE_TRAITEMENT timestamp )
##
MATRIC_TRAITEMENT_BATCH_CAD
=SQL IFNOTEXIST=MATRIC_TRAITEMENT_BATCH_CAD=TYPE_TRT=
ALTER TABLE MATRIC_TRAITEMENT_BATCH_CAD ADD TYPE_TRT VARCHAR2(8)
##
TAG_CHARSET=@€éèç
##
MP_EVENTID
=SQL IFNOTEXIST=MP_EVENTID=
CREATE TABLE "MP_EVENTID" ("EVENTID" VARCHAR2(32) NOT NULL ENABLE,"MATRIC" VARCHAR2(32) NOT NULL ENABLE, "EVENT" VARCHAR2(100) NOT NULL ENABLE,"CLE_SECONDAIRE" VARCHAR2(500), "ACTION" VARCHAR2(1),PRIMARY KEY (EVENTID)) 
##
TAG_CHARSET=@€éèç
##
MP_REF_EVENTS
==
delete from MP_REF_EVENTS where EVENT in ('/events/hr/v1/worker.custom-field.number.change','/events/hr/v1/worker.custom-field.date.change','/events/hr/v1/worker.custom-field.string.change')
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.custom-field.number.change',null,'Modification de mes infos supplémentaires',null,'Employee - Infos supplémentaires',null)
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.custom-field.date.change',null,'Modification de mes infos supplémentaires',null,'Employee - Infos supplémentaires',null)
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.custom-field.string.change',null,'Modification de mes infos supplémentaires',null,'Employee - Infos supplémentaires',null)
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
DELETE FROM MP_REF_EVENTS WHERE EVENT in ('/events/hr/v1/worker.work-assignment.assigned-work-location.change','/events/benefits/v1/benefit-coverages-enrollment.modify')
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.work-assignment.assigned-work-location.change','16','Modification du numéro de bureau',null,'Employee - Work Location','O')
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/benefits/v1/benefit-coverages-enrollment.modify','130','Souscription à une mutuelle','55300','Employee - Benefit Coverages','O')
##
MP_REF_EVENTS (EVENT,EVENT_ID,LIBELLE,OP_NUM,UX_EVENTNAME,IS_NOTIFICATION)
=SQL IFEXIST=MP_REF_EVENTS=
DELETE FROM MP_REF_EVENTS WHERE EVENT IN ('/events/hr/v1/worker.immigration-document.remove','/events/hr/v1/worker.immigration-document.add','/events/hr/v1/worker.immigration-document.change')
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.immigration-document.remove',NULL,'suppression Carte salarié étranger','40203',NULL,NULL)
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.immigration-document.add',NULL,'ajout Carte salarié étranger','40203',NULL,NULL)
##
MP_REF_EVENTS
=SQL IFEXIST=MP_REF_EVENTS=
insert into MP_REF_EVENTS values ('/events/hr/v1/worker.immigration-document.change',NULL,'Modification Carte salarié étranger','40203',NULL,NULL)
##
TRG_SIMU_TGE_STRUC
==
alter trigger TRG_SIMU_TGE_STRUC disable
##
TAG_CHARSET=@€éèç
##
SIMU_TGE_PERIODE_RECUEIL_PZAD
=SQL IFNOTEXIST=SIMU_TGE_PERIODE_RECUEIL_PZAD=DEBUT_PERIODE_RECUEIL_LTP=
ALTER TABLE SIMU_TGE_PERIODE_RECUEIL_PZAD ADD (DEBUT_PERIODE_RECUEIL_LTP  DATE)
##
SIMU_TGE_PERIODE_RECUEIL_PZAD
=SQL IFNOTEXIST=SIMU_TGE_PERIODE_RECUEIL_PZAD=FIN_PERIODE_RECUEIL_LTP=
ALTER TABLE SIMU_TGE_PERIODE_RECUEIL_PZAD ADD (FIN_PERIODE_RECUEIL_LTP  DATE)
##
TRG_SIMU_TGE_STRUC
==
alter trigger TRG_SIMU_TGE_STRUC enable
##
SYS_DEF_ERREURS
==
delete from SYS_DEF_ERREURS where CODMOD = 'TGE' and CODLANG = 'fr_fr' and NIV_DEFINITION = '0' and CODERR in ('TGE00353')
'TGE00353','TGE','fr_fr',0,'Êtes-vous sûr de vouloir escalader votre demande ?',1
##
SYS_DEF_ERREURS
==
delete from SYS_DEF_ERREURS where  CODLANG = 'fr_fr'  and CODERR in ('GENCNT77','GENWKF95')
'GENCNT77','GEN','fr_fr',0,'Il existe une date de fin de contrat pour ce salarié. La date de fin prévue du CDD ne peut pas être postérieure à cette fin de contrat.',1
'GENWKF95','GEN','fr_fr',0,'Le salarié sélectionné n''a pas de période d''emploi correspondant à la demande car le départ est présent dans les fichiers de paie et il n''est pas inclus dans la profondeur de rétro.',1
##
SYS_DEF_ERREURS
==
delete from SYS_DEF_ERREURS where  CODLANG = 'fr_fr'  and CODERR in ('STD00049','STD00014','STD00072') 
'STD00049','STD','fr_fr',0,'Vous n''avez pas les autorisations nécessaires pour utiliser la période d''emploi #1 du PAC #2.',1
'STD00014','STD','fr_fr',0,'Vous n''avez pas les autorisations nécessaires pour utiliser l''identifiant RH #',1
'STD00072','STD','fr_fr',0,'Vous n''avez pas les autorisations nécessaires pour utiliser le matricule #1 du PAC #2.',1
##
SYS_DEF_ERREURS
==
delete from SYS_DEF_ERREURS where CODLANG = 'fr_fr' and NIV_DEFINITION = '0' and CODERR in ('ADMAC001')
'ADMAC001','ADM','fr_fr',0,'La modification de la sécurité a été validée avec succès.',3
##
TAG_CHARSET=@€éèç
##
SYS_GRAPH_DEFINITION
=SQL IFNOTEXIST=SYS_GRAPH_DEFINITION=
create table SYS_GRAPH_DEFINITION (ID_TYPE_GRAPH NUMBER,PARAM_NAME VARCHAR2(255),VALUE_TYPE VARCHAR2(255),REQUIRED CHAR(1),DEFAULT_VALUE VARCHAR2(255),DESCRIPTION VARCHAR2(255), primary key (ID_TYPE_GRAPH, PARAM_NAME))
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
delete from SYS_GRAPH_DEFINITION
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 1, 'angleField', 'TEXT', '1', 'angle', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 2, 'angleField', 'TEXT', '1', 'angle', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 1, 'labelField', 'TEXT', '1', 'libelle', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 2, 'labelField', 'TEXT', '1', 'libelle', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 3, 'axeX', 'TEXT', '1', 'AXEX', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 3, 'axeY', 'TEXT', '1', 'AXEY', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 3, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 3, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 3, 'managePivot', 'BOOL', '0', 'false', 'Applique une fonction oracle pivot (tableau croisé)')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 4, 'axeX', 'TEXT', '1', 'AXEX', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 4, 'axeY', 'TEXT', '1', 'AXEY', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 4, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 4, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 4, 'managePivot', 'BOOL', '0', 'false', 'Applique une fonction oracle pivot (tableau croisé)')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 5, 'axeX', 'TEXT', '1', 'AXEX', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 5, 'axeY', 'TEXT', '1', 'AXEY', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 5, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 5, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 6, 'axeX', 'TEXT', '1', 'AXEX', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 6, 'axeY', 'TEXT', '1', 'AXEY', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 6, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 6, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 7, 'axeX', 'TEXT', '1', 'AXEX', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 7, 'axeY', 'TEXT', '1', 'AXEY', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 7, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 7, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 7, 'managePivot', 'BOOL', '0', 'false', 'Applique une fonction oracle pivot (tableau croisé)')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 8, 'libelleAxeX', 'TEXT', '1', 'libelle', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 8, 'data1', 'TEXT', '1', 'data', 'Alias de colonne à utiliser dans la requête SQL')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 8, 'showLabelX', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe X')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values ( 8, 'showLabelY', 'BOOL', '1', 'false', 'Affichage des libellés sur l''axe Y')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'codeColorList', 'COLOR', '1', 'CONTRASTSHORT', 'Ensemble de couleurs du graphe')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'orderby', 'MULTIPLE', '1', 'NO', 'Applique un tri sur la colonne 1')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'codeFilter', 'TEXT', '0', '', 'Alias utilisé dans la requête SQL pour le chainage')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'mandatoryFilter', 'BOOL', '0', 'false', 'Indique si le filtre est nécessaire et obligatoire pour chainer')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'fieldUnit', 'TEXT', '0', '', 'Positionne un libellé sur l''affichage de la donnée')
##
SYS_GRAPH_DEFINITION
=SQL IFEXIST=SYS_GRAPH_DEFINITION=
insert into SYS_GRAPH_DEFINITION values (-1, 'fieldNumberFormat', 'TEXT', '0', '0', 'Permet de donner un format numérique')
##
SYS_GRAPH_PARAM
=SQL IFNOTEXIST=SYS_GRAPH_PARAM=MODELE=
alter table sys_graph_param add MODELE varchar2(1) default '1'
##
SYS_GRAPH_PARAM
=SQL IFEXIST=SYS_GRAPH_PARAM=
DELETE FROM sys_graph_param WHERE id in (24,25,26)
##
SYS_GRAPH_PARAM
=SQL IFEXIST=SYS_GRAPH_PARAM=
insert into sys_graph_param (ID, ID_TYPE_GRAPH, REQUETE, TITRE, PAGE_ASSOCIE, PARAMS, CODERR) values ('24','8','select  count(distinct login) as AXEX,  to_char(to_date(FIRST_CONNEXION,''YYYYMMDDHH24MISS''),''HH24'')||''h00-''|| to_char(to_date(FIRST_CONNEXION,''YYYYMMDDHH24MISS''),''HH24'')||''h59'' as AXEY  FROM SYS_USR_CONNEX_HISTO WHERE  substr(FIRST_CONNEXION,0,8)= to_char(sysdate,''YYYYMMDD'') and LOGIN like(''%%'')  group by to_char(to_date(FIRST_CONNEXION,''YYYYMMDDHH24MISS''),''HH24''),substr(FIRST_CONNEXION,0,8)  order by to_number(to_char(to_date(FIRST_CONNEXION,''YYYYMMDDHH24MISS''),''HH24'')) asc','ExempleLine01',NULL,'axeX=AXEX;axeY=AXEY;codeColorList=YELLOWS;orderby=NO;showLabelX=true;showLabelY=true;',NULL)
##
SYS_GRAPH_PARAM
=SQL IFEXIST=SYS_GRAPH_PARAM=
insert into sys_graph_param (ID, ID_TYPE_GRAPH, REQUETE, TITRE, PAGE_ASSOCIE, PARAMS, CODERR) values ('25','8','select * from ( select to_char(LIBELLEAXEX,''YYYYMM'') as cOrder, to_char(LIBELLEAXEX,''MM.YYYY'') as LIBELLEAXEX, count(*) AS DATA1 from ( select dos_num, trunc(to_date(date_recept,''yyyymmddhh24miss''),''mm'') as LIBELLEAXEX from wkf_tracabilite t1 where trace_num=(select min(trace_num) from wkf_tracabilite t2 where t2.dos_num=t1.dos_num) and exists (select 1 from wkf_tracabilite t2 where t2.dos_num=t1.dos_num and not t2.trace_num=t1.trace_num) and dos_finished=''true'') group by LIBELLEAXEX order by cOrder desc) where rownum <=12','ExempleLine02',NULL,'libelleAxeX=LIBELLEAXEX;data1=DATA1;listOfColumnLine=DATA1;codeColorList=LINE;orderby=NO;showLabelX=true;showLabelY=true;',NULL)
##
SYS_GRAPH_PARAM
=SQL IFEXIST=SYS_GRAPH_PARAM=
insert into sys_graph_param (ID, ID_TYPE_GRAPH, REQUETE, TITRE, PAGE_ASSOCIE, PARAMS, CODERR) values ('26','8','SELECT * FROM  (SELECT TO_CHAR(LIBELLEAXEX,''YYYYMM'') AS cOrder, TO_CHAR(LIBELLEAXEX,''MM.YYYY'')      AS LIBELLEAXEX,SUM( CASE codsta When 1 THEN 1 ELSE 0 END )                            AS DATA1, SUM( CASE codsta When 2 THEN 1 ELSE 0 END )                            AS DATA2, SUM( CASE codsta When 3 THEN 1 ELSE 0 END )                            AS DATA3 , SUM( CASE codsta When 6 THEN 1 ELSE 0 END )                            AS DATA4  , SUM( CASE codsta When 10 THEN 1 ELSE 0 END )  AS DATA5 FROM ( sELECT codfiche,TRUNC(to_date(datemodif,''yyyymmdd''),''mm'') AS LIBELLEAXEX, codsta FROM HELPDESK_FICHE t1 ) GROUP BY LIBELLEAXEX ORDER BY cOrder DESC ) WHERE rownum <=12','ExempleLine03',NULL,'libelleAxeX=LIBELLEAXEX;data1=DATA1;data2=DATA2;data3=DATA3;listOfColumnLine=DATA1,DATA2,DATA3;codeColorList=LINE;orderby=NO;showLabelX=true;showLabelY=true;',NULL)
##
SYS_GRAPH_TYPE
=SQL IFNOTEXIST=SYS_GRAPH_TYPE=ICON=
alter table SYS_GRAPH_TYPE add ICON VARCHAR2(255)
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
delete from SYS_GRAPH_TYPE
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (1, 'Donut', 'icon-chart-donut')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (2, 'Camembert', 'fa-pie-chart')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (3, 'HistoBarStacked', 'icon-chart-column')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (4, 'HistoColumnStacked', 'icon-chart-column')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (5, 'HistoBar', 'icon-chart-column')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (6, 'HistoColumn', 'fa-bar-chart')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (7, 'AeraNeg', 'icon-chart-area')
##
SYS_GRAPH_TYPE
=SQL IFEXIST=SYS_GRAPH_TYPE=
insert into SYS_GRAPH_TYPE values (8, 'LineMarked', 'fa-line-chart')
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'TAB_RD_ZWOPTMUT' AND IDREQUETE = '2'
'TAB_RD_ZWOPTMUT','2','Utilisateur','GA_ZWOPTMUT OPT, GA_ZWCAIMUT CAI','OPT.CODE_OPTION, ''(''||CAI.LIBELLE_MUTUELLE||'') ''||OPT.LIBELLE_OPTION','OPT.CODE_OPTION, OPT.LIBELLE_OPTION','OPT.CODE_MUTUELLE=CAI.CODE_MUTUELLE','0','false','OPT.CODE_MUTUELLE , OPT.CODE_OPTION',null,'Option mutuelle UX','Code, Libellé'
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'TAB_RD_WKF_PERIODE_EMPLOI_RETRO_FIN' AND IDREQUETE = 2
'TAB_RD_WKF_PERIODE_EMPLOI_RETRO_FIN','2','Administrateur','DIC_ADM_CONTRAT_HISTO H inner join DIC_ADM_CONTRAT C on  C.NUMPAC=H.NUMPAC AND H.PACMAT=C.PACMAT AND C.NUMCNT = H.NUMCNT AND C.DSFCN = NVL(H.DATE_FIN,TO_DATE(''31.12.2099'',''dd.MM.yyyy'')) inner join TGE_REF_PAC P on  P.NUMPAC = C.NUMPAC left join TGE_REF_TDR T on C.TYPE_REEMBAUCHE_PREV = T.TYPE_REEMBAUCHE AND C.NUMPAC = T.NUMPAC','C.NUMCNT, TO_CHAR(C.DSDCN^''dd.MM.yyyy''), TO_CHAR(C.DSFCN^''dd.MM.yyyy''), H.ZT061, C.TYPE_REEMBAUCHE_PREV, T.LIBELLE','C.NUMCNT, TO_CHAR(C.DSDCN^''dd.MM.yyyy''), TO_CHAR(C.DSFCN^''dd.MM.yyyy''), H.ZT061, C.TYPE_REEMBAUCHE_PREV,TO_CHAR(H.DATE_EFF^''dd.MM.yyyy''),H.PAIEZAD','C.DSFCN IS NOT NULL AND ((P.DEB_HISTO_RETRO IS NOT NULL AND P.NB_MOIS_RETRO IS NOT NULL AND C.DSFCN &gt;= TO_DATE(GREATEST(DEB_HISTO_RETRO, TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS, ''YYYYMM''), -NB_MOIS_RETRO), ''YYYYMM'')) || ''01'', ''YYYYMMDD'')) OR NOT EXISTS (SELECT 1 FROM PHOTO_DIC_ADM_CONTRAT PH WHERE PH.NUMPAC=C.NUMPAC AND PH.PACMAT=C.PACMAT AND PH.NUMCNT=C.NUMCNT AND PH.DSFCN=C.DSFCN)) AND  H.MATRIC = ''@GEN_MATRIC@''','0','false','C.DSDCN ASC',null,'Périodes d''emploi dont la date de départ est incluse dans la profondeur de rétro','numéro de contrat, date début contrat, date fin contrat, nature de contrat, type de réembauche prévisionnel, libellé type de réembauche prévisionnel'
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'REG_RD_WKF_PERIODE_EMPLOI_RETRO_FIN' AND IDREQUETE = 4
'REG_RD_WKF_PERIODE_EMPLOI_RETRO_FIN','4','Administrateur','DIC_ADM_CONTRAT_HISTO H inner join DIC_ADM_CONTRAT C on  C.NUMPAC=H.NUMPAC AND H.PACMAT=C.PACMAT AND C.NUMCNT = H.NUMCNT AND C.DSFCN = NVL(H.DATE_FIN,TO_DATE(''31.12.2099'',''dd.MM.yyyy'')) inner join TGE_REF_PAC P on  P.NUMPAC = C.NUMPAC left join TGE_REF_TDR T on C.TYPE_REEMBAUCHE_PREV = T.TYPE_REEMBAUCHE AND C.NUMPAC = T.NUMPAC','C.NUMCNT, TO_CHAR(C.DSDCN^''dd.MM.yyyy''), TO_CHAR(C.DSFCN^''dd.MM.yyyy''), H.ZT061, C.TYPE_REEMBAUCHE_PREV, T.LIBELLE','C.NUMCNT, TO_CHAR(C.DSDCN^''dd.MM.yyyy''), TO_CHAR(C.DSFCN^''dd.MM.yyyy''), H.ZT061, C.TYPE_REEMBAUCHE_PREV,TO_CHAR(H.DATE_EFF^''dd.MM.yyyy''),H.PAIEZAD','C.DSFCN IS NOT NULL AND ((P.DEB_HISTO_RETRO IS NOT NULL AND P.NB_MOIS_RETRO IS NOT NULL AND C.DSFCN &gt;= TO_DATE(GREATEST(DEB_HISTO_RETRO, TO_CHAR(ADD_MONTHS(TO_DATE(PERIODEENCOURS, ''YYYYMM''), -NB_MOIS_RETRO), ''YYYYMM'')) || ''01'', ''YYYYMMDD'')) OR NOT EXISTS (SELECT 1 FROM PHOTO_DIC_ADM_CONTRAT PH WHERE PH.NUMPAC=C.NUMPAC AND PH.PACMAT=C.PACMAT AND PH.NUMCNT=C.NUMCNT AND PH.DSFCN=C.DSFCN)) AND H.MATRIC =''%1''','0','false','C.DSDCN ASC',null,'Périodes d''emploi pour la modification de départ','numéro de contrat, date début contrat, date fin contrat, nature de contrat, type de réembauche prévisionnel, libellé type de réembauche prévisionnel'
##
SYS_REQUETES_JSP
==
DELETE SYS_REQUETES_JSP WHERE  NOMPAGE='TAB_RD_GESTION_PARTENAIRE'
'TAB_RD_GESTION_PARTENAIRE', '1', 'Administrateur', 'MP_PARTENAIRES', 'ID_PARTENAIRE,LIBELLE,REQ_LISTE_MAT,REQ_LISTE_TABLE,REQ_LISTE_RUBRIQUES,REQ_LISTE_ELEMENTS,NOTIF_FIN_PAIE','ID_PARTENAIRE,LIBELLE,REQ_LISTE_MAT,REQ_LISTE_TABLE,REQ_LISTE_RUBRIQUES,REQ_LISTE_ELEMENTS,NOTIF_FIN_PAIE',null,'0','true',null,null,'tableau gestion partenaire','Partenaire,Libellé,Sécurité population,Sécurité tables,Sécurité rubriques de Paie,Sécurité éléments de paie,Notification fin de paie'
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE='ParametrageDonneesUX.jsp' and IDREQUETE = '2'
'ParametrageDonneesUX.jsp','2','Administrateur','MP_DATA_IHM D LEFT OUTER JOIN REF_DONNEE_MAPPING_UX M ON M.NOM_DONNEE_UX = D.NOM_DONNEE_UX AND M.COMPANY_ID=''*''','D.NOM_DONNEE_UX,D.LIBELLE_DONNEE_UX,M.NOM_DONNEE,M.CONDITION,M.IS_UX,M.IS_DEX','D.NOM_DONNEE_UX,D.LIBELLE_DONNEE_UX,M.NOM_DONNEE,M.CONDITION,M.IS_UX,M.IS_DEX',null,'0',null,null,null,'Affichage du mapping des données UX','Nom donnée UX, Libellé donnée UX,Nom donnée ALP,Condition'
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'ChartScreenSlide.js' and IDREQUETE = '1'
'ChartScreenSlide.js', '1', 'Administrateur', '(select ''Ecran'' as TYPE, CODE_ELEMENT, libelle, NOM_PAGE from sys_sch_element where nom_page is not null and nom_page not like ''%BacASable%'' union select ''Graphe''  as TYPE, id, titre, titre from sys_graph_param order by CODE_ELEMENT)', 'TYPE,CODE_ELEMENT,LIBELLE,NOM_PAGE', 'TYPE,CODE_ELEMENT,LIBELLE,NOM_PAGE', '', '0', 'true', '', '', '', ''
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE='TAB_RD_LISTE_OCCURRENCES' and IDREQUETE = '1'
'TAB_RD_LISTE_OCCURRENCES','1','Utilisateur','DIC_ADM_CONTRAT_HISTO','TO_CHAR(DATE_EFF^''dd.mm.yyyy''), TO_CHAR(DATE_EFF^''dd.mm.yyyy'')||'' - ''||DECODE(TO_CHAR(DATE_FIN^''dd.mm.yyyy'')^ ''31.12.2099''^ NULL^ TO_CHAR(DATE_FIN^''dd.mm.yyyy''))||'' (''||NUMCNT||'')''','TO_CHAR(DATE_EFF^''dd.mm.yyyy''), TO_CHAR(DATE_EFF^''dd.mm.yyyy'')||'' - ''||DECODE(TO_CHAR(DATE_FIN^''dd.mm.yyyy'')^ ''31.12.2099''^ NULL^ TO_CHAR(DATE_FIN^''dd.mm.yyyy''))||'' (''||NUMCNT||'')''','NUMPAC=''%1'' AND PACMAT=''%2''','0',null,'DATE_EFF DESC',null,'Liste des occurrences d''un salarié',null
##
SYS_SCH_ELEMENT
==
UPDATE SYS_SCH_ELEMENT SET TAGS='_PAS_VISIBLE_' WHERE niveau = '99' and nom_page='Modules/AdpUx/UxHelpdesk.jsp'
##
SYS_SCH_JSON
=SQL=
DELETE SYS_SCH_JSON WHERE NOM_JSON = 'OptionSignatureJsonServlet' AND NOM_PAGE = 'Ext.adp.Modules.Signature.OptionSignatureExtjs'
##
SYS_SCH_JSON
=SQL=
INSERT INTO SYS_SCH_JSON(NOM_PAGE, NOM_JSON) VALUES('Ext.adp.Modules.Signature.OptionSignatureExtjs', 'OptionSignatureJsonServlet')
##
SYS_SCH_JSON
=SQL=
DELETE SYS_SCH_JSON WHERE NOM_JSON = 'SignataireJsonServlet' AND NOM_PAGE = 'Ext.adp.Modules.Signature.SignataireMVVM'
##
SYS_SCH_JSON
=SQL=
INSERT INTO SYS_SCH_JSON(NOM_PAGE, NOM_JSON) VALUES('Ext.adp.Modules.Signature.SignataireMVVM', 'SignataireJsonServlet')
##
SYS_SCH_JSON (NOM_PAGE, NOM_JSON)
==
DELETE FROM SYS_SCH_JSON WHERE NOM_JSON = 'SuiviDocumentsEtSignaturesJsonServlet' AND NOM_PAGE = 'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures'
'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures', 'SuiviDocumentsEtSignaturesJsonServlet'
##
SYS_SCH_JSON
=SQL=
DELETE SYS_SCH_JSON WHERE NOM_JSON = 'SignataireCMJsonServlet' AND NOM_PAGE = 'Ext.adp.Modules.Signature.SignataireMVVM'
##
SYS_SCH_JSON
=SQL=
INSERT INTO SYS_SCH_JSON(NOM_PAGE, NOM_JSON) VALUES('Ext.adp.Modules.Signature.SignataireMVVM', 'SignataireCMJsonServlet') 
##
SYS_SCH_JSON
==
delete from SYS_SCH_JSON where NOM_PAGE = 'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures' 
'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures', 'SuiviDocumentsEtSignaturesJsonServlet' 
'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures', 'DetailSignatureJsonServlet'
'Ext.adp.Modules.Signature.SuiviDocumentsEtSignatures', 'SignataireCMJsonServlet'
##
SYS_SCH_JSON
==
DELETE FROM SYS_SCH_JSON where nom_page  = 'Ext.adp.Modules.GTA.CAD.ForcageCompteurs'
'Ext.adp.Modules.GTA.CAD.ForcageCompteurs','ForcageCompteursJsonServlet'
##
SYS_SCH_JSON
==
DELETE SYS_SCH_JSON WHERE NOM_JSON = 'TelechargementsJsonServelet' AND NOM_PAGE = 'Ext.adp.Moteur.Comp.WebAdmin.Telechargements'
##
SYS_SCH_JSON
==
INSERT INTO SYS_SCH_JSON(NOM_PAGE, NOM_JSON) VALUES('Ext.adp.Moteur.Comp.WebAdmin.Telechargements', 'TelechargementsJsonServelet')
##
SYS_SCH_JSON
==
DELETE FROM SYS_SCH_JSON WHERE NOM_PAGE = 'Ext.adp.Moteur.Charts.GestionCharts'
'Ext.adp.Moteur.Charts.GestionCharts','GestionChartsJsonServlet'
##
SYS_SCH_JSON
==
DELETE FROM SYS_SCH_JSON WHERE NOM_PAGE = 'Moteur/Trace/TracesInterpreterExpert.jsp'
'Moteur/Trace/TracesInterpreterExpert.jsp','TracesInterpreterJsonServlet'
##
SYS_SCH_JSON
==
DELETE FROM SYS_SCH_JSON WHERE NOM_PAGE = 'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI'
'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI', 'GestionApplicationConsommatriceAPIJsonServlet'
##
SYS_SCH_PAGE_INITIALIZER
==
DELETE FROM SYS_SCH_PAGE_INITIALIZER WHERE NOM_PAGE = 'Ext.adp.Moteur.Comp.WebAdmin.Telechargements'
'Ext.adp.Moteur.Comp.WebAdmin.Telechargements','','','TelechargementsJsonServelet'
##
SYS_SCH_PAGE_INITIALIZER
==
delete from SYS_SCH_PAGE_INITIALIZER where nom_page='Ext.adp.Modules.Structures.Parametrage.ModifDateEff'
'Ext.adp.Modules.Structures.Parametrage.ModifDateEff', 'HRO_PROPAGER_CHECKED;', 'HRO00022;HRO00023;', 'GestionNiveauxJsonServlet'
##
SYS_SCH_PAGE_INITIALIZER
==
DELETE FROM SYS_SCH_PAGE_INITIALIZER WHERE NOM_PAGE = 'Ext.adp.Moteur.Charts.GestionCharts'
'Ext.adp.Moteur.Charts.GestionCharts','','','GestionChartsJsonServlet'
##
SYS_SCH_PAGE_INITIALIZER
==
delete from SYS_SCH_PAGE_INITIALIZER where NOM_PAGE = 'Ext.adp.Modules.DEX.slide.UserMachineConfigSecu'
'Ext.adp.Modules.DEX.slide.UserMachineConfigSecu', null, 'ADMAC001;', 'GestionApplicationConsommatriceAPIJsonServlet'
##
SYS_SCH_PAGE_INITIALIZER
==
delete from SYS_SCH_PAGE_INITIALIZER where NOM_PAGE = 'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI'
'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI', null, null, 'GestionApplicationConsommatriceAPIJsonServlet'
##
SYS_SCH_PAGE_INITIALIZER
==
delete from SYS_SCH_PAGE_INITIALIZER where NOM_PAGE = 'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI_CDF'
'Ext.adp.Modules.DEX.GestionApplicationConsommatricesAPI_CDF', null, null, 'GestionApplicationConsommatriceAPIJsonServlet'
##
SYS_TRT_TOMAKE
=SQL IFEXIST=SYS_TRT_TOMAKE=
DELETE FROM SYS_TRT_TOMAKE WHERE ID_TRT = 'Traitement_PropagerCAD'
##
SYS_TRT_TOMAKE
=SQL IFEXIST=SYS_TRT_TOMAKE=
INSERT INTO SYS_TRT_TOMAKE (ID_TRT, REQUESTEDGO_OR_FREQUENCY) VALUES ('Traitement_PropagerCAD','00')
##
SYS_TRT_TOMAKELIB
=SQL IFEXIST=SYS_TRT_TOMAKELIB=
DELETE FROM SYS_TRT_TOMAKELIB WHERE ID_TRT = 'Traitement_PropagerCAD' AND LIBELLE = 'Traitement de propagation des CAD après import GAP'
##
SYS_TRT_TOMAKELIB
=SQL IFEXIST=SYS_TRT_TOMAKELIB=
INSERT INTO SYS_TRT_TOMAKELIB VALUES ('Traitement_PropagerCAD','Traitement de propagation des CAD après import GAP')
##
TAG_CHARSET=@€éèç
##
SYS_TRT_TYPE
=SQL IFEXIST=SYS_TRT_TYPE=
DELETE FROM SYS_TRT_TYPE WHERE TYPE_TRAITEMENT = 'Traitement_PropagerCAD'
##
SYS_TRT_TYPE
=SQL IFEXIST=SYS_TRT_TYPE=
INSERT INTO SYS_TRT_TYPE VALUES ('Traitement_PropagerCAD','Traitement de propagation des CAD après import GAP',null)
##
SYS_USR_AOID_MATRIC
=SQL=
UPDATE SYS_USR_AOID_MATRIC M1 SET AOID = SUBSTR(AOID,2,LENGTH(AOID)-2) WHERE AOID LIKE '''%''' AND NOT EXISTS (SELECT 1 FROM SYS_USR_AOID_MATRIC M2 WHERE M2.AOID=SUBSTR(M1.AOID,2,LENGTH(M1.AOID)-2))
##
SYS_USR_AOID_MATRIC
=SQL=
DELETE SYS_USR_AOID_MATRIC M1 WHERE AOID LIKE '''%''' AND EXISTS (SELECT 1 FROM SYS_USR_AOID_MATRIC M2 WHERE M2.AOID=SUBSTR(M1.AOID,2,LENGTH(M1.AOID)-2))
##
SYS_VARSYS
==
DELETE SYS_VARSYS WHERE  MODULE='SYS' and CODVAR='ADR_API_URL'
'SYS', 'ADR_API_URL', 'GEOSERVICE,MAPBOX', 'Texte', 'Préciser  l''ordre d''appel des API.'
##
SYS_VARSYS
=SQL=
UPDATE SYS_VARSYS SET VALVAR = 'Copyright 2020 ADP, Inc.' WHERE MODULE = 'STD' AND CODVAR = 'DESK_COPYRIGHT'
##
SYS_VARSYS
==
DELETE SYS_VARSYS WHERE  MODULE='STD' and CODVAR='DOCSERV_PDF_PROTECTION'
'STD', 'DOCSERV_PDF_PROTECTION', '', 'Texte', 'protection des pdf générés par docserver, on concatene les paramètres sans séparateurs. protection max = PCFS, protection mini = pas de varsys ou varsys a vide (P = Impression interdite, C = copie du contenu pour accessibilité interdite, copie du contenu interdite, F = remplissage de champs de formulaire interdit, apposition de signature interdite, création de modèle de page interdite, S = copie du contenu pour accessibilité interdite)'
##
TGE_PERIODE_RECUEIL_PAIEZAD
=SQL IFNOTEXIST=TGE_PERIODE_RECUEIL_PAIEZAD=DEBUT_PERIODE_RECUEIL_LTP=
ALTER TABLE TGE_PERIODE_RECUEIL_PAIEZAD ADD (DEBUT_PERIODE_RECUEIL_LTP  DATE)
##
TGE_PERIODE_RECUEIL_PAIEZAD
=SQL IFNOTEXIST=TGE_PERIODE_RECUEIL_PAIEZAD=FIN_PERIODE_RECUEIL_LTP=
ALTER TABLE TGE_PERIODE_RECUEIL_PAIEZAD ADD (FIN_PERIODE_RECUEIL_LTP  DATE)
##
TGE_PERIODE_RECUEIL_PAIEZAD_R
=SQL IFNOTEXIST=TGE_PERIODE_RECUEIL_PAIEZAD_R=DEBUT_PERIODE_RECUEIL_LTP=
ALTER TABLE TGE_PERIODE_RECUEIL_PAIEZAD_R ADD (DEBUT_PERIODE_RECUEIL_LTP  DATE)
##
TGE_PERIODE_RECUEIL_PAIEZAD_R
=SQL IFNOTEXIST=TGE_PERIODE_RECUEIL_PAIEZAD_R=FIN_PERIODE_RECUEIL_LTP=
ALTER TABLE TGE_PERIODE_RECUEIL_PAIEZAD_R ADD (FIN_PERIODE_RECUEIL_LTP  DATE)
##
TAG_CHARSET=@€éèç
##
TGE_REF_ENVOI_PAI
=SQL IFNOTEXIST=TGE_REF_ENVOI_PAI=
CREATE TABLE TGE_REF_ENVOI_PAI (ORIGINE VARCHAR2(10), CODE_REQ VARCHAR2(10), ORDRE_REQ VARCHAR2(10), REQUETE CLOB, PRIMARY KEY (ORIGINE,CODE_REQ,ORDRE_REQ))
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI2','1','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, to_date(''19000101'',''yyyymmdd'')) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, to_date(''19000102'',''yyyymmdd'')) AS FIN_REC, CS.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN (SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM (SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM gap_trt_liste_mat T JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat WHERE T.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_PAIE@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND (P.debut_periode_recueil IS NULL OR P.debut_periode_recueil = NVL(R.debut_periode_recueil, to_date(''19000101'',''yyyymmdd''))) AND (P.fin_periode_recueil IS NULL OR P.fin_periode_recueil = NVL(R.fin_periode_recueil, to_date(''19000102'',''yyyymmdd''))) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac= R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN dic_adm_contrat_situ CS ON CS.numpac = C.numpac AND CS.pacmat = C.pacmat AND CS.numcnt = C.numcnt AND CS.paiezad = C.current_paiezad JOIN gap_trt_liste_mat T ON T.numpac = R.numpac AND R.pacmat = T.pacmat WHERE (P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO) AND T.id_trt = @@@ID_TRT@@@ AND NOT EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac )'
'RD','PAI2_RETRO','1','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, to_date(''19000101'',''yyyymmdd'')) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, to_date(''19000102'',''yyyymmdd'')) AS FIN_REC, CS.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN ( SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM ( SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T JOIN gap_trt_liste_mat L ON L.numpac = T.numpac AND L.pacmat = L.pacmat JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE''  WHERE L.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_RETRO@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND ( P.debut_periode_recueil IS NULL OR P.debut_periode_recueil = NVL(R.debut_periode_recueil, to_date(''19000101'', ''yyyymmdd'')) ) AND ( P.fin_periode_recueil IS NULL OR P.fin_periode_recueil = NVL(R.fin_periode_recueil, to_date(''19000102'', ''yyyymmdd'')) ) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac = R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN dic_adm_contrat_situ CS ON CS.numpac = C.numpac AND CS.pacmat = C.pacmat AND CS.numcnt = C.numcnt AND CS.paiezad = C.current_paiezad JOIN gap_trt_liste_mat L ON L.numpac = R.numpac AND R.pacmat = L.pacmat JOIN ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T ON T.numpac = R.numpac AND R.pacmat = T.pacmat  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE''  WHERE ( P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO ) AND L.id_trt = @@@ID_TRT@@@ AND NOT EXISTS ( SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac )'
'RD','PAI3','1','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, P.DEBUT_PERIODE_RECUEIL) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, R.sortie) AS FIN_REC , A.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN (SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM (SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM gap_trt_liste_mat T JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat WHERE T.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_PAIE@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND ((P.debut_periode_recueil IS NULL OR P.debut_periode_recueil <> NVL(R.debut_periode_recueil, to_date(''19000101'',''yyyymmdd''))) OR (P.fin_periode_recueil IS NULL OR P.fin_periode_recueil <> NVL(R.fin_periode_recueil, to_date(''19000102'',''yyyymmdd'')))) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac= R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN gap_trt_liste_mat T ON T.numpac = R.numpac AND t.pacmat = R.pacmat JOIN situation_paie A ON A.numpac = R.numpac AND A.paiezad = R.paiezad AND A.PERIODEENCOURS = R.mois_paie WHERE (P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO OR R.entree BETWEEN P.fin_periode_recueil AND R.fin_periode_paie) AND (NVL(R.sortie,to_date(''20991231'',''yyyymmdd''))>= R.debut_periode_paie OR A.RETRO_SORTIE = ''O'') AND T.id_trt = @@@ID_TRT@@@ AND EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac )'
'RD','PAI3','2','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, to_date(''19000101'',''yyyymmdd'')) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, to_date(''19000102'',''yyyymmdd'')) AS FIN_REC , A.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN (SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM (SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM gap_trt_liste_mat T JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat WHERE T.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_PAIE@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND ((P.debut_periode_recueil IS NULL OR P.debut_periode_recueil <> NVL(R.debut_periode_recueil, to_date(''19000101'',''yyyymmdd''))) OR (P.fin_periode_recueil IS NULL OR P.fin_periode_recueil <> NVL(R.fin_periode_recueil, to_date(''19000102'',''yyyymmdd'')))) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac= R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN gap_trt_liste_mat T ON T.numpac = R.numpac AND t.pacmat = R.pacmat JOIN situation_paie A ON A.numpac = R.numpac AND A.paiezad = R.paiezad AND A.PERIODEENCOURS = R.mois_paie WHERE (P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO OR R.entree BETWEEN P.fin_periode_recueil AND R.fin_periode_paie) AND (NVL(R.sortie,to_date(''20991231'',''yyyymmdd''))>= R.debut_periode_paie OR A.RETRO_SORTIE = ''O'') AND T.id_trt = @@@ID_TRT@@@ AND NOT EXISTS (SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac ) AND NOT EXISTS (SELECT 1 FROM tge_periode_recueil_paiezad s WHERE s.paiezad = r.paiezad AND s.fin_periode_recueil >= r.sortie AND s.mois_paie < r.mois_paie AND s.numpac = t.numpac )'
'RD','PAI3_RETRO','1','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, P.DEBUT_PERIODE_RECUEIL) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, R.sortie) AS FIN_REC , A.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN ( SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM ( SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T JOIN gap_trt_liste_mat L ON L.numpac = T.numpac AND L.pacmat = L.pacmat JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE'' WHERE L.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_RETRO@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY s.mois_paie, COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND ( ( P.debut_periode_recueil IS NULL OR P.debut_periode_recueil <> NVL(R.debut_periode_recueil, to_date( ''19000101'',''yyyymmdd'')) ) OR ( P.fin_periode_recueil IS NULL OR P.fin_periode_recueil <> NVL(R.fin_periode_recueil, to_date(''19000102'', ''yyyymmdd'')) ) ) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac = R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN gap_trt_liste_mat L ON L.numpac = R.numpac AND R.pacmat = L.pacmat JOIN ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T ON T.numpac = R.numpac AND t.pacmat = R.pacmat JOIN situation_paie A ON A.numpac = R.numpac AND A.paiezad = R.paiezad AND A.PERIODEENCOURS = R.mois_paie  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE'' WHERE ( P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO OR R.entree BETWEEN P.fin_periode_recueil AND R.fin_periode_paie ) AND ( NVL(R.sortie,to_date(''20991231'',''yyyymmdd''))>= R.debut_periode_paie OR A.RETRO_SORTIE = ''O'' ) AND L.id_trt = @@@ID_TRT@@@ AND EXISTS ( SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac )'
'RD','PAI3_RETRO','2','SELECT R.pacmat, R.paiezad, C.numcnt, R.entree AS DEB_EMP, NVL(R.sortie, to_date(''31.12.2099'', ''dd.MM.yyyy'')) AS FIN_EMP, NVL(R.DEBUT_PERIODE_RECUEIL, to_date(''19000101'',''yyyymmdd'')) AS DEB_REC, NVL(R.FIN_PERIODE_RECUEIL, to_date(''19000102'',''yyyymmdd'')) AS FIN_REC , A.CODE_CHRONO AS CODE_CHRONO FROM tge_periode_recueil_paiezad R JOIN ( SELECT numpac, mois_paie, debut_periode_recueil, fin_periode_recueil FROM ( SELECT S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil, COUNT(paiezad) AS nb_Dossier FROM ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T JOIN gap_trt_liste_mat L ON L.numpac = T.numpac AND L.pacmat = L.pacmat JOIN tge_periode_recueil_paiezad S ON S.numpac = T.numpac AND S.pacmat = T.pacmat  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE'' WHERE L.id_trt = @@@ID_TRT@@@ AND S.mois_paie = @@@PERIODE_RETRO@@@ GROUP BY S.numpac, S.mois_paie, S.debut_periode_recueil, S.fin_periode_recueil ORDER BY COUNT(paiezad) DESC ) WHERE rownum = 1 ) P ON P.mois_paie = R.mois_paie AND P.numpac = R.numpac AND ( ( P.debut_periode_recueil IS NULL OR P.debut_periode_recueil <> NVL(R.debut_periode_recueil, to_date( ''19000101'',''yyyymmdd'')) ) OR ( P.fin_periode_recueil IS NULL OR P.fin_periode_recueil <> NVL(R.fin_periode_recueil, to_date(''19000102'', ''yyyymmdd'')) ) ) JOIN dic_adm_contrat_histo H ON H.numpac = R.numpac AND H.pacmat = R.pacmat AND H.paiezad =R.paiezad AND H.za996 = ''W'' JOIN dic_adm_contrat C ON C.numpac = R.numpac AND C.pacmat= R.pacmat AND C.numcnt= H.numcnt AND C.dsdcn = R.entree JOIN gap_trt_liste_mat L ON L.numpac = R.numpac AND R.pacmat = L.pacmat JOIN ( SELECT NUMPAC, PACMAT FROM GAP_RETRO_MATRIC where periode_retro = @@@PERIODE_RETRO@@@ UNION SELECT NUMPAC, PACMAT FROM GAP_SELECTION_RETRO where periode_retro = @@@PERIODE_RETRO@@@ ) T ON T.numpac = R.numpac AND t.pacmat = R.pacmat JOIN situation_paie A ON A.numpac = R.numpac AND A.paiezad = R.paiezad AND A.PERIODEENCOURS = R.mois_paie  JOIN TGE_MODIF_PACMAT_RETRO PR ON PR.NUMPAC = L.numpac AND PR.pacmat = L.pacmat AND Pr.Periode_Retro = @@@PERIODE_RETRO@@@ AND Pr.Table_Maj = ''PRD_PP_RETRO_INFOPAIE'' WHERE ( P.fin_periode_recueil IS NULL OR NVL(R.fin_periode_recueil,P.fin_periode_recueil) BETWEEN H.date_eff AND H.DATE_SORTIE_SIT_BO OR R.entree BETWEEN P.fin_periode_recueil AND R.fin_periode_paie ) AND ( NVL(R.sortie,to_date(''20991231'',''yyyymmdd''))>= R.debut_periode_paie OR A.RETRO_SORTIE = ''O'' ) AND L.id_trt = @@@ID_TRT@@@ AND NOT EXISTS ( SELECT 1 FROM TGE_PERIODE_RECUEIL_PAIEZAD S WHERE S.paiezad = R.paiezad AND S.RETOUR_SUSPENSION >= S.sortie AND S.mois_paie =R.mois_paie AND S.numpac =T.numpac ) AND NOT EXISTS ( SELECT 1 FROM tge_periode_recueil_paiezad s WHERE s.paiezad = r.paiezad AND s.fin_periode_recueil >= r.sortie AND s.mois_paie < r.mois_paie AND s.numpac = t.numpac )'
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, T.DEBUT_PERIODE_RECUEIL, T.FIN_PERIODE_RECUEIL, CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, T.DEBUT_PERIODE_RECUEIL, T.FIN_PERIODE_RECUEIL, CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO ) '
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, T.DEBUT_PERIODE_RECUEIL, T.FIN_PERIODE_RECUEIL, CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, T.DEBUT_PERIODE_RECUEIL, T.FIN_PERIODE_RECUEIL, CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO ) '
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP), NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP), CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP), NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP), CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO ) '
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI where ORIGINE = 'RD' and CODE_REQ in ('PAI','PAI_RETRO')
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP), NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP), CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T INNER JOIN dic_adm_contrat_histo H ON H.numpac   = T.numpac AND H.pacmat  = T.pacmat AND H.paiezad = T.paiezad AND H.za996 = ''W'' WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP), NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP), CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR, DIC_ADM_CONTRAT_HISTO H WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO ) and H.NUMPAC   = T.NUMPAC AND H.PACMAT  = T.PACMAT AND H.PAIEZAD = T.PAIEZAD AND H.ZA996 = ''W'' '
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI where ORIGINE = 'RD' and CODE_REQ in ('PAI','PAI_RETRO')
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T INNER JOIN dic_adm_contrat_histo H ON H.numpac   = T.numpac AND H.pacmat  = T.pacmat AND H.paiezad = T.paiezad AND H.za996 = ''W'' WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR, DIC_ADM_CONTRAT_HISTO H WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO ) and H.NUMPAC   = T.NUMPAC AND H.PACMAT  = T.PACMAT AND H.PAIEZAD = T.PAIEZAD AND H.ZA996 = ''W'' '
##
TGE_REF_MAPDO
==
delete from TGE_REF_MAPDO WHERE numpac = '*' AND ELEMENT IN ('WA52')
'*','WA52','**','ORGTR','DIC_TGE_RESPAIE_HISTO',NULL,NULL,NULL,NULL,NULL,'N'
##
TGE_REF_MAPDO
==
delete from TGE_REF_MAPDO WHERE numpac = '*' AND ELEMENT IN ('PE34','PE35','PE36')
'*','PE34','**','ZPE34','DIC_ADM_CONTRAT_HISTO',NULL,NULL,NULL,NULL,NULL,'N'
'*','PE35','**','ZPE35','DIC_ADM_CONTRAT_HISTO',NULL,NULL,NULL,NULL,NULL,'N'
'*','PE36','**','ZPE36','DIC_ADM_CONTRAT_HISTO',NULL,NULL,NULL,NULL,NULL,'N'
##
TGE_REF_MAPDO
==
delete from TGE_REF_MAPDO WHERE numpac = '*' AND ELEMENT IN ('A305')
'*','A305','**','DSFCN','DIC_ADM_CONTRAT',NULL,NULL,NULL,'(CASE WHEN (SELECT DISTINCT FIRST_VALUE(ZT061) OVER (PARTITION BY NUMPAC, PACMAT, NUMCNT ORDER BY DATE_EFF DESC) FROM DIC_ADM_CONTRAT_HISTO H WHERE H.NUMPAC=$TABLE.NUMPAC AND H.PACMAT=$TABLE.PACMAT AND H.NUMCNT=$TABLE.NUMCNT) in (''CDD'',''CAP'',''STG'') THEN NVL(DSFCN, (CASE WHEN ''$DICOUPHOTO''= ''DIC_ADM_CONTRAT'' THEN (SELECT DISTINCT FIRST_VALUE(DSFCNP) OVER (PARTITION BY NUMPAC, PACMAT, NUMCNT ORDER BY DATE_EFF DESC) FROM DIC_ADM_CONTRAT_HISTO H WHERE H.NUMPAC=$TABLE.NUMPAC AND H.PACMAT=$TABLE.PACMAT AND H.NUMCNT=$TABLE.NUMCNT)  ELSE (SELECT DISTINCT FIRST_VALUE(DSFCNP) OVER (PARTITION BY NUMPAC, PACMAT, NUMCNT ORDER BY DATE_EFF DESC) FROM PHOTO_DIC_ADM_CONTRAT_HISTO H WHERE H.NUMPAC=$TABLE.NUMPAC AND H.PACMAT=$TABLE.PACMAT AND H.NUMCNT=$TABLE.NUMCNT)   END)) ELSE NULL END)',NULL,'N'
##
UX_GS_OPTION
==
delete from UX_GS_OPTION WHERE ACCES_OPT IN ('HELPDESK')
'businessFeatures','HELPDESK','Collaborateur','UX - Helpdesk','Modules/AdpUx/UxHelpdesk.jsp'
##
WKF_BRANCH_GEN
=SQL IFEXIST=UX_EVENTS=
UPDATE WKF_BRANCH_GEN BG1 SET CODE_RETOUR='Valider', GBR_OBLIG='false', GBR_CRREPRIS='true' WHERE OP_EMET_NUM IN (SELECT OP_NUM FROM UX_EVENTS) AND CODE_RETOUR='Default' AND NOT EXISTS (SELECT 1 FROM WKF_BRANCH_GEN BG2 WHERE BG2.OP_EMET_NUM=BG1.OP_EMET_NUM AND CODE_RETOUR='Valider')
##
WKF_BRANCH_GEN
==
delete from WKF_BRANCH_GEN WHERE OP_EMET_NUM IN (50317,53203,53204)
'50317','Valider','50315','50320','1','false','true','true','false','false','20200515153516','false',null
'53203','Valider','53204','53205','1','true','false','true','false','false','20200617092842','false',null
'53203','Valider','53205','53205','1','true','false','true','false','false','20200616094142','false',null
'53204','Supprimer','53202','53207','1','false','true','true','false','false','20200617092929','false',null
'53204','Valider','53202','53206','1','false','true','true','false','false','20200515145638','false',null
##
WKF_BRANCH_GEN
==
delete from WKF_BRANCH_GEN WHERE OP_EMET_NUM in (40200,40201,40203)
'40200','Default','40201','40220','1','false','true','true','false','false','20190417145341','false',null
'40201','Default','40202','40221','1','false','true','true','false','false','20190419174150','false',null
'40203','Valider','40201','4203','1','false','false','true','false','false','20200630101236','false',null
##
WKF_OPERATIONS
==
delete from WKF_OPERATIONS WHERE OP_NUM in ('50317','53203','53204')
'50317','5003','UX modif N° bureau','UX modification numéro de bureau','2','0','I','true','false','false',null,'_PARAM_DYN_','false','false','false','12/05/20','false','0','false',null,null,null,null,null,'false','ASC','0','true'
'53203','5032','UX Modif mutuelle','UX modification de la mutuelle','2','0','I','true','false','false',null,'_PARAM_DYN_','false','false','false','07/05/20','false','0','false',null,null,null,null,null,'false','ASC','0','true'
'53204','5032','UX valid mutuelle','UX validation mutuelle','2','0','N','true','false','false',null,'_PARAM_DYN_','false','false','false','16/06/20','false','0','false',null,null,null,null,null,'false','ASC','0','true'
##
WKF_OPERATIONS
==
UPDATE WKF_OPERATIONS SET OP_LIBELLE = 'UX Validation de modification des coordonnées' WHERE OP_NUM = '50315'  
##
WKF_OPERATIONS
==
delete from WKF_OPERATIONS WHERE PROC_NUM = 4009
'40200','4009','modification_carte','Intialiser modification carte','0','0','I','true','false','false',null,'_PARAM_DYN_','false','false','false','20190416114648','false','0','false',null,null,null,null,null,'false',null,'0','false'
'40201','4009','valider_modif_carte','valider la modification de la carte','0','0','N','true','false','false',null,'_PARAM_DYN_','false','false','false','20190416115410','false','0','false',null,null,null,null,null,'false',null,'0','false'
'40202','4009','init-fin-carte','validation carte sejour','0','0','F','true','false','true','fr.adp.com.gxp.std.mot_met.lib.objects.workflow.WkfMetierGeneriqueObj',null,'false','false','false','20190417150400','false','0','false',null,null,null,null,null,'false','ASC','0','false'
'40203','4009','modif docImm salarié','modification Carte salarié étranger Market Place','0','0','I','true','false','false',null,'_PARAM_DYN_','false','false','false','20190416114648','false','0','false',null,null,null,null,null,'false',null,'0','false'
##
WKF_PROCESSUS
==
delete from WKF_PROCESSUS WHERE PROC_NUM = 4009
'4009','Modification de la carte de séjour','0',null,'false','0','fr.adp.com.gxp.std.mot_met.lib.objects.workflow.WkfMetierGeneriqueObj','true','DBA','true',null,'1'
##
WKF_TRANSITIONS
==
delete from WKF_TRANSITIONS WHERE TR_NUM in (53205,53206,53207,50317,50320)
'53205','5032','T53205 vers (UX validation mutuelle,UX validation mutuelle)'
'53206','5032','T53206 vers (Fin processus modification mutuelle,Fin processus modification mutuelle)'
'53207','5032','T53207 vers (Fin processus modification mutuelle,Fin processus modification mutuelle)'
'50317','5003','T50317 vers (Fin processus modification de l''adresse)'
'50320','5003','T50320 vers (UX Validation de modification des coordonnées)'
##
WKF_TRANSITIONS
==
delete from WKF_TRANSITIONS WHERE TR_NUM = 4203
'4203','4009','T4203vers(valider la modification de la carte)'
##
RELOAD_TGE_ALIM_PERIODE_INDIV
=SQL=
DECLARE
CURSOR cur_pac IS SELECT NUMPAC,PERIODEENCOURS FROM TGE_REF_PAC;
BEGIN
  FOR current_pac IN cur_pac
  LOOP
    TGE_ALIM_PERIODE_INDIV(0, current_pac.NUMPAC, '200001', null, null);
  END LOOP;
END;
##
ADM_CHANGE_NOM_PAGE
==
CALL ADM_CREATE_NOM_PAGE(99,'UX - Helpdesk','Modules/AdpUx/UxHelpdesk.jsp',null,'false')
##
SYS_SCH_ELEMENT
==
UPDATE SYS_SCH_ELEMENT SET TAGS='_PAS_VISIBLE_' WHERE niveau = '99' and nom_page='Modules/AdpUx/UxHelpdesk.jsp'
##
ADM_CHANGE_NOM_PAGE
==
CALL ADM_CHANGE_NOM_PAGE('Moteur/Comp/WebAdmin/TracesDownload.jsp','Ext.adp.Moteur.Comp.WebAdmin.Telechargements')
##
ADM_CREATE_NOM_PAGE
==
CALL ADM_CREATE_NOM_PAGE(99,'Paramétrage des graphes','Ext.adp.Moteur.Charts.GestionCharts',null,'false')
##
ADM_NEWPAGE_SYS_SCHEMAS
==
CALL ADM_NEWPAGE_SYS_SCHEMAS('Ext.adp.Moteur.Charts.GestionCharts','Modules/ADP_ONLY/Parametrage/DashboardParam.jsp')
##
ADM_CREATE_NOM_PAGE
==
CALL ADM_CREATE_NOM_PAGE(99,'Traces','Moteur/Trace/TracesInterpreterExpert.jsp',null,'false')
##
ADM_NEWPAGE_SYS_SCHEMAS
==
CALL ADM_NEWPAGE_SYS_SCHEMAS('Moteur/Trace/TracesInterpreterExpert.jsp','Modules/Gap/traitement/Selection.jsp?NOMTRAITEMENT=RECYCLAG')
##
TGE_CREATE_TRIGGER
=SQL=
BEGIN
  FOR TABLE_DIC IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE 'DIC%' AND NOT REGEXP_LIKE(TABLE_NAME,'DIC.*_[0-9]+')) LOOP
    TGE_CREATE_TRIGGER(TABLE_DIC.TABLE_NAME);
  END LOOP;
END;
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'ParametrageDonneesUX.jsp' and IDREQUETE = '1'
'ParametrageDonneesUX.jsp','1','Administrateur','MP_DATA_IHM','NOM_DONNEE_UX,LIBELLE_DONNEE_UX','NOM_DONNEE_UX,LIBELLE_DONNEE_UX',null,'0',null,null,null,'Recherche des données UX','Nom donnée UX, Libellé donnée UX'
##
TGE_GTA_ABS_STATUTS
=SQL=
update TGE_GTA_ABS_STATUTS set EST_INITIALE = '1' where code = 'F'
##
TGE_GTA_ABS_STATUTS
==
DELETE FROM TGE_GTA_ABS_STATUTS WHERE code='I' 
'I','A justifier ultérieurement','Validation expert, justificatif à fournir ultérieurement','1','1','1','#fcac6b','10','PENDING'
##
SYS_REQUETES_JSP
==
delete from SYS_REQUETES_JSP where NOMPAGE = 'eventUX' and IDREQUETE = 1
'eventUX',1,'Administrateur','MP_REF_EVENTS','event  , libelle','event  , libelle','op_num is null','0',null,'event , event_id',null,'Recherche d''un Ã©vÃ¨nement UX','EvÃ¨nement , LibellÃ©'
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI where ORIGINE = 'RD' and CODE_REQ in ('PAI','PAI_RETRO')
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? AND (T.NUMPAC,T.PACMAT,T.PAIEZAD) IN ( SELECT H.NUMPAC,H.PACMAT,H.PAIEZAD FROM dic_adm_contrat_histo H WHERE H.za996   = ''W'') '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO )  AND (T.NUMPAC,T.PACMAT,T.PAIEZAD) IN ( SELECT H.NUMPAC,H.PACMAT,H.PAIEZAD FROM dic_adm_contrat_histo H WHERE H.ZA996   = ''W'') '
##
TGE_REF_ENVOI_PAI
==
DELETE FROM TGE_REF_ENVOI_PAI where ORIGINE = 'RD' and CODE_REQ in ('PAI','PAI_RETRO')
##
TGE_REF_ENVOI_PAI (ORIGINE,CODE_REQ,ORDRE_REQ,REQUETE)
'RD','PAI','1','SELECT G.ID_TRT, T.NUMPAC, ''NORMAL'' AS TYPE_ENVOIE, T.MOIS_PAIE as PERIODE_PAIE, T.MOIS_PAIE as PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( (T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) AND (T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND (T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'',''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T WHERE G.NUMPAC = ? AND T.numpac = G.NUMPAC AND T.PACMAT =G.PACMAT AND G.ID_TRT = ? AND t.mois_paie = ? AND (T.NUMPAC,T.PACMAT,T.PAIEZAD) IN ( SELECT H.NUMPAC,H.PACMAT,H.PAIEZAD FROM dic_adm_contrat_histo H WHERE H.za996   = ''W'') '
'RD','PAI_RETRO','1','SELECT G.ID_TRT, T.NUMPAC, ''RETRO'' AS TYPE_ENVOIE, ? AS PERIODE_PAIE, PR.PERIODE_RETRO AS PERIODE_RETRO, T.PAIEZAD, T.PACMAT, T.DEBUT_PERIODE_PAIE, T.FIN_PERIODE_PAIE, T.ENTREE, T.SORTIE, NVL(T.DEBUT_PERIODE_RECUEIL,T.DEBUT_PERIODE_RECUEIL_LTP) AS DEBUT_PERIODE_RECUEIL, NVL(T.FIN_PERIODE_RECUEIL,T.FIN_PERIODE_RECUEIL_LTP) AS FIN_PERIODE_RECUEIL, CASE WHEN ( ( T.ENTREE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) AND ( T.SORTIE NOT BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) THEN ''PAI2'' ELSE ''PAI3'' END AS TYPEPAI , ( SELECT COUNT(*) FROM DIC_ADM_CONTRAT DAC WHERE T.NUMPAC =DAC.NUMPAC AND T.PACMAT =DAC.PACMAT AND DAC.CURRENT_PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDCN AND NVL(DSFCN,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDCN BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS NB_CONTRAT , ( SELECT CODE_CHRONO FROM DIC_ADM_CONTRAT_SITU DACS WHERE T.NUMPAC =DACS.NUMPAC AND T.PACMAT =DACS.PACMAT AND DACS.PAIEZAD=T.PAIEZAD AND ( T.DEBUT_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR T.FIN_PERIODE_PAIE BETWEEN DSDSC AND NVL(DSFSC,TO_DATE(''31.12.2099'', ''DD.MM.YYYY'')) OR DSDSC BETWEEN T.DEBUT_PERIODE_PAIE AND T.FIN_PERIODE_PAIE ) ) AS CODE_CHRONO FROM GAP_TRT_LISTE_MAT G , TGE_PERIODE_RECUEIL_PAIEZAD T , TGE_MODIF_PACMAT_RETRO PR WHERE T.NUMPAC =? AND T.numpac = G.NUMPAC AND T.PACMAT = G.PACMAT AND T.MOIS_PAIE = PR.PERIODE_RETRO AND PR.PERIODE_RETRO >= ? AND PR.NUMPAC = G.NUMPAC AND PR.Pacmat = G.PACMAT AND G.ID_TRT = ? AND PR.TABLE_MAJ = ''PRD_PP_RETRO_INFOPAIE'' AND ( G.NUMPAC,G.PACMAT,PR.PERIODE_RETRO ) IN ( SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_RETRO_MATRIC UNION ALL SELECT NUMPAC, PACMAT, PERIODE_RETRO FROM GAP_SELECTION_RETRO )  AND (T.NUMPAC,T.PACMAT,T.PAIEZAD) IN ( SELECT H.NUMPAC,H.PACMAT,H.PAIEZAD FROM dic_adm_contrat_histo H WHERE H.ZA996   = ''W'') '
##
DIC_GESTION_BACASABLE
=SQL=
create or replace PROCEDURE DIC_GESTION_BACASABLE( NOM_DICTIONNAIRE          IN VARCHAR2 ,
 NOM_DICTIONNAIRE_IDPROJET IN VARCHAR2 ,
 LISTKEYS                  IN VARCHAR2 ) AUTHID CURRENT_USER
 AS
 TYPE TYP_COL_NAME
 IS
 TABLE OF USER_TAB_COLUMNS.COLUMN_NAME%type ;
 Tabcol TYP_COL_NAME ;
 req  VARCHAR2(512);
 lkey VARCHAR2(512);
 ListCle TYP_COL_NAME ;
 selectCle VARCHAR2(512);
 v_nbMatric NUMBER(10);
 BEGIN
 BEGIN
 EXECUTE_IMMEDIATE_STRING('DROP TABLE '||NOM_DICTIONNAIRE_IDPROJET ,0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('table absente '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
  SELECT cols.column_name BULK COLLECT INTO ListCle
  FROM USER_CONSTRAINTS cons, user_cons_columns cols
  WHERE cols.table_name = NOM_DICTIONNAIRE
  AND cons.constraint_type = 'P'
  AND cons.constraint_name = cols.constraint_name
  AND cols.column_name IN ('NUMPAC','PACMAT','PAIEZAD','MATRIC')
  AND cons.owner = cols.owner
  ORDER BY cols.table_name, cols.position;
  IF (ListCle.COUNT = 1 AND ListCle(1) = 'NUMPAC') OR ListCle.COUNT = 0 THEN
    BEGIN
   EXECUTE_IMMEDIATE_STRING( 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select * from '||NOM_DICTIONNAIRE,0) ;
   EXCEPTION
   WHEN OTHERS THEN
   --dbms_output.put('impossible de créer la table '||NOM_DICTIONNAIRE_IDPROJET);
   --FIXME utiliser la procédure trace_dbms_output()
   NULL;
    END ;
  ELSE
    selectCle := 'CREATE TABLE '||NOM_DICTIONNAIRE_IDPROJET||' as select DISTINCT '||NOM_DICTIONNAIRE||'.* from '||NOM_DICTIONNAIRE||',CLE_BAC_A_SABLE ';
    IF ListCle.count>0 THEN
       FOR i IN ListCle.first..ListCle.last
       LOOP
         IF i  = 1 THEN
         selectCle:=selectCle||' WHERE '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         ELSE 
         selectCle:=selectCle||' AND '||NOM_DICTIONNAIRE||'.'||ListCle(i)||' = '||'CLE_BAC_A_SABLE'||'.'||ListCle(i);
         END IF;
       END LOOP;
    END IF; 
    EXECUTE_IMMEDIATE_STRING( selectCle,0) ;
  END IF;

 IF LISTKEYS IS NULL THEN
 SELECT cols.column_name BULK COLLECT
 INTO Tabcol
 FROM user_constraints cons,
 user_cons_columns cols
 WHERE cols.table_name    = NOM_DICTIONNAIRE
 AND cons.constraint_type = 'P'
 AND cons.constraint_name = cols.constraint_name
 AND cons.owner           = cols.owner
 ORDER BY cols.table_name,
 cols.position ;
 IF Tabcol.count>0 THEN
 FOR i IN Tabcol.first..Tabcol.last
 LOOP
 IF i   > 1 THEN
 lkey:=lkey||',';
 END IF;
 lkey:=lkey||Tabcol(i);
 END LOOP;
 END IF;
 IF LENGTH(lkey)>0 THEN
 req         :='ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||lkey||')';
 dbms_output.put_line('lkey : '||lkey);
 EXECUTE_IMMEDIATE_STRING (req,0);
 END IF ;
 ELSE
 BEGIN
 EXECUTE_IMMEDIATE_STRING('ALTER TABLE '||NOM_DICTIONNAIRE_IDPROJET||' ADD PRIMARY KEY ('||LISTKEYS||')',0);
 EXCEPTION
 WHEN OTHERS THEN
 --dbms_output.put('impossible de positionner les clés '||NOM_DICTIONNAIRE_IDPROJET);
 --FIXME utiliser la procédure trace_dbms_output()
 NULL;
 END ;
 END IF;
 END DIC_GESTION_BACASABLE;
##
TAG_CHARSET=@€éèç
##
R_PRESENT_FICHIER_PAIE
=SQL=
create or replace PROCEDURE R_PRESENT_FICHIER_PAIE( NUMPAC_TRAITEMENT IN SECUPACMAT.NUMPAC%Type , PACMAT_TRAITEMENT IN SECUPACMAT.PACMAT%Type ) IS 
PERIODEENCOURS_TRAITEMENT TGE_REF_PAC.PERIODEENCOURS%type;
BEGIN
-- récupère la periode en cours du pac
  BEGIN 
   SELECT PERIODEENCOURS into PERIODEENCOURS_TRAITEMENT from TGE_REF_PAC where NUMPAC=NUMPAC_TRAITEMENT;
   EXCEPTION
   WHEN NO_DATA_FOUND then
    RETURN;
  END;
--fait le merge ds secupacmat
MERGE INTO SECUPACMAT A
USING (
SELECT NUMPAC,
  PACMAT,
  CASE
    WHEN EXISTS
      ( WITH table_dates_eff (pacmat,paiezad,date_eff) AS
      ( SELECT DISTINCT dach2.pacmat,
        dach2.paiezad,
        MAX(date_eff) OVER(PARTITION BY dach2.pacmat,dach2.paiezad)
      FROM dic_adm_contrat_histo dach2
      WHERE dach2.numpac     = NUMPAC_TRAITEMENT
      AND dach2.pacmat       = NVL(PACMAT_TRAITEMENT,dach2.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
      AND dach2.date_eff    <= last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') )
      AND dach2.date_fin_bo >= add_months( (TO_DATE(PERIODEENCOURS_TRAITEMENT,'yyyymm') ), -
        (SELECT valvar                                                                     -1
        FROM sys_varsys
        WHERE codvar ='NB_MOIS_PAIE_INIT'
        AND module   ='GAP'
        ) )
      )
    SELECT 1
    FROM dic_adm_contrat_histo dach
    INNER JOIN table_dates_eff t
    ON dach.pacmat    = t.pacmat
    AND dach.paiezad  = t.paiezad
    AND dach.date_eff = t.date_eff
    LEFT JOIN dic_tge_respaie_unique dtru
    ON dtru.numpac                     = NUMPAC_TRAITEMENT
    AND dtru.pacmat                    = dach.pacmat
    AND dtru.paiezad                   = dach.paiezad
    WHERE dach.numpac                  = NUMPAC_TRAITEMENT
    AND dach.pacmat                    = NVL(PACMAT_TRAITEMENT,dach.pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
    AND sec.pacmat                     = dach.pacmat
    AND (dtru.numpac                  IS NULL
    OR ( dtru.prfpai                  != 'A'
    OR dtru.dtfpai                     > last_day(TO_DATE(PERIODEENCOURS_TRAITEMENT,'YYYYMM') )
    OR ( dach.ZREACT                  IS NOT NULL
    AND dtru.dtfpai                   <= dach.zreact
    AND EXTRACT(YEAR FROM dach.zreact) = SUBSTR(PERIODEENCOURS_TRAITEMENT,1,4) )
    OR dtru.dtfpai                     < dach.dssad ))
      )
    THEN 'O'
    ELSE 'N'
  END PRESENT_FICHIER_PAIE
FROM SECUPACMAT SEC
WHERE numpac     = NUMPAC_TRAITEMENT
AND pacmat       = NVL(PACMAT_TRAITEMENT,pacmat) -- si PACMAT_TRAITEMENT est renseigné, on l'utilise, sinon on neutralise le and
) B
ON (A.NUMPAC = B.NUMPAC and A.PACMAT = B.PACMAT)
WHEN MATCHED THEN UPDATE SET A.PRESENT_FICHIER_PAIE = B.PRESENT_FICHIER_PAIE ;

END R_PRESENT_FICHIER_PAIE;
##
DROP_DEX_EVENTS_PK
=SQL IF_INDEX_EXIST=DEX_EVENTS_PK=
DROP INDEX DEX_EVENTS_PK
##
CREATE_MP_EVENTS_PK
=SQL IF_INDEX_NOTEXIST=MP_EVENTS_PK=
CREATE INDEX MP_EVENTS_PK ON MP_EVENTS (ID_ENVOI)
