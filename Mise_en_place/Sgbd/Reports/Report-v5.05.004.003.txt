##
TAG_IMPORT=5.05.004.R003
##
TAG_CHARSET=@€éèç
##
TGE_CREATE_TRIGGER_DAC
==
CALL TGE_CREATE_TRIGGER('DIC_ADM_CONTRAT')
##
TGE_CREATE_TRIGGER_DACH
==
CALL TGE_CREATE_TRIGGER('DIC_ADM_CONTRAT_HISTO')
##
TGE_CLOTURE
=SQL=
create or replace PROCEDURE TGE_CLOTURE ( p_id in number, P_NUMPAC IN VARCHAR2 ) AS /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 P_PERIODEENCOURS TGE_REF_PAC.PERIODEENCOURS%type;
 p_dtdebMois varchar2(8);
 p_finMois varchar2(8);
 p_histoIP varchar2(1);
 
 P_DEB_RETRO TGE_REF_PAC.DEB_RETRO%type;
 P_DEB_HISTO_RETRO TGE_REF_PAC.DEB_HISTO_RETRO%type;
 P_NB_MOIS_RETRO TGE_REF_PAC.NB_MOIS_RETRO%type;
 P_PERIDOE_HISTO_LIMITE TGE_REF_PAC.PERIODEENCOURS%type;
 w_per   VARCHAR2(6);
 w_req   CLOB;
 isRetro number :=0;
 BEGIN
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin)','Début de la clôture du numpac  '||P_NUMPAC);
 
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Recup Periode + infos Rétro)','Récupération de la période en cours,date début Rétro, date début historisation Rétro et nombre de mois Rétro à partir de TGE_REF_PAC pour le numpac : '||P_NUMPAC);
 select PERIODEENCOURS ,DEB_RETRO,DEB_HISTO_RETRO,NB_MOIS_RETRO ,to_char( add_months(to_date(PERIODEENCOURS,'yyyymm'),(-1*nvl(NB_MOIS_RETRO,1))+1),'YYYYMM') PERIDOE_HISTO_LIMITE
 into P_PERIODEENCOURS,P_DEB_RETRO,P_DEB_HISTO_RETRO,P_NB_MOIS_RETRO ,P_PERIDOE_HISTO_LIMITE
 from TGE_REF_PAC where numpac=p_numpac;
 
 IF P_DEB_RETRO is not null  AND to_date(P_PERIODEENCOURS,'YYYYMM')>=to_date(P_DEB_HISTO_RETRO,'YYYYMM') THEN
 w_per := P_PERIDOE_HISTO_LIMITE;
 isRetro :=1;
 ELSE
 w_per := P_PERIODEENCOURS;
 isRetro:=0;
 END IF;
 
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant lecture REF PER)','Récupération de la date de début et de fin du mois pour le numpac '||P_NUMPAC || '  et la periode '|| p_PERIODEENCOURS );
 select DATE_DEBUT_MOIS,DATE_FIN_MOIS into p_dtdebMois,p_finMois from TGE_REF_PER where numpac=p_numpac and periodeencours=p_PERIODEENCOURS;
 --Purge et Historisation de dif_FSED
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Deb PURGE_HISTO_DIF_FSED)','Début PURGE_HISTO_DIF_FSED pour le numpac  '||P_NUMPAC );
 PURGE_HISTO_DIF_FSED ( p_id, P_NUMPAC,P_PERIODEENCOURS,P_DEB_RETRO,P_DEB_HISTO_RETRO,P_NB_MOIS_RETRO,P_PERIDOE_HISTO_LIMITE);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Fin PURGE_HISTO_DIF_FSED)','Fin PURGE_HISTO_DIF_FSED pour le numpac  '||P_NUMPAC );
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV DIF_FSED) ',' début sauvegarde DIF_FSED'  );
 BEGIN
 w_req :='Create TABLE DIF_FSED_'||P_PERIODEENCOURS||' as select * from DIF_FSED '  ;
 execute_immediate_string (w_req,0);
 EXCEPTION 
   WHEN OTHERS THEN
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (SAV DIF_FSED) ','la table DIF_FSED_'||P_PERIODEENCOURS||' existe déja ' );
 END ;


 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (DEBUT Supp DIF_FSED)','DEBUT Purge de la table DIF_FSED ');
 FOR C IN
 (SELECT DISTINCT to_char(id_trt) as trt FROM DIF_FSED WHERE NUMPAC =p_numpac
 )
 LOOP
 w_req :='ALTER TABLE DIF_FSED DROP PARTITION ID_'||C.trt ;
 BEGIN
 execute_immediate_string (w_req,0);
 EXCEPTION 
 when others then 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE ( Supp partition DIF_FSED)','ERREUR lors de la suppresstion partition ID_'||C.trt||' de DIF_FSED '||SQLCODE||'-'||SQLERRM);
 end ;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE ( Supp partition DIF_FSED)','suppression partition ID_'||C.trt||' de DIF_FSED ');
 END LOOP;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (FIN Supp DIF_FSED)','FIN Purge de la table DIF_FSED');
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant insert GAP TRT)','Préparation du traitement GAP_TRT pour le  '||P_NUMPAC);
 --Ajout  dans GAP_TRT
 insert into GAP_TRT (ID_TRT,NUMPAC,PERIODE_PAIE,NUMERO_ECHANGE,MODELE,NATURE,DATE_DEBUT_PAIE,DATE_FIN_PAIE,WORKFLOW_ID,DATE_PREVUE_TRT,DATE_PLANIF_TRT,DATE_DEBUT_TRT,INFO)
 values
 (p_id,P_NUMPAC,p_PERIODEENCOURS,'0000','ALP','CLOTURE',p_dtdebMois,p_finMois,'TGEPAY'||P_NUMPAC||'PACGXP'||p_PERIODEENCOURS||'0000',sysdate,sysdate,sysdate,'CLOTURE');
 
 --GAP_TRT_SUIVI
 FSED.insert_gap_trt_suivi(p_id,'PREPA_CLOTURE',null,'BATCH','CL');
 --BEGIN DIT 37805
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin Supp RELIQ)',' Début de la purge des tables  TGE_RELIQ_INCIDENTS_PAIE, TGE_RELIQ_DONNEES_PAIE, TGE_RELIQ_ELEMENTS_PAIE, TGE_RELIQ_IMPUTATIONS,TGE_RELIQ_PACMAT_TORESEND pour le numpac  '||P_NUMPAC);
 -- les tables TGE_RELIQ_* sont vidées pour le pac en question
 DELETE FROM TGE_RELIQ_INCIDENTS_PAIE  WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_DONNEES_PAIE    WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_ELEMENTS_PAIE   WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_IMPUTATIONS     WHERE NUMPAC = P_NUMPAC;
 DELETE FROM TGE_RELIQ_PACMAT_TORESEND WHERE NUMPAC = P_NUMPAC;
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (End Supp RELIQ)','Fin de de la purge des tables RELIQ pour le  numpac : '||P_NUMPAC);
 --FIN  DIT 37805
 
 -- Mise à jour secupacmat
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Update SECUPACMAT)','Deuxième période de recyclage : Mise à jour de la table SECUPACMAT pour le numpac : '||p_numpac);
 update SECUPACMAT set PERIODE_RECYCLAGE=2 where numpac=p_numpac;
 FSED.insert_gap_trt_suivi(p_id,'PERIODE_RECYCLAGE_2',null,'BATCH','CL');
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant insert LISTE MAT)','Préparation de la liste des matricules');
 -- RSI  Le 20/02/2015 DIT 41197:EVOL: Ajout du type de paie 'GAPSELMA'
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,null from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_PERIODEENCOURS  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and not exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 -- Le 25/04/2015 ajout des mal recyclés (colonne "TRAITE"='R')
 insert into GAP_TRT_LISTE_MAT select distinct  p_id,b.numpac,b.pacmat,'R' from (
 select distinct c.id_trt
 from TGE_SCHEMA_PRODUCTION a,GAP_TRT b,GAP_TRT_SUIVI c  where a.numpac=p_numpac and a.TYPE_PAIE in ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 and a.numpac=b.numpac and a.modele=b.modele and a.nature=b.nature and b.id_trt=c.id_trt and c.statut in ('PA','EX','DEMSEA') AND NVL(c.code_retour_zpp,'00')='00' and b.PERIODE_PAIE = p_PERIODEENCOURS  and b.numero_echange<>'0000') a, GAP_TRT_LISTE_MAT b where a.id_trt=b.id_trt
 and exists (select c.numpac,c.pacmat from GAP_RECYCL_MATRIC c where c.numpac=b.numpac and c.pacmat=b.pacmat ) ;
 -- photos
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant génération photo)','Début de la génération de la photo pour le numpac '||P_NUMPAC||'  à la date '||p_dtdebMois);
 tge_generation_photo(p_id,p_numpac,p_dtdebMois);
 FSED.insert_gap_trt_suivi(p_id,'PHOTO',null,'BATCH','CL');
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après génération photo)','Fin de la génération de la photo pour le numpac '||P_NUMPAC||'  à la date '||p_dtdebMois);
 
 
 insert into bypass_trg_recycl_on_session(date_event, message) values (sysdate, 'Cloture en cours pour le NUMPAC : ' || p_numpac);
 
 -- lecture de la valeur de HISTO_IP dans TGE_REF_PAC
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant lecture REF PER)','Récupération de la valeur de HISTO_IP dans TGE_REF_PAC pour le numpac '||P_NUMPAC );
 select nvl(HISTO_IP,'N') into p_histoIP from TGE_REF_PAC where NUMPAC = p_numpac;
 
 -- purge saisies quai
 FSED.insert_gap_trt_suivi(p_id,'PURGE_QUAIS',null,'BATCH','CL');
 delete from TGE_IMPUTATIONS where numpac=p_numpac and to_date(PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'YYYYMM') and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt=p_id
 and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null );
 
 IF p_histoIP = 'N' THEN
 
 w_req :='DELETE FROM TGE_INCIDENTS_PAIE z WHERE z.numpac='''||p_numpac||''' AND  ';
 if isRetro=1 then
 w_req := w_req || ' ( z.PERIODE <greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req || ' ( z.PERIODE           <=to_date('''||w_per||''',''yyyymm'')';
 end if;
 w_req := w_req||')'||' AND (z.numpac,z.paiezad) IN (SELECT DISTINCT b.numpac,
 d.paiezad FROM GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d,TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE b.id_trt ='||p_id||' AND d.numpac =b.numpac AND d.pacmat =b.pacmat AND d.numpac  =t.numpac AND d.pacmat  =t.pacmat
 AND d.paiezad   =t.paiezad AND ';
 if isRetro=1 then
 w_req := w_req || ' to_date(t.MOIS_PAIE,''YYYYMM'') <= greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
  w_req := w_req ||' to_date(t.MOIS_PAIE,''YYYYMM'') = to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||' AND (z.date_effet <= t.FIN_PERIODE_RECUEIL OR z.TYPE_IP       = ''T'')AND b.traite      IS NULL)';
  FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge incidents )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 update TGE_INCIDENTS_PAIE z
 set    ACTION_RETRO='H',ACTION_RETRO_DATE=null
 WHERE  z.numpac           =p_numpac
 AND z.PERIODE >to_date(P_PERIDOE_HISTO_LIMITE,'yyyymm')
 AND z.PERIODE<=to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.numpac,z.paiezad) IN
 (SELECT DISTINCT b.numpac,
 d.paiezad
 FROM GAP_TRT_LISTE_MAT b,
 DIC_ADM_CONTRAT_SITU d,
 TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE b.id_trt     =p_id
 AND d.numpac       =b.numpac
 AND d.pacmat       =b.pacmat
 AND d.numpac       =t.numpac
 AND d.pacmat       =t.pacmat
 AND d.paiezad      =t.paiezad
 AND to_date(t.MOIS_PAIE,'yyyymm') = to_date(p_PERIODEENCOURS,'yyyymm')
 AND (z.date_effet <= t.FIN_PERIODE_RECUEIL
 OR z.TYPE_IP       = 'T')
 AND b.traite      IS NULL
 );
 end if;
 END IF;
 
 w_req :='delete from TGE_DONNEES_PAIE where numpac='''||p_numpac||''' and ' ;
 if isRetro=1 then
 w_req := w_req || '( to_date(PERIODE,''YYYYMM'') < greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req ||' (  to_date(PERIODE,''YYYYMM'') <= to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||') and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt='||p_id||
 ' and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null)';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge donnes )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 update TGE_DONNEES_PAIE
 set    ACTION_RETRO ='H',
 ACTION_RETRO_DATE =null
 where numpac=p_numpac 
 and to_date(PERIODE,'YYYYMM')>to_date(P_PERIDOE_HISTO_LIMITE,'yyyymm') 
 AND to_date(PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'yyyymm')
 and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt=p_id
 and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null);
 end if;
 w_req :='delete from TGE_ELEMENTS_PAIE where numpac='''||p_numpac||''' and  ' ;
 if isRetro=1 then
 w_req := w_req || '( to_date(PERIODE,''YYYYMM'') < greatest(to_date('''||P_PERIDOE_HISTO_LIMITE||''',''YYYYMM''),to_date(nvl('''||P_DEB_HISTO_RETRO||''',''209912''),''YYYYMM''))'||' OR DERNIER_CODE_OPE=''S''';
 else
 w_req := w_req ||' (  to_date(PERIODE,''YYYYMM'') <= to_date('''||p_PERIODEENCOURS||''',''YYYYMM'')';
 end if;
 w_req := w_req ||')  and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt='||p_id||
 ' and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null )';
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge elements )',w_req);
 execute_immediate_string (w_req,0);
 if isRetro=1 then
 update TGE_ELEMENTS_PAIE
 set    ACTION_RETRO ='H',
 ACTION_RETRO_DATE =null
 where numpac=p_numpac 
 and to_date(PERIODE,'YYYYMM')>to_date(P_PERIDOE_HISTO_LIMITE,'yyyymm') 
 AND to_date(PERIODE,'YYYYMM')<=to_date(p_PERIODEENCOURS,'yyyymm')
 and (numpac,paiezad) in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt=p_id
 and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null);
 END IF;
 delete from DELETED_PAIEZAD where numpac=p_numpac and DATE_SUPPRESSION<=add_months(to_date(p_PERIODEENCOURS,'yyyymm'),-1)  and (numpac,paiezad) not in (select distinct b.numpac,d.paiezad from GAP_TRT_LISTE_MAT b,DIC_ADM_CONTRAT_SITU d where b.id_trt=p_id
 and d.numpac=b.numpac and d.pacmat=b.pacmat and b.traite is null);
 
 -- purge saisies quai des matricules mal recyclés
 FSED.insert_gap_trt_suivi(p_id,'PURGE_QUAIS_RECY',null,'BATCH','CL');
 delete from TGE_IMPUTATIONS z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 
 ( SELECT max (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )  AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 AND z.numpac       =e.numpac
 AND z.PAIEZAD      =d.paiezad
 )  and PERIODE<=p_PERIODEENCOURS ;
 
 IF p_histoIP='N' THEN
 DELETE
 FROM TGE_INCIDENTS_PAIE z
 WHERE z.numpac            =p_numpac
 AND (z.numpac,z.paiezad) IN
 (SELECT DISTINCT t.numpac,
 t.paiezad
 FROM TGE_PERIODE_RECUEIL_PAIEZAD t
 WHERE z.numpac     =t.numpac
 AND z.paiezad      =t.paiezad
 AND t.MOIS_PAIE = p_PERIODEENCOURS
 AND (z.date_effet <= t.FIN_PERIODE_RECUEIL
 OR z.TYPE_IP       = 'T')
 )
 AND z.date_maj<
 (SELECT MAX (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c,
 GAP_TRT_LISTE_MAT e,
 DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac                 =p_numpac
 AND a.TYPE_PAIE               IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac                   =b.numpac
 AND a.modele                   =b.modele
 AND a.nature                   =b.nature
 AND b.id_trt                   =c.id_trt
 AND c.statut                  IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE             = p_PERIODEENCOURS
 AND b.numero_echange          <>'0000'
 AND e.id_trt                   =b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )
 AND d.numpac  =e.numpac
 AND d.pacmat  =e.pacmat
 AND z.numpac  =e.numpac
 AND z.PAIEZAD =d.paiezad
 )
 AND to_date(z.PERIODE)<=to_date(p_PERIODEENCOURS,'YYYYMM');
 END IF;
 
 delete from TGE_DONNEES_PAIE z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 
 ( SELECT max (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )  AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 AND z.numpac       =e.numpac
 AND z.PAIEZAD      =d.paiezad
 ) and PERIODE<=p_PERIODEENCOURS ;
 
 delete from TGE_ELEMENTS_PAIE z where numpac=p_numpac AND to_date(date_maj,'yyyymmddHH24MI')<
 
 ( SELECT max (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )  AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 AND z.numpac       =e.numpac
 AND z.PAIEZAD      =d.paiezad
 )  and PERIODE<=p_PERIODEENCOURS ;
 
 delete from DELETED_PAIEZAD z where numpac=p_numpac AND DATE_SUPPRESSION<
 
 ( SELECT max (b.DATE_DEBUT_TRT)
 FROM TGE_SCHEMA_PRODUCTION a,
 GAP_TRT b,
 GAP_TRT_SUIVI c, GAP_TRT_LISTE_MAT e, DIC_ADM_CONTRAT_SITU d
 WHERE a.numpac       =p_numpac
 AND a.TYPE_PAIE     IN ('PRECONTR','CONTROLE','RECYCLAG','PARTICUL','REGLE','REGLEALL','GAPSELMA')
 AND a.numpac         =b.numpac
 AND a.modele         =b.modele
 AND a.nature         =b.nature
 AND b.id_trt         =c.id_trt
 AND c.statut        IN ('PA','EX','DEMSEA')
 AND NVL(c.code_retour_zpp,'00')='00'
 AND b.PERIODE_PAIE   = p_PERIODEENCOURS
 AND b.numero_echange<>'0000'
 and e.id_trt=b.id_trt
 AND EXISTS
 (SELECT f.numpac,
 f.pacmat
 FROM GAP_RECYCL_MATRIC f
 WHERE f.numpac=e.numpac
 AND f.pacmat  =e.pacmat
 )  AND d.numpac       =e.numpac
 AND d.pacmat       =e.pacmat
 AND z.pacmat       =d.pacmat
 AND z.numpac       =e.numpac
 AND z.PAIEZAD      =d.paiezad
 ) ;
 
 -- M+1 sur TGE_REF_PAC
 update TGE_REF_PAC set periodeencours=to_char(add_months(to_date(periodeencours,'yyyymm'), 1),'yyyymm') where numpac=p_numpac;
 
 merge into TGE_REF_PER a using (select p_numpac as numpac,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'), 1),'yyyymm') as periodeencours from dual) b on (a.numpac=b.numpac and a.periodeencours=b.periodeencours)
 when matched then
 update set a.DATE_DEBUT_MOIS=b.periodeencours||'01',a.DATE_FIN_MOIS= to_char(last_day(to_date(b.periodeencours,'yyyymm')),'yyyymmdd'),a.DERNIER_NUM_ECHANGE=nvl(a.DERNIER_NUM_ECHANGE,'0000')
 when not matched then
 insert (a.numpac,a.periodeencours,a.DATE_DEBUT_MOIS,a.DATE_FIN_MOIS,a.DERNIER_NUM_ECHANGE) values (b.numpac,b.periodeencours,b.periodeencours||'01', to_char(last_day(to_date(b.periodeencours,'yyyymm')),'yyyymmdd') ,'0000'      )
 ;
 -- purge histo technique
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant purge histo)','Début de la purge pour le numpac : '||P_NUMPAC);
 tge_purge_histo(p_numpac,to_char(add_months(to_date(p_PERIODEENCOURS,'yyyymm'), 1),'yyyymm'));
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après purge histo)','Fin de la purge pour le numpac : '||P_NUMPAC);
 
 --BEGIN DIT 37805
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Begin Insert RELIQ)','Début d insertion dans les tables RELIQ_  pour le numpac : '||P_NUMPAC);
 
 -- les tables TGE_RELIQ_* sont vidées pour le pac en question
 tge_insert_reliq (p_id,p_numpac,p_PERIODEENCOURS);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (End Insert RELIQ)','Fin d insertion dans les tables RELIQ_  pour le numpac : '||P_NUMPAC);
 
 -- Mise à jour secupacmat
 update SECUPACMAT set PERIODE_RECYCLAGE=0 where numpac=p_numpac;
 FSED.insert_gap_trt_suivi(p_id,'PERIODE_RECYCLAGE_0',null,'BATCH','CL');
 -- purger table matricules en recyclage
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge RECYCL)','Purger table matricules en recyclage  pour le numpac : '||P_NUMPAC);
 DELETE from GAP_RECYCL_MATRIC where numpac=p_numpac ;
 DELETE from TGE_MODIF_PACMAT_TORESEND where numpac=p_numpac ;
 DELETE from GAP_SELECTION_PACMAT where nomtraitement='RECYCLAG' and numpac=p_numpac;
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (Purge RETRO)','Purger table matricules Rétro  pour le numpac : '||P_NUMPAC);
 -- purger table matricules  RETRO
 if P_DEB_RETRO is not null AND to_date(P_PERIODEENCOURS,'YYYYMM')>=to_date(P_DEB_RETRO,'YYYYMM') then
 DELETE from GAP_RETRO_MATRIC where numpac=p_numpac ;
 DELETE from GAP_RETRO_MATRIC_TRAITE where numpac=p_numpac ;
 DELETE from TGE_MODIF_PACMAT_RETRO where numpac=p_numpac ;
 DELETE from GAP_SELECTION_RETRO where  numpac=p_numpac;
 END IF;
 -- RSI Le 20/02/2015 DIT 41197 : Supprimer pour le pac en cours des matricules
 -- sélectionnés dans GAP_SELECTION_PACMAT pour les natures de traitements associés à GAPSELMA dans TGE_SCHEMA_PRODUCTION
 DELETE from GAP_SELECTION_PACMAT
 where numpac= p_numpac
 and nomtraitement in (select distinct NATURE from TGE_SCHEMA_PRODUCTION where type_paie =  'GAPSELMA' and date_fin is null and numpac=p_numpac);
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (avant alimentation période recueil)','Début de la procédure d''alimentation des périodes de recueil pour le numpac '||P_NUMPAC);
 TGE_ALIM_PERIODE_INDIV(p_id, p_numpac, TO_CHAR(ADD_MONTHS(TO_DATE(p_periodeencours,'yyyymm'), 1),'YYYYMM'), NULL);
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (après alimentation période recueil)','Fin de la procédure d''alimentation des périodes de recueil pour le numpac '||P_NUMPAC);
 
 FSED.FSED_AVANCEMENT_PLSQL(p_id,'TGE_CLOTURE (end)','Fin de la clôture pour le numpac '||P_NUMPAC);
 FSED.insert_gap_trt_suivi(p_id,'CLOTURE_OK',null,'BATCH','CL');
 
 exception
 when others then
 FSED.FSED_ERREUR(p_id,'TGE_CLOTURE (raise)',P_NUMPAC,SQLCODE||'-'||SQLERRM);
 update SECUPACMAT set PERIODE_RECYCLAGE=1 where numpac=p_numpac;
 raise;
 END TGE_CLOTURE;
##
TGE_CONTROLE_30
=SQL=
create or replace PROCEDURE TGE_CONTROLE_30 ( P_LOGIN IN VARCHAR2
 , P_DATE_IMPORT IN VARCHAR2
 , P_NUMLIGNE IN VARCHAR2
 , P_CODLANG in VARCHAR2
 -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
 , P_TYPE_ACTION IN VARCHAR2
 ) AS
 /********************************************************************************
 Version     : V5.05.000
 *********************************************************************************/
 clWhere varchar2(1000);
 -- Pour les merge, la clause where ne doit pas inclure la colonne ERREURS, on gère des clauses spécifiques
 clWhereMerge varchar2(1000);
 clWhereMergeErreur varchar2(250);
 
 req varchar2(2000);
 w_exist_element NUMBER ;
 w_err VARCHAR2(2000);
 w_param_longueur VARCHAR2(10);
 
 BEGIN
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||''' and EI.code_element not in (''B690'',''B691'') ';
 
 if p_numligne is not null then
 	clwhere:=clwhere||' AND EI.NUMLIGNE='||p_numligne;
 end if;

 -- On ne traite que les lignes qui sont en statut TRAIT et TRANS (les autres FIN, ANNULER, ... ne doivent plus être controlées 
 clwhere:=clwhere || ' AND (EI.STATUT = ''TRAIT''';
 clwhere:=clwhere || ' OR EI.STATUT = ''TRANS'') ';
  
 clWhereMerge := clwhere;
 clWhereMergeErreur := '';
 
 IF p_type_action = 'VI' and p_login <> 'BATCH' then
   -- A la validation d'import Web, on ne va passer que sur les lignes qui ne sont pas déjà en erreur.
   -- Certaines lignes sont déjà en erreur et on ne veut pas les retraiter (sinon double message)
   clwhere := clwhere || ' and EI.ERREURS is null';
   clWhereMergeErreur := ' where EI.ERREURS is null';
 END IF;
 
 IF p_login ='BATCH' THEN 
 -- Mise à blanc de tous les messages d'erreur des lignes qui vont être contrôlées. Seulement pour le BATCH, car dans les autres cas il y a des contrôles
 -- qui sont fait en amont des contrôles PL/SQL (côté Java)
 	req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS = '''' WHERE '||clwhere;
 	EXECUTE_IMMEDIATE_STRING( req,0);
 	
 -- Contrôle que le collaborateur est cohérent : date effet / paiezad. En Batch, on n'utilise pas IdentifiantCollab pour récupérer les informations
 -- du collaborateur, on prend juste ce qui est dans le fichier. On doit donc contrôler que le collab existe
  	req:= 'update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS, '''||replace(get_message_erreur('STD', 'STD00046', p_codlang),'''','''''')||''',EI.MATRICULE||''|''||EI.NUMPAC||''|''||EI.PACMAT||''|''||EI.PAIEZAD||''|''||EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere;
  	req:= req || ' and EI.NUMPAC is not null and EI.PAIEZAD is not null';
  	req:= req || ' and (not exists(SELECT 1 FROM DIC_ADM_CONTRAT_SITU DACS WHERE DACS.NUMPAC=EI.NUMPAC and DACS.PAIEZAD=EI.PAIEZAD';
  	req:= req || ' and TO_DATE(EI.DATE_EFFET, ''YYYYMMDD'') between DACS.DSDSC and DACS.DSFSC))';
  	EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Met une erreur sur les lignes en doublon dans le fichier d'import
 IF p_type_action = 'I' or p_type_action = 'VI' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00032',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' AND  P.LOGIN='''||p_login||''' ';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*'') )in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*'') from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- On conserve la ligne dont le numLigne est le max dans la liste des doublons (on enlève le message d'erreur)
 IF p_type_action = 'I' or p_type_action = 'VI' THEN
 req :='update TGE_IMPORT_ELEMENTS EI SET ERREURS=null WHERE  '||clwhere||' AND ';
 req := req ||' NUMLIGNE IN (select numligne from  tge_import_elements P where P.date_import ='''||P_DATE_IMPORT||''' AND  P.LOGIN='''||p_login||''' ';
 req := req ||' AND (NUMPAC,PAIEZAD,PERIODE,TYPE_TRAITEMENT,code_element,nvl(INDICATIF,''XyZ''),NVL(CODE_REMPLACEMENT,''*''),numligne) in ';
 req := req ||' (select t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,nvl(t.INDICATIF,''XyZ''),NVL(t.CODE_REMPLACEMENT,''*''),max(numligne) as numligne from tge_import_elements t';
 req := req ||' where t.login='''||p_login||''' and t.date_import='''||P_DATE_IMPORT||''' group by t.NUMPAC,t.PAIEZAD,t.PERIODE,t.TYPE_TRAITEMENT,t.CODE_ELEMENT,t.INDICATIF,t.CODE_REMPLACEMENT having count(*)>1) )' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 IF p_type_action = 'EC' or p_type_action = 'I' or p_type_action = 'VI' THEN
   -- Non existe EZ (seulement en création ou import. Les tests d'existence en modification sont exécutés en Java)
   -- Si l'élément existant a comme DERNIER_CODE_OPE = 'S', alors message ZEZ00040
   -- sinon ZEZ00030
   req :='merge into TGE_IMPORT_ELEMENTS EI using TGE_ELEMENTS_PAIE E on (';
   req := req || clwhereMerge;
   req := req ||' and E.NUMPAC = EI.NUMPAC and E.PAIEZAD = EI.PAIEZAD and E.PERIODE = EI.PERIODE';
   req := req ||' and E.TYPE_TRAITEMENT = EI.TYPE_TRAITEMENT and E.CODE_ELEMENT = EI.CODE_ELEMENT and E.INDICATIF = EI.INDICATIF AND E.CODE_REMPLACEMENT=NVL(EI.CODE_REMPLACEMENT,''*''))';
   req := req ||' when matched then update set ERREURS ='; 
   req := req ||' case';
   req := req ||' when E.DERNIER_CODE_OPE = ''S'' then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00040',p_codlang),'''','''''')||''',EI.CODE_ELEMENT||''|''||TGE_IMPORT_FORMATE_DATE(EI.PERIODE, EI.LOGIN, ''YYYYMM'', ''MM.YYYY'')||''|''||EI.INDICATIF,'''||p_codlang||''')';
   req := req ||' else TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00030',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF||''|''||TGE_IMPORT_FORMATE_DATE(PERIODE, LOGIN, ''YYYYMM'', ''MM.YYYY''),'''||p_codlang||''')';
   req := req ||' end';
   req:= req || clWhereMergeErreur;
   EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Numpac non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00077',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND NUMPAC is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- PaieZad non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00078',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PAIEZAD is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Periode non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND PERIODE is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Type Traitement non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00079',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND TYPE_TRAITEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Code_element non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00016',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND CODE_ELEMENT is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Date d'effet non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00314',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND DATE_EFFET is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Longueur Matricule
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00089',p_codlang),'''','''''')||''',MATRICULE,'''||p_codlang||''') where '||clwhere||' AND MATRICULE is NOT null AND LENGTH (MATRICULE)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Origine
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00100',p_codlang),'''','''''')||''',ORIGINE,'''||p_codlang||''') where '||clwhere||' AND ORIGINE is NOT null AND LENGTH (ORIGINE)>1 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 --
 -- Longueur LOGIN (sauf pour le Batch)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00107',p_codlang),'''','''''')||''',LOGIN,'''||p_codlang||''') where '||clwhere||' AND LOGIN!=''BATCH'' AND LENGTH (LOGIN)>32 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- date_effet/periode de paie TGE00310
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00310',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere;
 -- permet de gérer les cas où DATE_EFFET ou PERIODE ne sont pas des dates valides
 req:= req ||' and (select case when to_date(EI.DATE_EFFET,''YYYYMMDD'') > last_day(to_date(EI.PERIODE,''YYYYMM'')) then ''O'' else ''N'' end from dual where is_date(EI.DATE_EFFET, ''YYYYMMDD'')=1 and is_date(EI.PERIODE, ''YYYYMM'')=1 ) = ''O''';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- période de paie pour les EZ : TGE00311 / ZEZ00037 / TGE00336 / TGE00337
 req:='merge into TGE_IMPORT_ELEMENTS EI using';
 req:= req ||' (select P1.NUMPAC, P1.PERIODEENCOURS, P1.DEB_RETRO, P1.DEB_HISTO_RETRO, P1.NB_MOIS_RETRO, ';
 req:= req ||' NVL(D.CALCUL_RETRO,''0'') as CALCUL_RETRO, D.ELEMENT, add_months(to_date(P1.PERIODEENCOURS, ''YYYYMM''), -P1.NB_MOIS_RETRO) as LIMITE_RETRO from TGE_REF_PAC P1, TGE_REF_DICOZ D where P1.NUMPAC = D.NUMPAC) P';
 req:= req ||' on (';
 req:= req || clwhereMerge;
 req:= req ||' and EI.PERIODE < P.PERIODEENCOURS';
 req:= req ||' and ( P.DEB_RETRO IS NULL';
 IF not p_type_action = 'GAP' then
   -- Pour les éléments créés en sous-marin depuis la GAP, on ne teste pas le caractère CALCUL_RETRO de l'élément, ni la cohérence entre la période et la date d'effet
   req:= req ||' or P.CALCUL_RETRO = ''0'' or EI.PERIODE <> substr(EI.DATE_EFFET, 0, 6)';
 END IF;
 req:= req ||' or EI.PERIODE < P.DEB_HISTO_RETRO or EI.PERIODE < TO_CHAR(P.LIMITE_RETRO, ''YYYYMM''))';
 req:= req ||' and EI.CODE_ELEMENT = P.ELEMENT'; 
 req:= req ||' and (((select count(*) from TGE_REF_DICOZ D1 where D1.NUMPAC=EI.NUMPAC and D1.ELEMENT = EI.CODE_ELEMENT) > 0 and P.NUMPAC=EI.NUMPAC)';
 req:= req ||' OR ((select count(*) from TGE_REF_DICOZ D2 where D2.NUMPAC= EI.NUMPAC and D2.ELEMENT = EI.CODE_ELEMENT) = 0 and P.NUMPAC=''*'')))';
 req:= req ||' when matched then update set ERREURS = case';
 req:= req ||' when P.DEB_RETRO is null then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00311',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 IF not p_type_action = 'GAP' then
   req:= req ||' when P.CALCUL_RETRO = ''0'' then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00037',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
   req:= req ||' when EI.PERIODE <> substr(EI.DATE_EFFET, 0, 6) then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00041',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 END IF;
 req:= req ||' when EI.PERIODE < P.DEB_HISTO_RETRO then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00336',p_codlang),'''','''''')||''',to_char(to_date(P.DEB_HISTO_RETRO, ''YYYYMM''), ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' when EI.PERIODE < to_char(P.LIMITE_RETRO, ''YYYYMM'')';
 req:= req ||' then TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00337',p_codlang),'''','''''')||''',to_char(P.LIMITE_RETRO, ''MM.YYYY''),'''||p_codlang||''')';
 req:= req ||' end';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format date d'effet TGE00315
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00315',p_codlang),'''','''''')||''',EI.DATE_EFFET,'''||p_codlang||''') where '||clwhere||' AND EI.DATE_EFFET is not null and IS_DATE(EI.DATE_EFFET,''YYYYMMDD'')=0';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- IdPacMat non vide
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00102',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') where '||clwhere||' AND (RPAD(NUMPAC,6) || PACMAT) is null ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur NumPac
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00072',p_codlang),'''','''''')||''',numpac,'''||p_codlang||''') where '||clwhere||' AND NVL(LENGTH(NUMPAC),0)>6 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur PaieZad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00073',p_codlang),'''','''''')||''',NULL,PAIEZAD) where '||clwhere||' AND NVL(LENGTH(PAIEZAD),0)>8 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format Periode
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00328',p_codlang),'''','''''')||''',PERIODE,'''||p_codlang||''') WHERE '||clwhere||' AND PERIODE is NOT null AND IS_DATE(PERIODE,''YYYYMM'')=0 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur Cle_import
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00099',p_codlang),'''','''''')||''',LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE,'''||p_codlang||''') WHERE '||clwhere||' AND LOGIN IS NOT NULL AND DATE_IMPORT IS NOT NULL AND NUMLIGNE IS NOT NULL AND  LENGTH(LOGIN || ''#'' ||DATE_IMPORT || ''#'' ||NUMLIGNE) >70 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Longueur IdPacMat
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00103',p_codlang),'''','''''')||''',RPAD(NUMPAC,6) || PACMAT,'''||p_codlang||''') WHERE '||clwhere||' AND NUMPAC   IS NOT NULL AND PACMAT IS NOT NULL AND  LENGTH(RPAD(NUMPAC,6) || PACMAT) >14 ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF p_login = 'BATCH' THEN
 -- Autorisation paiezad
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('STD','STD00049',p_codlang),'''','''''')||''',paiezad,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.paiezad IS NOT NULL AND EI.numpac is not null AND NOT ';
 req:= req || '(';
 req:= req ||   ' ( exists (SELECT * from DIC_ADM_CONTRAT C WHERE C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and not nvl(mpe,''N'')=''N'')) )';
 req:= req || ' OR ';
 req:= req ||   '(exists (SELECT * from DIC_ADM_CONTRAT C ,SECUPACMAT S  WHERE C.NUMPAC = S.NUMPAC and C.PACMAT = S.PACMAT and C.NUMCNT = S.CURRENT_NUMCNT AND C.NUMPAC =EI.numpac and C.CURRENT_PAIEZAD =EI.paiezad and c.numpac in (select numpac from TGE_REF_PAC where numpac = c.numpac and nvl(mpe,''N'')=''N'')) )';
 req:= req || ') ' ;
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Chez les clients, ils n'ont pas de pac * dans TGE_DICOZ, par contre en recette interne ils n'ont que celui là (pac *). 
 -- Du coup on conserve la complexité de choisir les éléments du pac *, mais en gros, il n'y a pas de cohabitation entre les 2 gestions 
 -- (sauf en dev ce qui peut provoquer des incohérences sur les contrôles : 
 --  - Elément U101 existe sur le pac *, mais s'il y a d'autres éléments sur le pac TLSE01 mais pas U101
 --  - L'appel table va proposer U101 mais le contrôle ici va bloquer en disant que U101 n'existe pas
 
 -- Existe code_element
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00017',p_codlang),'''','''''')||''',code_element,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.code_element is not null  AND NOT ';
 req:= req || '(';
 req:= req ||   '( EI.code_element in (SELECT RD.element FROM TGE_REF_DICOZ RD WHERE rd.numpac = EI.numpac AND rd.element=EI.code_element))';
 req:= req || ' OR ';
 req:= req ||   '( EI.code_element in (SELECT RD.element FROM TGE_REF_DICOZ RD WHERE rd.numpac=''*'' AND rd.element=EI.code_element AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rd2 WHERE rd2.numpac=EI.numpac)))';
 req:= req || ')  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Existe type_traitement
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00101',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND  EI.type_traitement is not null AND NOT ';
 req:= req || '(';
 req:= req ||   '( EI.type_traitement in (SELECT RT.codetyptrt FROM tge_ref_typetrt RT WHERE rt.numpac=EI.numpac AND rt.codetyptrt=EI.type_traitement ))';
 req:= req || ' OR ';
 req:= req ||   '( EI.type_traitement in (SELECT RT.codetyptrt FROM tge_ref_typetrt RT WHERE rt.numpac=''*'' AND rt.codetyptrt=EI.type_traitement AND NOT EXISTS (SELECT 1 FROM tge_ref_typetrt rt2 WHERE rt2.numpac=EI.numpac)))';
 req:= req || ')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format sens
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00038',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') WHERE '||clwhere||' AND sens IS NOT NULL AND sens NOT IN (''+'',''-'') ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Autorisation sens (Valeur 'Aucun' attendue pour les TYPE = 'A')
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00015',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''') ';
 req:= req || ' WHERE '||clwhere||' AND EI.sens IS NOT NULL AND EI.sens IN (''+'',''-'') ';
 req:= req || 'AND EXISTS (';
 req:= req ||   ' (SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=EI.numpac AND rd.element= EI.code_element AND rd.type=''A'' )';
 req:= req || ' UNION ';
 req:= req ||   '(SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=''*'' AND rd.element=EI.code_element AND rd.type=''A'' AND NOT EXISTS (SELECT 1 FROM tge_ref_dicoz rd2 where rd2.numpac=EI.numpac ))';
 req:= req || ')  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 /** Début des tests sur l'INDICATIF */
 -- On fait les tests sur l'indicatif qu'en création ou import. En modification, l'indicatif ne change pas.
 IF p_type_action = 'EC' or p_type_action = 'I' or p_type_action = 'VI' THEN
 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null and ';
 req:= req || ' (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''COT'',''CZR'',''CTM'',''CRA'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE IN (''COT'',''CZR'',''CTM'',''CRA'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 req:= req || ' AND not';
 req:= req || ' (( exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=Ei.numpac AND ct.CODECAISSE=Ei.INDICATIF ))';
 req:= req || ' OR ';
 req:= req||'(exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE CT.NUMPAC=''*'' AND Ct.CODECAISSE=Ei.INDICATIF AND NOT EXISTS(SELECT 1 FROM TGE_REF_CAISSE ct2 WHERE ct2.numpac=Ei.numpac and Ct2.CODECAISSE=Ei.INDICATIF)))';
 req:= req || ' ) ';
 EXECUTE_IMMEDIATE_STRING( req,0);

  -- OCC1 > 0 et GROUPE = TXR : Existe code_rubrique
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00334',p_codlang),'''','''''')||''',Ei.INDICATIF,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null and ';
 req:= req || ' (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''TXR'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE IN (''TXR'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 req:= req || ' AND not';
 req:= req || ' (( exists (SELECT 1 FROM TGE_REF_RUBRIQUE CT WHERE ct.numpac=Ei.numpac AND ct.CODERUB=Ei.INDICATIF ))';
 req:= req || ' OR ';
 req:= req||'(exists (SELECT 1 FROM TGE_REF_RUBRIQUE CT WHERE CT.NUMPAC=''*'' AND Ct.CODERUB=Ei.INDICATIF AND NOT EXISTS(SELECT 1 FROM TGE_REF_RUBRIQUE ct2 WHERE ct2.numpac=Ei.numpac and Ct2.CODERUB=Ei.INDICATIF)))';
 req:= req || ' ) ';
 EXECUTE_IMMEDIATE_STRING( req,0);

 -- OCC1 > 0 et GROUPE = COT/CZR/CTM/CRA : Caisse référence interdite
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null AND ';
 req:= req || ' (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''COT'',''CZR'',''CTM'',''CRA'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE IN (''COT'',''CZR'',''CTM'',''CRA'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 req:= req || ' AND ';
 req:= req || ' (( exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=Ei.numpac AND CT.codeGroup =''R'' AND ct.CODECAISSE=Ei.INDICATIF ))';
 req:= req || ' OR ';
 req:= req||'(exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=''*'' AND CT.codeGroup =''R'' AND Ct.CODECAISSE=Ei.INDICATIF AND NOT EXISTS(SELECT 1 FROM TGE_REF_CAISSE ct2 WHERE ct2.numpac=Ei.numpac and Ct2.CODECAISSE=Ei.INDICATIF)))';
 req:= req || ' ) ';
 req:= req || ' AND nvl((SELECT OLDCOT FROM TGE_REF_PAC WHERE NUMPAC = Ei.numpac ), ''N'') != ''O''  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - longueur attendue 6
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''MM:CCC'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null  AND LENGTH(Ei.indicatif)!=6 AND  ';
 req:= req || ' (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE =''HCO''))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE =''HCO'' AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac)))';
 req:= req || '  )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - MM doit correspondre à un mois
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00011',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null AND LENGTH(Ei.indicatif)=6';
 req:= req || ' and (IS_NUMBER(substr(Ei.indicatif, 0, 2)) is null or IS_DATE(substr(Ei.indicatif,0, 2),''MM'') !=1)';
 req:= req || ' and (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''HCO'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE IN (''HCO'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Existe code_caisse
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00013',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null and length(Ei.INDICATIF) =6 ';
 req:= req || ' and (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''HCO'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND  RT.OCC1>0 AND RT.GROUPE IN (''HCO'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 req:= req || ' AND not';
 req:= req || ' (( exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=Ei.numpac AND ct.CODECAISSE=SUBSTR(Ei.INDICATIF, 4)))';
 req:= req || ' OR ';
 req:= req||'(exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE CT.NUMPAC=''*'' AND Ct.CODECAISSE=SUBSTR(Ei.INDICATIF, 4) AND NOT EXISTS(SELECT 1 FROM TGE_REF_CAISSE ct2 WHERE ct2.numpac=Ei.numpac and Ct2.CODECAISSE=SUBSTR(Ei.INDICATIF, 4))))';
 req:= req || ' ) ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCO : Format attendu MM:CCC - CCC Caisse référence interdite
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00010',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.INDICATIF is not null AND Ei.numpac is not null and length(Ei.INDICATIF) =6 ';
 req:= req || ' and (( Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=Ei.numpac AND rt.ELEMENT=Ei.CODE_ELEMENT AND  RT.OCC1>0 AND RT.GROUPE IN (''HCO'') ))';
 req:= req || ' OR  ';
 req:= req ||'(Ei.CODE_ELEMENT in (SELECT RT.ELEMENT FROM TGE_REF_DICOZ RT WHERE rt.numpac=''*'' AND RT.OCC1>0 AND RT.GROUPE IN (''HCO'') AND rt.ELEMENT=Ei.CODE_ELEMENT AND NOT EXISTS (SELECT 1 FROM TGE_REF_DICOZ rt2 WHERE rt2.numpac=Ei.numpac and rt2.ELEMENT=Ei.CODE_ELEMENT)))';
 req:= req || '  )';
 req:= req || ' AND ';
 req:= req || ' (( exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=Ei.numpac AND CT.codeGroup =''R'' AND ct.CODECAISSE=SUBSTR(Ei.INDICATIF, 4)))';
 req:= req || ' OR ';
 req:= req||'(exists (SELECT 1 FROM TGE_REF_CAISSE CT WHERE ct.numpac=''*'' AND CT.codeGroup =''R'' AND Ct.CODECAISSE=SUBSTR(Ei.INDICATIF, 4) AND NOT EXISTS(SELECT 1 FROM TGE_REF_CAISSE ct2 WHERE ct2.numpac=Ei.numpac and Ct2.CODECAISSE=SUBSTR(Ei.INDICATIF, 4))))';
 req:= req || ' ) ';
 req:= req || ' AND nvl((SELECT OLDCOT FROM TGE_REF_PAC WHERE NUMPAC = Ei.numpac ), ''N'') != ''O''  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (';
 req:= req || ' (SELECT * FROM   TGE_REF_DICOZ DZ WHERE  DZ.ELEMENT = EI.CODE_ELEMENT ';
 req:= req || '  AND EXISTS ((SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=EI.numpac AND rd.element= EI.code_element)UNION ';
 req:= req || ' (SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=''*'' AND rd.element=EI.code_element  AND NOT EXISTS (SELECT 1 FROM tge_ref_dicoz rd2 where rd2.numpac=EI.numpac ))) ';
 req:= req || ' AND DZ.OCC2 = 0 AND DZ.GROUPE = ''HIS'' ';
 req:= req || ' AND (LENGTH(EI.indicatif) != 7 OR IS_NUMBER(substr(EI.indicatif,7,1)) is null OR IS_DATE(substr(EI.indicatif,0,6),''YYYYMM'') !=1 ) ))  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 = 0 : Format attendu SSAAMMN - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC2 = 0 AND DZ.GROUPE = ''HIS'' ';
 req:= req || ' AND LENGTH(Ei.INDICATIF) = 7 and (IS_NUMBER(substr(Ei.indicatif,7,1)) IS NULL or substr(Ei.indicatif,7,1) < 1 OR substr(Ei.indicatif,7,1) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMMN:XX'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (';
 req:= req || ' (SELECT * FROM   TGE_REF_DICOZ DZ WHERE  DZ.ELEMENT = Ei.CODE_ELEMENT ';
 req:= req || '  AND EXISTS ((SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=Ei.numpac AND rd.element= Ei.code_element)UNION ';
 req:= req || ' (SELECT 1 FROM tge_ref_dicoz rd WHERE rd.numpac=''*'' AND rd.element=Ei.code_element  AND NOT EXISTS (SELECT 1 FROM tge_ref_dicoz rd2 where rd2.numpac=Ei.numpac ))) ';
 req:= req || ' AND DZ.OCC2 > 0 AND DZ.GROUPE = ''HIS'' ';
 req:= req || ' AND (LENGTH(Ei.indicatif) != 10 OR IS_NUMBER(substr(Ei.indicatif,7,1)) is null OR IS_DATE(substr(Ei.indicatif,0,6),''YYYYMM'') !=1 ';
 req:= req || ' or substr(Ei.indicatif,8,1) != '':'' or IS_NUMBER(substr(Ei.indicatif,9,2)) is null) ))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - N doit etre compris etre 1 et 9
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00012',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC2 > 0 AND DZ.GROUPE = ''HIS'' ';
 req:= req || ' AND LENGTH(Ei.INDICATIF) = 10 and (IS_NUMBER(substr(Ei.indicatif,7,1)) IS NULL or substr(Ei.indicatif,7,1) < 1 OR substr(Ei.indicatif,7,1) > 9))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HIS et OCC2 > 0 : Format attendu SSAAMMN:XX - XX doit être compris entre 01 et TGE_REF_DICOZ.OCC2
 -- Utilisation d'un  afin de pouvoir utiliser DZ.OCC2 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and (((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT  = DZ.ELEMENT) > 0 and DZ.NUMPAC = Ei.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT = DZ.ELEMENT) = 0 and DZ.NUMPAC =''*'')) ';
 req:= req || ' and DZ.OCC2 > 0 and DZ.GROUPE = ''HIS'' ';
 req:= req || ' and (length(Ei.INDICATIF)) = 10 and is_number(substr(Ei.INDICATIF,7,1)) is not null and is_date(substr(Ei.INDICATIF,0,6),''YYYYMM'') !=0 and is_number(substr(Ei.INDICATIF,9,2)) is not null ';
 req:= req || ' and (substr(Ei.INDICATIF,9,2)< 1 or substr(Ei.INDICATIF,9,2) > DZ.OCC2 )) ';
 req:= req || ' when matched then update set ERREURS = TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00013',p_codlang),'''','''''')||''',DZ.OCC2,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''AAMM+Code Chrono'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ  ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC1>0  AND DZ.GROUPE  IN (''HCP'',''HC2'')';
 req:= req || ' AND  LENGTH(Ei.indicatif) !=10 )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, partie AAMM non valide
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00035',p_codlang),'''','''''')||''',''AAMM+Code Chrono|AAMM'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ  ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC1>0  AND DZ.GROUPE  IN (''HCP'',''HC2'')';
 req:= req || ' AND  LENGTH(Ei.indicatif) =10  AND IS_DATE(substr(Ei.indicatif,0,4),''YYMM'') !=1)  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et GROUPE = HCP ou HC2 : Format indicatif attendu AAMM+Code Chrono, Code chrono n'existe pas pour le collaborateur
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00034',p_codlang),'''','''''')||''',substr(Ei.indicatif,5),'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ  ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC1>0  AND DZ.GROUPE  IN (''HCP'',''HC2'')';
 req:= req || ' AND  LENGTH(Ei.indicatif) =10  AND IS_DATE(substr(Ei.indicatif,0,4),''YYMM'')=1  ) ';
 req:= req || ' and not exists (select 1 from dic_adm_contrat_situ where numpac=Ei.NUMPAC and pacmat =Ei.pacmat and code_chrono=substr(Ei.indicatif,5))';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu SSAAMM
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00036',p_codlang),'''','''''')||''',''SSAAMM '','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ  ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC2=0 AND DZ.OCC1=13 AND DZ.GROUPE NOT IN (''HIS'',''HCO'',''COT'',''CZR'',''CTM'',''CRA'',''DFR'', ''HCP'', ''HC2'', ''TXR'',''CRF'',''CAA'',''CPP'')';
 req:= req || ' AND  IS_DATE(Ei.indicatif,''YYYYMM'') !=1 )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- CODE_ELEMENT commence par 'R' et OCC2 = 0 et OCC1 = 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR /CRF / CAA / CPP: Format indicatif attendu compris entre (PERIODE -12 mois) et (PERIODE - 1 mois)
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00035',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists  (SELECT * FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.OCC2=0 AND DZ.OCC1=13 AND DZ.GROUPE NOT IN (''HIS'',''HCO'',''COT'',''CZR'',''CTM'',''CRA'',''DFR'', ''HCP'', ''HC2'', ''TXR'',''CRF'',''CAA'',''CPP'')';
 req:= req || ' AND  IS_DATE(Ei.indicatif,''YYYYMM'') =1 AND Ei.CODE_ELEMENT IS NOT NULL AND LENGTH(Ei.CODE_ELEMENT)=4 AND Ei.CODE_ELEMENT like ''R%'' AND (TO_DATE(Ei.indicatif,''YYYYMM'')>ADD_MONTHS( TO_DATE(Ei.PERIODE,''YYYYMM''),-1) OR TO_DATE(Ei.indicatif,''YYYYMM'')<ADD_MONTHS( TO_DATE(Ei.PERIODE,''YYYYMM''),-12) ))   ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- OCC1 > 0 et OCC1 <> 13 et GROUPE not in COT / CZR / CTM / CRA / HCO / HIS / HCP / HC2 / TXR / CRF / CAA / CPP: Format indicatif attendu entre 1 et OCC1 
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.OCC1 dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and (((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT  = DZ.ELEMENT) > 0 and DZ.NUMPAC = Ei.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT = DZ.ELEMENT) = 0 and DZ.NUMPAC =''*'')) ';
 req:= req || ' and DZ.OCC1 > 0 and DZ.OCC1 <> 13 AND DZ.GROUPE NOT IN (''HIS'',''HCO'',''COT'',''CZR'',''CTM'',''CRA'',''DFR'', ''HCP'', ''HC2'', ''TXR'',''CRF'',''CAA'',''CPP'')';
 req:= req || ' and (is_number(Ei.INDICATIF) is null or Ei.INDICATIF < 1 or Ei.INDICATIF > DZ.OCC1))';
 req:= req || ' when matched then update set ERREURS = TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00014',p_codlang),'''','''''')||''',DZ.OCC1,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- GROUPE in CRF / CAA / CPP : Format indicatif attendu alphanumerique <= 2 Caractères
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00343',p_codlang),'''','''''')||''',''XX=alphanumérique'','''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND exists (SELECT *  FROM      TGE_REF_DICOZ DZ  ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = Ei.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = Ei.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) ';
 req:= req || ' AND DZ.GROUPE  IN (''CRF'',''CAA'',''CPP'')';
 req:= req || ' AND  (LENGTH(Ei.indicatif) > 2 OR NOT REGEXP_LIKE (Ei.indicatif, ''^[a-zA-Z0-9]+$''))) ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 -- Fin tests sur l'indicatif
 
  -- Format valeur : longueur valide (TYPE = A ou N ou B)
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00006',p_codlang),'''','''''')||''',(select distinct(oz.longueur) from tge_ref_dicoz oz where oz.element = ei.code_element and ei.numpac =oz.numpac and oz.type in (''A'',''N'',''B'')),'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.VALEUR IS NOT NULL AND exists( ';
 req:= req || ' SELECT *  FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = Ei.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = EI.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*''))AND IS_NUMBER(EI.VALEUR) is not null  AND ((DZ.TYPE =''A'' ';
 req:= req || '  AND length(to_number(EI.VALEUR)) > DZ.LONGUEUR) OR (DZ.TYPE = ''N'' AND length(to_number(EI.VALEUR)) > DZ.LONGUEUR AND (DZ.MASQUE<1 OR DZ.MASQUE>16))OR (DZ.TYPE =''B'' AND length(to_number(EI.VALEUR)) > DZ.LONGUEUR ))';
 req:= req || ' )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format valeur : nombre non décimal (TYPE = N ou B)
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00007',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.VALEUR IS NOT NULL AND exists ( ';
 req:= req || ' SELECT *  FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = EI.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = EI.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) AND ((DZ.TYPE = ''N'' AND IS_NUMBER(EI.VALEUR) is null  AND (DZ.MASQUE<1 OR DZ.MASQUE>16)) OR ((DZ.TYPE = ''B'' AND IS_NUMBER(EI.VALEUR) is null))';
 req:= req || ' ))  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 -- Format valeur : date ne respectant pas la longueur (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.LONGUEUR dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and (((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT  = DZ.ELEMENT) > 0 and DZ.NUMPAC = Ei.NUMPAC)';
 req:= req || ' or ((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT = DZ.ELEMENT) = 0 and DZ.NUMPAC =''*''))';
 req:= req || ' AND Ei.VALEUR IS NOT NULL AND DZ.TYPE = ''N'' AND DZ.MASQUE>=1 AND DZ.MASQUE<=16';
 req:= req || ' AND LENGTH(EI.VALEUR) != DZ.LONGUEUR';
 req:= req || ' )';
 req:= req || ' when matched then update set ERREURS = TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00008',p_codlang),'''','''''')||''',DZ.LONGUEUR,'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : date pas dans bon format (TYPE = N)
 -- Utilisation d'un MERGE afin de pouvoir utiliser DZ.MASQUE dans le message d'erreurs
 req:='merge into TGE_IMPORT_ELEMENTS Ei using TGE_REF_DICOZ DZ on (';
 req:= req || clwhereMerge;
 req:= req || ' and DZ.ELEMENT = Ei.CODE_ELEMENT and (((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT  = DZ.ELEMENT) > 0 and DZ.NUMPAC = Ei.NUMPAC)';
 req:= req || ' or ((select count(*) from TGE_REF_DICOZ where NUMPAC = Ei.NUMPAC and ELEMENT = DZ.ELEMENT) = 0 and DZ.NUMPAC =''*''))'; 
 req:= req || ' AND DZ.TYPE = ''N'' AND DZ.MASQUE>=1 AND DZ.MASQUE<=16';
 req:= req || ' AND LENGTH(EI.VALEUR) = DZ.LONGUEUR AND (';
 req:= req || ' (DZ.MASQUE =1 AND IS_DATE(EI.VALEUR,''DDMMYYYY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =2 AND IS_DATE(EI.VALEUR,''MMYYYY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =3 AND IS_DATE(EI.VALEUR,''YYYYMM'')!=1) OR'; 
 req:= req || ' (DZ.MASQUE =4 AND IS_DATE(EI.VALEUR,''DD'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =5 AND IS_DATE(EI.VALEUR,''MM'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =6 AND IS_DATE(EI.VALEUR,''YYYY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =7 AND IS_DATE(EI.VALEUR,''YYYYMMDD'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =8 AND IS_DATE(EI.VALEUR,''DDMMYY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =9 AND IS_DATE(EI.VALEUR,''MMYY'')!=1) OR'; 
 req:= req || ' (DZ.MASQUE =10 AND IS_DATE(EI.VALEUR,''YYMM'')!=1) OR';
 req:= req || ' (DZ.MASQUE =11 AND IS_DATE(EI.VALEUR,''YY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =12 AND IS_DATE(EI.VALEUR,''YYMMDD'')!=1) OR';
 req:= req || ' (DZ.MASQUE =13 AND IS_DATE(EI.VALEUR,''DDYY'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =14 AND IS_DATE(EI.VALEUR,''DDMM'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =15 AND IS_DATE(EI.VALEUR,''MMDD'')!=1) OR';  
 req:= req || ' (DZ.MASQUE =16 AND IS_DATE(EI.VALEUR,''MMDDYYYY'')!=1)';
 req:= req || '))';
 req:= req || ' when matched then update set ERREURS = TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00024',p_codlang),'''','''''')||''',TGE_VALEUR_FORMAT_DATE(DZ.MASQUE),'''||p_codlang||''')';
 req:= req || clWhereMergeErreur;
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Format valeur : nombre attendu (TYPE = P)
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00009',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND Ei.VALEUR IS NOT NULL AND exists ( ';
 req:= req || ' SELECT *  FROM      TGE_REF_DICOZ DZ ';
 req:= req || ' WHERE   DZ.ELEMENT = EI.CODE_ELEMENT AND (((SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND ELEMENT  = DZ.ELEMENT) > 0 AND DZ.NUMPAC  = EI.NUMPAC) ';
 req:= req || ' OR ((SELECT COUNT(*) FROM  TGE_REF_DICOZ WHERE NUMPAC = EI.NUMPAC AND   ELEMENT  = DZ.ELEMENT) = 0 AND DZ.NUMPAC=''*'')) AND DZ.TYPE = ''P'' and is_number(Ei.VALEUR) is  null ';
 req:= req || ' )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Controle Origine et mode_3060 : TGE00317
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00317',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and EI.CODE_REMPLACEMENT = ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''R'' and G.MODE_3060 <> ''F'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 IF P_TYPE_ACTION = 'EM' THEN
 -- Ce test n'est à faire qu'en modification (EM), mais pas à la création (EC ou I)
 -- Controle Origine et mode_3060 : TGE00318
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00318',p_codlang),'''','''''')||''',EI.ORIGINE ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null and nvl(EI.CODE_REMPLACEMENT, ''*'') <> ''R''';
 req:= req || ' and exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC and G.MODE_3060 <> ''W'')';
 EXECUTE_IMMEDIATE_STRING( req,0);
 END IF;
 
 -- Mise à jour de l'élément autorisée ZEZ00005
 req:='update TGE_IMPORT_ELEMENTS EI set ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','ZEZ00005',p_codlang),'''','''''')||''',EI.CODE_ELEMENT ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.CODE_ELEMENT is not null and (EI.ORIGINE is null or EI.ORIGINE <> ''&'') and not exists (select 1 from TGE_REF_DICOZ DZ where DZ.ELEMENT = EI.CODE_ELEMENT and DZ.CODEMODIF =''2'' ';
 req:= req || ' and (((select count(*) from TGE_REF_DICOZ where NUMPAC= EI.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DZ.NUMPAC = EI.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_DICOZ where NUMPAC = EI.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DZ.NUMPAC = ''*'')) ';
 -- L'élément n'est pas présent dans MAPDO (pour le numpac ou le pac *)
 req:= req || ' and (DZ.ELEMENT not in (select ELEMENT from TGE_REF_MAPDO DO2 where (((select count(*) from TGE_REF_MAPDO where NUMPAC = EI.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO2.NUMPAC = EI.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = EI.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO2.NUMPAC = ''*''))) ';
 -- Si l'élément est présent dans MAPDO alors TGE_REF_MAPDO.OCCURENCE doit contenir '!'
 -- ou TGE_REF_MAPTA.ALLERRETOUR = 'R' pour être modifiable
 req:= req || ' or ((select count(*) from TGE_REF_MAPDO DO left outer join TGE_REF_MAPTA TA on DO.TABLEGXP = TA.TABLEPARAM where DO.ELEMENT = DZ.ELEMENT ';
 req:= req || ' and (((select count(*) from TGE_REF_MAPDO where NUMPAC = EI.NUMPAC and ELEMENT = DZ.ELEMENT ) > 0 and DO.NUMPAC = EI.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_MAPDO where NUMPAC = EI.NUMPAC and ELEMENT = DZ.ELEMENT ) = 0 and DO.NUMPAC = ''*'')) ';
 req:= req || ' and (((select count(*) from TGE_REF_MAPTA where NUMPAC = EI.NUMPAC and TABLEPARAM = DO.TABLEGXP ) > 0 and TA.NUMPAC = EI.NUMPAC) ';
 req:= req || ' or ((select count(*) from TGE_REF_MAPTA where NUMPAC = EI.NUMPAC and TABLEPARAM = DO.TABLEGXP ) = 0 and TA.NUMPAC = ''*'')) ';
 req:= req || ' and (DO.OCCURENCE like ''%!%'' or TA.ALLERRETOUR = ''R'')) > 0 )) ';
 req:= req || ' )';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Contrôle Origine existe pour le numPac TGE00331
 -- Ce test devra être supprimé lorsque celui associé au message TGE00321(origine est cohérente avec la GTA du collaborateur)
 -- sera intégré au contrôle PL/SQL (pour le moment fait en Java pour les saisies écrans et imports Web)
 req:='update TGE_IMPORT_ELEMENTS EI SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00331',p_codlang),'''','''''')||''',EI.ORIGINE||''|''||EI.NUMPAC ,'''||p_codlang||''') where '||clwhere;
 req:= req || ' and EI.ORIGINE is not null';
 req:= req || ' and not exists (select 1 from TGE_REF_ORIGINE_GTA G where G.CODE_ORIGINE = EI.ORIGINE and G.NUMPAC = EI.NUMPAC)';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 -- Ecrasement de la clause Where
 clwhere:='EI.login='''||p_login||''' and EI.date_import='''||P_DATE_IMPORT||'''';
 -- Controles pour les éléments B691 et B690
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00195',p_codlang),'''','''''')||''',ei.valeur,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND code_element=''B690'' and not exists(select * from   TGE_REF_IMPUTATION
 Ei2 where ei2.numpac in (Ei.numpac,''*'') and ei2.codeimp=ei.valeur )  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00193',p_codlang),'''','''''')||''',NULL,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND code_element=''B691'' and exists(select * from
 (select date_import,login,numpac,paiezad, code_element, sum(to_number(replace(valeur,''.'','',''))) as somme from TGE_IMPORT_ELEMENTS Ei2 where code_element=''B691'' AND IS_NUMBER(VALEUR) is not null  group by  date_import,login,numpac,paiezad, code_element) tmp where   ei.date_import  =tmp.date_import  AND ei.login =tmp.login and somme<>100 and ei.numpac =tmp.numpac
 AND ei.paiezad  =tmp.paiezad)  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 --
 req:='update TGE_IMPORT_ELEMENTS Ei SET ERREURS=TGE_GET_MESSAGE_ERREUR(ERREURS,'''||replace(get_message_erreur('TGE','TGE00194',p_codlang),'''','''''')||''',CODE_ELEMENT||''|''||INDICATIF,'''||p_codlang||''')';
 req:= req || ' WHERE '||clwhere||' AND code_element in (''B90'',''B691'') and not exists(select * from TGE_REF_MAPDO d where code_element=ELEMENT and indicatif=occurence and (d.numpac=Ei.numpac or d.numpac=''*''))  ';
 EXECUTE_IMMEDIATE_STRING( req,0);
 
 EXCEPTION
 WHEN OTHERS THEN
 	IF (P_LOGIN != 'BATCH') THEN
    	-- On remonte l'erreur à l'application	
 		raise;
	END IF;
 END TGE_CONTROLE_30;
##
TGE_CREATE_TRIGGER
=SQL=
create or replace PROCEDURE TGE_CREATE_TRIGGER(
    NOM_TABLE IN VARCHAR2)
AS
  PROC CLOB;
  condition CLOB;
  v_typeTable VARCHAR(1);
  CURSOR cur_mapdo
  IS
    SELECT numpac,
      donneegxp
    FROM tge_ref_mapdo
    WHERE TABLEGXP IN
      (SELECT tableparam
      FROM tge_ref_mapta
      WHERE tablephy = nom_table
        --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
        --Ajout du type 'I'
      AND allerretour IN ('A','2','I')
      )
  AND (donneegxp, tablegxp) IN
    (SELECT column_name, table_name FROM user_tab_cols
    )
  UNION
    (SELECT numpac,donneegxp FROM TABLE(GET_GXP_TRT_PARTICULIER_DATAS(nom_table))
    )
  ORDER BY donneegxp,
    numpac;
  lig_mapdo cur_mapdo%rowtype;
  is_aller_ou_allerretour_mapta NUMBER;
  table_exist                   NUMBER;
  type_writer_exists            NUMBER;
  date_eff_exists               NUMBER;
  nom_col_date_test_recycl      VARCHAR2(30);
  CURSOR cur_numpac
  IS
    SELECT DISTINCT numpac
    FROM tge_ref_mapdo
    WHERE TABLEGXP IN
      (SELECT tableparam
      FROM tge_ref_mapta
      WHERE tablephy = nom_table
        --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
        --Ajout du type 'I'
      AND allerretour IN ('A', '2','I')
      )
  AND (donneegxp, tablegxp) IN
    (SELECT column_name, table_name FROM user_tab_cols
    )
  ORDER BY numpac;
  lig_numpac cur_numpac%rowtype;
  sscondition CLOB;
  existeMappingEtoile NUMBER;
  donneeprec          VARCHAR(100);
  -- variables retro  ---
  -----------------------
  champDateEffetRetro VARCHAR2(50);
  conditionRetro CLOB;
  conditionRetroDateSpecif CLOB;
  ssconditionRetro CLOB;
  ssconditionRetroDateSpecif CLOB;
  donneeprecRetro VARCHAR(100);
  donneeprecRetroDateSpecif VARCHAR(100);
  procRetroPaiezadCodeChrono VARCHAR(4000);
  CURSOR cur_mapdoRetro
  IS
    SELECT DISTINCT dz.numpac,
      md.donneegxp
    FROM tge_ref_dicoz dz,
      tge_ref_mapdo md
    WHERE dz.calcul_retro = '1'
    AND md.element not in ('A302','A309')
    AND md.element        = dz.element
    AND (md.numpac        = dz.numpac
    OR (md.numpac         = '*'
    AND NOT EXISTS
      (SELECT 1
      FROM tge_ref_mapdo z
      WHERE z.numpac= dz.numpac
      AND z.element = dz.element
      )) )
    AND TABLEGXP IN
      (SELECT tableparam FROM tge_ref_mapta WHERE tablephy = NOM_TABLE
      )
    ORDER BY donneegxp,
      numpac;
    lig_mapdoRetro cur_mapdoRetro%rowtype;
  CURSOR cur_mapdoRetroDateSpecif
  IS
    SELECT DISTINCT dz.numpac,
      md.donneegxp
    FROM tge_ref_dicoz dz,
      tge_ref_mapdo md
    WHERE dz.calcul_retro = '1'
    AND md.element in ('A302','A309')
    AND md.element        = dz.element
    AND (md.numpac        = dz.numpac
    OR (md.numpac         = '*'
    AND NOT EXISTS
      (SELECT 1
      FROM tge_ref_mapdo z
      WHERE z.numpac= dz.numpac
      AND z.element = dz.element
      )) )
    AND TABLEGXP IN
      (SELECT tableparam FROM tge_ref_mapta WHERE tablephy = NOM_TABLE
      )
    ORDER BY donneegxp,
      numpac;
    lig_mapdoRetroDateSpecif cur_mapdoRetroDateSpecif%rowtype;
    CURSOR cur_numpacRetro
    IS
      SELECT DISTINCT dz.numpac
      FROM tge_ref_dicoz dz,
        tge_ref_mapdo md
      WHERE dz.calcul_retro = '1'
      AND md.element        = dz.element
      AND (md.numpac        = dz.numpac
      OR (md.numpac         = '*'
      AND NOT EXISTS
        (SELECT 1
        FROM tge_ref_mapdo z
        WHERE z.numpac= dz.numpac
        AND z.element = dz.element
        )) )
      AND TABLEGXP IN
        (SELECT tableparam FROM tge_ref_mapta WHERE tablephy = NOM_TABLE
        )
      ORDER BY numpac;
      lig_numpacRetro cur_numpacRetro%rowtype;
  -- variables dex  ---
  -----------------------
      CURSOR cur_donneesDex
      IS
        SELECT DISTINCT DMED.EVENT,
          RDMU.NOM_DONNEE,
          RDMU.CONDITION
        FROM DEX_MAPPING_EVENT_DATA DMED,
          REF_DONNEE_MAPPING_UX RDMU,
          REF_DONNEE_GEN_MODEL RDGM
        WHERE DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX
        AND RDMU.NOM_DONNEE               =RDGM.NOM_DONNEE
        AND DMED.UTILISE_TRIGGER          ='O'
        AND DMED.TYPE                     ='D'
        AND NVL(RDMU.IS_DEX,'N')          ='O'
        AND RDGM.NOM_DICTIONNAIRE         =NOM_TABLE
        ORDER BY DMED.EVENT,
          RDMU.NOM_DONNEE;
      lig_donneeDex cur_donneesDex%rowtype;
      v_existeDonneeDex BOOLEAN;
      v_eventDexPrec    VARCHAR(100);
      CURSOR cur_eventsDex
      IS
        SELECT DISTINCT DMED.EVENT,
          RDMU.CONDITION
        FROM DEX_MAPPING_EVENT_DATA DMED,
          REF_DONNEE_MAPPING_UX RDMU,
          REF_DONNEE_GEN_MODEL RDGM
        WHERE DMED.NOM_DONNEE_DEX_OU_EVENT=RDMU.NOM_DONNEE_UX
        AND RDMU.NOM_DONNEE               =RDGM.NOM_DONNEE
        AND DMED.UTILISE_TRIGGER          ='O'
        AND DMED.TYPE                     ='D'
        AND NVL(RDMU.IS_DEX,'N')          ='O'
        AND RDGM.NOM_DICTIONNAIRE         =NOM_TABLE;
      lig_eventDex cur_eventsDex%rowtype;
    BEGIN
      -- On teste si la table existe bien
      SELECT COUNT(*)
      INTO table_exist
      FROM user_tables
      WHERE table_name = nom_table;
      IF table_exist   > 0 THEN
        SELECT COUNT(*)
        INTO is_aller_ou_allerretour_mapta
        FROM tge_ref_mapta
        WHERE tablephy = nom_table
          --RSI DIT 39298 MPE : Fonction d'envoi inconditionnel pour la table TGE_OPTION_REPORT
          --Ajout du type 'I'
        AND allerretour                                   IN ('A', '2','I');
        IF is_aller_ou_allerretour_mapta > 0 OR nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
          -- Si la colonne TYPE_WRITER n'existe pas, on la crée
          SELECT COUNT(*)
          INTO type_writer_exists
          FROM user_tab_cols
          WHERE column_name     = 'TYPE_WRITER'
          AND table_name        = NOM_TABLE;
          IF type_writer_exists = 0 THEN
            EXECUTE_IMMEDIATE_STRING( 'ALTER TABLE ' || NOM_TABLE || ' ADD (TYPE_WRITER VARCHAR2(1 BYTE))',0);
          END IF;
          v_typeTable := fsed.getTypeTable(NOM_TABLE);
          PROC        := 'create or replace 
TRIGGER TRG_' || NOM_TABLE || ' FOR INSERT or UPDATE or delete  ON '||NOM_TABLE||
          ' COMPOUND TRIGGER 
type pacmats 
IS 
record 
( 
R_numpac VARCHAR2(6), 
R_pacmat VARCHAR2(8), 
R_periode_recycl VARCHAR2(1) 
); 
TYPE TAB_pacmats 
IS 
TABLE OF pacmats INDEX BY binary_integer; 
tab TAB_pacmats; 
v_recycl varchar2(1); 
v_periode_recycl varchar2(1); 
v_error_periode_recycl_3 number; 
v_numpac varchar2(6); 
v_pacmat varchar2(8); 
v_periode varchar2(6); 

existNumpacPaizad NUMBER; 
v_type_writer varchar2(1); 
v_bypass_trigger number; 
v_bypass_DACH number; 
v_date_debut_periode_paie DATE :=NULL;  

V_DE_SSAAMM               VARCHAR2(6); 
V_DATE_LIMITE_RETRO       VARCHAR2(6); 
V_DEB_RETRO               VARCHAR2(6); 
V_DEB_HISTO_RETRO         VARCHAR2(6); 
V_PERIODEENCOURS          VARCHAR2(6); 
V_CODE_CHRONO             VARCHAR2(6); 
V_PAIEZAD                 VARCHAR2(8); 
V_MATRIC                  VARCHAR2(32); 
v_nb_mois_retro           NUMBER; 
v_retro                   VARCHAR2(1); 
V_DATE_EFF                VARCHAR2(6); 
'
          ;
          -- On vérifie si la table va générer des évènements pour DEX (au moins une donnée mappée, ou dictionnaire DIC_ADM_CONTRAT qui gère l'embauche et le départ)
          v_existeDonneeDex := (nom_table='DIC_ADM_CONTRAT');
          IF NOT v_existeDonneeDex THEN
            OPEN cur_donneesDex;
            LOOP
              FETCH cur_donneesDex INTO lig_donneeDex ;
              EXIT
            WHEN cur_donneesDex%NOTFOUND OR v_existeDonneeDex;
              v_existeDonneeDex := true;
            END LOOP;
            CLOSE cur_donneesDex;
          END IF;
          OPEN cur_numpac;
          LOOP
            FETCH cur_numpac INTO lig_numpac ;
            EXIT
          WHEN cur_numpac%NOTFOUND ;
            IF lig_numpac.numpac<>'*' THEN
              PROC              :=PROC||' b'||lig_numpac.numpac||' boolean ;';
            END IF;
          END LOOP;
          CLOSE cur_numpac;
          OPEN cur_numpacRetro;
          LOOP
            FETCH cur_numpacRetro INTO lig_numpacRetro ;
            EXIT
          WHEN cur_numpacRetro%NOTFOUND ;
            IF lig_numpacRetro.numpac<>'*' THEN
              PROC                   :=PROC||' bRet'||lig_numpacRetro.numpac||' boolean ;';
            END IF;
          END LOOP;
          CLOSE cur_numpacRetro;
          IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
            PROC           :=PROC||' v_listMatricToUpdate CLOB := NULL; 
v_nbMatricToUpdate NUMBER := 0; 
v_countSecNav NUMBER := -1;';
            IF nom_table    ='DIC_ADM_PERSO' THEN
              PROC         :=PROC||'v_listMatricToDelete CLOB := NULL; 
v_nbMatricToDelete NUMBER := 0;';
            ELSIF nom_table ='DIC_ADM_CONTRAT' THEN
              PROC         :=PROC||'v_nbLig NUMBER; 
v_doMajPerso NUMBER := 0; 
TYPE NUMPAC_PACMAT_TO_DELETE IS RECORD (MATRIC DIC_ADM_CONTRAT.MATRIC%TYPE, NUMPAC DIC_ADM_CONTRAT.NUMPAC%TYPE, PACMAT DIC_ADM_CONTRAT.PACMAT%TYPE); 
TYPE TAB_NUMPAC_PACMAT_TO_DELETE IS TABLE OF NUMPAC_PACMAT_TO_DELETE; 
v_NUMPAC_PACMAT NUMPAC_PACMAT_TO_DELETE; 
v_TAB_NUMPAC_PACMAT TAB_NUMPAC_PACMAT_TO_DELETE; 
v_listNumpacPacmatToDelete CLOB := '','';';
            ELSIF nom_table = 'DIC_ADM_CONTRAT_HISTO' THEN
              PROC         :=PROC||
              ' v_nbOccForCnt number; 
v_dsdcn DIC_ADM_CONTRAT.DSDCN%TYPE; 
v_natcol DIC_ADM_CONTRAT.NATCOL%TYPE;  

TYPE paiezadTabType is table of DIC_ADM_CONTRAT_HISTO.PAIEZAD%TYPE ; 
TYPE numpacTabType is  table of DIC_ADM_CONTRAT_HISTO.NUMPAC%TYPE ; 
TYPE periodeTabType is  table of TGE_REF_PAC.PERIODEENCOURS%TYPE ; 
paiezadTab paiezadTabType := paiezadTabType(); 
numpacTab numpacTabType := numpacTabType(); 
periodeTab periodeTabType := periodeTabType();  

TYPE T_TRAITEMENT_PERIODES_INDIV IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(100); 
-- Ce tableau indexé contient plusieurs chose : 
-- + Une entrée avec un code PAC + un PAIEZAD --> Un flag permettant de savoir si le couple NUMPAC/PAIEZAD a déjà été traité 
-- + Une entrée avec un code PAC --> La période en cours du PAC 
tabTrtPeriodesIndividuelles T_TRAITEMENT_PERIODES_INDIV;  

TYPE T_COMPARAISON_VAL_OLD_NEW IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(20); 
tabValToCompare T_COMPARAISON_VAL_OLD_NEW;  

alimPeriodesIndiv boolean;  

'
              ;
            END IF;
            IF nom_table='DIC_ADM_CONTRAT' OR nom_table='DIC_ADM_CONTRAT_HISTO' THEN
              PROC     :=PROC||' v_cle_idx_contrat T_CLE_IDX_CONTRAT_HISTO; 
v_cles_idx_contrat T_CLES_IDX_CONTRAT_HISTO := T_CLES_IDX_CONTRAT_HISTO();';
            END IF;
            IF nom_table='DIC_ADM_PERSO' OR nom_table='DIC_ADM_CONTRAT' THEN
              PROC     :=PROC||' 
v_matricForPacmat VARCHAR2(32); 
v_matricForLock VARCHAR2(32); 
TYPE T_LOCKED_MATRIC IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(32); 
tabLockedMatric T_LOCKED_MATRIC; 
';
            END IF;
          END IF;
          date_eff_exists          := 0;
          nom_col_date_test_recycl := NULL;
          IF nom_table              ='DIC_ADM_CONTRAT' THEN
            -- Pour DIC_ADM_CONTRAT c'est DSDCN qui fera office de DATE_EFF pour tester s'il faut mettre en recyclage
            nom_col_date_test_recycl := 'DSDCN';
          ELSE
            SELECT COUNT(*)
            INTO date_eff_exists
            FROM user_tab_cols
            WHERE column_name           = 'DATE_EFF'
            AND table_name              = NOM_TABLE;
            IF date_eff_exists          >0 THEN
              nom_col_date_test_recycl := 'DATE_EFF';
            END IF;
          END IF;
          IF nom_col_date_test_recycl IS NOT NULL THEN
            PROC                      :=PROC||'TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE; 
tabPeriodeByNumpac T_PERIODE_BY_NUMPAC; 
date_test_recycl DATE;';
          END IF;
          IF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
		  
			PROC     :=PROC||'TYPE paiezadPacPeriodModifedType IS  TABLE OF TGE_PAC_PAIEZAD_PERIOD_RETRO  INDEX BY VARCHAR2(15);  ';
  
			PROC     :=PROC||'paiezadPacPeriodModifed paiezadPacPeriodModifedType ;';
           
            PROC     :=PROC||' idx  VARCHAR2(15);';
		ELSE 
			PROC     :=PROC||'idx NUMBER; ';
          END IF;
          IF v_existeDonneeDex THEN
            PROC := PROC||'v_dexaction varchar2(1); 
TYPE eventsTabType is  table of DEX_MAPPING_EVENT_DATA.EVENT%TYPE ; 
eventsTab eventsTabType := eventsTabType(); 
v_processEventDex boolean; 
';
          END IF;
          IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
            PROC      :=PROC||' 
BEFORE STATEMENT IS BEGIN  ';
            PROC      := PROC || 'select count(*) into v_bypass_DACH from bypass_trg_DACH_on_session; 
END BEFORE STATEMENT; ';
          END IF;
          PROC        := PROC || '  

BEFORE EACH ROW IS BEGIN ' ;
          IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
            PROC      := PROC || ' IF (v_bypass_DACH > 0) THEN null; else ';
          END IF;
          PROC := PROC || ' 
if (v_bypass_trigger > 0)  then 
v_type_writer := ''N''; 
else 
IF DELETING THEN 
v_type_writer :=NVL(:old.type_writer,''O''); 
ELSE 
v_type_writer :=NVL(:NEW.type_writer,''O''); 
-- On remet TYPE_WRITER à NULL pour qu''il ne soit pas considéré comme ''N'' lors des futurs update n''incluant pas cette colonne 
:NEW.type_writer := NULL; 
END IF; 
end if; 
';
          IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO') THEN
            PROC := PROC || ' 
IF v_type_writer<>''N'' AND v_countSecNav=-1 THEN 
SELECT COUNT(*) INTO v_countSecNav FROM SECUPACMAT_TMP WHERE MATRIC=''SECNAV''; 
IF v_countSecNav>0 THEN 
RAISE_APPLICATION_ERROR(-20000,''CODERR=GENREC03''); 
END IF; 
END IF; 
';
          END IF;
          IF nom_table ='DIC_ADM_PERSO' OR nom_table ='DIC_ADM_CONTRAT' THEN
            -- On récupère le MATRIC et on teste si on l'a déjà traité
            PROC := PROC || ' 
v_matricForLock := NVL(:NEW.MATRIC,:OLD.MATRIC); 
IF v_type_writer<>''N'' AND NOT tabLockedMatric.exists(v_matricForLock) THEN';
            -- En cas de modification de DAP, on lock les tables qui la mette à jour par trigger (DAPH, DAC, DACS et DACH)
            -- En cas de modification de DAC, on lock les tables qui la mette à jour par trigger (DACS et DACH)
            IF nom_table ='DIC_ADM_PERSO' THEN
              -- DAPH et DAC uniquement pour DAP
              PROC := PROC || ' 
BEGIN 
UPDATE DIC_ADM_PERSO_HISTO SET MATRIC=MATRIC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matricForLock; 
EXCEPTION WHEN OTHERS THEN NULL; END; 
BEGIN 
UPDATE DIC_ADM_CONTRAT SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matricForLock; 
EXCEPTION WHEN OTHERS THEN NULL; END;';
            END IF;
            -- DACs et DACH uniquement pour les 2 (DAP et DAC)
            PROC := PROC || ' 
BEGIN 
UPDATE DIC_ADM_CONTRAT_SITU SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd'') WHERE MATRIC=v_matricForLock; 
EXCEPTION WHEN OTHERS THEN NULL; END; 
BEGIN 
UPDATE DIC_ADM_CONTRAT_HISTO SET NUMPAC=NUMPAC, DATE_DERNIERE_MODIF=TO_DATE(''19010101'',''yyyymmdd''), TYPE_WRITER=''N'' WHERE MATRIC=v_matricForLock; 
EXCEPTION WHEN OTHERS THEN NULL; END;';
            -- On stocke le MATRIC pour indiquer qu'on l'a déjà traité
            PROC := PROC || ' 
tabLockedMatric(v_matricForLock) := ''O''; 
END IF;';
          END IF;
          IF nom_table   ='DIC_ADM_PERSO' THEN
            PROC        :=PROC||TRG_PERSO_BEFORE_ROW();
          ELSIF nom_table='DIC_ADM_PERSO_HISTO' THEN
            PROC        :=PROC||TRG_PERSO_HISTO_BEFORE_ROW();
          ELSIF nom_table='DIC_ADM_CONTRAT' THEN
            PROC        :=PROC||TRG_CONTRAT_BEFORE_ROW();
          ELSIF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
            PROC        :=PROC||TRG_CONTRAT_HISTO_BEFORE_ROW();
          END IF;
          IF is_aller_ou_allerretour_mapta > 0 THEN
              PROC                        :=PROC||' 
v_matric:=nvl(:NEW.matric,:OLD.matric); ';
            IF v_typeTable                 ='z' THEN
              PROC                        :=PROC||' 
v_numpac:=nvl(:NEW.numpac,:OLD.numpac); 
v_paiezad:=nvl(:NEW.paiezad,:OLD.paiezad); ';
            elsif v_typeTable              ='p' THEN
              PROC                        :=PROC||' 
v_numpac:=nvl(:NEW.numpac,:OLD.numpac); 
v_pacmat:=nvl(:NEW.pacmat,:OLD.pacmat); ';
            END IF;
            PROC :=PROC||'  if v_type_writer<>''N'' THEN ';
            -- Récupération du numpac si besoin
            IF v_typeTable   ='z' THEN
              PROC          :=PROC||' 
SELECT DISTINCT D.numpac as R_numpac, 
D.pacmat as R_pacmat, 
T.PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM DIC_ADM_CONTRAT_SITU D ,SECUPACMAT T 
WHERE D.NUMPAC=v_numpac AND D.PAIEZAD=v_paiezad AND D.NUMPAC=T.NUMPAC AND D.PACMAT=T.PACMAT;';
            elsif v_typeTable='m' THEN
              PROC          :=PROC||' 
SELECT numpac as R_numpac, 
pacmat as R_pacmat , 
PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM SECUPACMAT 
WHERE matric=v_matric;';
            elsif v_typeTable='p' THEN
              PROC          :=PROC||' 
SELECT numpac as R_numpac, 
pacmat as R_pacmat , 
PERIODE_RECYCLAGE as R_periode_recycl bulk collect 
INTO tab 
FROM SECUPACMAT 
WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat;';
            END IF;
            PROC            :=PROC||' v_retro := ''N'';';
            PROC            :=PROC||' if tab.exists(1) then';
            PROC            :=PROC||'  FOR i IN 1..tab.last  LOOP';
            PROC            :=PROC||'   v_numpac:=tab(i).r_numpac;';
            PROC            :=PROC||'   IF NOT v_numpac = ''TMPPAC'' THEN';
            PROC            :=PROC||'   v_pacmat:=tab(i).r_pacmat;';
            PROC            :=PROC||'   v_periode_recycl:=nvl(tab(i).R_periode_recycl,''1'');';
            IF NOT nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
              -- une valeur '3' dans PERIODE_RECYCLAGE retourne une erreur
              -- sauf en cas de réembauche (insertion dans DIC_ADM_CONTRAT et DIC_ADM_CONTRAT_HISTO)
              PROC        :=PROC||'    IF v_periode_recycl = ''3'' THEN';
              IF nom_table ='DIC_ADM_CONTRAT' THEN
                PROC      :=PROC||'     IF UPDATING OR DELETING THEN';
              END IF;
              PROC        :=PROC||'     RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC02'');';
              IF nom_table ='DIC_ADM_CONTRAT' THEN
                PROC      :=PROC||'     END IF;';
              END IF;
              PROC:=PROC||'    END IF;';
            ELSE
              -- on positionne PERIODE_RECYCLAGE à '1' en cas de réembauche d'un salarié ayant une valeur '0' ou '3' dans PERIODE_RECYCLAGE et répondant aux critères suivants :
              -- - DRPAI2 est non-vide et différent de 'B'
              -- - NATCOL vaut 'SAL' ou 'STA'
              -- - DSDCN est antérieure ou égale à la période en cours
              PROC:=PROC||'    IF v_periode_recycl IN (''0'',''3'') THEN';
              PROC:=PROC||'     IF v_periode_recycl = ''3'' THEN';
              -- si PERIODE_RECYCLAGE vaut '3', on prévoit qu'il va falloir retourner une erreur (modification d'un contrat existant)
              PROC:=PROC||'      v_error_periode_recycl_3 := 1;';
              PROC:=PROC||'     ELSE';
              PROC:=PROC||'      v_error_periode_recycl_3 := 0;';
              PROC:=PROC||'     END IF;';
              PROC:=PROC||'     IF INSERTING THEN';
              -- insertion d'un historique de contrat : on vérifie s'il s'agit de la première occurrence du contrat (réembauche)
              PROC:=PROC||'      v_nbOccForCnt := GET_NB_LIGNES(''DIC_ADM_CONTRAT_HISTO'', ''NUMPAC=''''''||:NEW.NUMPAC||'''''' AND PACMAT=''''''||:NEW.PACMAT||'''''' AND NUMCNT=''||:NEW.NUMCNT);';
              PROC:=PROC||'      IF v_nbOccForCnt = 0 THEN';
              -- première occurrence du contrat (réembauche) : on ne retourne pas d'erreur, et, si PERIODE_RECYCLAGE = '3', on va réactiver le dossier
              PROC:=PROC||'       IF v_periode_recycl = ''3'' THEN';
              PROC:=PROC||'        v_error_periode_recycl_3 := 0;';
              PROC:=PROC||'        :NEW.ZREACT := TO_DATE(TO_CHAR(:NEW.DATE_EFF,''yyyy'')||''0101'',''yyyymmdd'');';
              PROC:=PROC||'       END IF;';
              -- vérification des critères pour positionner PERIODE_RECYCLAGE à '1'
              PROC:=PROC||'       IF CHECK_FORCAGE_RECYCLAGE(:NEW.NUMPAC, :NEW.PACMAT, :NEW.NUMCNT, :NEW.DRPAI2, NULL) = 1 THEN';
              -- OK pour PERIODE_RECYCLAGE = '1'
              PROC:=PROC||'        v_periode_recycl := ''1'';';
              PROC:=PROC||'       END IF;';--fin CHECK_FORCAGE_RECYCLAGE
              PROC:=PROC||'      END IF;'; --fin v_nbOccForCnt = 0
              PROC:=PROC||'     ELSIF UPDATING THEN';
              -- un update : on va vérifier si on doit réactiver le dossier
              PROC:=PROC||'      IF UPDATING(''DRPAI2'') AND ((NVL(:OLD.DRPAI2, ''B'') = ''B'' AND NVL(:NEW.DRPAI2, ''B'') <> ''B'') OR(NVL(:OLD.DRPAI2, ''B'')<> ''B'' AND NVL(:NEW.DRPAI2, ''B'') = ''B'')) THEN';
              -- update de DRPAI2 pour déblocage paie : on ne retourne pas d'erreur, et on va réactiver le dossier
              PROC:=PROC||'       v_error_periode_recycl_3 := 0;';
              PROC:=PROC||'       IF CHECK_FORCAGE_RECYCLAGE(:NEW.NUMPAC, :NEW.PACMAT, :NEW.NUMCNT, :NEW.DRPAI2, NULL) = 1 THEN';
              -- OK pour PERIODE_RECYCLAGE = '1'
              PROC:=PROC||'        v_periode_recycl := ''1'';';
              PROC:=PROC||'       END IF;';--fin CHECK_FORCAGE_RECYCLAGE
              PROC:=PROC||'      ELSIF UPDATING(''ZREACT'') AND :OLD.ZREACT IS NULL AND :NEW.ZREACT IS NOT NULL THEN';
              -- update de ZREACT pour réactivation : si l'année de ZREACT est inférieure ou égale à l'année de la période en cours, on ne retourne pas d'erreur
              PROC:=PROC||'       BEGIN';
              PROC:=PROC||'        IF NOT tabPeriodeByNumpac.exists(:NEW.NUMPAC) THEN';
              PROC:=PROC||'         select periodeencours into tabPeriodeByNumpac(:NEW.NUMPAC) from tge_ref_pac where numpac = :NEW.NUMPAC;';
              PROC:=PROC||'        END IF;';
              PROC:=PROC||'        IF TO_CHAR(:NEW.ZREACT,''yyyy'') <= SUBSTR(tabPeriodeByNumpac(:NEW.NUMPAC),1,4) THEN';
              PROC:=PROC||'         v_error_periode_recycl_3 := 0;';
              PROC:=PROC||'         IF CHECK_FORCAGE_RECYCLAGE(:NEW.NUMPAC, :NEW.PACMAT, :NEW.NUMCNT, :NEW.DRPAI2, tabPeriodeByNumpac(:NEW.NUMPAC)) = 1 THEN';
              -- OK pour PERIODE_RECYCLAGE = '1'
              PROC:=PROC||'          v_periode_recycl := ''1'';';
              PROC:=PROC||'         END IF;';--fin CHECK_FORCAGE_RECYCLAGE
              PROC:=PROC||'        END IF;'; --fin ZREACT <= PERIODEENCOURS
              PROC:=PROC||'       EXCEPTION WHEN OTHERS THEN NULL; END;';
              PROC:=PROC||'      END IF;';--fin UPDATING DRPAI2 ou ZREACT
              PROC:=PROC||'     END IF;'; --fin INSERTING/UPDATING
              PROC:=PROC||'     IF v_error_periode_recycl_3 = 1 THEN';
              PROC:=PROC||'      RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC02'');';
              PROC:=PROC||'     END IF;';
              PROC:=PROC||'    END IF;';--fin v_periode_recycl = 0 ou 3
            END IF;
            PROC:=PROC||'    IF v_periode_recycl = ''2'' THEN';
            PROC:=PROC||'     RAISE_APPLICATION_ERROR(-20001,''CODERR=GENREC01'');';
            PROC:=PROC||'    ELSIF v_periode_recycl = ''1'' THEN';
            OPEN cur_numpac;
            LOOP
              FETCH cur_numpac INTO lig_numpac ;
              EXIT
            WHEN cur_numpac%NOTFOUND ;
              IF lig_numpac.numpac<>'*' THEN
                PROC              :=PROC||' b'||lig_numpac.numpac||':=(v_numpac='''||lig_numpac.numpac||''') ;';
              END IF;
            END LOOP;
            CLOSE cur_numpac;
            -- on vérifie si des colonnes paies ont été modifié
            PROC                        :=PROC||'     v_recycl:=''N'';';
            IF nom_col_date_test_recycl IS NOT NULL THEN
              PROC                      :=PROC||'     IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN';
              PROC                      :=PROC||'      select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;';
              PROC                      :=PROC||'     END IF;';
              PROC                      :=PROC||'     IF DELETING THEN';
              PROC                      :=PROC||'      date_test_recycl := :old.'||nom_col_date_test_recycl||';';
              PROC                      :=PROC||'     ELSE';
              PROC                      :=PROC||'      date_test_recycl := :new.'||nom_col_date_test_recycl||';';
              PROC                      :=PROC||'     END IF;';
              PROC                      :=PROC||'     IF (NVL(TO_CHAR(date_test_recycl,''yyyymm''),''000000'') <= tabPeriodeByNumpac(v_numpac)) THEN';
            END IF;
            PROC     :=PROC||'     IF INSERTING OR DELETING THEN ';
            PROC     :=PROC||'      v_recycl:=''O''; ';
            PROC     :=PROC||'     ELSIF UPDATING THEN ';
            condition:=NULL;
            OPEN cur_mapdo;
            LOOP
              FETCH cur_mapdo INTO lig_mapdo ;
              IF donneeprec    IS NOT NULL AND (cur_mapdo%NOTFOUND OR lig_mapdo.donneegxp<>donneeprec ) THEN
                IF sscondition IS NOT NULL THEN
                  sscondition  :='('||sscondition||') and ';
                END IF;
                IF condition IS NULL AND NOM_TABLE ='DIC_ADM_CONTRAT_HISTO' THEN
                  condition  := ' IF NVL(:OLD.DRPAI2, ''B'') <> NVL(:NEW.DRPAI2, ''B'') AND (NVL(:OLD.DRPAI2, ''B'') =''B'' OR NVL(:NEW.DRPAI2, ''B'')=''B'') THEN v_recycl:=''O'';';
                END IF;
                IF condition IS NULL THEN
                  condition  :=' if ';
                ELSE
                  condition:=condition||' elsif ';
                END IF;
                condition:=condition||sscondition||' (:NEW.'||donneeprec||'<>:OLD.'||donneeprec||' OR  (:NEW.'||donneeprec||' IS NOT NULL AND :OLD.'||donneeprec||' IS NULL) OR  (:NEW.'||donneeprec||' IS NULL AND :OLD.'||donneeprec||' IS NOT NULL)) THEN ';
                condition:=condition||' v_recycl:=''O''; ';
              END IF;
              EXIT
            WHEN cur_mapdo%NOTFOUND;
              IF lig_mapdo.donneegxp IS NOT NULL THEN
                IF donneeprec        IS NULL OR lig_mapdo.donneegxp<>donneeprec THEN
                  sscondition        :='';
                  existeMappingEtoile:=0;
                END IF;
                IF lig_mapdo.numpac      ='*' THEN
                  sscondition           :='';
                  existeMappingEtoile   :=1;
                ELSIF existeMappingEtoile=0 THEN
                  IF sscondition        IS NOT NULL THEN
                    sscondition         :=sscondition||' or ';
                  END IF;
                  sscondition :=sscondition||' b'||lig_mapdo.numpac||'  ';
                END IF;
                donneeprec:=lig_mapdo.donneegxp;
              END IF;
            END LOOP;
            CLOSE cur_mapdo;
            IF condition IS NOT NULL THEN
              condition  :=condition||' end if;';
            END IF;
            IF condition IS NULL THEN
              PROC       :=PROC||' NULL; ';
            ELSE
              PROC:=PROC||condition;
            END IF;
            -- traitement du matricule pour recyclage
            PROC                        :=PROC||'    END IF; ';--fin updating
            PROC                        :=PROC||' 
IF v_recycl=''O'' THEN 
merge INTO GAP_RECYCL_MATRIC a USING 
(SELECT v_numpac AS numpac,v_pacmat AS pacmat FROM dual 
) b ON (a.pacmat=b.pacmat AND a.numpac=b.numpac) 
WHEN NOT MATCHED THEN 
INSERT 
(a.numpac,a.pacmat 
) VALUES 
(b.numpac,b.pacmat 
);  

merge INTO TGE_MODIF_PACMAT_TORESEND a USING 
(SELECT v_numpac AS numpac,v_pacmat AS pacmat, '''||NOM_TABLE||''' as TABLE_TO_SEND FROM dual 
) b ON (a.pacmat=b.pacmat AND a.numpac=b.numpac and a.TABLE_TO_SEND=b.TABLE_TO_SEND) 
WHEN MATCHED THEN 
update set a.DATE_MAJ=sysdate 
WHEN NOT MATCHED THEN 
INSERT 
(a.numpac,a.pacmat,a.TABLE_TO_SEND,a.DATE_MAJ 
) VALUES 
(b.numpac,b.pacmat,b.TABLE_TO_SEND, sysdate 
);   ';
            PROC                        :=PROC||' END IF; ';--fin v_recycl
            IF nom_col_date_test_recycl IS NOT NULL THEN
              PROC                      :=PROC||' END IF; ';--fin test date recycl
            END IF;
            PROC :=PROC||' END IF; ';--fin v_periode_recycl
            -- AJOUT CODE RETRO
            -- Recupération du champs DATE de la table
            IF NOM_TABLE           = 'DIC_ADM_CONTRAT' THEN
              champDateEffetRetro := 'DSDCN' ;
            ELSE
              BEGIN
                SELECT a.column_name
                INTO champDateEffetRetro
                FROM SYS.USER_CONS_COLUMNS a,
                  USER_TAB_COLUMNS b
                WHERE a.table_name   = NOM_TABLE
                AND a.table_name     =b.table_name
                AND a.column_name    =b.column_name
                AND b.data_type      = 'DATE'
                AND constraint_name IN
                  (SELECT c.constraint_name
                  FROM user_constraints c
                  WHERE c.table_name =a.table_name
                  AND CONSTRAINT_TYPE='P'
                  );
              EXCEPTION
              WHEN OTHERS THEN
                champDateEffetRetro := NULL;
              END;
            END IF;
            IF champDateEffetRetro IS NOT NULL THEN
              
                procRetroPaiezadCodeChrono := NULL;
                IF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
                  -- Traitement spécifique pour DIC_ADM_CONTRAT_HISTO : dans un trigger, il n'est pas possible de lire la table en cours de modification
                  -- De toute façon il n'y a pas besoin : on a le paiezad dans le :NEW/:OLD, il faut juste lire DIC_ADM_CONTRAT_SITU pour récupérer le CODE_CHRONO
                  procRetroPaiezadCodeChrono := ' 
BEGIN 
V_PAIEZAD := NVL(:NEW.PAIEZAD,:OLD.PAIEZAD); 
SELECT dacs.code_chrono 
INTO V_CODE_CHRONO 
FROM dic_adm_contrat_situ dacs 
WHERE dacs.numpac = V_NUMPAC AND dacs.pacmat = V_PACMAT AND dacs.numcnt = NVL(:NEW.NUMCNT,:OLD.NUMCNT) AND dacs.paiezad = V_PAIEZAD; 
EXCEPTION 
WHEN OTHERS THEN v_retro := ''N''; 
END; ';
                ELSE
                  procRetroPaiezadCodeChrono := ' 
BEGIN 
SELECT dacs.code_chrono, dach.paiezad, TO_CHAR(dach.DATE_EFF, ''YYYYMM'') 
INTO V_CODE_CHRONO, V_PAIEZAD, V_DATE_EFF 
FROM dic_adm_contrat_histo dach , dic_adm_contrat_situ dacs 
WHERE dach.numpac = V_NUMPAC AND dach.pacmat = V_PACMAT AND dach.matric = v_matric AND 
dacs.numpac = dach.numpac AND dacs.pacmat = dach.pacmat AND dacs.numcnt = dach.numcnt AND dacs.paiezad = dach.paiezad AND 
dach.date_eff = (select min(z.date_eff) 
from dic_adm_contrat_histo z 
where z.matric = dach.matric AND z.date_sortie_sit_bo >= NVL(:NEW.' || champDateEffetRetro ||',:OLD.' || champDateEffetRetro || ') );  

-- La période rétro doit être >= à la 1ère date d''effet du salarié
IF (V_DE_SSAAMM < V_DATE_EFF) THEN
V_DE_SSAAMM := V_DATE_EFF; 
END IF;
EXCEPTION 
WHEN OTHERS THEN v_retro := ''N''; 
END; ';
                END IF;

              conditionRetro  :=NULL;
              OPEN cur_mapdoRetro;
              LOOP
                FETCH cur_mapdoRetro INTO lig_mapdoRetro ;
                IF donneeprecRetro    IS NOT NULL AND (cur_mapdoRetro%NOTFOUND OR lig_mapdoRetro.donneegxp<>donneeprecRetro ) THEN
                  IF ssconditionRetro IS NOT NULL THEN
                    ssconditionRetro  :='('||ssconditionRetro||') and ';
                  END IF;
                  IF conditionRetro IS NULL THEN
                    conditionRetro  :=' if ';
                  ELSE
                    conditionRetro:=conditionRetro||' elsif ';
                  END IF;
                  conditionRetro  :=conditionRetro||ssconditionRetro||' (:NEW.'||donneeprecRetro||'<>:OLD.'||donneeprecRetro ||' OR  (:NEW.'||donneeprecRetro||' IS NOT NULL AND :OLD.'||donneeprecRetro||' IS NULL) OR  (:NEW.'||donneeprecRetro||' IS NULL AND :OLD.'||donneeprecRetro||' IS NOT NULL)) THEN ';
                  conditionRetro  :=conditionRetro||' v_retro :=''O''; ';
                END IF;
                EXIT
              WHEN cur_mapdoRetro%NOTFOUND;
                IF lig_mapdoRetro.donneegxp IS NOT NULL THEN
                  IF donneeprecRetro        IS NULL OR lig_mapdoRetro.donneegxp<>donneeprecRetro THEN
                    ssconditionRetro        :='';
                    existeMappingEtoile     :=0;
                  END IF;
                  IF lig_mapdoRetro.numpac ='*' THEN
                    ssconditionRetro      :='';
                    existeMappingEtoile   :=1;
                  ELSIF existeMappingEtoile=0 THEN
                    IF ssconditionRetro   IS NOT NULL THEN
                      ssconditionRetro    :=ssconditionRetro||' or ';
                    END IF;
                    ssconditionRetro :=ssconditionRetro||' bRet'||lig_mapdoRetro.numpac||'  ';
                  END IF;
                  donneeprecRetro:=lig_mapdoRetro.donneegxp;
                END IF;
              END LOOP;
              CLOSE cur_mapdoRetro;
              
              conditionRetroDateSpecif  :=NULL;
              OPEN cur_mapdoRetroDateSpecif;
              LOOP
                FETCH cur_mapdoRetroDateSpecif INTO lig_mapdoRetroDateSpecif ;
                IF donneeprecRetroDateSpecif    IS NOT NULL AND (cur_mapdoRetroDateSpecif%NOTFOUND OR lig_mapdoRetroDateSpecif.donneegxp<>donneeprecRetroDateSpecif ) THEN
                  IF ssconditionRetroDateSpecif IS NOT NULL THEN
                    ssconditionRetroDateSpecif  :='('||ssconditionRetroDateSpecif||') and ';
                  END IF;
                  conditionRetroDateSpecif :=conditionRetroDateSpecif||'
IF UPDATING AND '||ssconditionRetroDateSpecif||' :NEW.'||donneeprecRetroDateSpecif||' IS NOT NULL AND (:NEW.'||donneeprecRetroDateSpecif||'<>:OLD.'||donneeprecRetroDateSpecif||' OR :OLD.'||donneeprecRetroDateSpecif||' IS NULL) THEN
  -- La période rétro doit être >= à : 
  -- - La date de début des histos de rétro 
  -- - La période en cours - le nombre de mois de rétro 
  -- On prend donc la plus grande de ces 2 dates + la date sur laquelle on travaille
  V_DE_SSAAMM := GREATEST(TO_CHAR(:NEW.'||donneeprecRetroDateSpecif||' ,''YYYYMM''),V_DEB_HISTO_RETRO,TO_CHAR(ADD_MONTHS(to_date(V_PERIODEENCOURS,''YYYYMM''),-V_NB_MOIS_RETRO),''YYYYMM''));
  IF(V_DE_SSAAMM < V_PERIODEENCOURS) THEN
    v_retro := ''O'';
    IF V_CODE_CHRONO IS NULL THEN
      -- Le paiezad et le code chrono n''ont pas été récupéré : on le fait maintenant
';
                  conditionRetroDateSpecif :=conditionRetroDateSpecif||procRetroPaiezadCodeChrono;
                  conditionRetroDateSpecif :=conditionRetroDateSpecif||'
    END IF;
    IF (v_retro = ''O'') THEN
      v_retro := ''Z'';
      TGE_RETRO_INSCRIPTION(V_NUMPAC,
        V_PACMAT,
        V_DE_SSAAMM,
        V_CODE_CHRONO,
        V_PAIEZAD,
        ''' || NOM_TABLE ||''');
    END IF; 
  END IF;
END IF;';
                END IF;
                EXIT
              WHEN cur_mapdoRetroDateSpecif%NOTFOUND;
                IF lig_mapdoRetroDateSpecif.donneegxp IS NOT NULL THEN
                  IF donneeprecRetroDateSpecif        IS NULL OR lig_mapdoRetroDateSpecif.donneegxp<>donneeprecRetroDateSpecif THEN
                    ssconditionRetroDateSpecif        :='';
                    existeMappingEtoile     :=0;
                  END IF;
                  IF lig_mapdoRetroDateSpecif.numpac ='*' THEN
                    ssconditionRetroDateSpecif      :='';
                    existeMappingEtoile   :=1;
                  ELSIF existeMappingEtoile=0 THEN
                    IF ssconditionRetroDateSpecif   IS NOT NULL THEN
                      ssconditionRetroDateSpecif    :=ssconditionRetroDateSpecif||' or ';
                    END IF;
                    ssconditionRetroDateSpecif :=ssconditionRetroDateSpecif||' bRet'||lig_mapdoRetroDateSpecif.numpac||'  ';
                  END IF;
                  donneeprecRetroDateSpecif:=lig_mapdoRetroDateSpecif.donneegxp;
                END IF;
              END LOOP;
              CLOSE cur_mapdoRetroDateSpecif;
              
              IF conditionRetro IS NOT NULL OR conditionRetroDateSpecif IS NOT NULL THEN
                PROC            := PROC||' 
-- traitement de la retro 
IF NVL(v_retro,''N'') = ''Z'' THEN 
V_DEB_RETRO := NULL; 
ELSE 
SELECT PERIODEENCOURS, 
DEB_RETRO, 
DEB_HISTO_RETRO, 
NVL(NB_MOIS_RETRO, 0) 
INTO V_PERIODEENCOURS, 
V_DEB_RETRO, 
V_DEB_HISTO_RETRO, 
V_NB_MOIS_RETRO 
FROM TGE_REF_PAC 
WHERE NUMPAC = V_NUMPAC; 
END IF;  

IF(V_PERIODEENCOURS >= V_DEB_RETRO AND V_DEB_RETRO IS NOT NULL) THEN 
';
                OPEN cur_numpacRetro;
                LOOP
                  FETCH cur_numpacRetro INTO lig_numpacRetro ;
                  EXIT
                WHEN cur_numpacRetro%NOTFOUND ;
                  IF lig_numpacRetro.numpac<>'*' THEN
                    PROC              :=PROC||' bRet'||lig_numpacRetro.numpac||':=(v_numpac='''||lig_numpacRetro.numpac||''') ;';
                  END IF;
                END LOOP;
                CLOSE cur_numpacRetro;
              END IF;
              IF conditionRetro IS NOT NULL THEN
                PROC              := PROC || '
-- La période rétro doit être >= à : 
-- - La date de début des histos de rétro 
-- - La période en cours - le nombre de mois de rétro 
-- On prend donc la plus grande de ces 2 dates + la date d''effet
V_DE_SSAAMM       := GREATEST(TO_CHAR(NVL(:NEW.'||champDateEffetRetro||',:OLD.'||champDateEffetRetro||') ,''YYYYMM''),V_DEB_HISTO_RETRO,TO_CHAR(ADD_MONTHS(to_date(V_PERIODEENCOURS,''YYYYMM''),-V_NB_MOIS_RETRO),''YYYYMM''));
IF(V_DE_SSAAMM < V_PERIODEENCOURS) THEN 
v_retro :=''N''; 
IF INSERTING OR DELETING THEN 
v_retro:=''O''; 
ELSIF UPDATING THEN 
';
                conditionRetro  :=conditionRetro||' end if;';
                PROC:=PROC||conditionRetro;
                -- traitement du matricule pour recyclage
                PROC       :=PROC||'    END IF; ';--fin updating
                PROC       :=PROC||' 
IF (v_retro = ''O'') THEN ';
                PROC :=PROC||procRetroPaiezadCodeChrono;
                PROC :=PROC||'  

IF(V_DE_SSAAMM < V_PERIODEENCOURS AND v_retro = ''O'') THEN 
-- On positionne une valeur reconnaissable pour savoir qu''on a déjà trouvé notre bonheur 
-- Pas la peine de refaire tous les select pour les autres couples NUMPAC/PACMAT 
v_retro := ''Z''; 
TGE_RETRO_INSCRIPTION(V_NUMPAC,
  V_PACMAT,
  V_DE_SSAAMM,
  V_CODE_CHRONO,
  V_PAIEZAD,
  ''' || NOM_TABLE ||'''); 
END IF; -- Fin V_DE_SSAAMM < V_PERIODEENCOURS AND v_retro = ''O'' 
END IF; -- Fin v_retro = ''O'' 
END IF; -- Fin V_DE_SSAAMM < V_PERIODEENCOURS 
';
              END IF;
              IF conditionRetroDateSpecif IS NOT NULL THEN
                PROC :=PROC||conditionRetroDateSpecif;
              END IF;
              IF conditionRetro IS NOT NULL OR conditionRetroDateSpecif IS NOT NULL THEN
                PROC :=PROC||'
END IF; -- Fin V_PERIODEENCOURS >= V_DEB_RETRO 
';
              END IF;
            END IF;                  -- end if traitementRetro
            PROC :=PROC||' END IF; ';--fin v_numpac<>'TMPPAC'
            PROC :=PROC||' END LOOP;  ';
            PROC :=PROC||' END IF; ';--fin table exist
            PROC :=PROC||' END IF;'; --fin type_writer
          END IF;
          IF nom_table ='DIC_ADM_CONTRAT_HISTO' THEN
            PROC      := PROC || ' END IF ; ';
          END IF;
          -- DEBUT TRAITEMENT DEX
          IF v_existeDonneeDex THEN
            -- Au moins une donnée DEX = on va vérifier si le traitement pour DEX doit être effectué
            IF date_eff_exists>0 THEN
              -- Date d'effet = traitement DEX seulement si modification à date du jour (à revoir pour DACH ?)
              PROC :=PROC||' 
IF SYSDATE BETWEEN nvl(:NEW.DATE_EFF,:OLD.DATE_EFF) AND nvl(:NEW.DATE_FIN,:OLD.DATE_FIN) THEN ';
            END IF;
            -- Si traitement DEX sur une table de type PAIEZAD ou PACMAT, on récupère le MATRIC
            IF v_typeTable    ='z' THEN
              PROC           :=PROC||' 
SELECT MAX(MATRIC) INTO v_matric FROM DIC_ADM_CONTRAT_SITU WHERE NUMPAC=v_numpac AND PAIEZAD=v_paiezad; 
IF v_matric IS NULL THEN v_matric:=NVL(:NEW.MATRIC,:OLD.MATRIC); END IF; ';
            ELSIF v_typeTable ='p' THEN
              PROC           :=PROC||' 
SELECT MATRIC INTO v_matric FROM SECUPACMAT WHERE NUMPAC=v_numpac AND PACMAT=v_pacmat; ';
            END IF;
            -- Le traitement en lui-même
            IF nom_table ='DIC_ADM_PERSO' THEN
              -- Pour DIC_ADM_PERSO, on ne gère que la modification
              PROC         :=PROC||' 
IF UPDATING THEN ';
            ELSIF nom_table ='DIC_ADM_CONTRAT' THEN
              -- Pour DIC_ADM_CONTRAT, on gère en spécifique
              -- - La création --> Evènement worker.hire
              -- - La suppression --> Evènement worker.terminate ???
              -- - La mise à jour de DSFCN --> Evènement worker.terminate (ou autre pour la modification ou l'annulation de départ ???)
              PROC :=PROC||
              ' 
IF INSERTING THEN 
MERGE INTO DEX_EVENTS DE USING (SELECT v_matric AS MATRIC,''worker.hire'' AS EVENT FROM DUAL) Z ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT) 
WHEN MATCHED THEN UPDATE SET ACTION=''C'',DATE_MODIF=CURRENT_TIMESTAMP,DATE_ENVOI_MIN=:NEW.DSDCN 
WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,ACTION,DATE_MODIF,DATE_ENVOI_MIN) VALUES (v_matric,''worker.hire'',''Z'',CURRENT_TIMESTAMP,:NEW.DSDCN); 
ELSIF DELETING THEN 
MERGE INTO DEX_EVENTS DE USING (SELECT v_matric AS MATRIC,''worker.terminate'' AS EVENT FROM DUAL) Z ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT) 
WHEN MATCHED THEN UPDATE SET ACTION=''S'',DATE_MODIF=CURRENT_TIMESTAMP,DATE_ENVOI_MIN=:OLD.DSDCN 
WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,ACTION,DATE_MODIF,DATE_ENVOI_MIN) VALUES (v_matric,''worker.terminate'',''S'',CURRENT_TIMESTAMP,:OLD.DSDCN); 
ELSIF :NEW.DSFCN<>:OLD.DSFCN OR (:NEW.DSFCN IS NOT NULL AND :OLD.DSFCN IS NULL) OR (:NEW.DSFCN IS NULL AND :OLD.DSFCN IS NOT NULL) THEN 
IF :NEW.DSFCN IS NOT NULL AND :OLD.DSFCN IS NULL THEN 
MERGE INTO DEX_EVENTS DE USING (SELECT v_matric AS MATRIC,''worker.terminate'' AS EVENT FROM DUAL) Z ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT) 
WHEN MATCHED THEN UPDATE SET ACTION=''S'',DATE_MODIF=CURRENT_TIMESTAMP,DATE_ENVOI_MIN=:NEW.DSFCN 
WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,ACTION,DATE_MODIF,DATE_ENVOI_MIN) VALUES (v_matric,''worker.terminate'',''M'',CURRENT_TIMESTAMP,:NEW.DSFCN); 
ELSE 
NULL; -- On fait quoi si on modifie une date de départ, ou qu''on annule un départ ??? 
END IF; 
ELSE '
              ;
            ELSE
              -- Pour les autres tables, en création et suppression, on insère une ligne par évènement potentiellement généré par la table, avec le bon code action
              PROC :=PROC||' 
IF INSERTING OR DELETING THEN 
IF INSERTING THEN 
v_dexaction := ''C''; 
ELSE 
v_dexaction := ''S''; 
END IF; -- FIN INSERTING / DELETING ';
              OPEN cur_eventsDex;
              LOOP
                FETCH cur_eventsDex INTO lig_eventDex ;
                EXIT
              WHEN cur_eventsDex%NOTFOUND;
                IF lig_eventDex.CONDITION IS NOT NULL THEN
                  PROC                    :=PROC||' 
IF '||regexp_replace(regexp_replace(lig_eventDex.CONDITION, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(:new.\1,:old.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(:new.\2,:old.\2)=\1')||' THEN ';
                END IF;
                PROC                      :=PROC||' 
MERGE INTO DEX_EVENTS DE USING (SELECT v_matric AS MATRIC,'''||lig_eventDex.EVENT||''' AS EVENT FROM DUAL) Z ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT) 
WHEN MATCHED THEN UPDATE SET ACTION=v_dexaction,DATE_MODIF=CURRENT_TIMESTAMP 
WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,ACTION,DATE_MODIF) VALUES (v_matric,'''||lig_eventDex.EVENT||''',v_dexaction,CURRENT_TIMESTAMP); ';
                IF lig_eventDex.CONDITION IS NOT NULL THEN
                  PROC                    :=PROC||' 
END IF; ';
                END IF;
              END LOOP;
              CLOSE cur_eventsDex;
              PROC :=PROC||' 
ELSE ';
            END IF;
            PROC           :=PROC||' 
eventsTab.delete; ';
            v_eventDexPrec := NULL;
            OPEN cur_donneesDex;
            LOOP
              FETCH cur_donneesDex INTO lig_donneeDex ;
              IF cur_donneesDex%NOTFOUND OR (v_eventDexPrec IS NOT NULL AND NOT v_eventDexPrec=lig_donneeDex.EVENT) THEN
                -- Dernière donnée pour l'event
                PROC :=PROC||' 
END IF; -- FIN :NEW<>:OLD 
IF v_processEventDex THEN 
eventsTab.EXTEND ; 
eventsTab(eventsTab.LAST) :='''||v_eventDexPrec||'''; 
END IF; -- FIN v_processEventDex 
';
              END IF;
              IF v_eventDexPrec IS NULL OR (NOT cur_donneesDex%NOTFOUND AND NOT v_eventDexPrec=lig_donneeDex.EVENT) THEN
                -- Première donnée pour l'event
                PROC :=PROC||' 
v_processEventDex := FALSE; 
IF FALSE THEN NULL; ';
              END IF;
              EXIT
            WHEN cur_donneesDex%NOTFOUND;
              PROC                       :=PROC||' 
ELSIF (:NEW.'||lig_donneeDex.NOM_DONNEE||'<>:OLD.'||lig_donneeDex.NOM_DONNEE||' OR (:NEW.'||lig_donneeDex.NOM_DONNEE||' IS NOT NULL AND :OLD.'||lig_donneeDex.NOM_DONNEE||' IS NULL) OR (:NEW.'||lig_donneeDex.NOM_DONNEE||' IS NULL AND :OLD.'||lig_donneeDex.NOM_DONNEE||' IS NOT NULL)) ';
              IF lig_donneeDex.CONDITION IS NOT NULL THEN
                PROC                     :=PROC||' AND '||regexp_replace(regexp_replace(lig_donneeDex.CONDITION, '([^ ]+)[ ]*=[ ]*(''[^ ]+'')', 'nvl(:new.\1,:old.\1)=\2'), '(''[^ ]+'')[ ]*=[ ]*([^ ]+)', 'nvl(:new.\2,:old.\2)=\1');
              END IF;
              PROC          :=PROC||' 
THEN v_processEventDex := TRUE; ';
              v_eventDexPrec:=lig_donneeDex.EVENT;
            END LOOP;
            CLOSE cur_donneesDex;
            PROC             :=PROC||' 
IF eventsTab.count>0 THEN 
for i in 1..eventsTab.count loop 
MERGE INTO DEX_EVENTS DE USING (SELECT v_matric AS MATRIC,eventsTab(i) AS EVENT FROM DUAL) Z ON (Z.MATRIC=DE.MATRIC AND Z.EVENT=DE.EVENT) 
WHEN MATCHED THEN UPDATE SET ACTION=''M'',DATE_MODIF=CURRENT_TIMESTAMP 
WHEN NOT MATCHED THEN INSERT (MATRIC,EVENT,ACTION,DATE_MODIF) VALUES (v_matric,eventsTab(i),''M'',CURRENT_TIMESTAMP); 
end loop; 
END IF; -- FIN eventsTab.count>0 
END IF; -- FIN UPDATING 
';
            IF date_eff_exists>0 THEN
              PROC           :=PROC||' 
END IF; -- FIN SYSDATE BETWEEN DATE_EFF AND DATE_FIN 
';
            END IF;
          END IF;
          -- FIN TRAITEMENT DEX
          PROC :=PROC||' END BEFORE EACH ROW;';
          IF nom_table IN ('DIC_ADM_CONTRAT_HISTO','DIC_PERIODES_RECUEIL_HIS') THEN
            PROC          :=PROC||' AFTER EACH ROW IS BEGIN ';
            IF nom_table   = 'DIC_ADM_CONTRAT_HISTO' THEN
              PROC        := PROC|| TRG_CONTRAT_HISTO_AFTER_ROW();
            ELSIF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
              PROC        := PROC|| DIC_PERIOD_REC_HISTO_AFTER_ROW();
            END IF;
            PROC :=PROC||' END AFTER EACH ROW;';
          END IF;
          IF nom_table IN ('DIC_ADM_PERSO','DIC_ADM_PERSO_HISTO','DIC_ADM_CONTRAT','DIC_ADM_CONTRAT_HISTO','DIC_PERIODES_RECUEIL_HIS') THEN
            PROC          :=PROC||' AFTER STATEMENT IS BEGIN';
            IF nom_table   ='DIC_ADM_PERSO' THEN
              PROC        :=PROC||TRG_PERSO_AFTER_STMNT();
            ELSIF nom_table='DIC_ADM_PERSO_HISTO' THEN
              PROC        :=PROC||TRG_PERSO_HISTO_AFTER_STMNT();
            ELSIF nom_table='DIC_ADM_CONTRAT' THEN
              PROC        :=PROC||TRG_CONTRAT_AFTER_STMNT();
            ELSIF nom_table='DIC_ADM_CONTRAT_HISTO' THEN
              PROC        :=PROC||TRG_CONTRAT_HISTO_AFTER_STMNT();
            ELSIF nom_table='DIC_PERIODES_RECUEIL_HIS' THEN
              PROC        :=PROC||DIC_PERIODES_REC_H_AFTER_STMNT();
            END IF;
            PROC:=PROC||'END AFTER STATEMENT;';
          END IF;
          PROC :=PROC||' END TRG_'||NOM_TABLE||';';
          EXECUTE_IMMEDIATE_STRING( PROC,0);
        END IF;
      END IF;
    END TGE_CREATE_TRIGGER;
##
TGE_IMPORT_30
=SQL=
create or replace PROCEDURE TGE_IMPORT_30
(
    P_LOGIN       IN VARCHAR2 ,
    P_DATE_IMPORT IN VARCHAR2 ,
    P_ROLE        IN VARCHAR2 ,
    P_ORIGINE     IN VARCHAR2 ,
    P_VALIDATION  IN VARCHAR2 ,
    P_WITH30      IN VARCHAR2 ,
    P_CODLANG     IN VARCHAR2,
    -- Valeurs attendues : EC -> écran création, EM -> écran modification, GAP -> création en sous-marin, I --> pour le préchargement des imports Web, VI -> pour la validation des imports Web ou Batch
    P_TYPE_ACTION IN VARCHAR2 ,
    P_DATE_MAJ    IN SYS_TRC_MODIF.DATEMAJ%type )
AS
  w_err   VARCHAR2(2000);
  v_start NUMBER;
  v_stop  NUMBER;
  req CLOB;
  reqvalues CLOB;
  reqInsert CLOB;
  dateMaj SYS_TRC_MODIF.datemaj%type;
BEGIN
  v_start       := DBMS_UTILITY.GET_TIME;
  IF P_DATE_MAJ IS NULL THEN
    SELECT CURRENT_TIMESTAMP INTO dateMaj FROM dual;
  ELSE
    dateMaj:= P_DATE_MAJ;
  END IF;
  IF ( P_WITH30 =1) THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début controle carte 30');
      TGE_CONTROLE_30 (p_login, p_date_import, NULL, p_codlang, P_TYPE_ACTION);
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  '||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'imp:TGE_CONTROLE_30 - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
  END IF;
  IF p_validation = 1 THEN
    BEGIN
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début validation : insertion TGE_ELEMENTS_PAIE');
      INSERT
      INTO TGE_ELEMENTS_PAIE
        (
          NUMPAC ,
          PAIEZAD ,
          PERIODE ,
          TYPE_TRAITEMENT ,
          CODE_ELEMENT ,
          INDICATIF ,
          ORIGINE ,
          SENS ,
          VALEUR ,
          DERNIER_CODE_OPE ,
          LOGIN_MAJ ,
          DATE_MAJ ,
          CLE_IMPORT ,
          IDPACMAT,
          type_writer,
          CODE_REMPLACEMENT,
          DATE_EFFET,
         ACTION_RETRO,
         ACTION_RETRO_DATE
        )
      SELECT E.NUMPAC ,
        PAIEZAD ,
        PERIODE ,
        TYPE_TRAITEMENT ,
        CODE_ELEMENT ,
        UPPER (NVL(INDICATIF,'*')) AS INDICATIF,
        ORIGINE ,
        SENS ,
        VALEUR ,
        'C' ,
        p_login ,
        TO_CHAR (sysdate, 'YYYYMMDDHH24MI') ,
        CASE
          WHEN 'VI' = P_TYPE_ACTION
          THEN P_LOGIN
            ||'#'
            ||P_DATE_IMPORT
            ||'#'
            ||NUMLIGNE
          ELSE NULL
        END AS CLE_IMPORT,
        CASE
          WHEN E.NUMPAC IS NOT NULL
          AND PACMAT    IS NOT NULL
          THEN RPAD(E.NUMPAC,6)
            || PACMAT
          ELSE ' '
        END AS IDPACMAT,
        CASE
          WHEN (SELECT O.MODE_T2
              ||'#'
              ||O.ENVOI_MODE_R
            FROM TGE_REF_ORIGINE_GTA O
            WHERE O.NUMPAC     = E.NUMPAC
            AND O.CODE_ORIGINE = E.ORIGINE) = 'R#N'
          THEN 'N'
          ELSE NULL
        END AS TYPE_WRITER,
        NVL(E.CODE_REMPLACEMENT,'*') AS CODE_REMPLACEMENT,
        TO_DATE(E.DATE_EFFET,'YYYYMMDD') AS DATE_EFFET,
        -- Gestion Action Retro : pour ne pas bousiller les perfs, on va positionner une valeur '*' dans actionRetro et null dans actionRetroDate
        -- et ensuite avec une requête d'update mettre à jour la valeur de actionRetro et actionRetroDate.
        -- On évite ainsi de faire 2 sous-select sur TGE_REF_PAC ou une jointure globale pour récupérer TGE_REF_PAC.PERIODEENCOURS
        case
        	when  E.PERIODE < (select PAC.PERIODEENCOURS from TGE_REF_PAC PAC where PAC.NUMPAC = E.NUMPAC)
         	then '*'
         	else NULL
        end as ACTION_RETRO,
        NULL as ACTION_RETRO_DATE
                             
      FROM TGE_IMPORT_ELEMENTS E
      WHERE LOGIN           =P_LOGIN
      AND CODE_ELEMENT NOT IN ('B690','B691')
      AND DATE_IMPORT       = p_date_import
      AND ((ERREURS        IS NULL
      AND STATUT            = 'TRAIT')
      OR (ERREURS          IS NOT NULL
      AND STATUT            = 'TRANS'));
      
      -- Gestion Action Retro : si création d'une ligne rétro, on sauvegarde qu'il s'agit d'une création comme première action et la date à laquelle elle a eu lieu
      update TGE_ELEMENTS_PAIE set 
      	ACTION_RETRO = 'C',
      	ACTION_RETRO_DATE = DATE_MAJ
      where ACTION_RETRO = '*';
      
    EXCEPTION
    WHEN OTHERS THEN
      w_err := SQLCODE;
      w_err := w_err||'  ' ||sqlerrm;
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'ValidElement - Erreur : ' || w_err);
      IF (P_LOGIN != 'BATCH') THEN
      	-- On remonte l'erreur à l'application
      	raise;
      END IF;
    END ;
    
    IF P_TYPE_ACTION = 'VI' THEN
      --- Gestion de la trace : on enregistre une trace généréale lors d'un import car on ne peut pas gérer de trace individuelle 
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion TGE_ELEMENTS_PAIE');
      SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPORT_ELEMENT_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE, 'Import Batch/Web 30','C',NULL,NULL,NULL,NULL);
    END IF;
    
    -- Mise à jour de la column RETRO_GC de la table TGE_PERIODE_RECUEIL_PAIEZAD
    -- si la "full" rétroactivité n'est pas activé sur le pac
    UPDATE TGE_PERIODE_RECUEIL_PAIEZAD R
    SET R.RETRO_GC =
      (SELECT E.VALEUR
      FROM TGE_ELEMENTS_PAIE E
      WHERE R.NUMPAC     = E.NUMPAC
      AND R.PAIEZAD      = E.PAIEZAD
      AND R.MOIS_PAIE    = E.PERIODE
      AND E.CODE_ELEMENT = 'WG96'
      )
    WHERE (R.NUMPAC, R.PAIEZAD, R.MOIS_PAIE) IN
      (SELECT e2.numpac,
        e2.paiezad,
        e2.periode
      FROM TGE_IMPORT_ELEMENTS E2
      WHERE e2.login     = P_LOGIN
      AND e2.date_import = p_date_import
      AND ((e2.ERREURS  IS NULL
      AND e2.STATUT     IN ('TRAIT','FIN'))
      OR (e2.ERREURS    IS NOT NULL
      AND e2.STATUT      = 'TRANS'))
      AND EXISTS (SELECT 'ACTIVE_RETRO_GC'
	 	FROM TGE_REF_PAC
	 	WHERE NUMPAC = e2.NUMPAC
	 		AND (DEB_RETRO IS NULL OR DEB_RETRO > e2.periode)
	 	)
      );
    ----------------------------------------------------------------------------
    
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début update TGE_IMPORT_ELEMENTS');
    UPDATE TGE_IMPORT_ELEMENTS
    SET ERREURS           ='',
      STATUT              ='FIN'
    WHERE LOGIN           = P_LOGIN
    AND DATE_IMPORT       = p_date_import
    AND ((ERREURS        IS NULL
    AND STATUT            = 'TRAIT')
    OR (ERREURS          IS NOT NULL
    AND STATUT            = 'TRANS'))
    AND CODE_ELEMENT NOT IN ('B690','B690');
    -- Suppression des lignes dans dans DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début DELETE FROM dic_tge_imputations_perm');
    DELETE
    FROM DIC_TGE_IMPUTATIONS_PERM A
    WHERE (A.NUMPAC,A.PAIEZAD) IN
      (SELECT B.NUMPAC,
        B.paiezad
      FROM TGE_IMPORT_ELEMENTS B
      WHERE B.CODE_ELEMENT >='B690'
      AND B.CODE_ELEMENT   <='B691'
      AND B.CODE_ELEMENT   IS NOT NULL
      AND B.ERREURS        IS NULL
      AND B.DATE_IMPORT     = p_date_import
      AND B.LOGIN           = P_LOGIN
      GROUP BY LOGIN,
        NUMPAC,
        PAIEZAD,
        DATE_IMPORT,
        INDICATIF
      HAVING COUNT(DISTINCT B.CODE_ELEMENT ) >1
      ) ;
    -- Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début Ajout dans la table  DIC_TGE_IMPUTATION_PERMANENTE');
    FOR b_numpac IN
    (SELECT DISTINCT numpac
    FROM TGE_IMPORT_ELEMENTS
    WHERE LOGIN       = P_LOGIN
    AND DATE_IMPORT   = p_date_import
    AND ERREURS      IS NULL
    AND code_ELEMENT IN ('B690','B691')
    )
    LOOP
      req      :='insert into DIC_TGE_IMPUTATIONS_PERM p(numpac,paiezad,MATRIC,pacmat';
      reqInsert:='select numpac,paiezad,MATRICULE,pacmat,';
      reqvalues:= ' from (select numpac,paiezad,MATRICULE,pacmat,code_element||''#''||indicatif as el, valeur';
      reqvalues:= reqvalues|| ' from TGE_IMPORT_ELEMENTS b where login='''||p_login||''' and date_import='''||P_DATE_IMPORT||''' 
and code_element in (''B690'',''B691'')  and  exists (select * from TGE_IMPORT_ELEMENTS c where b.login=c.login and b.date_import=c.date_import and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B690''  and b.indicatif=c.indicatif and ERREURs is  null) 
and  exists (select * from TGE_IMPORT_ELEMENTS c where b.login=c.login and b.date_import=c.date_import and b.numpac=c.numpac and b.paiezad=c.paiezad and c.code_element=''B691''  and b.indicatif=c.indicatif and ERREURs is  null) ';
      reqvalues:= reqvalues|| ' ) pivot (max(valeur)   for(el) in (';
      TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Trace SYS_TRC_MODIF : insertion DIC_TGE_IMPUTATIONS_PERM');
      FOR cur IN
      (SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     =b_numpac.numpac
      UNION
      SELECT ELEMENT,
        occurence,
        DOnneegxp,
        tablegxp
      FROM tge_ref_mapdo
      WHERE element IN ('B690','B691')
      AND numpac     ='*'
      )
      LOOP
        req           :=req||','||cur.DONNEEGXP;
        reqvalues     := reqvalues||''''||cur.element||'#'||cur.occurence ||''' as '|| cur.DONNEEGXP||',';
        IF cur.element ='B690' THEN
          reqInsert   := reqInsert||cur.DONNEEGXP ||',';
        ELSE
          reqInsert:= reqInsert||' IS_NUMBER(replace('||cur.DONNEEGXP ||','','',''.'')) as '||cur.DONNEEGXP ||' ,';
        END IF;
        IF P_LOGIN = 'BATCH' THEN
          SYS_TRACE_MODIF(P_LOGIN,dateMaj,'3','IMPUTATION_PAIE', 'CARTE=30&LOGIN='||P_LOGIN||'&DATE_IMPORT='||P_DATE_IMPORT||'&ROLE=3'||'&ORIGINE='||P_ORIGINE||'&ELEMENT='||cur.element||'&DONNEEGXP='||cur.DONNEEGXP, 'Import Batch 30 B690/B691','C',NULL,NULL,NULL,NULL);
        END IF;
      END LOOP;
      reqvalues:= SUBSTR(reqvalues,1,LENGTH(reqvalues)-1)||'))  ';
      reqInsert:= SUBSTR(reqInsert,1,LENGTH(reqInsert)-1);
      req      :=req||')  ';
      req      :=req||reqInsert|| reqvalues;
       EXECUTE_IMMEDIATE_STRING( req,0);
    END LOOP;
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'début UPDATE TGE_IMPORT_LISTE');
    UPDATE TGE_IMPORT_LISTE
    SET NBLIGNES_ERR =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NOT NULL
      ),
      NBLIGNES_IMP =
      (SELECT COUNT(*)
      FROM TGE_IMPORT_ELEMENTS
      WHERE LOGIN     = P_LOGIN
      AND DATE_IMPORT = p_date_import
      AND ERREURS    IS NULL
      ),
      STATUT        ='TRANS'
    WHERE LOGIN     = P_LOGIN
    AND DATE_IMPORT = p_date_import
    AND TYPE        = 2;
    -- Inscription en recyclage
    TGE_IMPORT_AVANCEMENT_proc(P_DATE_IMPORT,'Inscription en recyclage');
    merge into GAP_SELECTION_PACMAT P using (
      select distinct E.PACMAT,
      E.NUMPAC
      from TGE_IMPORT_ELEMENTS E
      where 
        E.LOGIN = P_LOGIN
        and E.DATE_IMPORT = p_date_import
        and E.ERREURS    IS NULL
    ) IE on (P.NOMTRAITEMENT = 'RECYCLAG' and P.LOGIN = 'IMPORT_309' and P.PACMAT = IE.PACMAT and P.NUMPAC = IE.NUMPAC)
    when not matched then
    insert
      (
        P.NOMTRAITEMENT,
        P.LOGIN,
        P.NUMPAC,
        P.PACMAT
      )
      values
      (
        'RECYCLAG',
        'IMPORT_309',
        IE.NUMPAC,
        IE.PACMAT
      );
  END IF;
END TGE_IMPORT_30;
##
TAG_CHARSET=@€éèç
##
TGE_RETRO_INSCRIPTION
=SQL=
CREATE OR REPLACE PROCEDURE TGE_RETRO_INSCRIPTION(
  P_NUMPAC IN VARCHAR2,
  P_PACMAT IN VARCHAR2,
  P_PERIODE_RETRO IN VARCHAR2,
  P_CODE_CHRONO IN VARCHAR2,
  P_PAIEZAD IN VARCHAR2,
  P_TABLE_MAJ IN VARCHAR2)
AS
  V_EXIST_TGE_MODIF_PACMAT_RETRO NUMBER;
  V_GAP_RETRO_MATRIC_UPDATE      NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO V_EXIST_TGE_MODIF_PACMAT_RETRO
  FROM TGE_MODIF_PACMAT_RETRO
  WHERE NUMPAC      = P_NUMPAC
  AND PACMAT        = P_PACMAT
  AND PERIODE_RETRO = P_PERIODE_RETRO;
  IF (V_EXIST_TGE_MODIF_PACMAT_RETRO=0) THEN
    -- S'il n'y a pas encore de ligne dans TGE_MODIF_PACMAT_RETRO pour le NUMPAC / PACMAT / PERIODE_RETRO, on insère
    INSERT INTO TGE_MODIF_PACMAT_RETRO VALUES (
      P_NUMPAC,
      P_PACMAT,
      P_PERIODE_RETRO,
      P_TABLE_MAJ,
      SYSDATE
    );
  END IF;
  SELECT COUNT(*)
  INTO V_GAP_RETRO_MATRIC_UPDATE
  FROM GAP_RETRO_MATRIC 
  WHERE NUMPAC        = P_NUMPAC
  AND PACMAT          = P_PACMAT
  AND PERIODE_RETRO   = P_PERIODE_RETRO
  AND MIN_CODE_CHRONO < P_CODE_CHRONO;
  IF(V_GAP_RETRO_MATRIC_UPDATE=0) THEN
    -- S'il n'y a pas de ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, et avec un CODE_CHRONO > au CODE_CHRONO qui a été modifié, on met à jour
    SELECT COUNT(*)
    INTO V_GAP_RETRO_MATRIC_UPDATE
    FROM GAP_RETRO_MATRIC 
    WHERE NUMPAC      = P_NUMPAC
    AND PACMAT        = P_PACMAT
    AND PERIODE_RETRO = P_PERIODE_RETRO;
    IF(V_GAP_RETRO_MATRIC_UPDATE=0) THEN
      -- S'il n'y a pas encore de ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, on insère
      INSERT INTO GAP_RETRO_MATRIC VALUES (
        P_NUMPAC,
        P_PACMAT,
        P_PERIODE_RETRO ,
        P_CODE_CHRONO,
        P_PAIEZAD
      );
    ELSE
      -- S'il y a déjà une ligne dans GAP_RETRO_MATRIC pour le NUMPAC / PACMAT / PERIODE_RETRO, on met à jour
      UPDATE GAP_RETRO_MATRIC SET 
        MIN_CODE_CHRONO = P_CODE_CHRONO,
        PAIEZAD_RETRO   = P_PAIEZAD
      WHERE MIN_CODE_CHRONO > P_CODE_CHRONO
      AND NUMPAC            = P_NUMPAC
      AND PACMAT            = P_PACMAT
      AND PERIODE_RETRO     = P_PERIODE_RETRO;
    END IF;
  END IF;
END TGE_RETRO_INSCRIPTION;
##
TAG_CHARSET=@€éèç
##
TGE_RETRO_INSCRIPT_WITH_CHECK
=SQL=
CREATE OR REPLACE PROCEDURE TGE_RETRO_INSCRIPT_WITH_CHECK(
  P_NUMPAC IN VARCHAR2, 
  P_PACMAT IN VARCHAR2, 
  P_PERIODE_YYYYMM IN VARCHAR2, 
  P_CODE_CHRONO IN VARCHAR2, 
  P_PAIEZAD IN VARCHAR2, 
  P_TABLE_MAJ IN VARCHAR2, 
  P_REQ_COUNT_CHECK_SPECIF IN VARCHAR2 DEFAULT NULL) 
AS
  V_PERIODEENCOURS     VARCHAR2(6);
  V_DEB_RETRO          VARCHAR2(6);
  V_DEB_HISTO_RETRO    VARCHAR2(6);
  V_NB_MOIS_RETRO      NUMBER;
  V_COUNT_CHECK_SPECIF NUMBER;
BEGIN
  BEGIN
    SELECT PERIODEENCOURS,
      DEB_RETRO,
      DEB_HISTO_RETRO,
      nvl(NB_MOIS_RETRO,0)
    INTO V_PERIODEENCOURS,
      V_DEB_RETRO,
      V_DEB_HISTO_RETRO,
      V_NB_MOIS_RETRO
    FROM TGE_REF_PAC
    WHERE NUMPAC = P_NUMPAC;
  END;
  IF(V_PERIODEENCOURS >= V_DEB_RETRO AND V_DEB_RETRO IS NOT NULL) THEN
    BEGIN
      V_COUNT_CHECK_SPECIF := 1;
      IF P_REQ_COUNT_CHECK_SPECIF IS NOT NULL THEN
        EXECUTE IMMEDIATE P_REQ_COUNT_CHECK_SPECIF INTO V_COUNT_CHECK_SPECIF;
      END IF;
      IF(P_PERIODE_YYYYMM  < V_PERIODEENCOURS AND V_COUNT_CHECK_SPECIF > 0)THEN
        IF(TO_DATE(P_PERIODE_YYYYMM ,'YYYYMM') < ADD_MONTHS(TO_DATE(V_PERIODEENCOURS,'YYYYMM'),-V_NB_MOIS_RETRO)) THEN
          --La période de rétroactivité maximum est dépassée
          RAISE_APPLICATION_ERROR(-20001, 'CODERR=TGERET01');
        ELSIF (P_PERIODE_YYYYMM < V_DEB_HISTO_RETRO AND V_DEB_HISTO_RETRO IS NOT NULL) THEN
          --La rétroactivité est impossible avant la période de début de conservation des historiques
          RAISE_APPLICATION_ERROR(-20001, 'CODERR=TGERET02');
        ELSE
          TGE_RETRO_INSCRIPTION(P_NUMPAC,
            P_PACMAT,
            P_PERIODE_YYYYMM,
            P_CODE_CHRONO,
            P_PAIEZAD,
            P_TABLE_MAJ);
        END IF;
      END IF;
    END;
  END IF;
END TGE_RETRO_INSCRIPT_WITH_CHECK;
##
TRG_TGE_DONNEES_PAIE
=SQL=
create or replace trigger trg_tge_donnees_paie FOR
  insert or
  update or
  delete on tge_donnees_paie COMPOUND TRIGGER
  
  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   varchar2(1);
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  V_CODE_RUBRIQUE    varchar2(6);
  V_OPTION_RETRO     varchar2(1);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   varchar2(6);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
  end if;

  if (v_type_writer <> 'N') then
    v_numpac       := nvl(:new.numpac, :old.numpac);
    v_paiezad      := nvl(:new.paiezad, :old.paiezad);
    SELECT t.pacmat,nvl(t.periode_recyclage,'1'),CODE_CHRONO
    INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
    from dic_adm_contrat_situ d, secupacmat t
    where d.numpac = v_numpac 
    and d.paiezad  = v_paiezad
    and d.numpac   = t.numpac
    and d.pacmat   = t.pacmat
    and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
    if v_periode_recycl = '3' then
      raise_application_error(-20001, 'CODERR=GENREC02');
    elsif v_periode_recycl = '2' then
      raise_application_error(-20001, 'CODERR=GENREC01');
    elsif v_periode_recycl = '1' then
      v_recycl            := 'N';
      IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
        select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
      END IF;
      IF DELETING THEN
        date_test_recycl := :old.periode;
      ELSE
        date_test_recycl := :new.periode;
      END IF;
      if (NVL(date_test_recycl,'000000') <= tabPeriodeByNumpac(v_numpac)) then
        if inserting or deleting then
          v_recycl := 'O';
        elsif updating then
          if :new.code_caisse            <> :old.code_caisse or (:new.code_caisse is not null and :old.code_caisse is null) or (:new.code_caisse is null and :old.code_caisse is not null) then
            v_recycl                     := 'O';
          elsif :new.code_imputation     <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
            v_recycl                     := 'O';
          elsif :new.code_rubrique       <> :old.code_rubrique or (:new.code_rubrique is not null and :old.code_rubrique is null) or (:new.code_rubrique is null and :old.code_rubrique is not null) then
            v_recycl                     := 'O';
          elsif :new.date_deb_arret      <> :old.date_deb_arret or (:new.date_deb_arret is not null and :old.date_deb_arret is null) or (:new.date_deb_arret is null and :old.date_deb_arret is not null) then
            v_recycl                     := 'O';
          elsif :new.domaine_prcte       <> :old.domaine_prcte or (:new.domaine_prcte is not null and :old.domaine_prcte is null) or (:new.domaine_prcte is null and :old.domaine_prcte is not null) then
            v_recycl                     := 'O';
          elsif :new.montant             <> :old.montant or (:new.montant is not null and :old.montant is null) or (:new.montant is null and :old.montant is not null) then
            v_recycl                     := 'O';
          elsif :new.nombre              <> :old.nombre or (:new.nombre is not null and :old.nombre is null) or (:new.nombre is null and :old.nombre is not null) then
            v_recycl                     := 'O';
          elsif :new.no_sequence         <> :old.no_sequence or (:new.no_sequence is not null and :old.no_sequence is null) or (:new.no_sequence is null and :old.no_sequence is not null) then
            v_recycl                     := 'O';
          elsif :new.origine             <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_recycl                     := 'O';
          elsif :new.periode_affectation <> :old.periode_affectation or (:new.periode_affectation is not null and :old.periode_affectation is null) or (:new.periode_affectation is null and :old.periode_affectation is not null) then
            v_recycl                     := 'O';
          elsif :new.periode_rattach_deb <> :old.periode_rattach_deb or (:new.periode_rattach_deb is not null and :old.periode_rattach_deb is null) or (:new.periode_rattach_deb is null and :old.periode_rattach_deb is not null) then
            v_recycl                     := 'O';
          elsif :new.periode_rattach_fin <> :old.periode_rattach_fin or (:new.periode_rattach_fin is not null and :old.periode_rattach_fin is null) or (:new.periode_rattach_fin is null and :old.periode_rattach_fin is not null) then
            v_recycl                     := 'O';
          elsif :new.pourcentage         <> :old.pourcentage or (:new.pourcentage is not null and :old.pourcentage is null) or (:new.pourcentage is null and :old.pourcentage is not null) then
            v_recycl                     := 'O';
          elsif :new.sens                <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
            v_recycl                     := 'O';
          elsif :new.taux                <> :old.taux or (:new.taux is not null and :old.taux is null) or (:new.taux is null and :old.taux is not null) then
            v_recycl                     := 'O';
          elsif :new.type_donnee         <> :old.type_donnee or (:new.type_donnee is not null and :old.type_donnee is null) or (:new.type_donnee is null and :old.type_donnee is not null) then
            v_recycl                     := 'O';
          elsif :new.type_traitement     <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
            v_recycl                     := 'O';
          elsif :new.periode             <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
            v_recycl                     := 'O';
          elsif :new.code_remplacement   <> :old.code_remplacement or (:new.code_remplacement is not null and :old.code_remplacement is null) or (:new.code_remplacement is null and :old.code_remplacement is not null) then
            v_recycl                     := 'O';
          elsif :new.action_retro        <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_recycl                     := 'O';
          end if;
        end if;
        if v_recycl = 'O' then
          begin
            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
          when not matched then
            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
          exception
          when others then 
            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;
          end;
        end if;
      end if;
    end if;
    /** Test de mise en rétro **/
    v_retro            := 'N';
    if inserting or deleting then
      v_retro := 'O';
    elsif updating then
      if :new.code_caisse            <> :old.code_caisse or (:new.code_caisse is not null and :old.code_caisse is null) or (:new.code_caisse is null and :old.code_caisse is not null) then
        v_retro                     := 'O';
      elsif :new.code_imputation     <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
        v_retro                     := 'O';
      elsif :new.code_rubrique       <> :old.code_rubrique or (:new.code_rubrique is not null and :old.code_rubrique is null) or (:new.code_rubrique is null and :old.code_rubrique is not null) then
        v_retro                     := 'O';
      elsif :new.date_deb_arret      <> :old.date_deb_arret or (:new.date_deb_arret is not null and :old.date_deb_arret is null) or (:new.date_deb_arret is null and :old.date_deb_arret is not null) then
        v_retro                     := 'O';
      elsif :new.domaine_prcte       <> :old.domaine_prcte or (:new.domaine_prcte is not null and :old.domaine_prcte is null) or (:new.domaine_prcte is null and :old.domaine_prcte is not null) then
        v_retro                     := 'O';
      elsif :new.montant             <> :old.montant or (:new.montant is not null and :old.montant is null) or (:new.montant is null and :old.montant is not null) then
        v_retro                     := 'O';
      elsif :new.nombre              <> :old.nombre or (:new.nombre is not null and :old.nombre is null) or (:new.nombre is null and :old.nombre is not null) then
        v_retro                     := 'O';
      elsif :new.no_sequence         <> :old.no_sequence or (:new.no_sequence is not null and :old.no_sequence is null) or (:new.no_sequence is null and :old.no_sequence is not null) then
        v_retro                     := 'O';
      elsif :new.origine             <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
        v_retro                     := 'O';
      elsif :new.periode_affectation <> :old.periode_affectation or (:new.periode_affectation is not null and :old.periode_affectation is null) or (:new.periode_affectation is null and :old.periode_affectation is not null) then
        v_retro                     := 'O';
      elsif :new.periode_rattach_deb <> :old.periode_rattach_deb or (:new.periode_rattach_deb is not null and :old.periode_rattach_deb is null) or (:new.periode_rattach_deb is null and :old.periode_rattach_deb is not null) then
        v_retro                     := 'O';
      elsif :new.periode_rattach_fin <> :old.periode_rattach_fin or (:new.periode_rattach_fin is not null and :old.periode_rattach_fin is null) or (:new.periode_rattach_fin is null and :old.periode_rattach_fin is not null) then
        v_retro                     := 'O';
      elsif :new.pourcentage         <> :old.pourcentage or (:new.pourcentage is not null and :old.pourcentage is null) or (:new.pourcentage is null and :old.pourcentage is not null) then
        v_retro                     := 'O';
      elsif :new.sens                <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
        v_retro                     := 'O';
      elsif :new.taux                <> :old.taux or (:new.taux is not null and :old.taux is null) or (:new.taux is null and :old.taux is not null) then
        v_retro                     := 'O';
      elsif :new.type_donnee         <> :old.type_donnee or (:new.type_donnee is not null and :old.type_donnee is null) or (:new.type_donnee is null and :old.type_donnee is not null) then
        v_retro                     := 'O';
      elsif :new.type_traitement     <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
        v_retro                     := 'O';
      elsif :new.periode             <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
        v_retro                     := 'O';
      elsif :new.code_remplacement   <> :old.code_remplacement or (:new.code_remplacement is not null and :old.code_remplacement is null) or (:new.code_remplacement is null and :old.code_remplacement is not null) then
        v_retro                     := 'O';
      elsif :new.action_retro        <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
        v_retro                     := 'O';
      end if;
    end if;
    if v_retro = 'O' then
      V_PERIODE := NVL(:NEW.PERIODE,:OLD.PERIODE);
      V_CODE_RUBRIQUE := NVL(:OLD.CODE_RUBRIQUE,:NEW.CODE_RUBRIQUE);
      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_DONNEES_PAIE', 'SELECT COUNT(*) FROM TGE_REF_RUBRIQUE WHERE TGE_REF_RUBRIQUE.CODERUB = '''||V_CODE_RUBRIQUE||''' AND NUMPAC = '''||V_NUMPAC||''' AND NVL(OPTION_RETRO,''N'') <> ''N''');
    END IF;
  /** Fin test de mise en rétro **/
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_donnees_paie;
##
TRG_TGE_ELEMENTS_PAIE
=SQL=
create or replace trigger trg_tge_elements_paie FOR
  insert or
  update or
  delete on tge_elements_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   varchar2(1);
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_CODE_ELEMENT     varchar2(4);
  v_calcul_retro     varchar2(1);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   varchar2(6);
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
  end if;

  if (v_type_writer <> 'N') then
    v_numpac       := nvl(:new.numpac, :old.numpac);
    v_paiezad      := nvl(:new.paiezad, :old.paiezad);
    SELECT t.pacmat,nvl(t.periode_recyclage,'1'),CODE_CHRONO
    INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
    from dic_adm_contrat_SITU d, secupacmat t
    where d.numpac = v_numpac
    and d.paiezad  = v_paiezad
    and d.numpac   = t.numpac
    and d.pacmat   = t.pacmat
    and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
    if v_periode_recycl = '3' then
      raise_application_error(-20001, 'CODERR=GENREC02');
    elsif v_periode_recycl = '2' then
      raise_application_error(-20001, 'CODERR=GENREC01');
    elsif v_periode_recycl = '1' then
      v_recycl            := 'N';
      IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
        select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
      END IF;
      IF DELETING THEN
        date_test_recycl := :old.periode;
      ELSE
        date_test_recycl := :new.periode;
      END IF;
      if (NVL(date_test_recycl,'000000') <= tabPeriodeByNumpac(v_numpac)) then
        if inserting or deleting then
          v_recycl := 'O';
        elsif updating then
          -- Les valeurs des colonnes clés ne peuvent pas être nulls 
          if :new.code_element         <> :old.code_element then
            v_recycl                   := 'O';
          elsif :new.indicatif         <> :old.indicatif then
            v_recycl                   := 'O';
          elsif :new.origine           <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_recycl                   := 'O';
          elsif :new.sens              <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
            v_recycl                   := 'O';
          elsif :new.type_traitement   <> :old.type_traitement then
            v_recycl                   := 'O';
          elsif :new.valeur            <> :old.valeur or (:new.valeur is not null and :old.valeur is null) or (:new.valeur is null and :old.valeur is not null) then
            v_recycl                   := 'O';
          elsif :new.periode           <> :old.periode then
            v_recycl                   := 'O';
          elsif :new.code_remplacement <> :old.code_remplacement then
            v_recycl                   := 'O';
          elsif :new.action_retro      <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_recycl                   := 'O';
          end if;
        end if;
        if v_recycl = 'O' then
          begin
            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
          when not matched then
            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
          exception
          when others then
            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;
          end;
        end if;
      end if;
    end if;
    /** Test de mise en rétro **/
    v_retro            := 'N';
    if inserting or deleting then
      v_retro := 'O';
    elsif updating then
      -- Les valeurs des colonnes clés ne peuvent pas être nulls 
      if :new.code_element         <> :old.code_element then
        v_retro                   := 'O';
      elsif :new.indicatif         <> :old.indicatif then
        v_retro                   := 'O';
      elsif :new.origine           <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
        v_retro                   := 'O';
      elsif :new.sens              <> :old.sens or (:new.sens is not null and :old.sens is null) or (:new.sens is null and :old.sens is not null) then
        v_retro                   := 'O';
      elsif :new.type_traitement   <> :old.type_traitement then
        v_retro                   := 'O';
      elsif :new.valeur            <> :old.valeur or (:new.valeur is not null and :old.valeur is null) or (:new.valeur is null and :old.valeur is not null) then
        v_retro                   := 'O';
      elsif :new.periode           <> :old.periode then
        v_retro                   := 'O';
      elsif :new.code_remplacement <> :old.code_remplacement then
        v_retro                   := 'O';
      elsif :new.action_retro      <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
        v_retro                   := 'O';
      end if;
    end if;
    if v_retro = 'O' then
      V_PERIODE := NVL(:NEW.PERIODE,:OLD.PERIODE);
      V_CODE_ELEMENT := NVL(:NEW.CODE_ELEMENT,:OLD.CODE_ELEMENT);
      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_ELEMENTS_PAIE', 'SELECT COUNT(*) FROM TGE_REF_DICOZ WHERE TGE_REF_DICOZ.ELEMENT = '''||V_CODE_ELEMENT||''' AND NUMPAC = '''||V_NUMPAC||''' AND NVL(CALCUL_RETRO,''0'') = ''1''');
    END IF;
  /** Fin test de mise en rétro **/
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_elements_paie;
##
TRG_TGE_INCIDENTS_PAIE
=SQL=
create or replace trigger trg_tge_incidents_paie FOR
  insert or
  update or
  delete on tge_incidents_paie COMPOUND TRIGGER

  v_recycl           varchar2(1);
  v_retro            varchar2(1);
  v_periode_recycl   varchar2(1);
  v_numpac           varchar2(6);
  v_pacmat           varchar2(8);
  v_type_writer      varchar2(1);
  v_paiezad          varchar2(8);
  v_date_effet       DATE; 
  v_periode_retro    VARCHAR2(6);
  V_PERIODE          varchar2(6);
  V_DEB_RETRO        varchar2(6);
  V_DEB_HISTO_RETRO  varchar2(6);
  V_PERIODEENCOURS   varchar2(6);
  V_CODE_CHRONO      varchar2(6);
  v_bypass_trigger   number;
  V_NB_MOIS_RETRO    number;
  TYPE T_PERIODE_BY_NUMPAC IS TABLE OF TGE_REF_PAC.PERIODEENCOURS%TYPE INDEX BY TGE_REF_PAC.NUMPAC%TYPE;
  tabPeriodeByNumpac T_PERIODE_BY_NUMPAC;
  date_test_recycl   DATE;
BEFORE EACH ROW
IS
begin
  -- action de 'bypass' le trigger 
  select count(*) into v_bypass_trigger from bypass_trg_recycl_on_session;
  if (v_bypass_trigger = 0) then
    -- s'il y a une ligne dans la table temporaire, alors il n'y a pas de recyclage ni de rétroactivité

  if deleting then
    v_type_writer := nvl(:old.type_writer, 'O');
  else
    v_type_writer := nvl(:new.type_writer, 'O');
    -- On remet TYPE_WRITER à NULL pour qu'il ne soit pas considéré comme 'N' lors des futurs update n'incluant pas cette colonne
    :new.type_writer := null;
    BEGIN
        v_numpac        := NVL(:new.numpac, :old.numpac);
        v_paiezad       := NVL(:new.paiezad, :old.paiezad);
        v_date_effet    := NVL(:new.date_effet, :old.date_effet);
        SELECT MIN(MOIS_PAIE) 
        INTO v_periode_retro
        FROM TGE_PERIODE_RECUEIL_PAIEZAD
        WHERE numpac = v_numpac
        AND paiezad  = v_paiezad
        AND v_date_effet BETWEEN DEBUT_PERIODE_RECUEIL AND FIN_PERIODE_RECUEIL;
        IF v_periode_retro IS NOT NULL THEN
          :new.periode     := TO_DATE(v_periode_retro || 01, 'yyyyMMdd');
        END IF;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Période de recueil non trouvé
        null;
    END;
  end if;

  if (v_type_writer <> 'N') then
    v_numpac      := nvl(:new.numpac, :old.numpac);
    v_paiezad     := nvl(:new.paiezad, :old.paiezad);
    BEGIN
        SELECT t.pacmat,nvl(t.periode_recyclage,'1'),CODE_CHRONO
        INTO v_pacmat,v_periode_recycl,V_CODE_CHRONO
        from dic_adm_contrat_SITU d, secupacmat t
        where d.numpac = v_numpac
        and d.paiezad  = v_paiezad
        and d.numpac   = t.numpac
        and d.pacmat   = t.pacmat
        and nvl(:new.DATE_EFFET,:old.DATE_EFFET) BETWEEN d.DSDSC AND NVL(d.DSFSC,to_date('31122099','DDMMYYYY'));
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        null;
    END;
    if v_periode_recycl = '3' then
      raise_application_error(-20000, 'CODERR=GENREC02');
    elsif v_periode_recycl = '2' then
      raise_application_error(-20000, 'CODERR=GENREC01');
    elsif v_periode_recycl = '1' then
      v_recycl            := 'N';
      IF NOT tabPeriodeByNumpac.exists(v_numpac) THEN
        select periodeencours into tabPeriodeByNumpac(v_numpac) from tge_ref_pac where numpac = v_numpac;
      END IF;
      IF DELETING THEN
        date_test_recycl := :old.periode;
      ELSE
        date_test_recycl := :new.periode;
      END IF;
      if (NVL(TO_CHAR(date_test_recycl,'yyyymm'),'000000') <= tabPeriodeByNumpac(v_numpac)) then
        if inserting or deleting then
          v_recycl := 'O';
        elsif updating then
          if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
            v_recycl                 := 'O';
          elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
            v_recycl                 := 'O';
          elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
            v_recycl                 := 'O';
          elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
            v_recycl                 := 'O';
          elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
            v_recycl                 := 'O';
          elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
            v_recycl                 := 'O';
          elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
            v_recycl                 := 'O';
          elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
            v_recycl                 := 'O';
          elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
            v_recycl                 := 'O';
          end if;
        end if;
        if v_recycl = 'O' then
          begin
            merge into gap_recycl_matric a using (select v_numpac as numpac, v_pacmat as pacmat from dual) b on (a.pacmat = b.pacmat and a.numpac = b.numpac)
          when not matched then
            insert (a.numpac, a.pacmat) values (b.numpac, b.pacmat);
          exception
          when others then
            --dbms_output.put_line('Collaborateur déjà en recyclage ' || v_numpac || '/' || v_pacmat);
            --FIXME utiliser la procédure trace_dbms_output()
            NULL;
          end;
        end if;
      end if;
    end if;
    /** Test de mise en rétro **/
    v_retro            := 'N';
    if inserting or deleting then
      v_retro := 'O';
    elsif updating then
      -- Les valeurs des colonnes clés ne peuvent pas être nulls 
      if :new.code_imputation    <> :old.code_imputation or (:new.code_imputation is not null and :old.code_imputation is null) or (:new.code_imputation is null and :old.code_imputation is not null) then
        v_retro                 := 'O';
      elsif :new.code_ip         <> :old.code_ip or (:new.code_ip is not null and :old.code_ip is null) or (:new.code_ip is null and :old.code_ip is not null) then
        v_retro                 := 'O';
      elsif :new.date_effet      <> :old.date_effet or (:new.date_effet is not null and :old.date_effet is null) or (:new.date_effet is null and :old.date_effet is not null) then
        v_retro                 := 'O';
      elsif :new.heures          <> :old.heures or (:new.heures is not null and :old.heures is null) or (:new.heures is null and :old.heures is not null) then
        v_retro                 := 'O';
      elsif :new.origine         <> :old.origine or (:new.origine is not null and :old.origine is null) or (:new.origine is null and :old.origine is not null) then
        v_retro                 := 'O';
      elsif :new.type_ip         <> :old.type_ip or (:new.type_ip is not null and :old.type_ip is null) or (:new.type_ip is null and :old.type_ip is not null) then
        v_retro                 := 'O';
      elsif :new.type_traitement <> :old.type_traitement or (:new.type_traitement is not null and :old.type_traitement is null) or (:new.type_traitement is null and :old.type_traitement is not null) then
        v_retro                 := 'O';
      elsif :new.periode         <> :old.periode or (:new.periode is not null and :old.periode is null) or (:new.periode is null and :old.periode is not null) then
        v_retro                 := 'O';
      elsif :new.action_retro    <> :old.action_retro or (:new.action_retro is not null and :old.action_retro is null) or (:new.action_retro is null and :old.action_retro is not null) then
        v_retro                 := 'O';
      end if;
    end if;
    if v_retro = 'O' then
      V_PERIODE := TO_CHAR(NVL(:NEW.PERIODE,:OLD.PERIODE),'YYYYMM');
      TGE_RETRO_INSCRIPT_WITH_CHECK(V_NUMPAC, V_PACMAT, V_PERIODE, V_CODE_CHRONO, V_PAIEZAD, 'TGE_INCIDENTS_PAIE');
    END IF;
  /** Fin test de mise en rétro **/
  end if;
  end if;
END BEFORE EACH ROW;
end trg_tge_incidents_paie;
##
EDI_HISTO_LANCEMENTS
=SQL IFNOTEXIST=EDI_HISTO_LANCEMENTS=NUMPAC=
ALTER TABLE EDI_HISTO_LANCEMENTS ADD NUMPAC VARCHAR2(6)
##
TAG_CHARSET=@€éèç
##
GAP_TRT_DOC
=SQL IFEXIST=GAP_TRT_DOC=DOC_NAME=
alter table GAP_TRT_DOC modify DOC_NAME varchar2(256 BYTE)
##
SYS_DEF_ERREURS
==
DELETE FROM SYS_DEF_ERREURS WHERE CODERR = 'TGE00343' AND CODLANG = 'fr_fr' AND CODMOD ='TGE'
'TGE00343','TGE','fr_fr','0','La taille de l''indicatif ne doit pas dépasser 2 caractères alphanumériques.','3'
##
SYS_REQUETES_JSP
==
DELETE FROM SYS_REQUETES_JSP WHERE NOMPAGE = 'ETATS_CONTAINER_ECP' AND IDREQUETE in ('2')
'ETATS_CONTAINER_ECP','2','Utilisateur','(WITH T1 AS (SELECT RE.*, S.LOGIN FROM SYS_DEF_REPLIB RE INNER JOIN SYS_SEC_USR_WDIR S ON S.ID_REP = RE.ID_REP AND S.LOGIN = @LOGIN@ AND RE.CHEMIN LIKE ''!%!_DSF!_!%PAIE%'' ESCAPE ''!''), T2 AS (SELECT M.* , GAP_TRT_DOC.DOC_NAME, GAP_TRT_DOC.ID_TRT FROM DOC_CONTAINER_METADATA_VIEW M INNER JOIN GAP_TRT_DOC ON M.DOC_ID = GAP_TRT_DOC.DOC_ID WHERE ID_TRT = %1 AND m.pac =%2 AND (m.periode_paie =%3 or m.periode_paie_simul =%3) AND m.num_ech =%4) SELECT (Select MAX(LIBELLE) from SYS_DEF_REPLIB where UPPER(CHEMIN) = ''%_DSF_%PAIE/''|| T2.PAC || ''/'' || UPPER(T2.GRP_EDIT) ) AS LIBELLE, T2.* FROM T2 WHERE (SELECT COUNT(*) FROM T1 WHERE UPPER(CHEMIN) = UPPER(''%_DSF_%PAIE/'' ||T2.PAC) OR UPPER(CHEMIN) = UPPER(''%_DSF_%PAIE/'' ||T2.PAC ||''/'' ||T2.GRP_EDIT) OR UPPER(CHEMIN) = ''%_DSF_%PAIE'') > 0)','DOC_ID,DOC_TYPE,PAC,ETAB,MATRIC,PACMAT,COMPANY_ID,ASSOCIATE_ID, PERIODE_PAIE,EXERCICE,MOTEUR_PAIE,BULLETIN_REF,IMPORT_REF,TO_CHAR(TO_DATE(PERIODE_PAIE_SIMUL^''YYYYmm'')^''mm.YYYY''), LIBELLE,NUM_ECH,ANNEXE_INC,ANNEXE_LABEL,DOC_NAME,ID_TRT,NOM,PRENOM',NULL,NULL,'0','true','PERIODE_PAIE ASC',NULL,'Consultation des états de paie de simulation et de paie de test','Id, Type, Pac,Etablissement,Matricule, Matricule de paie, Company id, Associate Id, Période de paie, Exercice, Moteur de paie, Réf. Bulletin, Réf. Import, Période de paie de simulation, Groupe édition,  N° échange, Inc. Annexe, Libellé annexe, Libellé document, Id Traitement,Nom,Prénom'
##
SYS_REQUETES_JSP
==
DELETE FROM SYS_REQUETES_JSP WHERE NOMPAGE = 'ETATS_CONTAINER_ECP' AND IDREQUETE in ('2')
'ETATS_CONTAINER_ECP','2','Utilisateur','(WITH T1 AS (SELECT RE.*, S.LOGIN FROM SYS_DEF_REPLIB RE INNER JOIN SYS_SEC_USR_WDIR S ON S.ID_REP = RE.ID_REP AND S.LOGIN = @LOGIN@ AND RE.CHEMIN LIKE ''!%!_DSF!_!%PAIE%'' ESCAPE ''!''), T2 AS (SELECT M.* , GAP_TRT_DOC.DOC_NAME, GAP_TRT_DOC.ID_TRT FROM DOC_CONTAINER_METADATA_VIEW M INNER JOIN GAP_TRT_DOC ON M.DOC_ID = GAP_TRT_DOC.DOC_ID WHERE ID_TRT = %1 AND m.pac =%2 AND (m.periode_paie =%3 or m.periode_paie_simul =%3) AND nvl(m.num_ech, %4) = %4) SELECT (Select MAX(LIBELLE) from SYS_DEF_REPLIB where UPPER(CHEMIN) = ''%_DSF_%PAIE/''|| T2.PAC || ''/'' || UPPER(nvl( T2.GRP_EDIT, SUBSTR(T2.BULLETIN_REF, 0,INSTR(T2.BULLETIN_REF, ''.'', 1) - 1) ) ) ) AS LIBELLE, T2.* FROM T2 WHERE (SELECT COUNT(*) FROM T1 WHERE UPPER(CHEMIN) = UPPER(''%_DSF_%PAIE/'' ||T2.PAC) OR UPPER(CHEMIN) = UPPER(''%_DSF_%PAIE/'' ||T2.PAC ||''/'' ||nvl( T2.GRP_EDIT, SUBSTR(T2.BULLETIN_REF, 0, INSTR(T2.BULLETIN_REF, ''.'', 1) - 1) ) ) OR UPPER(CHEMIN) = ''%_DSF_%PAIE'') > 0)','DOC_ID,DOC_TYPE,PAC,ETAB,MATRIC,PACMAT,COMPANY_ID,ASSOCIATE_ID, PERIODE_PAIE,EXERCICE,MOTEUR_PAIE,BULLETIN_REF,IMPORT_REF,TO_CHAR(TO_DATE(PERIODE_PAIE_SIMUL^''YYYYmm'')^''mm.YYYY''), LIBELLE,NUM_ECH,ANNEXE_INC,ANNEXE_LABEL,DOC_NAME,ID_TRT,NOM,PRENOM',NULL,NULL,'0','true','PERIODE_PAIE ASC',NULL,'Consultation des états de paie de simulation et de paie de test','Id, Type, Pac,Etablissement,Matricule, Matricule de paie, Company id, Associate Id, Période de paie, Exercice, Moteur de paie, Réf. Bulletin, Réf. Import, Période de paie de simulation, Groupe édition,  N° échange, Inc. Annexe, Libellé annexe, Libellé document, Id Traitement,Nom,Prénom'
##
SYS_VARSYS
==
DELETE SYS_VARSYS WHERE  MODULE='STD' and CODVAR='INTERFACE_FSED'
'STD', 'INTERFACE_FSED', 'FSD', 'Texte','Nom de l''interface FSED'
##
TAG_CHARSET=@€éèç
##
TGE_REF_CARTE_FSED
==
DELETE from TGE_REF_CARTE_FSED where CODE_CARTE in ('29_30_DIF_FSED_RETRO','29_30_DIF_FSED','W566','ANNULATION','ANNULATION_RETRO','W566_RETRO','29_30_TGE_ELEMENT_PAIE','29_30_TGE_ELEMENT_PAIE_RETRO','40','40_RETRO','60','60_RETRO','70','70_RETRO') and ORIGINE_CARTE = 'RD'
##
TGE_REF_CARTE_FSED
'29_30_DIF_FSED','RD','SELECT','001',NULL,'DIF_FSED','NUMPAC','6','0','FALSE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','001',NULL,'DIF_FSED_PARTIERETRO','NUMPAC','6','0','FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','002','30',NULL,NULL,'2','0','FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','004',NULL,'DIF_FSED','PAIEZAD','8','0','TRUE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','004',NULL,'DIF_FSED_PARTIERETRO','PAIEZAD','8','0','TRUE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','007',NULL,'DIF_FSED','ELEM','4',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','007',NULL,'DIF_FSED_PARTIERETRO','ELEM','4',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','009',NULL,'DIF_FSED','OCC','16',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','009',NULL,'DIF_FSED_PARTIERETRO','OCC','16',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','010',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','011',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','012',NULL,'DIF_FSED','VALEUR','40',NULL,'FALSE',NULL,'FORMATAGE_TYPE_DONNEE_VALEUR'
'29_30_DIF_FSED_RETRO','RD','SELECT','012',NULL,'DIF_FSED_PARTIERETRO','VALEUR','40',NULL,'FALSE',NULL,'FORMATAGE_TYPE_DONNEE_VALEUR'
'29_30_DIF_FSED','RD','SELECT','013',NULL,'DIF_FSED','TYPE_DONNEE','1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','013',NULL,'DIF_FSED_PARTIERETRO','TYPE_DONNEE','1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','014',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,'FORMATAGE_COMPLEMENT_DESCRIPTIF_FROM_TYPE_DONNEE'
'29_30_DIF_FSED','RD','SELECT','015',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','016',NULL,NULL,NULL,'75',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','017',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'29_30_DIF_FSED','RD','SELECT','018',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'29_30_DIF_FSED','RD','SELECT','019',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'29_30_DIF_FSED','RD','SELECT','020',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','021','DIF_FSED',NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED_RETRO','RD','SELECT','021','DIF_FSED_PARTIERETRO',NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','022',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'29_30_DIF_FSED','RD','SELECT','023',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'29_30_DIF_FSED','RD','SELECT','024',NULL,'DIF_FSED','DTEFFET','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')','FORMATAGE_DATE_EFFET'
'29_30_DIF_FSED_RETRO','RD','SELECT','024',NULL,'DIF_FSED_PARTIERETRO','DTEFFET','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')','FORMATAGE_DATE_EFFET'
'29_30_DIF_FSED','RD','SELECT','025',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'29_30_DIF_FSED_RETRO','RD','SELECT','025',NULL,'DIF_FSED_PARTIERETRO','PERIODE','6',0,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','026',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','027','TT',NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','028',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','029',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','030',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'29_30_DIF_FSED','RD','SELECT','031',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT','032',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'29_30_DIF_FSED','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,'4',NULL,'FALSE','/*+ FULL(DIF_FSED)*/ TGE_REF_DICOZ.MASQUE',NULL
'29_30_DIF_FSED_RETRO','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,'4',NULL,'FALSE','/*+ FULL(DIF_FSED_PARTIERETRO)*/ TGE_REF_DICOZ.MASQUE',NULL
'29_30_DIF_FSED','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,'4',NULL,'FALSE','DIF_FSED.CODEOP',NULL
'29_30_DIF_FSED_RETRO','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,'4',NULL,'FALSE','DIF_FSED_PARTIERETRO.CODEOP',NULL
'29_30_DIF_FSED','RD','SELECT_EN_PLUS','003',NULL,NULL,NULL,'4',NULL,'FALSE','TO_CHAR(DAC.DSDCN,''YYYYMMDD'') as DSDCN',NULL
'29_30_DIF_FSED','RD','SELECT_EN_PLUS','004',NULL,NULL,NULL,'4',NULL,'FALSE','DIF_FSED.CLE',NULL
'29_30_DIF_FSED_RETRO','RD','SELECT_EN_PLUS','004',NULL,NULL,NULL,'4',NULL,'FALSE','DIF_FSED_PARTIERETRO.CLE',NULL
'29_30_DIF_FSED','RD','FROM','003',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_DICOZ',NULL
'29_30_DIF_FSED','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'DIF_FSED',NULL
'29_30_DIF_FSED_RETRO','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'DIF_FSED_PARTIERETRO',NULL
'29_30_DIF_FSED','RD','FROM_WITH','001',NULL,DAC,NULL,NULL,NULL,NULL,'WITH DAC AS (select /*+ MATERIALIZE */ C.MATRIC,C.PACMAT,max(DACS.CODE_CHRONO) CODE_CHRONO,DACH.PAIEZAD,min(C.DSDCN) DSDCN,max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO from DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH, GAP_TRT_LISTE_MAT L where C.NUMPAC=@@@NUMPAC@@@ and DACH.NUMPAC=@@@NUMPAC@@@ and C.NUMPAC=DACH.NUMPAC and C.PACMAT=DACH.PACMAT and C.NUMCNT=DACH.NUMCNT and C.NUMPAC=DACS.NUMPAC and C.PACMAT=DACS.PACMAT and C.NUMCNT=DACS.NUMCNT and DACH.date_eff = (select MAX(dach2.DATE_EFF) from DIC_ADM_CONTRAT_HISTO dach2 where dach2.numpac =@@@NUMPAC@@@ and c.numpac = dach2.numpac and c.pacmat = dach2.pacmat and c.numcnt = dach2.numcnt and dach2.DATE_EFF <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm''))) and C.DSDCN <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH.DATE_SORTIE_SIT_BO >= add_months((to_date(@@@PERIODE_PAIE@@@,''yyyymm'')),-@@@NB_MOIS_PAIE_INIT@@@) and L.ID_TRT=@@@ID_TRT@@@ and L.NUMPAC=@@@NUMPAC@@@ and C.PACMAT=L.PACMAT and NVL(DACH.DRPAI2, ''B'') <> ''B'' and C.NATCOL IN (''SAL'',''STA'') group by C.MATRIC,C.PACMAT,DACH.PAIEZAD)',NULL
'29_30_DIF_FSED','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'DIF_FSED.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'DIF_FSED_PARTIERETRO.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_DIF_FSED','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_REF_DICOZ.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_DIF_FSED','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED_PARTIERETRO.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_DIF_FSED','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED.ID_TRT = @@@ID_TRT@@@',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED_PARTIERETRO.ID_TRT = @@@ID_TRT@@@',NULL
'29_30_DIF_FSED','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED.PAIEZAD = DAC.PAIEZAD',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED_PARTIERETRO.PAIEZAD = DAC.PAIEZAD',NULL
'29_30_DIF_FSED','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED.ELEM = TGE_REF_DICOZ.ELEMENT',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED_PARTIERETRO.ELEM = TGE_REF_DICOZ.ELEMENT',NULL
'29_30_DIF_FSED','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED.PAIEZAD not in (select PAIEZAD from DELETED_PAIEZAD where NUMPAC = @@@NUMPAC@@@)',NULL
'29_30_DIF_FSED_RETRO','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,'and DIF_FSED_PARTIERETRO.PAIEZAD not in (select PAIEZAD from DELETED_PAIEZAD where NUMPAC = @@@NUMPAC@@@)',NULL
'29_30_DIF_FSED','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'PAIEZAD,ELEM,CLE,CODEOP,OCC',NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','001',NULL,'TGE_ELEMENTS_PAIE','NUMPAC','6','0','FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','002','30',NULL,NULL,'2','0','FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','004',NULL,'TGE_ELEMENTS_PAIE','PAIEZAD','8','0','TRUE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','007',NULL,'TGE_ELEMENTS_PAIE','CODE_ELEMENT','4',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','009',NULL,'TGE_ELEMENTS_PAIE','INDICATIF','16',NULL,'FALSE',NULL,'FORMATAGE_INDICATIF'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','010',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','011',NULL,'TGE_ELEMENTS_PAIE','SENS','1',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','012',NULL,'TGE_ELEMENTS_PAIE','VALEUR','40',NULL,'FALSE',NULL,'FORMATAGE_TYPE_VALEUR'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','013',NULL,'TGE_REF_DICOZ','TYPE','1',NULL,'FALSE',NULL,'FORMATAGE_TYPE'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','014',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,'FORMATAGE_COMPLEMENT_DESCRIPTIF_FROM_TYPE'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','015',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','016',NULL,NULL,NULL,'75',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','017',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','018',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','019',NULL,'TGE_ELEMENTS_PAIE','ORIGINE','1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','020',NULL,'TGE_ELEMENTS_PAIE','CODE_REMPLACEMENT','1',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','021',NULL,'TGE_ELEMENTS_PAIE','LOGIN_MAJ','8',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','022',NULL,'TGE_ELEMENTS_PAIE','DATE_MAJ','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','023',NULL,'TGE_ELEMENTS_PAIE','DATE_MAJ','6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','024',NULL,'TGE_ELEMENTS_PAIE','DATE_EFFET','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','025',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'29_30_TGE_ELEMENT_PAIE_RETRO','RD','SELECT','025',NULL,'TGE_ELEMENTS_PAIE','PERIODE','6',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','026',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','027','TT',NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','028',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','029',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','030',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','031',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT','032',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,'4',NULL,'FALSE','TGE_REF_DICOZ.MASQUE',NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,'4',NULL,'FALSE','TGE_ELEMENTS_PAIE.DERNIER_CODE_OPE',NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT_EN_PLUS','003',NULL,NULL,NULL,'4',NULL,'FALSE','TO_CHAR(DAC.DSDCN,''YYYYMMDD'') as DSDCN',NULL
'29_30_TGE_ELEMENT_PAIE','RD','SELECT_EN_PLUS','004',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'29_30_TGE_ELEMENT_PAIE','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(select C.MATRIC,C.PACMAT,max(DACS.CODE_CHRONO) CODE_CHRONO,DACH.PAIEZAD,min(C.DSDCN) DSDCN,max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO from DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH, GAP_TRT_LISTE_MAT L where C.NUMPAC=@@@NUMPAC@@@ and DACH.NUMPAC=@@@NUMPAC@@@ and C.NUMPAC=DACH.NUMPAC and C.PACMAT=DACH.PACMAT and C.NUMCNT=DACH.NUMCNT and C.NUMPAC=DACS.NUMPAC and C.PACMAT=DACS.PACMAT and C.NUMCNT=DACS.NUMCNT and DACH.date_eff = (select MAX(dach2.DATE_EFF) from DIC_ADM_CONTRAT_HISTO dach2 where dach2.numpac =@@@NUMPAC@@@ and c.numpac = dach2.numpac and c.pacmat = dach2.pacmat and c.numcnt = dach2.numcnt and dach2.DATE_EFF <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm''))) and C.DSDCN <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH.DATE_SORTIE_SIT_BO >= add_months((to_date(@@@PERIODE_PAIE@@@,''yyyymm'')),-17) and L.ID_TRT=@@@ID_TRT@@@ and L.NUMPAC=@@@NUMPAC@@@ and C.PACMAT=L.PACMAT group by C.MATRIC,C.PACMAT,DACH.PAIEZAD) DAC',NULL
'29_30_TGE_ELEMENT_PAIE','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_ELEMENTS_PAIE',NULL
'29_30_TGE_ELEMENT_PAIE','RD','FROM','003',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_DICOZ',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_ELEMENTS_PAIE.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_REF_DICOZ.NUMPAC = @@@NUMPAC@@@',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_ELEMENTS_PAIE.PAIEZAD = DAC.PAIEZAD ',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_ELEMENTS_PAIE.CODE_ELEMENT = TGE_REF_DICOZ.ELEMENT ',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_ELEMENTS_PAIE.DERNIER_CODE_OPE <> ''S''',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_ELEMENTS_PAIE.ORIGINE is null or TGE_ELEMENTS_PAIE.ORIGINE = ''T'' or TGE_ELEMENTS_PAIE.ORIGINE in ( select CODE_ORIGINE from TGE_REF_ORIGINE_GTA where NUMPAC = @@@NUMPAC@@@ and (MODE_3060 = ''W'' or ( MODE_3060 = ''R'' and ENVOI_MODE_R = ''O'' )))) or TGE_ELEMENTS_PAIE.CODE_REMPLACEMENT is not null) ',NULL
'29_30_TGE_ELEMENT_PAIE','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,' and TGE_ELEMENTS_PAIE.PERIODE @@@OPERARTEUR_RETRO@@@ @@@PERIODE_PAIE@@@',NULL
'29_30_TGE_ELEMENT_PAIE_RETRO','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,' AND TGE_ELEMENTS_PAIE.PERIODE in (SELECT PERIODE_RETRO FROM GAP_RETRO_MATRIC G WHERE G.NUMPAC=TGE_ELEMENTS_PAIE.NUMPAC AND G.numpac||G.pacmat=TGE_ELEMENTS_PAIE.idpacmat union all select periode_retro from gap_selection_retro S where S.NUMPAC=TGE_ELEMENTS_PAIE.NUMPAC AND  S.numpac||S.pacmat=TGE_ELEMENTS_PAIE.idpacmat) AND TGE_ELEMENTS_PAIE.ACTION_RETRO is not null ',NULL
'29_30_TGE_ELEMENT_PAIE','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD, TGE_ELEMENTS_PAIE.CODE_ELEMENT',NULL
'40','RD','SELECT','001',NULL,'TGE_INCIDENTS_PAIE','NUMPAC','6','0','FALSE',NULL,NULL
'40','RD','SELECT','002','40',NULL,NULL,'2','0','FALSE',NULL,NULL
'40','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','004',NULL,'TGE_INCIDENTS_PAIE','PAIEZAD','8','0','TRUE',NULL,NULL
'40','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','007',NULL,'TGE_INCIDENTS_PAIE','DATE_EFFET','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'40','RD','SELECT','008',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','009',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','010',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','011',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','012',NULL,'TGE_INCIDENTS_PAIE','TYPE_IP','1',NULL,'FALSE','CASE WHEN @COLONNE_CIBLE@ = ''R'' THEN ''R'' WHEN @COLONNE_CIBLE@ = ''T'' THEN ''T'' ELSE '' '' END',NULL
'40','RD','SELECT','013',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','014','F',NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','015',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','016',NULL,'TGE_INCIDENTS_PAIE','HEURES_T','5','0','TRUE','CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''P'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''T'') THEN '' '' ELSE nvl(TO_CHAR(TGE_INCIDENTS_PAIE.HEURES),'' '') END','FORMATAGE_40_HEURES_TRAVAILLEES'
'40','RD','SELECT','017',NULL,'TGE_INCIDENTS_PAIE','TEMOIN_HT','1','0','FALSE','CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''R'') and TGE_INCIDENTS_PAIE.HEURES is not null  THEN ''1'' ELSE ''0'' END',NULL
'40','RD','SELECT','018',NULL,'TGE_INCIDENTS_PAIE','HEURES_I','5','0','TRUE','CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''R'') THEN '' '' ELSE nvl(TO_CHAR(TGE_INCIDENTS_PAIE.HEURES),'' '') END','FORMATAGE_40_HEURES_INCIDENT'
'40','RD','SELECT','019',NULL,'TGE_INCIDENTS_PAIE','TEMOIN_HI','1','0','FALSE','CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''P'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''T'') and TGE_INCIDENTS_PAIE.HEURES is not null  THEN ''1'' WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''P'') and CODE_IP is not null THEN ''1'' ELSE ''0'' END',NULL
'40','RD','SELECT','020',NULL,'TGE_INCIDENTS_PAIE','CODE_IP','5',NULL,'FALSE','CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''P'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''T'') THEN to_char(TGE_INCIDENTS_PAIE.CODE_IP) ELSE '' '' END',NULL
'40','RD','SELECT','021',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','022',NULL,'TGE_INCIDENTS_PAIE','CODE_IMPUTATION','18',NULL,'FALSE',NULL,'FORMATAGE_40_IMPUTATION'
'40','RD','SELECT','023',NULL,'TGE_INCIDENTS_PAIE','DOM_IMPUTATION','1',NULL,'FALSE','CASE WHEN TGE_INCIDENTS_PAIE.CODE_IMPUTATION is null THEN '''' ELSE CASE WHEN (TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' or TGE_INCIDENTS_PAIE.TYPE_IP = ''P'') THEN ''1'' WHEN TGE_INCIDENTS_PAIE.TYPE_IP = ''R'' THEN ''H'' ELSE '' '' END END',NULL
'40','RD','SELECT','024',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','025',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','026',NULL,NULL,NULL,'73',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','027',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'40','RD','SELECT','028',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'40','RD','SELECT','029',NULL,'TGE_INCIDENTS_PAIE','ORIGINE','1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'40','RD','SELECT','030',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','031',NULL,'TGE_INCIDENTS_PAIE','LOGIN_MAJ','8',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','032',NULL,'TGE_INCIDENTS_PAIE','DATE_MAJ','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'40','RD','SELECT','033',NULL,'TGE_INCIDENTS_PAIE','DATE_MAJ','6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'40','RD','SELECT','034',NULL,'TGE_INCIDENTS_PAIE','DATE_EFFET','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'40','RD','SELECT','035',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'40_RETRO','RD','SELECT','035',NULL,'TGE_INCIDENTS_PAIE','PERIODE','6',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','036',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','037',NULL,'TGE_INCIDENTS_PAIE','TYPE_TRAITEMENT','2',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','038',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','039',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'40','RD','SELECT','040',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'40','RD','SELECT','041',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'40','RD','SELECT','042',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'40','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_INCIDENTS_PAIE.TYPE_IP as TYPE_IP_FROM_TABLE',NULL
'40','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_INCIDENTS_PAIE.CODE_IP as CODE_IP_FROM_TABLE',NULL
'40','RD','SELECT_EN_PLUS','003',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'40','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(select C.MATRIC,C.PACMAT,max(DACS.CODE_CHRONO) CODE_CHRONO,DACH.PAIEZAD,min(C.DSDCN) DSDCN,max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO from DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH, GAP_TRT_LISTE_MAT L where C.NUMPAC=@@@NUMPAC@@@ and DACH.NUMPAC=@@@NUMPAC@@@ and C.NUMPAC=DACH.NUMPAC and C.PACMAT=DACH.PACMAT and C.NUMCNT=DACH.NUMCNT and C.NUMPAC=DACS.NUMPAC and C.PACMAT=DACS.PACMAT and C.NUMCNT=DACS.NUMCNT and DACH.date_eff = (select MAX(dach2.DATE_EFF) from DIC_ADM_CONTRAT_HISTO dach2 where dach2.numpac =@@@NUMPAC@@@ and c.numpac = dach2.numpac and c.pacmat = dach2.pacmat and c.numcnt = dach2.numcnt and dach2.DATE_EFF <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm''))) and C.DSDCN <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH.DATE_SORTIE_SIT_BO >= add_months((to_date(@@@PERIODE_PAIE@@@,''yyyymm'')),-17) and L.ID_TRT=@@@ID_TRT@@@ and L.NUMPAC=@@@NUMPAC@@@ and C.PACMAT=L.PACMAT group by C.MATRIC,C.PACMAT,DACH.PAIEZAD) DAC',NULL
'40','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_INCIDENTS_PAIE',NULL
'40','RD','FROM','003',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC',NULL
'40','RD','FROM','004',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_PERIODE_RECUEIL_PAIEZAD',NULL
'40','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_INCIDENTS_PAIE.NUMPAC = @@@NUMPAC@@@',NULL
'40','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_REF_PAC.NUMPAC = @@@NUMPAC@@@',NULL
'40','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_INCIDENTS_PAIE.PAIEZAD = DAC.PAIEZAD  ',NULL
'40','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and (TGE_INCIDENTS_PAIE.TYPE_IP <> ''T'' or (TGE_INCIDENTS_PAIE.TYPE_IP=''T'' and TGE_REF_PAC.ENVOI_HP = ''O''))',NULL
'40','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and (TGE_INCIDENTS_PAIE.ORIGINE is null or TGE_INCIDENTS_PAIE.ORIGINE = ''T'' or TGE_INCIDENTS_PAIE.ORIGINE in ( select CODE_ORIGINE from TGE_REF_ORIGINE_GTA where NUMPAC = @@@NUMPAC@@@ and (MODE_T2 = ''W'' or ( MODE_T2 = ''R'' and ENVOI_MODE_R = ''O'' )))) ',NULL
'40','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'//and TGE_INCIDENTS_PAIE.ORIGINE_CREATE <> ''BATCH''',NULL
'40','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,'and TO_CHAR(TGE_INCIDENTS_PAIE.PERIODE,''YYYYMM'') @@@OPERARTEUR_RETRO@@@ TGE_REF_PAC.PERIODEENCOURS',NULL
'40_RETRO','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,' and TO_CHAR(TGE_INCIDENTS_PAIE.PERIODE,''YYYYMM'') in (SELECT PERIODE_RETRO FROM GAP_RETRO_MATRIC G WHERE G.NUMPAC=TGE_INCIDENTS_PAIE.NUMPAC AND G.numpac||G.pacmat=TGE_INCIDENTS_PAIE.idpacmat union all select periode_retro from gap_selection_retro S where S.NUMPAC=TGE_INCIDENTS_PAIE.NUMPAC AND  S.numpac||S.pacmat=TGE_INCIDENTS_PAIE.idpacmat)',NULL
'40','RD','WHERE','008',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_INCIDENTS_PAIE.NUMPAC = TGE_PERIODE_RECUEIL_PAIEZAD.NUMPAC',NULL
'40','RD','WHERE','009',NULL,NULL,NULL,NULL,NULL,NULL,'and TO_CHAR(TGE_INCIDENTS_PAIE.PERIODE,''YYYYMM'') = TGE_PERIODE_RECUEIL_PAIEZAD.MOIS_PAIE',NULL
'40','RD','WHERE','010',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_INCIDENTS_PAIE.PAIEZAD = TGE_PERIODE_RECUEIL_PAIEZAD.PAIEZAD',NULL
'40','RD','WHERE','011',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_INCIDENTS_PAIE.TYPE_IP in (''A'',''P'',''R'')',NULL
'40','RD','WHERE','012',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_INCIDENTS_PAIE.TYPE_IP = ''A'' and TGE_PERIODE_RECUEIL_PAIEZAD.RETRO_GC = ''O'' and TGE_INCIDENTS_PAIE.CODE_IP in (select trp.CODE_INCIDENT as CODE_INCIDENT from TGE_REF_PRE trp, TGE_REF_TMA trt where trp.NUMPAC = @@@NUMPAC@@@ and trp.NUMPAC = trt.NUMPAC and trp.MOTIF_ABS = trt.MOTIF_ABS and trt.MOTIF_CNAM is not null))',NULL
'40','RD','WHERE','013',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PER_RECUEIL_RETRO <= TGE_INCIDENTS_PAIE.DATE_EFFET and TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_RECUEIL_RETRO >= TGE_INCIDENTS_PAIE.DATE_EFFET)',NULL
'40','RD','WHERE','014',NULL,NULL,NULL,NULL,NULL,NULL,'or (TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_RECUEIL_RETRO is null and TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PER_RECUEIL_RETRO <= TGE_INCIDENTS_PAIE.DATE_EFFET)))',NULL
'40','RD','WHERE','015',NULL,NULL,NULL,NULL,NULL,NULL,'or ((TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_RECUEIL_RETRO is null and TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PER_RECUEIL_RETRO <= TGE_INCIDENTS_PAIE.DATE_EFFET)',NULL
'40','RD','WHERE','016',NULL,NULL,NULL,NULL,NULL,NULL,'or (TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PER_RECUEIL_RETRO <= TGE_INCIDENTS_PAIE.DATE_EFFET and TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_RECUEIL_RETRO >= TGE_INCIDENTS_PAIE.DATE_EFFET)))',NULL
'40','RD','WHERE','017',NULL,NULL,NULL,NULL,NULL,NULL,'or (TGE_INCIDENTS_PAIE.TYPE_IP = ''T''',NULL
'40','RD','WHERE','018',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PER_GENERATION_HP <= TGE_INCIDENTS_PAIE.DATE_EFFET and TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_GENERATION_HP >= TGE_INCIDENTS_PAIE.DATE_EFFET)',NULL 
'40','RD','WHERE','019',NULL,NULL,NULL,NULL,NULL,NULL,'or (TGE_PERIODE_RECUEIL_PAIEZAD.FIN_PER_GENERATION_HP  is null and TGE_PERIODE_RECUEIL_PAIEZAD.DEBUT_PERIODE_RECUEIL <= TGE_INCIDENTS_PAIE.DATE_EFFET))))',NULL
'40','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD,TGE_INCIDENTS_PAIE.DATE_EFFET',NULL
'60','RD','SELECT','001',NULL,'TGE_DONNEES_PAIE','NUMPAC','6','0','FALSE',NULL,NULL
'60','RD','SELECT','002','60',NULL,NULL,'2','0','FALSE',NULL,NULL
'60','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','004',NULL,'DAC','PAIEZAD','8','0','TRUE',NULL,NULL
'60','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','007',NULL,'TGE_DONNEES_PAIE','CODE_RUBRIQUE','4',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','009',NULL,'TGE_DONNEES_PAIE','MONTANT','13','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(100)'
'60','RD','SELECT','010',NULL,'TGE_DONNEES_PAIE','MONTANT','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'60','RD','SELECT','011',NULL,'TGE_DONNEES_PAIE','NOMBRE','15','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(10000)'
'60','RD','SELECT','012',NULL,'TGE_DONNEES_PAIE','NOMBRE','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'60','RD','SELECT','013',NULL,'TGE_DONNEES_PAIE','TAUX','15','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(10000)'
'60','RD','SELECT','014',NULL,'TGE_DONNEES_PAIE','TAUX','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'60','RD','SELECT','015',NULL,'TGE_DONNEES_PAIE','POURCENTAGE','6',NULL,'FALSE',NULL,'FORMATAGE_MULTIPLI_VALEUR(1000)'
'60','RD','SELECT','016',NULL,'TGE_DONNEES_PAIE','DOMAINE_PRCTE','1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','017',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','018',NULL,'TGE_DONNEES_PAIE','SENS','1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','019',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','020',NULL,'TGE_DONNEES_PAIE','CODE_IMPUTATION','18',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','021',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','022',NULL,'TGE_DONNEES_PAIE','CODE_CAISSE','10',NULL,'FALSE',NULL,'VALEUR_CONDITIONNEE_AVEC_AUTRE_COLONNE(TYPE_DONNEE;3;CODE_CAISSE;)'
'60','RD','SELECT','023',NULL,NULL,NULL,'22',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','024',NULL,'TGE_DONNEES_PAIE','DATE_DEB_ARRET','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'60','RD','SELECT','025',NULL,'TGE_DONNEES_PAIE','PERIODE_RATTACH_DEB','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'60','RD','SELECT','026',NULL,'TGE_DONNEES_PAIE','PERIODE_RATTACH_FIN','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'60','RD','SELECT','027',NULL,NULL,NULL,'9',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','028',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'60','RD','SELECT','029',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'60','RD','SELECT','030',NULL,'TGE_DONNEES_PAIE','ORIGINE','1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'60','RD','SELECT','031',NULL,'TGE_DONNEES_PAIE','CODE_REMPLACEMENT','1',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','032',NULL,'TGE_DONNEES_PAIE','LOGIN_MAJ','8',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','033',NULL,'TGE_DONNEES_PAIE','DATE_MAJ','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'60','RD','SELECT','034',NULL,'TGE_DONNEES_PAIE','DATE_MAJ','6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'60','RD','SELECT','035',NULL,'TGE_DONNEES_PAIE','DATE_EFFET','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'60','RD','SELECT','036',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'60_RETRO','RD','SELECT','036',NULL,'TGE_DONNEES_PAIE','PERIODE','6',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','037',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','038',NULL,'TGE_DONNEES_PAIE','TYPE_TRAITEMENT','2',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','039',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','040',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'60','RD','SELECT','041',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'60','RD','SELECT','042',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'60','RD','SELECT','043',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'60','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE.TYPE_DONNEE',NULL
'60','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'60','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(select C.MATRIC,C.PACMAT,max(DACS.CODE_CHRONO) CODE_CHRONO,DACH.PAIEZAD,min(C.DSDCN) DSDCN,max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO from DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH, GAP_TRT_LISTE_MAT L where C.NUMPAC=@@@NUMPAC@@@ and DACH.NUMPAC=@@@NUMPAC@@@ and C.NUMPAC=DACH.NUMPAC and C.PACMAT=DACH.PACMAT and C.NUMCNT=DACH.NUMCNT and C.NUMPAC=DACS.NUMPAC and C.PACMAT=DACS.PACMAT and C.NUMCNT=DACS.NUMCNT and DACH.date_eff = (select MAX(dach2.DATE_EFF) from DIC_ADM_CONTRAT_HISTO dach2 where dach2.numpac =@@@NUMPAC@@@ and c.numpac = dach2.numpac and c.pacmat = dach2.pacmat and c.numcnt = dach2.numcnt and dach2.DATE_EFF <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm''))) and C.DSDCN <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH.DATE_SORTIE_SIT_BO >= add_months((to_date(@@@PERIODE_PAIE@@@,''yyyymm'')),-17) and L.ID_TRT=@@@ID_TRT@@@ and L.NUMPAC=@@@NUMPAC@@@ and C.PACMAT=L.PACMAT group by C.MATRIC,C.PACMAT,DACH.PAIEZAD) DAC',NULL
'60','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE',NULL
'60','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE.NUMPAC = @@@NUMPAC@@@',NULL
'60','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.TYPE_DONNEE = ''1''',NULL
'60','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.DERNIER_CODE_OPE <> ''S''',NULL
'60','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.PAIEZAD = DAC.PAIEZAD',NULL
'60','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_DONNEES_PAIE.ORIGINE is null or TGE_DONNEES_PAIE.ORIGINE = ''T'' or TGE_DONNEES_PAIE.ORIGINE in ( select CODE_ORIGINE from TGE_REF_ORIGINE_GTA where NUMPAC = @@@NUMPAC@@@ and (MODE_3060 = ''W'' or ( MODE_3060 = ''R'' and ENVOI_MODE_R = ''O'' )))) or TGE_DONNEES_PAIE.CODE_REMPLACEMENT is not null)',NULL
'60','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.PERIODE @@@OPERARTEUR_RETRO@@@ (SELECT PERIODEENCOURS FROM TGE_REF_PAC WHERE NUMPAC = @@@NUMPAC@@@)',NULL
'60_RETRO','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,' and TGE_DONNEES_PAIE.PERIODE in (SELECT PERIODE_RETRO FROM GAP_RETRO_MATRIC G WHERE G.NUMPAC=TGE_DONNEES_PAIE.NUMPAC AND G.numpac||G.pacmat=TGE_DONNEES_PAIE.idpacmat union all select periode_retro from gap_selection_retro S where S.NUMPAC=TGE_DONNEES_PAIE.NUMPAC AND  S.numpac||S.pacmat=TGE_DONNEES_PAIE.idpacmat) AND TGE_DONNEES_PAIE.ACTION_RETRO is not null ',NULL
'60','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD,TGE_DONNEES_PAIE.CODE_RUBRIQUE',NULL
'70','RD','SELECT','001',NULL,'TGE_DONNEES_PAIE','NUMPAC','6','0','FALSE',NULL,NULL
'70','RD','SELECT','002','70',NULL,NULL,'2','0','FALSE',NULL,NULL
'70','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','004',NULL,'TGE_DONNEES_PAIE','PAIEZAD','8','0','TRUE',NULL,NULL
'70','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','007',NULL,'TGE_DONNEES_PAIE','CODE_RUBRIQUE','4',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','009',NULL,'TGE_DONNEES_PAIE','MONTANT','13','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(100)'
'70','RD','SELECT','010',NULL,'TGE_DONNEES_PAIE','MONTANT','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'70','RD','SELECT','011',NULL,'TGE_DONNEES_PAIE','NOMBRE','15','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(10000)'
'70','RD','SELECT','012',NULL,'TGE_DONNEES_PAIE','NOMBRE','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'70','RD','SELECT','013',NULL,'TGE_DONNEES_PAIE','TAUX','15','0','TRUE',NULL,'FORMATAGE_MULTIPLI_VALEUR(10000)'
'70','RD','SELECT','014',NULL,'TGE_DONNEES_PAIE','TAUX','1',NULL,'FALSE',NULL,'VALEUR_CONDITIONEE(NULL;0;1) '
'70','RD','SELECT','015',NULL,'TGE_DONNEES_PAIE','POURCENTAGE','6',NULL,'FALSE',NULL,'FORMATAGE_MULTIPLI_VALEUR(1000)'
'70','RD','SELECT','016',NULL,'TGE_DONNEES_PAIE','DOMAINE_PRCTE','1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','017',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','018',NULL,'TGE_DONNEES_PAIE','SENS','1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','019',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','020',NULL,'TGE_DONNEES_PAIE','CODE_IMPUTATION','18',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','021',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','022',NULL,'TGE_DONNEES_PAIE','CODE_CAISSE','10',NULL,'FALSE',NULL,'VALEUR_CONDITIONNEE_AVEC_AUTRE_COLONNE(TYPE_DONNEE;3;CODE_CAISSE;)'
'70','RD','SELECT','023',NULL,NULL,NULL,'22',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','024',NULL,'TGE_DONNEES_PAIE','DATE_DEB_ARRET','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'70','RD','SELECT','025',NULL,'TGE_DONNEES_PAIE','PERIODE_RATTACH_DEB','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'70','RD','SELECT','026',NULL,'TGE_DONNEES_PAIE','PERIODE_RATTACH_FIN','8',NULL,'FALSE','TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')',NULL
'70','RD','SELECT','027',NULL,'TGE_DONNEES_PAIE','PERIODE_AFFECTATION','9',NULL,'FALSE','CASE WHEN ( nvl(TO_CHAR(@COLONNE_CIBLE@,''YYYYMM''),'''') is null) THEN '''' ELSE CASE WHEN (TGE_REF_PAC.MPE=''S'') THEN TO_CHAR(@COLONNE_CIBLE@,''YYYYMMDD'')||'' '' ELSE TO_CHAR(@COLONNE_CIBLE@,''YYYYMM'')||''001'' END END',NULL
'70','RD','SELECT','028',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'70','RD','SELECT','029',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'70','RD','SELECT','030',NULL,'TGE_DONNEES_PAIE','ORIGINE','1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'70','RD','SELECT','031',NULL,'TGE_DONNEES_PAIE','CODE_REMPLACEMENT','1',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','032',NULL,'TGE_DONNEES_PAIE','LOGIN_MAJ','8',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','033',NULL,'TGE_DONNEES_PAIE','DATE_MAJ','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'70','RD','SELECT','034',NULL,'TGE_DONNEES_PAIE','DATE_MAJ','6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'70','RD','SELECT','035',NULL,'TGE_DONNEES_PAIE','DATE_EFFET','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'70','RD','SELECT','036',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'70_RETRO','RD','SELECT','036',NULL,'TGE_DONNEES_PAIE','PERIODE','6',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','037',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','038',NULL,'TGE_DONNEES_PAIE','TYPE_TRAITEMENT','2',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','039',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','040',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'70','RD','SELECT','041',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'70','RD','SELECT','042',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'70','RD','SELECT','043',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'70','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE.TYPE_DONNEE',NULL
'70','RD','SELECT_EN_PLUS','002',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'70','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(select C.MATRIC,C.PACMAT,max(DACS.CODE_CHRONO) CODE_CHRONO,DACH.PAIEZAD,min(C.DSDCN) DSDCN,max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO from DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH, GAP_TRT_LISTE_MAT L where C.NUMPAC=@@@NUMPAC@@@ and DACH.NUMPAC=@@@NUMPAC@@@ and C.NUMPAC=DACH.NUMPAC and C.PACMAT=DACH.PACMAT and C.NUMCNT=DACH.NUMCNT and C.NUMPAC=DACS.NUMPAC and C.PACMAT=DACS.PACMAT and C.NUMCNT=DACS.NUMCNT and DACH.date_eff = (select MAX(dach2.DATE_EFF) from DIC_ADM_CONTRAT_HISTO dach2 where dach2.numpac =@@@NUMPAC@@@ and c.numpac = dach2.numpac and c.pacmat = dach2.pacmat and c.numcnt = dach2.numcnt and dach2.DATE_EFF <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm''))) and C.DSDCN <=last_day(to_date(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH.DATE_SORTIE_SIT_BO >= add_months((to_date(@@@PERIODE_PAIE@@@,''yyyymm'')),-17) and L.ID_TRT=@@@ID_TRT@@@ and L.NUMPAC=@@@NUMPAC@@@ and C.PACMAT=L.PACMAT group by C.MATRIC,C.PACMAT,DACH.PAIEZAD) DAC',NULL
'70','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE',NULL
'70','RD','FROM','003',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC',NULL
'70','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_DONNEES_PAIE.NUMPAC = @@@NUMPAC@@@',NULL
'70','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_REF_PAC.NUMPAC = @@@NUMPAC@@@',NULL
'70','RD','WHERE','003',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.TYPE_DONNEE in (''2'',''3'')',NULL
'70','RD','WHERE','004',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.DERNIER_CODE_OPE <> ''S''',NULL
'70','RD','WHERE','005',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.PAIEZAD = DAC.PAIEZAD',NULL
'70','RD','WHERE','006',NULL,NULL,NULL,NULL,NULL,NULL,'and ((TGE_DONNEES_PAIE.ORIGINE is null or TGE_DONNEES_PAIE.ORIGINE = ''T'' or TGE_DONNEES_PAIE.ORIGINE in ( select CODE_ORIGINE from TGE_REF_ORIGINE_GTA where NUMPAC = @@@NUMPAC@@@ and (MODE_3060 = ''W'' or ( MODE_3060 = ''R'' and ENVOI_MODE_R = ''O'' )))) or TGE_DONNEES_PAIE.CODE_REMPLACEMENT is not null)',NULL
'70','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,'and TGE_DONNEES_PAIE.PERIODE @@@OPERARTEUR_RETRO@@@ (SELECT PERIODEENCOURS FROM TGE_REF_PAC WHERE NUMPAC = @@@NUMPAC@@@)',NULL
'70_RETRO','RD','WHERE','007',NULL,NULL,NULL,NULL,NULL,NULL,' and TGE_DONNEES_PAIE.PERIODE in (SELECT PERIODE_RETRO FROM GAP_RETRO_MATRIC G WHERE G.NUMPAC=TGE_DONNEES_PAIE.NUMPAC AND G.numpac||G.pacmat=TGE_DONNEES_PAIE.idpacmat union all select periode_retro from gap_selection_retro S where S.NUMPAC=TGE_DONNEES_PAIE.NUMPAC AND  S.numpac||S.pacmat=TGE_DONNEES_PAIE.idpacmat) AND TGE_DONNEES_PAIE.ACTION_RETRO is not null ',NULL
'70','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD,TGE_DONNEES_PAIE.CODE_RUBRIQUE',NULL
'ANNULATION','RD','SELECT','001',NULL,'TGE_REF_PAC','NUMPAC','6','0','FALSE',NULL,NULL
'ANNULATION','RD','SELECT','002','30',NULL,NULL,'2','0','FALSE',NULL,NULL
'ANNULATION','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','004',NULL,'DAC','PAIEZAD','8','0','TRUE',NULL,NULL
'ANNULATION','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','007','££££',NULL,NULL,'4','0','FALSE',NULL,NULL
'ANNULATION','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','009',NULL,NULL,NULL,'16',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','010',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','011',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','012',NULL,NULL,NULL,'40',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','013',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','014',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','015',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','016',NULL,NULL,NULL,'75',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','017',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'ANNULATION','RD','SELECT','018',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'ANNULATION','RD','SELECT','019',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'ANNULATION','RD','SELECT','020',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','021','DIF_FSED',NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','022',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'ANNULATION','RD','SELECT','023',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'ANNULATION','RD','SELECT','024',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie;01)'
'ANNULATION_RETRO','RD','SELECT','024',NULL,'DAC','PERIODE','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'ANNULATION','RD','SELECT','025',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'ANNULATION_RETRO','RD','SELECT','025',NULL,'DAC','PERIODE','6',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','026',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','027','TT',NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','028',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','029',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT','030',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'ANNULATION','RD','SELECT','031',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'ANNULATION','RD','SELECT','032',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'ANNULATION','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'ANNULATION','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(WITH TABLE_DATES_EFF (PACMAT, NUMCNT, DATE_EFF) AS ( SELECT DISTINCT DACH2.PACMAT, DACH2.NUMCNT , MAX(DATE_EFF) OVER (PARTITION BY L.NUMPAC, L.PACMAT, DACH2.NUMCNT) FROM GAP_TRT_LISTE_MAT L, DIC_ADM_CONTRAT_HISTO DACH2 WHERE L.ID_TRT = @@@ID_TRT@@@ and L.NUMPAC = @@@NUMPAC@@@ and DACH2.NUMPAC = @@@NUMPAC@@@ and DACH2.PACMAT = L.PACMAT and DACH2.DATE_EFF <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')),-@@@NB_MOIS_PAIE_INIT@@@) ) SELECT C.PACMAT, DACH.PAIEZAD, C.MATRIC, MIN(C.DSDCN) DSDCN, MAX(DACS.CODE_CHRONO) CODE_CHRONO, max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO FROM TABLE_DATES_EFF T, DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH WHERE C.NUMPAC = @@@NUMPAC@@@ and DACS.NUMPAC = @@@NUMPAC@@@ and DACH.NUMPAC = @@@NUMPAC@@@ and C.PACMAT = T.PACMAT and C.NUMCNT = T.NUMCNT and DACH.PACMAT = T.PACMAT and DACH.NUMCNT = T.NUMCNT and DACH.DATE_EFF = T.DATE_EFF and DACS.PACMAT = T.PACMAT and DACS.NUMCNT = T.NUMCNT and DACS.PAIEZAD = DACH.PAIEZAD and C.DSDCN <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and NVL(DACH.DRPAI2, ''B'') <> ''B'' and C.NATCOL IN (''SAL'',''STA'') GROUP BY C.PACMAT, DACH.PAIEZAD, C.MATRIC ) DAC',NULL
'ANNULATION_RETRO','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(WITH TABLE_DATES_EFF (PACMAT, NUMCNT, DATE_EFF) AS ( SELECT DISTINCT DACH2.PACMAT, DACH2.NUMCNT , MAX(DATE_EFF) OVER (PARTITION BY L.NUMPAC, L.PACMAT, DACH2.NUMCNT) FROM GAP_TRT_LISTE_MAT L, DIC_ADM_CONTRAT_HISTO DACH2 WHERE L.ID_TRT = @@@ID_TRT@@@ and L.NUMPAC = @@@NUMPAC@@@ and DACH2.NUMPAC = @@@NUMPAC@@@ and DACH2.PACMAT = L.PACMAT and DACH2.DATE_EFF <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')),-@@@NB_MOIS_PAIE_INIT@@@) ) SELECT C.PACMAT, DACH.PAIEZAD, C.MATRIC,RETRO.PERIODE_RETRO AS PERIODE, MIN(C.DSDCN) DSDCN, MAX(DACS.CODE_CHRONO) CODE_CHRONO, max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO FROM TABLE_DATES_EFF T, DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH,GAP_RETRO_MATRIC RETRO WHERE C.NUMPAC = @@@NUMPAC@@@ and DACS.NUMPAC = @@@NUMPAC@@@ and DACH.NUMPAC = @@@NUMPAC@@@ and C.PACMAT = T.PACMAT and C.NUMCNT = T.NUMCNT and DACH.PACMAT = T.PACMAT and DACH.NUMCNT = T.NUMCNT and DACH.DATE_EFF = T.DATE_EFF and DACS.PACMAT = T.PACMAT and DACS.NUMCNT = T.NUMCNT and DACS.PAIEZAD = DACH.PAIEZAD and C.DSDCN <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and NVL(DACH.DRPAI2, ''B'') <> ''B'' and C.NATCOL IN (''SAL'',''STA'') AND RETRO.NUMPAC =C.NUMPAC  AND RETRO.PACMAT =C.PACMAT AND RETRO.PAIEZAD_RETRO=C.PAIEZAD GROUP BY C.PACMAT, DACH.PAIEZAD, C.MATRIC ,RETRO.PERIODE_RETRO) DAC',NULL
'ANNULATION','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC',NULL
'ANNULATION','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC.NUMPAC = @@@NUMPAC@@@',NULL
'ANNULATION','RD','WHERE','002',NULL,NULL,NULL,NULL,NULL,NULL,'and DAC.PAIEZAD not in (select PAIEZAD from DELETED_PAIEZAD where NUMPAC=@@@NUMPAC@@@)',NULL
'ANNULATION','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD',NULL
'W566','RD','SELECT','001',NULL,'TGE_REF_PAC','NUMPAC','6','0','FALSE',NULL,NULL
'W566','RD','SELECT','002','30',NULL,NULL,'2','0','FALSE',NULL,NULL
'W566','RD','SELECT','003',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','004',NULL,'DAC','PAIEZAD','8','0','TRUE',NULL,NULL
'W566','RD','SELECT','005',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','006',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','007','W566',NULL,NULL,'4','0','FALSE',NULL,NULL
'W566','RD','SELECT','008',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','009',NULL,NULL,NULL,'16',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','010',NULL,NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','011',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','012','200',NULL,NULL,'40',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','013','N',NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','014',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','015',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','016',NULL,NULL,NULL,'75',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','017',NULL,'DAC','PACMAT','8',NULL,'FALSE',NULL,'FORMATAGE_PACMAT'
'W566','RD','SELECT','018',NULL,'DAC','CODE_CHRONO','6',NULL,'FALSE',NULL,'FORMATAGE_CODE_CHRONO'
'W566','RD','SELECT','019',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(code_origine)'
'W566','RD','SELECT','020',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','021','DIF_FSED',NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','022',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'W566','RD','SELECT','023',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'FORMATAGE_DATE(HHMNSS)'
'W566','RD','SELECT','024',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie;01)'
'W566_RETRO','RD','SELECT','024',NULL,'DAC','PERIODE','8',NULL,'FALSE',NULL,'FORMATAGE_DATE(AAAAMMJJ)'
'W566','RD','SELECT','025',NULL,NULL,NULL,'6',NULL,'FALSE',NULL,'PARAM_ORIGINE(periode_paie)'
'W566_RETRO','RD','SELECT','025',NULL,'DAC','PERIODE','6',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','026',NULL,NULL,NULL,'8',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','027','TT',NULL,NULL,'2',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','028',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','029',NULL,NULL,NULL,'3',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT','030',NULL,NULL,NULL,'1',NULL,'FALSE',NULL,'PARAM_ORIGINE(TYPE_PAIE)'
'W566','RD','SELECT','031',NULL,NULL,NULL,'1','E','FALSE',NULL,NULL
'W566','RD','SELECT','032',NULL,NULL,NULL,'4',NULL,'FALSE',NULL,NULL
'W566','RD','SELECT_EN_PLUS','001',NULL,NULL,NULL,'4',NULL,'FALSE','DAC.CODE_CHRONO',NULL
'W566','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(WITH TABLE_DATES_EFF (PACMAT, NUMCNT, DATE_EFF) AS ( SELECT DISTINCT DACH2.PACMAT, DACH2.NUMCNT , MAX(DATE_EFF) OVER (PARTITION BY L.NUMPAC, L.PACMAT, DACH2.NUMCNT) FROM GAP_TRT_LISTE_MAT L, DIC_ADM_CONTRAT_HISTO DACH2 WHERE L.ID_TRT = @@@ID_TRT@@@ and L.NUMPAC = @@@NUMPAC@@@ and DACH2.NUMPAC = @@@NUMPAC@@@ and DACH2.PACMAT = L.PACMAT and DACH2.DATE_EFF <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')),-@@@NB_MOIS_PAIE_INIT@@@) ) SELECT C.PACMAT, DACH.PAIEZAD, C.MATRIC, MIN(C.DSDCN) DSDCN, MAX(DACS.CODE_CHRONO) CODE_CHRONO, max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO FROM TABLE_DATES_EFF T, DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH WHERE C.NUMPAC = @@@NUMPAC@@@ and DACS.NUMPAC = @@@NUMPAC@@@ and DACH.NUMPAC = @@@NUMPAC@@@ and C.PACMAT = T.PACMAT and C.NUMCNT = T.NUMCNT and DACH.PACMAT = T.PACMAT and DACH.NUMCNT = T.NUMCNT and DACH.DATE_EFF = T.DATE_EFF and DACS.PACMAT = T.PACMAT and DACS.NUMCNT = T.NUMCNT and DACS.PAIEZAD = DACH.PAIEZAD and C.DSDCN <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and NVL(DACH.DRPAI2, ''B'') <> ''B'' and C.NATCOL IN (''SAL'',''STA'') GROUP BY C.PACMAT, DACH.PAIEZAD, C.MATRIC ) DAC',NULL
'W566_RETRO','RD','FROM','001',NULL,NULL,NULL,NULL,NULL,NULL,'(WITH TABLE_DATES_EFF (PACMAT, NUMCNT, DATE_EFF) AS ( SELECT DISTINCT DACH2.PACMAT, DACH2.NUMCNT , MAX(DATE_EFF) OVER (PARTITION BY L.NUMPAC, L.PACMAT, DACH2.NUMCNT) FROM GAP_TRT_LISTE_MAT L, DIC_ADM_CONTRAT_HISTO DACH2 WHERE L.ID_TRT = @@@ID_TRT@@@ and L.NUMPAC = @@@NUMPAC@@@ and DACH2.NUMPAC = @@@NUMPAC@@@ and DACH2.PACMAT = L.PACMAT and DACH2.DATE_EFF <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and DACH2.DATE_SORTIE_SIT_BO >= ADD_MONTHS((TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')),-@@@NB_MOIS_PAIE_INIT@@@) ),date_R (mois) AS ( select trunc(ADD_MONTHS(TO_DATE(@@@PERIODE_PAIE@@@,''YYYYMM''),level-1-24),''month'') mois from dual connect by trunc(ADD_MONTHS(TO_DATE(@@@PERIODE_PAIE@@@,''YYYYMM''),level-1-24),''month'' )< TO_DATE(@@@PERIODE_PAIE@@@,''YYYYMM'')) SELECT C.PACMAT, DACH.PAIEZAD, C.MATRIC,to_char(D.mois,''yyyymm'') as periode, MIN(C.DSDCN) DSDCN, MAX(DACS.CODE_CHRONO) CODE_CHRONO, max(DACH.DATE_SORTIE_SIT_BO) DATE_SORTIE_SIT_BO FROM TABLE_DATES_EFF T, DIC_ADM_CONTRAT C, DIC_ADM_CONTRAT_SITU DACS, DIC_ADM_CONTRAT_HISTO DACH,date_R D WHERE C.NUMPAC = @@@NUMPAC@@@ and DACS.NUMPAC = @@@NUMPAC@@@ and DACH.NUMPAC = @@@NUMPAC@@@ and C.PACMAT = T.PACMAT and C.NUMCNT = T.NUMCNT and DACH.PACMAT = T.PACMAT and DACH.NUMCNT = T.NUMCNT and DACH.DATE_EFF = T.DATE_EFF and DACS.PACMAT = T.PACMAT and DACS.NUMCNT = T.NUMCNT and DACS.PAIEZAD = DACH.PAIEZAD and C.DSDCN <= LAST_DAY(TO_DATE(@@@PERIODE_PAIE@@@,''yyyymm'')) and NVL(DACH.DRPAI2, ''B'') <> ''B'' and C.NATCOL IN (''SAL'',''STA'')  AND D.mois >=trunc(to_date((select min(RETRO.PERIODE_RETRO) from  gap_retro_matric RETRO where RETRO.NUMPAC=C.NUMPAC AND RETRO.PACMAT =C.PACMAT AND RETRO.PAIEZAD_RETRO=C.PAIEZAD),''YYYYMM''),''month'') AND D.mois >=trunc(DACS.dsdsc,''month'') GROUP BY C.PACMAT, DACH.PAIEZAD, C.MATRIC,to_char(D.mois,''yyyymm'') ) DAC',NULL
'W566','RD','FROM','002',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC',NULL,NULL
'W566','RD','WHERE','001',NULL,NULL,NULL,NULL,NULL,NULL,'TGE_REF_PAC.NUMPAC = @@@NUMPAC@@@',NULL
'W566','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD',NULL
'W566_RETRO','RD','ORDER_BY','001',NULL,NULL,NULL,NULL,NULL,NULL,'DAC.PAIEZAD,DAC.PERIODE',NULL
